% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[a4paper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}


\title{GeogG122 Documentation}
\date{September 30, 2014}
\release{1.0}
\author{Prof. P. Lewis}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\renewcommand\PYGZsq{\textquotesingle}

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


Contents:


\chapter{Welcome to GeogG122: Scientific Computing}
\label{Chapter0_Introduction/f1_index:welcome-to-geogg122-scientific-computing}\label{Chapter0_Introduction/f1_index:welcome-to-geogg122-s-documentation}\label{Chapter0_Introduction/f1_index::doc}

\section{Course information}
\label{Chapter0_Introduction/f1_index:course-information}

\subsection{Course Convenor}
\label{Chapter0_Introduction/f1_index:course-convenor}
\href{http://www.geog.ucl.ac.uk/~plewis}{Prof P. Lewis}


\subsection{Course Staff}
\label{Chapter0_Introduction/f1_index:course-staff}
\href{http://www.geog.ucl.ac.uk/~plewis}{Prof P. Lewis} \href{http://www.geog.ucl.ac.uk/about-the-department/people/research-staff/research-staff/jose-gomez-dans}{Dr. J.
Gomez-Dans}


\section{Purpose of this course}
\label{Chapter0_Introduction/f1_index:purpose-of-this-course}
This course, GeogG122 Scientific Computing, is a term 1 MSc module worth
15 credits (25\% of the term 1 credits) that aims to:
\begin{itemize}
\item {} 
impart an understanding of scientific computing

\item {} 
give students a grounding in the basic principles of algorithm
development and program construction

\item {} 
to introduce principles of computer-based image analysis and model
development

\end{itemize}

It is open to students from a number of \href{http://www.geog.ucl.ac.uk/admissions-and-teaching/postgraduates}{MSc
courses}
run by the \href{http://www.geog.ucl.ac.uk}{Department of Geography}
UCL, but the material should be of wider value to
others wishing to make use of scientific computing.

The module will cover:
\begin{itemize}
\item {} 
Introduction to programming

\item {} 
Computing for image analysis

\item {} 
Computing in Python

\item {} 
Computing for environmental modelling

\item {} 
Data visualisation for scientific applications

\end{itemize}


\section{Learning Outcomes}
\label{Chapter0_Introduction/f1_index:learning-outcomes}
At the end of the module, students should:
\begin{itemize}
\item {} 
have an understanding of algorithm development and be able to use
widely used scientific computing software to manipulate datasets and
accomplish analytical tasks

\item {} 
have an understanding of the technical issues specific to image-based
analysis, model implementation and scientific visualisation

\end{itemize}


\section{Additional Outcomes}
\label{Chapter0_Introduction/f1_index:additional-outcomes}
If you follow the various `advanced' sections of the course, you will
gain a deeper understanding of the concepts and codes, and in addition:
\begin{itemize}
\item {} 
have a working knowledge of linux / unix operating systems and have

\end{itemize}

the knowledge and confidence to obtain, compile and install commonly
available scientific software packages


\section{Timetable}
\label{Chapter0_Introduction/f1_index:timetable}
The course takes place over 10 weeks in term 1, on Wednesdays usually
from 10:00 to 13:00 (09:00-13:00 in the first two sessions) in the
Geography Department Unix Computing Lab (PB110) in the \href{http://www.ucl.ac.uk/efd/roombooking/building-location/?id=003}{Pearson
Building,
UCL}.

Classes take place from the second week of term to the final week of
term, other than Reading week. See \href{http://www.ucl.ac.uk/staff/term-dates}{UCL term dates for further
information}.


\section{Structure of the Course}
\label{Chapter0_Introduction/f1_index:structure-of-the-course}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{}1  1  Oct 09:00\PYGZhy{}13:00 4 hrs Python 101}
\PYG{c}{\PYGZsh{}2  8  Oct 09:00\PYGZhy{}13:00 4 hrs Plotting and Numerical Python}
\PYG{c}{\PYGZsh{}3  15 Oct 10:00\PYGZhy{}13:00 4 hrs Geospatial Data}
\PYG{c}{\PYGZsh{}4  22 Oct 10:00\PYGZhy{}13:00 3 hrs Interpolation}
\PYG{c}{\PYGZsh{}5  29 Oct 10:00\PYGZhy{}13:00 3 hrs Practical}
\PYG{c}{\PYGZsh{}5a READING WEEK (ENVI)}
\PYG{c}{\PYGZsh{}6  12 Nov 10:00\PYGZhy{}13:00 3 hrs TBD}
\PYG{c}{\PYGZsh{}7  19 Nov 10:00\PYGZhy{}13:00 3 hrs TBD}
\PYG{c}{\PYGZsh{}8  26 Nov 10:00\PYGZhy{}13:00 3 hrs TBD}
\PYG{c}{\PYGZsh{}9  3  Dec 10:00\PYGZhy{}13:00 3 hrs Group practical}
\PYG{c}{\PYGZsh{}10 10 Dec 10:00\PYGZhy{}13:00 3 hrs Group practical}
\end{Verbatim}

Total scheduled hours: 32 hours

Prof Philip Lewis

Rooms: Pearson Building Unix Lab, Room 110, 1st floor

In addition to the 10:300 session, I will be available 09:00-10:00 for
help and questions (other than the first few weeks when we start at
09:00 anyway).


\section{Assessment}
\label{Chapter0_Introduction/f1_index:assessment}
Assessment is through one piece of coursework that is submitted in both
paper form and electronically via Moodle. See the \href{http://moodle.ucl.ac.uk/course/view.php?id=13891}{Moodle
page} for more
details.

Information on the assessment is directly available in a later section
of the
notes.


\section{Useful links}
\label{Chapter0_Introduction/f1_index:useful-links}
\href{http://moodle.ucl.ac.uk/course/view.php?id=13891}{Course Moodle
page}

\href{http://www.ee.surrey.ac.uk/Teaching/Unix/books-uk.html}{A useful reading list for basic and advanced
Unix.}


\section{Detailed Struucture of the Course}
\label{Chapter0_Introduction/f1_index:detailed-struucture-of-the-course}
\textbf{0.0 Introduction}

A brief overview of the course (these notes):

{[}Introductory
notes{]}

An introduction to some of the basics of the Unix operating system. The
aim is to enable students to understand the directory structure and
basic unix operations (e.g. copying and moving files) as well simple
operations such as text editing.

\textbf{Students should read and follow these notes in their own time}* as
we will not be going through them in class (unless requested).

{[}Unix
notes{]}
{[}Unix
exercises{]}

\textbf{1.0 Python 101}

The aim of this section is to introduce you to some of the fundamental
concepts in Python. Mainly, this is based around fundamental data types
in Python (\code{int}, \code{float}, \code{str}, \code{bool} etc.) and ways to group
them (\code{tuple}, \code{list} and \code{dict}). We then learn about how to loop
over groups of things, which gives us control to iterate some process.
We need to spend a little time on strings, as you will likely to quite a
bit of string processing in Scientific Computing (e.g. reading/writing
data to/from ASCII text files). Although some of the examples we use are
very simple to explain a concept, the more developed ones should be
directly applicable to the sort of programming you are likely to need to
do. A set of exercises is developed throughout the chapter, with worked
answers available to you once you have had a go yourself. In addition, a
more advanced section of the chapter is available, that goes into some
more detail and complications. This too has a set of exercises with
worked examples.

{[}Course
Notes{]}
{[}Answers{]}
{[}Advanced{]}
{[}Advanced
Answers{]}

\textbf{2.0 Plotting and Numerical Python}

In this session, we will introduce and use some packages that you will
commonly use in scientific programming.

These are:

\href{http://www.numpy.org/}{numpy}: NumPy is the fundamental package for
scientific computing with Python

\href{http://matplotlib.org/}{matplotlib}: Python 2D plotting library

We will also introduce some additional programming concepts, and set an
exercise that you can do and get feedback on.

{[}Course
Notes{]}
{[}Answers{]}
{[}Advanced{]}

\textbf{3.0 Geospatial Data}

In this session, we will introduced the gdal geospatial module which can
read a wide range of scientific data formats. You will find that using
it to read data is quite similar to the work we did last week on netCDF
datasets.

The main challenges are also much the same: very often, you need to be
able to read data from a `stack' of image files and generate a useful 3D
(space and time) dataset from these. Once you have the data in such a
form, there are many things we can do with it, and very many of these
are convenient to do using array-based expressions such as in numpy
(consider the simplicity of the expression absorbed = rad * (1 -
albedo) from last week's exercise).

That said, it can sometimes be quite an effort to prepare datasets in
this form. Last week, we developed a `valid data' mask from the
GlobAlbedo dataset, as invalid data were stored as nan. Very often
though, scientific datasets have more complex `Quality Control' (QC)
information, that gives per-pixel information describing the quality of
the product at that location (e.g. it was very cloudy so the results are
not so good).

To explore this, we will first consider the MODIS Leaf Area Index (LAI)
product taht is mapped at 1 km resolution, every 8 days from the year
2000.

We will learn how to read in these data (in hdf format) using gdal, and
how to interpret the QC information in such products to produce valid
data masks. As an exercise, you will wrap some code around that to form
a 3D masked array of the dataset.

Next, we will consider how to download such data. This should be a
reinforcement of material from last week, but it is useful to know how
to conveniently access NASA data products. A challenge in the exercise
then is to download a different dataset (MODIS snow cover) for the UK,
and form a masked 3D dataset from this.

Finally, we will introduce vector datasets and show you python tools
that allow you (among many other things) to build a mask in the
projection and sampling of your spatial dataset (MODIS LAI in this
case).

There are many features and as many complexities to the Python tools we
will deal with today, but in this material, we cover some very typical
tasks you will want to do. They all revolve around generating masked 3D
datasets from NASA MODIS datasets, which is a very useful form of global
biophysical information over the last decade+. We also provide much
material for further reading and use when you are more confident in your
programming.

A final point here is that the material we cover today is very closely
related to what you will need to do in the first section of your
assessed practical that we will introduce next week, so you really need
to get to grips with this now.

There is not as much `new' material as in previous weeks now, but we
assume that you have understood, and can make use of, material from
those lectures.

{[}Course
Notes{]}
{[}Answers{]}
{[}Advanced{]}

\textbf{4.0 Interpolation}

In today's session, we will be using some of the LAI datasets we
examined last week (masked by national boundaries) and doing some
analysis on them. First, we will examine how to improve our data reading
function by extracting only the area we are interested in. This involves
querying the `country' mask to find its limits and passing this
information through to the reader. Then we will look at methods to
interpolate and smooth over gaps in datasets using various methods.
Finally, we will look at fitting models to datasets, in this case a
model describing LAI phenology.

{[}Course
Notes{]}

\textbf{4a ENVI}

This session is rather apart from the rest and is included to allow
students to familarise themselves with a package image processing
environment (ENVI). This is an \emph{unsupervised} session, that takes place
during UCL Reading Week in Term 1.

{[}Course
Notes{]}

\textbf{5.0 Practical}

This section describes the coursework you are to submit for assessment
for this course.

{[}Practical for
assessment{]}

\textbf{6.0 ENSO}

To finish the course, some practical applications. The first of these
looks at predicting fire activity from from climatic data.

Using monthly fire count data from MODIS Terra, develop and test a
predictive model for the number of fires per unit area per year driven
by Sea Surface Temperature anomaly data.

{[}Course
Notes{]}

\textbf{7.0 P Theory}

Another practical application involves a simple radiative transfer model
applied to help interpret hyperspectral remote sensing data over an
agricultural site.

Using hyperspectral image data over an agricultural area, use photon
recollision theory to produce a map of Leaf Area Index.

{[}Course
Notes{]}


\section{Using these notes}
\label{Chapter0_Introduction/f1_index:using-these-notes}
These notes and all associated files should be directly available for
you in the directory \code{\textasciitilde{}/DATA/geogg122}.

You should be able to just start firefox (or another browser) and type:

\code{berlin\% firefox \&}

\code{berlin\% cd \textasciitilde{}/Data/geogg122}

\code{berlin\% ipython notebook -{-}pylab=inline}

Then navigate to the section you want in the browser. This will allow
you to run the sessions in the python notebook.

If you only want to view the notes (in html), then navigate to the
\href{http://www2.geog.ucl.ac.uk/~plewis/geogg122\_current/\_build/html/Chapter0\_Introduction/f1\_index.html}{pretty course notes
link}
or the \href{http://www.geog.ucl.ac.uk/~plewis/geogg122}{simple course notes
link}.


\section{Other ways to access the notes}
\label{Chapter0_Introduction/f1_index:other-ways-to-access-the-notes}
There are several ways you can access this course material.

These notes are created in \href{http://ipython.org/ipython-doc/dev/interactive/notebook.html}{ipython
notebooks}.

The course is all stored online in
\href{https://github.com/profLewis/geogg122}{github}, so you can just
navigate to that site and download the files as you like.

Probably the easiest option is to access the html version of the notes
from notebook links in the README on
\href{https://github.com/profLewis/geogg122/blob/master/README.md}{github}
or above on this page. You can access \emph{notebook} links, which are
guaranteed to be up to date, or \emph{html} links, which should be (but not
guaranteed).

Another option is to access individual notebooks online through the
\href{http://nbviewer.ipython.org/}{IPython Notebook Viewer}.

For example, to view the notebook
\code{Chapter0\_Introduction/f2\_intro.html}, you use a link to the github
file.

From these viewers, you can download the notebook if you like, using the
\emph{Download Notebook} button (top right of the page).

Provided you have a relatively up to date version of
\href{http://ipython.org/ipython-doc/dev/interactive/nbconvert.html\#nbconvert}{ipython}
and a few other tools such as
\href{http://johnmacfarlane.net/pandoc/installing.html}{pandoc} you can
convert your own notebooks to other formats using \code{ipython}, e.g.:

\code{berlin\% ipython nbconvert -{-}to html f2\_intro.html}

You can also convert the notebooks to other
\href{http://ipython.org/ipython-doc/rel-1.0.0/interactive/nbconvert.html}{formats}
though you might need some other tools as well for this. If you have a
working copy of \code{LaTeX} on your system (e.g.
\href{http://tug.org/mactex/downloading.html}{MacTeX} on OS X), you can
convert the notebooks to pdf format:

\code{berlin\% ipython nbconvert -{-}to latex -{-}post PDF f2\_intro.html}


\subsection{Obtaining the course material}
\label{Chapter0_Introduction/f1_index:obtaining-the-course-material}
Alternatively, you can obtain the whole course from
\href{https://github.com/profLewis/geogg122}{github}.

To download the whole course, you can:
\begin{enumerate}
\item {} 
\textbf{using git}

\end{enumerate}

\begin{DUlineblock}{0em}
\item[] use the command
\end{DUlineblock}

\href{http://en.wikipedia.org/wiki/Git\_\%28software\%29}{git}, if available:
\textbar{}  Create a place on the system that you want to work in (N.B., don't
type \code{berlin\%}: that represents the command line prompt), e.g.:

\begin{DUlineblock}{0em}
\item[] \code{berlin\% cd \textasciitilde{}/DATA}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \code{berlin\% git clone https://github.com/profLewis/geogg122.git}
\item[] \code{berlin\% cd \textasciitilde{}/DATA/geogg122}
\end{DUlineblock}
\end{DUlineblock}

This will create a directory \code{\textasciitilde{}/Data/msc/geogg122} which has the
current versions of the notebooks for the course and associated files.

If the course notes change at all (e.g. are updated), you can update
your copy with:

\code{berlin\% git pull}

To find out more about using \code{git}, type \code{git -{-}help}, get \href{http://www.siteground.com/tutorials/git/commands.htm}{help
online} or
download and use a \href{http://git-scm.com/downloads}{gui tool}.

If you set up an account on \href{https://github.com/edu}{github}, you can
fork the \href{https://github.com/profLewis/geogg122}{course repository}
to make your own version of the course notes, and add in your own
comments and examples, if that helps you learn or remember things.
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
\textbf{using a zip file}

\end{enumerate}

Download the course as a zip file:

\begin{DUlineblock}{0em}
\item[] \code{berlin\% mkdir -p \textasciitilde{}/Data/msc}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \code{berlin\% cd \textasciitilde{}/Data/msc}
\item[] 
\end{DUlineblock}
\end{DUlineblock}

\code{berlin\% wget -O geogg122.zip https://github.com/profLewis/geogg122/archive/master.zip}
\textbar{}  \code{berlin\% unzip geogg122.zip}
\textbar{}  \code{berlin\% cd \textasciitilde{}/Data/msc/geogg122-master}

You can directly use the notebooks, or you can open the \code{html} files,
e.g. opening

file:///home/plewis/Data/geogg122/Chapter1\_Unix/f3\_1\_unix\_intro.html
in a browser (obviously changing the username and path as appropriate).


\subsection{Using the course material}
\label{Chapter0_Introduction/f1_index:using-the-course-material}
Once you have copied the course material as described above (and have
changed directory to where you have put the course (e.g.
\code{\textasciitilde{}/DATA/geogg122-master} or \code{\textasciitilde{}/DATA/geogg122}) then \code{cd} to the
chapter you want, e.g.:

\code{berlin\% cd \textasciitilde{}/DATA/geogg122/Chapter0\_Introduction}

and you can start the notebooks with:

\code{berlin\% ipython notebook}

This should launch a web browser with the address
\code{http://127.0.0.1:8888/} or similar with links to the notebooks you
have available.

To load a \emph{specific} notebook, you can type e.g.:

\code{berlin\% ipython notebook f1\_index.html}


\subsection{Python}
\label{Chapter0_Introduction/f1_index:python}
For most users wanting to install a working python environment, Anaconda
appears to be far easier and overall quite nice to use:
\href{https://store.continuum.io/cshop/anaconda/}{https://store.continuum.io/cshop/anaconda/}. Comes with Python notebooks,
spyder and a wealth of other things not in some other releases.


\subsection{System access}
\label{Chapter0_Introduction/f1_index:system-access}
You should be able to install python on a windows operating system and
so could run most of the class material from any windows computer that
you have. As we have noted above, you can download all of the class
notes as python notebooks or other formats (such as html).

For windows users, it's probably best if you just use
\href{http://mobaxterm.mobatek.net/}{http://mobaxterm.mobatek.net/} to connect to the UCL system (you don't
need exceed, it's free, got SFTP, etc).

For linux and OS X machines, it's very straightforward as you already
have a unix system. For OS X, you can find the terminal in the
\code{Utilities} folder under \code{Applications}. For \code{X windows} on OS X,
you may need to \href{http://support.apple.com/kb/HT5293}{install this} if
you have a recent version of the operating system.

Another approach is to use the \href{http://www.ucl.ac.uk/isd/students/windows/wts/access/remote}{UCL
WTS}
system, where you have access to some software called \code{exceed} to
allow you to log on to the system.

Using any of these (or other!) approaches, you want to be able to use
the command \code{ssh} (or similar) to log on to the gateway machine
\code{shankly.geog.ucl.ac.uk}:

This will normally be:

\code{ssh -Y username@shankly.geog.ucl.ac.uk}

From there, you should log in (with \code{ssh}) to another computer in the
lab (or else everyone will be on the same computer).

An alternative gateway, if \code{shankly} is down or busy is
\code{lyon.geog.ucl.ac.uk}.


\chapter{1. Introduction to Python}
\label{Chapter2_Python_intro/python101::doc}\label{Chapter2_Python_intro/python101:introduction-to-python}
The aim of this Chapter is to introduce you to some of the fundamental
concepts in Python. Mainly, this is based around fundamental data types
in Python (\code{int}, \code{float}, \code{str}, \code{bool} etc.) and ways to group
them (\code{tuple}, \code{list} and \code{dict}).

We then learn about how to loop over groups of things, which gives us
control to iterate some process.

We need to spend a little time on strings, as you will likely to quite a
bit of string processing in Scientific Computing (e.g. reading/writing
data to/from ASCII text files).

Although some of the examples we use are very simple to explain a
concept, the more developed ones should be directly applicable to the
sort of programming you are likely to need to do.

A set of exercises is developed throughout the chapter, with worked
answers available to you once you have had a go yourself.

In addition, a more advanced section of the chapter is available, that
goes into some more detail and complkications. This too has a set of
exercises with worked examples.


\section{1.1 Python}
\label{Chapter2_Python_intro/python101:python}
\href{http://www.python.org/}{Python} is a high level programming language
that is freely available, relatively easy to learn and portable across
different computing systems. In Python, you can rapidly develop
solutions for the sorts of problems you might need to solve in your MSc
courses and in the world beyond. Code written in Python is also easy to
maintain, is (or should be) self-documented, and can easily be linked to
code written in other languages.

Relevant features include:
\begin{itemize}
\item {} 
it is automatically compiled and executed

\item {} 
code is portable provided you have the appropriate Python modules.

\item {} 
for compute intensive tasks, you can easily make calls to methods
written in (faster) lower-level languages such as C or FORTRAN

\item {} 
there is an active user and development community, which means that
new capabilities appear over time and there are many existing
extensions and enhancements easily available to you.

\end{itemize}

For further background on Python, look over the material on \href{https://python.g-node.org/wiki/schedule}{Advanced
Scientific Programming in
Python} and/or the
\href{http://software-carpentry.org/v3/py01.html}{software-carpentry.org}
and \href{http://www.python.org/}{python.org} web sites.

In this session, you will be introduced to some of the basic concepts in
Python.


\section{1.2 Running Python Programs}
\label{Chapter2_Python_intro/python101:running-python-programs}

\subsection{1.2.1 Requirements}
\label{Chapter2_Python_intro/python101:requirements}
For this course, we suggest you use the
\href{https://store.continuum.io/cshop/anaconda/}{anaconda} Python
distribution (this is what is installed in the unix lab computers),
though you are free to use whichever version of it you like on your own
computers.

If you are intending to use these notes on your opwn computer, you will
need a relatively comprehensive installation of Python (such as that
from \href{https://store.continuum.io/cshop/anaconda/}{anaconda}), and
will also need \href{http://www.gdal.org/}{GDAL} installed for some of the
work. You may also find it of value to have
\href{http://git-scm.com/}{git} installed.

We are assuming that you are new to computing in this course, but that
you are aware of the basic unix material covered in the previous
lecture.


\subsection{2.2.2 Running Python}
\label{Chapter2_Python_intro/python101:running-python}
We will generally use the \code{ipython} interpreter for running
interactive Python programs.

You will probably want to run each session and store scripts in your
\code{Data} (or \code{DATA}) directory.

If you are taking this course at UCL, the notes should already have been
downloaded to your \code{DATA} directory.

If so, then:

\begin{Verbatim}[commandchars=\\\{\}]
berlin\PYGZpc{} cd \PYGZti{}/DATA/geogg122
berlin\PYGZpc{} git reset \PYGZhy{}\PYGZhy{}hard HEAD
berlin\PYGZpc{} git pull
\end{Verbatim}

will update the notes (for any changes I make over the sessions).

If you need to download the notes and want to run the session directly
in the notebook, you will need to download the course material from
\href{https://github.com/profLewis/geogg122}{github} and run the notebook
with e.g.:

\begin{Verbatim}[commandchars=\\\{\}]
berlin\PYGZpc{} cd \PYGZti{}/DATA
berlin\PYGZpc{} git clone https://github.com/profLewis/geogg122.git
\end{Verbatim}

to obtain the notes.

You should next check that you are using the version of Python that we
intend:

\begin{Verbatim}[commandchars=\\\{\}]
berlin\PYGZpc{} which ipython
/opt/anaconda/bin/ipython
\end{Verbatim}

If this isn't the version of Python that you are picking up (note the
use of the unix command \code{which} here), then you can either just type
the full path name:

\begin{Verbatim}[commandchars=\\\{\}]
berlin\PYGZpc{} /opt/anaconda/bin/ipython
\end{Verbatim}

in place of where it says \code{ipython} in these notes, or modify your
shell initialisation file (\code{\textasciitilde{}/.bashrc} if you are using \code{bash} or
\code{\textasciitilde{}/.cshrc} for \code{tcsh} or \code{csh}) to include \code{/opt/anaconda/bin}
early on in the \code{PATH}.

To go to the directory for this session:

\begin{DUlineblock}{0em}
\item[] \code{berlin\% cd \textasciitilde{}/Data/geogg122/Chapter2\_Python\_intro}
\item[] \code{berlin\% ipython notebook python101.html -{-}pylab=inline}
\end{DUlineblock}

You quit an \code{ipython} notebook session with \code{\textasciicircum{}C} (\code{Control C}).

To exectute (`run') blocks of Python code in the notebook, use
\code{\textasciicircum{}\textless{}return\textgreater{}} (\code{SHIFT} and \code{RETURN} keys together).

Alternatively, just run \code{ipython}:

\begin{Verbatim}[commandchars=\\\{\}]
berlin\PYGZpc{} cd \PYGZti{}/DATA/geogg122/Chapter2\PYGZus{}Python\PYGZus{}intro
berlin\PYGZpc{} ipython \PYGZhy{}\PYGZhy{}pylab=inline
\end{Verbatim}

and type your own commands in at the prompt, following the class or the
material on the webpages.


\section{2.3 Getting Started}
\label{Chapter2_Python_intro/python101:getting-started}

\subsection{2.3.1 Variables, Values and Data types}
\label{Chapter2_Python_intro/python101:variables-values-and-data-types}
The idea of \textbf{variables} is fundamental to any programming. You can
think of this as the \emph{name} of \emph{something}, so it is a way of allowing
us to refer to some object in the language.

What the variable \emph{is} set to is called its \textbf{value}.

So let's start with a variable we will call (\emph{declare to be}) \code{x}.

We will give the \emph{value} \code{1} to this variable:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{1}
\end{Verbatim}

In a computing language, the \emph{sort of thing} the variable can be set to
is called its \textbf{data type}.

In the example above, the datatype is an \textbf{integer} number (e.g.
\code{1, 2, 3, 4}).

In `natural language', we might read the example above as `x is one'.

This is different to:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{one}\PYG{l+s}{\PYGZsq{}}
\end{Verbatim}

because here we have set value of the variable \code{x} to a \textbf{string}
(i.e. some text).

A string is enclosed in quotes, e.g. \code{"one"} or \code{'one'}, or even
\code{"'one'"} or \code{'"one"'}.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{one}\PYG{l+s}{\PYGZdq{}}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{one}\PYG{l+s}{\PYGZsq{}}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{one}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZdq{}}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{one}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZsq{}}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{one}
\PYG{n}{one}
\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{one}\PYG{l+s}{\PYGZsq{}}
\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{one}\PYG{l+s}{\PYGZdq{}}
\end{Verbatim}

This is different to:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mf}{1.0}
\end{Verbatim}

because here we have set value of the variable \code{x} to a \textbf{floating
point} number (these are treated and stored differently to integers in
computing).

This is different to:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{=} \PYG{n+nb+bp}{True}
\end{Verbatim}

where \code{True} is a \textbf{logical} or \textbf{boolean} datatype (something is
\code{True} or \code{False}).

We have so far seen three datatypes:
\begin{itemize}
\item {} 
integer (\code{int}): 32 bits long on most machines

\item {} 
(double-precision) floating point (\code{float}): (64 bits long)

\item {} 
Boolean (\code{bool})

\item {} 
string (\code{str})

\end{itemize}

but we will come across more (and even create our own!) as we go through
the course.


\subsubsection{type}
\label{Chapter2_Python_intro/python101:type}
In each of these cases above, we have used the variable \code{x} to contain
these different data types. If you want to know what the data type of a
variable is, you can use the method \code{type()}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{n+nb}{type}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{print} \PYG{n+nb}{type}\PYG{p}{(}\PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{print} \PYG{n+nb}{type}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{one}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{print} \PYG{n+nb}{type}\PYG{p}{(}\PYG{n+nb+bp}{True}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}type \PYGZsq{}int\PYGZsq{}\PYGZgt{}
\PYGZlt{}type \PYGZsq{}float\PYGZsq{}\PYGZgt{}
\PYGZlt{}type \PYGZsq{}str\PYGZsq{}\PYGZgt{}
\PYGZlt{}type \PYGZsq{}bool\PYGZsq{}\PYGZgt{}
\end{Verbatim}

You can explicitly convert between data types, e.g.:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{int(1.1) = }\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n+nb}{int}\PYG{p}{(}\PYG{l+m+mf}{1.1}\PYG{p}{)}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{float(1) = }\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n+nb}{float}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{str(1) = }\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n+nb}{str}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{bool(1) = }\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n+nb}{bool}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nb}{int}\PYG{p}{(}\PYG{l+m+mf}{1.1}\PYG{p}{)} \PYG{o}{=}  \PYG{l+m+mi}{1}
\PYG{n+nb}{float}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{=}  \PYG{l+m+mf}{1.0}
\PYG{n+nb}{str}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{=}  \PYG{l+m+mi}{1}
\PYG{n+nb}{bool}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{=}  \PYG{n+nb+bp}{True}
\end{Verbatim}

but only when it makes sense:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{converting the string }\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{1}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{ to an integer makes sense:}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n+nb}{int}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{1}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
converting the string \PYGZsq{}1\PYGZsq{} to an integer makes sense: 1
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{converting the string }\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{one}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{ to an integer doesn}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{t:}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n+nb}{int}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{one}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
converting the string \PYGZsq{}one\PYGZsq{} to an integer doesn\PYGZsq{}t:
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
ValueError                                Traceback (most recent call last)

\PYGZlt{}ipython\PYGZhy{}input\PYGZhy{}9\PYGZhy{}20c6d9c1fc49\PYGZgt{} in \PYGZlt{}module\PYGZgt{}()
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} 1 print \PYGZdq{}converting the string \PYGZsq{}one\PYGZsq{} to an integer doesn\PYGZsq{}t:\PYGZdq{},int(\PYGZsq{}one\PYGZsq{})


ValueError: invalid literal for int() with base 10: \PYGZsq{}one\PYGZsq{}
\end{Verbatim}

When you get an error (such as above), you will need to learn to \emph{read}
the error message to work out what you did wrong.


\subsubsection{del}
\label{Chapter2_Python_intro/python101:del}
You can delete a variable with \code{del}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mf}{100.}
\PYG{k}{print} \PYG{n}{x}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{100.0}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mf}{100.}
\PYG{k}{del} \PYG{n}{x}

\PYG{c}{\PYGZsh{} so now if we try to do anything with the variable}
\PYG{c}{\PYGZsh{} x, it should fail as x is no longer defined}
\PYG{k}{print} \PYG{n}{x}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
NameError                                 Traceback (most recent call last)

\PYGZlt{}ipython\PYGZhy{}input\PYGZhy{}11\PYGZhy{}f602427acddb\PYGZgt{} in \PYGZlt{}module\PYGZgt{}()
      4 \PYGZsh{} so now if we try to do anything with the variable
      5 \PYGZsh{} x, it should fail as x is no longer defined
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} 6 print x


NameError: name \PYGZsq{}x\PYGZsq{} is not defined
\end{Verbatim}


\subsection{2.3.2 Arithmetic}
\label{Chapter2_Python_intro/python101:arithmetic}
Often we will want to do some
\href{http://www.tutorialspoint.com/python/python\_basic\_operators.htm}{arithmetic}
with numbers in a program, and we use the `normal' (derived from C)
operators for this.

Note the way this works for integers and floating point representations.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+sd}{    Some examples of arithmetic operations in Python}

\PYG{l+s+sd}{    Note how, if we mix float and int, the result is raised to float}
\PYG{l+s+sd}{    (as the more general form)}
\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}

\PYG{k}{print} \PYG{l+m+mi}{10} \PYG{o}{+} \PYG{l+m+mi}{100}     \PYG{c}{\PYGZsh{} int addition}
\PYG{k}{print} \PYG{l+m+mf}{10.} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{100}    \PYG{c}{\PYGZsh{} float subtraction}
\PYG{k}{print} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{l+m+mf}{2.}        \PYG{c}{\PYGZsh{} float division}
\PYG{k}{print} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{l+m+mi}{2}          \PYG{c}{\PYGZsh{} int division}
\PYG{k}{print} \PYG{l+m+mf}{10.}\PYG{o}{*}\PYG{l+m+mf}{20.}      \PYG{c}{\PYGZsh{} float multiplication}
\PYG{k}{print} \PYG{l+m+mi}{2} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mf}{3.}      \PYG{c}{\PYGZsh{} float exponent}
\PYG{k}{print} \PYG{l+m+mi}{8}\PYG{o}{\PYGZpc{}}\PYG{l+m+mi}{2}          \PYG{c}{\PYGZsh{} int remainder}

\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{========}\PYG{l+s}{\PYGZsq{}}
\PYG{c}{\PYGZsh{} demonstration of floor (//) and remainder (\PYGZpc{})}
\PYG{n}{number}    \PYG{o}{=} \PYG{l+m+mf}{9.5}
\PYG{n}{base}      \PYG{o}{=} \PYG{l+m+mf}{2.0}
\PYG{n}{remainder} \PYG{o}{=} \PYG{n}{number}\PYG{o}{\PYGZpc{}}\PYG{n}{base} \PYG{c}{\PYGZsh{} float remainder}
\PYG{n}{floor}     \PYG{o}{=} \PYG{n}{number}\PYG{o}{/}\PYG{o}{/}\PYG{n}{base} \PYG{c}{\PYGZsh{} \PYGZsq{}floor\PYGZsq{} operation}
\PYG{k}{print} \PYG{n}{number}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{is}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{floor}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{times}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{base}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{plus}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{remainder}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
110
\PYGZhy{}90.0
0.5
0
200.0
8.0
0
========
9.5 is 4.0 times 2.0 plus 1.5
\end{Verbatim}


\subsection{Exercise}
\label{Chapter2_Python_intro/python101:exercise}
Change the numbers in the examples above to make sure you understand
these basic operations.

Try combining operations and use brackets () to check that that works as
expected.


\subsection{2.3.3 Assignment Operators}
\label{Chapter2_Python_intro/python101:assignment-operators}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+sd}{    Assignment operators}

\PYG{l+s+sd}{    x = 3   assigns the value 3 to the variable x}
\PYG{l+s+sd}{    x += 2  adds 2 onto the value of x}
\PYG{l+s+sd}{            so is the same as x = x + 2}
\PYG{l+s+sd}{            similarly /=, *=, \PYGZhy{}=}
\PYG{l+s+sd}{    x \PYGZpc{}= 2  is the same as x = x \PYGZpc{} 2}
\PYG{l+s+sd}{    x **= 2 is the same as x = x ** 2}
\PYG{l+s+sd}{    x //= 2 is the same as x = x // 2}

\PYG{l+s+sd}{    A \PYGZsq{}magic\PYGZsq{} trick}
\PYG{l+s+sd}{    ===============}

\PYG{l+s+sd}{    http://www.wikihow.com/Read\PYGZhy{}Someone\PYGZbs{}}
\PYG{l+s+sd}{        \PYGZpc{}27s\PYGZhy{}Mind\PYGZhy{}With\PYGZhy{}Math\PYGZhy{}\PYGZpc{}28Math\PYGZhy{}Trick\PYGZpc{}29}

\PYG{l+s+sd}{    whatever you put as myNumber, the answer is 3}

\PYG{l+s+sd}{    Try this with integers or floating point numbers ...}
\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}

\PYG{c}{\PYGZsh{} pick a number}
\PYG{n}{myNumber} \PYG{o}{=} \PYG{l+m+mf}{34.67}

\PYG{c}{\PYGZsh{} assign this to the variable x}
\PYG{n}{x} \PYG{o}{=} \PYG{n}{myNumber}

\PYG{c}{\PYGZsh{} multiply it by 2}
\PYG{n}{x} \PYG{o}{*}\PYG{o}{=} \PYG{l+m+mi}{2}

\PYG{c}{\PYGZsh{} multiply this by 5}
\PYG{n}{x} \PYG{o}{*}\PYG{o}{=} \PYG{l+m+mi}{5}

\PYG{c}{\PYGZsh{} divide by the original number}
\PYG{n}{x} \PYG{o}{/}\PYG{o}{=} \PYG{n}{myNumber}

\PYG{c}{\PYGZsh{} subtract 7}
\PYG{n}{x} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{l+m+mi}{7}

\PYG{c}{\PYGZsh{} The answer will always be 3}
\PYG{k}{print} \PYG{n}{x}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{3.0}
\end{Verbatim}


\subsection{2.3.4 Logical Operators}
\label{Chapter2_Python_intro/python101:logical-operators}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+sd}{    Logical operators}
\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{n}{alive} \PYG{o}{=} \PYG{n+nb+bp}{True}
\PYG{n}{dead} \PYG{o}{=} \PYG{o+ow}{not} \PYG{n}{alive}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{dead or alive is}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{dead} \PYG{o+ow}{or} \PYG{n}{alive}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{dead and alive is}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{dead} \PYG{o+ow}{and} \PYG{n}{alive}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{dead} \PYG{o+ow}{or} \PYG{n}{alive} \PYG{o+ow}{is} \PYG{n+nb+bp}{True}
\PYG{n}{dead} \PYG{o+ow}{and} \PYG{n}{alive} \PYG{o+ow}{is} \PYG{n+nb+bp}{False}
\end{Verbatim}

The result of running comparison operators will give a logical (i.e.
\code{bool}) output.

Most of this should be obvious, but consider carefully how this works
for string data types.


\subsection{2.3.5 Comparison Operators}
\label{Chapter2_Python_intro/python101:comparison-operators}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+sd}{    Related, comparison operators:}

\PYG{l+s+sd}{    ==  : equvalence}
\PYG{l+s+sd}{    !=  : not equivalent}
\PYG{l+s+sd}{    \PYGZgt{}   : greater than}
\PYG{l+s+sd}{    \PYGZgt{}=  : greater than or equal to}
\PYG{l+s+sd}{    \PYGZlt{}   : less than}
\PYG{l+s+sd}{    \PYGZlt{}=  : less than or equal to}
\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}

\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{is one plus one equal to two?}\PYG{l+s}{\PYGZdq{}}
\PYG{k}{print} \PYG{l+m+mi}{1} \PYG{o}{+} \PYG{l+m+mi}{1} \PYG{o}{==} \PYG{l+m+mi}{2}

\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{is one less than or equal to 0.999?}\PYG{l+s}{\PYGZdq{}}
\PYG{k}{print} \PYG{l+m+mi}{1} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mf}{0.999}

\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{is one plus one not equal to two?}\PYG{l+s}{\PYGZdq{}}
\PYG{k}{print} \PYG{l+m+mi}{1} \PYG{o}{+} \PYG{l+m+mi}{1} \PYG{o}{!=} \PYG{l+m+mi}{2}

\PYG{c}{\PYGZsh{} note the use of double quotes inside a single quoted string here}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{is }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Hello}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ not the same as }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{hello}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{?}\PYG{l+s}{\PYGZsq{}}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Hello}\PYG{l+s}{\PYGZsq{}} \PYG{o}{!=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{hello}\PYG{l+s}{\PYGZsq{}}

\PYG{c}{\PYGZsh{} note the use of single quotes inside a double quoted string here}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{is }\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{more}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{ greater than }\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{less}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{?}\PYG{l+s}{\PYGZdq{}}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{more}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZgt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{less}\PYG{l+s}{\PYGZdq{}}

\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{is }\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{100}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{ less than }\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{2}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{?}\PYG{l+s}{\PYGZdq{}}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{100}\PYG{l+s}{\PYGZsq{}} \PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{2}\PYG{l+s}{\PYGZsq{}}

\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{is 100 less than 2?}\PYG{l+s}{\PYGZdq{}}
\PYG{k}{print} \PYG{l+m+mi}{100} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{2}

\PYG{c}{\PYGZsh{} a boolean example just to see what happens}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{is True greater than False?}\PYG{l+s}{\PYGZdq{}}
\PYG{k}{print} \PYG{n+nb+bp}{True} \PYG{o}{\PYGZgt{}} \PYG{n+nb+bp}{False}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
is one plus one equal to two?
True
is one less than or equal to 0.999?
False
is one plus one not equal to two?
False
is \PYGZdq{}Hello\PYGZdq{} not the same as \PYGZdq{}hello\PYGZdq{}?
True
is \PYGZsq{}more\PYGZsq{} greater than \PYGZsq{}less\PYGZsq{}?
True
is \PYGZsq{}100\PYGZsq{} less than \PYGZsq{}2\PYGZsq{}?
True
is 100 less than 2?
False
is True greater than False?
True
\end{Verbatim}

We can combine such logical statements, bracketing the terms as
required:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o+ow}{and} \PYG{p}{(}\PYG{n+nb+bp}{True} \PYG{o+ow}{or} \PYG{n+nb+bp}{False}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nb+bp}{True}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{}!/usr/bin/env python}

\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Exercise in logical statements}

\PYG{l+s+sd}{   P. Lewis p.lewis@ucl.ac.uk}

\PYG{l+s+sd}{   Tue  8 Oct 2013 10:11:03 BST}
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}

\PYG{c}{\PYGZsh{} hunger threshold in hours}
\PYG{n}{hungerThreshold} \PYG{o}{=} \PYG{l+m+mf}{3.0}
\PYG{c}{\PYGZsh{} sleep threshold in hours}
\PYG{n}{sleepThreshold} \PYG{o}{=} \PYG{l+m+mf}{8.0}

\PYG{c}{\PYGZsh{} time since fed, in hours}
\PYG{n}{timeSinceFed} \PYG{o}{=} \PYG{l+m+mf}{4.0}
\PYG{c}{\PYGZsh{} time since sleep, in hours}
\PYG{n}{timeSinceSleep} \PYG{o}{=} \PYG{l+m+mf}{3.0}

\PYG{c}{\PYGZsh{} Note use of \PYGZbs{} as line continuation here}
\PYG{c}{\PYGZsh{}It is poor style to have code lines \PYGZgt{} 79 characters}
\PYG{c}{\PYGZsh{}}
\PYG{c}{\PYGZsh{} see http://www.python.org/dev/peps/pep\PYGZhy{}0008/\PYGZsh{}maximum\PYGZhy{}line\PYGZhy{}length}
\PYG{c}{\PYGZsh{}}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Tired and hungry?}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{p}{(}\PYG{n}{timeSinceSleep} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{sleepThreshold}\PYG{p}{)} \PYG{o+ow}{and} \PYGZbs{}
                            \PYG{p}{(}\PYG{n}{timeSinceFed} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{hungerThreshold}\PYG{p}{)}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Just tired?}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{p}{(}\PYG{n}{timeSinceSleep} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{sleepThreshold}\PYG{p}{)} \PYG{o+ow}{and} \PYGZbs{}
                            \PYG{p}{(}\PYG{o+ow}{not} \PYG{p}{(}\PYG{n}{timeSinceFed} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{hungerThreshold}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Just hungry?}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{p}{(}\PYG{o+ow}{not} \PYG{p}{(}\PYG{n}{timeSinceSleep} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{sleepThreshold}\PYG{p}{)}\PYG{p}{)} \PYG{o+ow}{and} \PYGZbs{}
                            \PYG{p}{(}\PYG{n}{timeSinceFed} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{hungerThreshold}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
Tired and hungry? False
Just tired? False
Just hungry? True
\end{Verbatim}


\subsection{Exercise 2.1}
\label{Chapter2_Python_intro/python101:exercise-2-1}
The code above works fine, but the large blocks of logical tests are not
very clear or readable, and contain repeated items.

Type the code into a file (or download it).

To run the code \emph{either} type at the unix prompt:

\code{berlin\% python hungry.py}

OR, within ipython:

\code{In {[}17{]}: run hungry.py}

Modify this block of code to be clearer by assigning the individual
logical tests to variables,

e.g.

\code{tired = timeSinceSleep \textgreater{}= sleepThreshold}


\section{2.4 Groups of things}
\label{Chapter2_Python_intro/python101:groups-of-things}

\subsection{2.4.1 tuples, lists and dictionaries}
\label{Chapter2_Python_intro/python101:tuples-lists-and-dictionaries}
Very often, we will want to group items together.

There are several main mechanisms for doing this in Python, known as:
\begin{itemize}
\item {} 
tuple, e.g. (1, 2, 3)

\item {} 
list, e.g. {[}1, 2, 3{]}

\item {} 
dict, e.g. \{1:'one', 2:'two', 3:'three'\}

\end{itemize}

You will notice that each of these grouping structures uses a different
form of bracket.


\subsubsection{tuple}
\label{Chapter2_Python_intro/python101:tuple}
A \code{tuple} is a group of items separated by commas.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{t} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{three}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb+bp}{False}
\PYG{k}{print} \PYG{n}{t}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{three}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb+bp}{False}\PYG{p}{)}
\end{Verbatim}

Note that when you declare the tuple, you don't need to put the braces
(brackets) as this is implicit.

Often though, it is a good idea to do so.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{t} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{three}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb+bp}{False}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{t}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{three}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb+bp}{False}\PYG{p}{)}
\end{Verbatim}

If there is only one element in a tuple, you must put a comma \code{,} at
the end, otherwise it is \emph{not} interpreted as a tuple:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{t} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{t}\PYG{p}{,}\PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
1 \PYGZlt{}type \PYGZsq{}int\PYGZsq{}\PYGZgt{}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{t} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{t}\PYG{p}{,}\PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
(1,) \PYGZlt{}type \PYGZsq{}tuple\PYGZsq{}\PYGZgt{}
\end{Verbatim}

You can have an \emph{empty} tuple though:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{t} \PYG{o}{=} \PYG{p}{(}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{t}\PYG{p}{,}\PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
() \PYGZlt{}type \PYGZsq{}tuple\PYGZsq{}\PYGZgt{}
\end{Verbatim}

Notice that the tuple can contain data of different types.

It can also be nested (i.e. a tuple can contain a tuple):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{t} \PYG{o}{=} \PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{one}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{t}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{one}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

Some operations we can perform on tuples include:
\begin{itemize}
\item {} 
length : \code{len()}

\item {} 
selection (`slice') : {[}{]}

\end{itemize}


\subsubsection{len}
\label{Chapter2_Python_intro/python101:len}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} set up a simple tuple}
\PYG{n}{t} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{The length of the tuple (1,2,3) is}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}

\PYG{c}{\PYGZsh{} a nested example}
\PYG{n}{t} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{2a}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{2b}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{The length of the tuple (1,(1,(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{2a}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{2b}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{),3),3) is}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
The length of the tuple (1,2,3) is 3
The length of the tuple (1,(1,(\PYGZsq{}2a\PYGZsq{},\PYGZsq{}2b\PYGZsq{}),3),3) is 3
\end{Verbatim}


\subsubsection{slice}
\label{Chapter2_Python_intro/python101:slice}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} select an item with []}
\PYG{c}{\PYGZsh{} note the first item is 0, i.e. we start counting at 0}
\PYG{c}{\PYGZsh{} Python uses a 0\PYGZhy{}based indexing system}

\PYG{n}{t} \PYG{o}{=} \PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{it}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{is}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{a}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{truth}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{universally}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{acknowledged}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{item 0}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{t}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{item 4}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{t}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
item 0 it
item 4 universally
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} using negative to count from the end}
\PYG{c}{\PYGZsh{} so \PYGZhy{}1 is the last item, \PYGZhy{}2 the second to last etc}

\PYG{n}{t} \PYG{o}{=} \PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{it}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{is}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{a}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{truth}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{universally}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{acknowledged}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{item \PYGZhy{}1}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{t}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{item \PYGZhy{}3}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{t}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
item \PYGZhy{}1 acknowledged
item \PYGZhy{}3 truth
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} select a range (a \PYGZsq{}slice\PYGZsq{}) of items with [start:end:step]}

\PYG{n}{t} \PYG{o}{=} \PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{it}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{is}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{a}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{truth}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{universally}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{acknowledged}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{items 0:1}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{t}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{l+m+mi}{1}\PYG{p}{]}        \PYG{c}{\PYGZsh{} 0 to 1, so only item 0}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{items 0:2}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{t}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{]}        \PYG{c}{\PYGZsh{} 0 to 2, so items 0 and 1}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{items :4:2}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{t}\PYG{p}{[}\PYG{p}{:}\PYG{l+m+mi}{4}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{]}      \PYG{c}{\PYGZsh{} :4:2 so items 0 (implicit) to 4, in steps of 2}
                                  \PYG{c}{\PYGZsh{} so items 0 and 3}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{items ::\PYGZhy{}1}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{t}\PYG{p}{[}\PYG{p}{:}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}      \PYG{c}{\PYGZsh{} 0 to end in steps of \PYGZhy{}1, so reverse order}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{items 1:\PYGZhy{}1:2}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{t}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{]}  \PYG{c}{\PYGZsh{} 1 to \PYGZhy{}1 in steps of 2 so items 1 and 3}

\PYG{c}{\PYGZsh{} Note the use of \PYGZbs{}t in the strings above e.g. \PYGZsq{}items 0:1\PYGZbs{}t\PYGZsq{}}
\PYG{c}{\PYGZsh{} where \PYGZbs{}t is a tab character (for prettier formatting)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
items 0:1   (\PYGZsq{}it\PYGZsq{},)
items 0:2   (\PYGZsq{}it\PYGZsq{}, \PYGZsq{}is\PYGZsq{})
items :4:2  (\PYGZsq{}it\PYGZsq{}, \PYGZsq{}a\PYGZsq{})
items ::\PYGZhy{}1  (\PYGZsq{}acknowledged\PYGZsq{}, \PYGZsq{}universally\PYGZsq{}, \PYGZsq{}truth\PYGZsq{}, \PYGZsq{}a\PYGZsq{}, \PYGZsq{}is\PYGZsq{}, \PYGZsq{}it\PYGZsq{})
items 1:\PYGZhy{}1:2        (\PYGZsq{}is\PYGZsq{}, \PYGZsq{}truth\PYGZsq{})
\end{Verbatim}

In effect, when we set up a tuple, we are \emph{packing} some group of items
together:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{t} \PYG{o}{=} \PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{the}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{past}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{is}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{a}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{foreign}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{country}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

And we can similarly \emph{unpack}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c} \PYG{o}{=} \PYG{n}{t}

\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{a:}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{a}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{b:}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{b}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{c:}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{c}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
a: the
b: past
c: (\PYGZsq{}is\PYGZsq{}, \PYGZsq{}a\PYGZsq{}, \PYGZsq{}foreign\PYGZsq{}, \PYGZsq{}country\PYGZsq{})
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{t} \PYG{o}{=} \PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{As}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Gregor}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Samsa}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{awoke}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{one}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{morning}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{a}\PYG{p}{,}\PYG{n}{b} \PYG{o}{=} \PYG{n}{t}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{l+m+mi}{4}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{a:}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{a}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{b:}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{b}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
a: Gregor
b: awoke
\end{Verbatim}

The set of operations we can perform on tuples includes:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}tr\PYGZgt{}\PYGZlt{}td\PYGZgt{}\PYGZlt{}b\PYGZgt{}Name\PYGZlt{}/b\PYGZgt{}\PYGZlt{}/td\PYGZgt{}\PYGZlt{}td\PYGZgt{}\PYGZlt{}b\PYGZgt{}Example\PYGZlt{}/b\PYGZgt{}\PYGZlt{}/td\PYGZgt{}\PYGZlt{}td\PYGZgt{}\PYGZlt{}b\PYGZgt{}Result\PYGZlt{}/b\PYGZgt{}\PYGZlt{}/td\PYGZgt{}\PYGZlt{}td\PYGZgt{}\PYGZlt{}b\PYGZgt{}Meaning\PYGZlt{}/b\PYGZgt{}\PYGZlt{}/td\PYGZgt{}\PYGZlt{}/tr\PYGZgt{}
\PYGZlt{}tr\PYGZgt{}\PYGZlt{}td\PYGZgt{}\PYGZlt{}pre\PYGZgt{}len()\PYGZlt{}/pre\PYGZgt{}\PYGZlt{}/td\PYGZgt{}\PYGZlt{}td\PYGZgt{}\PYGZlt{}pre\PYGZgt{}len((1,2,(3,4))\PYGZlt{}/pre\PYGZgt{}\PYGZlt{}/td\PYGZgt{}\PYGZlt{}td\PYGZgt{}\PYGZlt{}pre\PYGZgt{}3\PYGZlt{}/pre\PYGZgt{}\PYGZlt{}/td\PYGZgt{}\PYGZlt{}td\PYGZgt{}Length\PYGZlt{}/td\PYGZgt{}\PYGZlt{}/tr\PYGZgt{}
\PYGZlt{}tr\PYGZgt{}\PYGZlt{}td\PYGZgt{}\PYGZlt{}pre\PYGZgt{}+\PYGZlt{}/pre\PYGZgt{}\PYGZlt{}/td\PYGZgt{}\PYGZlt{}td\PYGZgt{}\PYGZlt{}pre\PYGZgt{}(1,2) + (3,4,5)\PYGZlt{}/pre\PYGZgt{}\PYGZlt{}/td\PYGZgt{}\PYGZlt{}td\PYGZgt{}\PYGZlt{}pre\PYGZgt{}(1,2,3,4,5)\PYGZlt{}/pre\PYGZgt{}\PYGZlt{}/td\PYGZgt{}\PYGZlt{}td\PYGZgt{}Concatenate (join)\PYGZlt{}/td\PYGZgt{}\PYGZlt{}/tr\PYGZgt{}
\PYGZlt{}tr\PYGZgt{}\PYGZlt{}td\PYGZgt{}\PYGZlt{}pre\PYGZgt{}\PYGZbs{}*\PYGZlt{}/pre\PYGZgt{}\PYGZlt{}/td\PYGZgt{}\PYGZlt{}td\PYGZgt{}\PYGZlt{}pre\PYGZgt{}(1,2) * 3\PYGZlt{}/pre\PYGZgt{}\PYGZlt{}/td\PYGZgt{}\PYGZlt{}td\PYGZgt{}\PYGZlt{}pre\PYGZgt{}(1, 2, 1, 2, 1, 2, 1, 2)\PYGZlt{}/pre\PYGZgt{}\PYGZlt{}/td\PYGZgt{}\PYGZlt{}td\PYGZgt{}Repetition\PYGZlt{}/td\PYGZgt{}\PYGZlt{}/tr\PYGZgt{}
\PYGZlt{}tr\PYGZgt{}\PYGZlt{}td\PYGZgt{}\PYGZlt{}pre\PYGZgt{}in\PYGZlt{}/pre\PYGZgt{}\PYGZlt{}/td\PYGZgt{}\PYGZlt{}td\PYGZgt{}\PYGZlt{}pre\PYGZgt{}2 in (1,2,3,4)\PYGZlt{}/pre\PYGZgt{}\PYGZlt{}/td\PYGZgt{}\PYGZlt{}td\PYGZgt{}\PYGZlt{}pre\PYGZgt{}True\PYGZlt{}/pre\PYGZgt{}\PYGZlt{}/td\PYGZgt{}\PYGZlt{}td\PYGZgt{}Membership\PYGZlt{}/td\PYGZgt{}\PYGZlt{}/tr\PYGZgt{}
\PYGZlt{}tr\PYGZgt{}\PYGZlt{}td\PYGZgt{}\PYGZlt{}pre\PYGZgt{}index\PYGZlt{}/pre\PYGZgt{}\PYGZlt{}/td\PYGZgt{}\PYGZlt{}td\PYGZgt{}\PYGZlt{}pre\PYGZgt{}(\PYGZsq{}a\PYGZsq{},\PYGZsq{}b\PYGZsq{},\PYGZsq{}c\PYGZsq{},\PYGZsq{}d\PYGZsq{}).index(\PYGZsq{}c\PYGZsq{})\PYGZlt{}/pre\PYGZgt{}\PYGZlt{}/td\PYGZgt{}\PYGZlt{}td\PYGZgt{}\PYGZlt{}pre\PYGZgt{}2\PYGZlt{}/pre\PYGZgt{}\PYGZlt{}/td\PYGZgt{}\PYGZlt{}td\PYGZgt{}\PYGZlt{}p\PYGZgt{}Index\PYGZlt{}/p\PYGZgt{}\PYGZlt{}p\PYGZgt{}T.index(value, [start, [stop]]) \PYGZhy{}\PYGZgt{} integer \PYGZhy{}\PYGZhy{} return first index of value.\PYGZlt{}/p\PYGZgt{}\PYGZlt{}p\PYGZgt{}Raises ValueError if the value is not present\PYGZlt{}/p\PYGZgt{}\PYGZlt{}/td\PYGZgt{}\PYGZlt{}/tr\PYGZgt{}
\PYGZlt{}tr\PYGZgt{}\PYGZlt{}td\PYGZgt{}\PYGZlt{}pre\PYGZgt{}count\PYGZlt{}/pre\PYGZgt{}\PYGZlt{}/td\PYGZgt{}\PYGZlt{}td\PYGZgt{}\PYGZlt{}pre\PYGZgt{}(\PYGZsq{}a\PYGZsq{},\PYGZsq{}b\PYGZsq{},\PYGZsq{}c\PYGZsq{},\PYGZsq{}c\PYGZsq{},\PYGZsq{}d\PYGZsq{},\PYGZsq{}c\PYGZsq{}).count(\PYGZsq{}c\PYGZsq{})\PYGZlt{}/pre\PYGZgt{}\PYGZlt{}/td\PYGZgt{}\PYGZlt{}td\PYGZgt{}\PYGZlt{}pre\PYGZgt{}3\PYGZlt{}/pre\PYGZgt{}\PYGZlt{}/td\PYGZgt{}\PYGZlt{}td\PYGZgt{}\PYGZlt{}p\PYGZgt{}Count\PYGZlt{}/p\PYGZgt{}\PYGZlt{}p\PYGZgt{}T.count(value) \PYGZhy{}\PYGZgt{} integer \PYGZhy{}\PYGZhy{} return number of occurrences of value\PYGZlt{}/p\PYGZgt{}\PYGZlt{}/td\PYGZgt{}\PYGZlt{}/tr\PYGZgt{}
\PYGZlt{}tr\PYGZgt{}\PYGZlt{}td\PYGZgt{}\PYGZlt{}pre\PYGZgt{}min(), max()\PYGZlt{}/pre\PYGZgt{}\PYGZlt{}/td\PYGZgt{}\PYGZlt{}td\PYGZgt{}\PYGZlt{}p\PYGZgt{}\PYGZlt{}pre\PYGZgt{}min((\PYGZsq{}a\PYGZsq{},\PYGZsq{}b\PYGZsq{},\PYGZsq{}c\PYGZsq{}))\PYGZlt{}/pre\PYGZgt{}\PYGZlt{}/p\PYGZgt{}\PYGZlt{}p\PYGZgt{}\PYGZlt{}pre\PYGZgt{}max((3,4,1))\PYGZlt{}/pre\PYGZgt{}\PYGZlt{}/p\PYGZgt{}\PYGZlt{}/td\PYGZgt{}\PYGZlt{}td\PYGZgt{}\PYGZlt{}p\PYGZgt{}\PYGZlt{}pre\PYGZgt{}\PYGZsq{}a\PYGZsq{}\PYGZlt{}/pre\PYGZgt{}\PYGZlt{}/p\PYGZgt{}\PYGZlt{}p\PYGZgt{}\PYGZlt{}pre\PYGZgt{}4\PYGZlt{}/pre\PYGZgt{}\PYGZlt{}/p\PYGZgt{}\PYGZlt{}/td\PYGZgt{}\PYGZlt{}td\PYGZgt{}Minimum, maximum\PYGZlt{}/td\PYGZgt{}\PYGZlt{}/tr\PYGZgt{}
\PYGZlt{}tr\PYGZgt{}\PYGZlt{}td\PYGZgt{}\PYGZlt{}pre\PYGZgt{}tuple()\PYGZlt{}/pre\PYGZgt{}\PYGZlt{}/td\PYGZgt{}\PYGZlt{}td\PYGZgt{}\PYGZlt{}p\PYGZgt{}\PYGZlt{}pre\PYGZgt{}tuple([1,2,3])\PYGZlt{}/pre\PYGZgt{}\PYGZlt{}/p\PYGZgt{}\PYGZlt{}p\PYGZgt{}\PYGZlt{}pre\PYGZgt{}tuple(\PYGZsq{}hello\PYGZsq{})\PYGZlt{}/pre\PYGZgt{}\PYGZlt{}/p\PYGZgt{}\PYGZlt{}p\PYGZgt{}\PYGZlt{}pre\PYGZgt{}tuple(\PYGZob{}1:\PYGZsq{}one\PYGZsq{},2:\PYGZsq{}two\PYGZsq{}\PYGZcb{})\PYGZlt{}/pre\PYGZgt{}\PYGZlt{}/p\PYGZgt{}\PYGZlt{}/td\PYGZgt{}\PYGZlt{}td\PYGZgt{}\PYGZlt{}p\PYGZgt{}\PYGZlt{}pre\PYGZgt{}(1,2,3)\PYGZlt{}/pre\PYGZgt{}\PYGZlt{}/p\PYGZgt{}\PYGZlt{}p\PYGZgt{}\PYGZlt{}pre\PYGZgt{}(\PYGZsq{}h\PYGZsq{}, \PYGZsq{}e\PYGZsq{}, \PYGZsq{}l\PYGZsq{}, \PYGZsq{}l\PYGZsq{}, \PYGZsq{}o\PYGZsq{})\PYGZlt{}/pre\PYGZgt{}\PYGZlt{}/p\PYGZgt{}\PYGZlt{}p\PYGZgt{}\PYGZlt{}pre\PYGZgt{}(1,2)\PYGZlt{}/pre\PYGZgt{}\PYGZlt{}/p\PYGZgt{}\PYGZlt{}/td\PYGZgt{}\PYGZlt{}td\PYGZgt{}Convert to tuple\PYGZlt{}/td\PYGZgt{}\PYGZlt{}/tr\PYGZgt{}
\end{Verbatim}

You will find that these basic operators work with any of the group
types, so you should make sure you are aware of them.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} some examples}

\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{tuple(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{hello world}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{):}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n+nb}{tuple}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{hello world}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{tuple(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{hello world}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{).count(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{o}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{):}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n+nb}{tuple}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{hello world}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{count}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{o}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{1}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{,)*5 + (1,)*5:}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{1}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{5} \PYG{o}{+} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{5}

\PYG{c}{\PYGZsh{} Note use of \PYGZbs{}t in string for tab and \PYGZbs{}n for newline}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
tuple(\PYGZsq{}hello world\PYGZsq{}):
    (\PYGZsq{}h\PYGZsq{}, \PYGZsq{}e\PYGZsq{}, \PYGZsq{}l\PYGZsq{}, \PYGZsq{}l\PYGZsq{}, \PYGZsq{}o\PYGZsq{}, \PYGZsq{} \PYGZsq{}, \PYGZsq{}w\PYGZsq{}, \PYGZsq{}o\PYGZsq{}, \PYGZsq{}r\PYGZsq{}, \PYGZsq{}l\PYGZsq{}, \PYGZsq{}d\PYGZsq{})

tuple(\PYGZsq{}hello world\PYGZsq{}).count(\PYGZsq{}o\PYGZsq{}):
    2

(\PYGZsq{}1\PYGZsq{},)*5 + (1,)*5:
    (\PYGZsq{}1\PYGZsq{}, \PYGZsq{}1\PYGZsq{}, \PYGZsq{}1\PYGZsq{}, \PYGZsq{}1\PYGZsq{}, \PYGZsq{}1\PYGZsq{}, 1, 1, 1, 1, 1)
\end{Verbatim}

You \textbf{cannot} directly replace an element in a tuple:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{t} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{n}{t}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{three}\PYG{l+s}{\PYGZsq{}}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
TypeError                                 Traceback (most recent call last)

\PYGZlt{}ipython\PYGZhy{}input\PYGZhy{}32\PYGZhy{}0dc2fa4129fe\PYGZgt{} in \PYGZlt{}module\PYGZgt{}()
      1 t = (1,2,3,4)
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} 2 t[2] = \PYGZsq{}three\PYGZsq{}


TypeError: \PYGZsq{}tuple\PYGZsq{} object does not support item assignment
\end{Verbatim}

so you would need to find another way to do this, e.g.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{t} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}

\PYG{n}{t} \PYG{o}{=} \PYG{n}{t}\PYG{p}{[}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{+} \PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{three}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{p}{)} \PYG{o}{+} \PYG{n}{t}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{:}\PYG{p}{]}
\PYG{k}{print} \PYG{n}{t}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{three}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}
\end{Verbatim}

Neither can you delete an item in a tuple:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{t} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}

\PYG{k}{del} \PYG{n}{t}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{k}{print} \PYG{n}{t}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
TypeError                                 Traceback (most recent call last)

\PYGZlt{}ipython\PYGZhy{}input\PYGZhy{}34\PYGZhy{}b33678abdb80\PYGZgt{} in \PYGZlt{}module\PYGZgt{}()
      1 t = (1,2,3,4)
      2
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} 3 del t[2]
      4 print t


TypeError: \PYGZsq{}tuple\PYGZsq{} object doesn\PYGZsq{}t support item deletion
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} again, find another way around}

\PYG{n}{t} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}

\PYG{n}{t} \PYG{o}{=} \PYG{n}{t}\PYG{p}{[}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{+} \PYG{n}{t}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{:}\PYG{p}{]}
\PYG{k}{print} \PYG{n}{t}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}
\end{Verbatim}


\subsubsection{string as a group}
\label{Chapter2_Python_intro/python101:string-as-a-group}
You might have noticed that a string data type \code{str} acts as a
collection of individual characters, e.g.:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{word} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{hello world}\PYG{l+s}{\PYGZsq{}}

\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{word =}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{word}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}

\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{tuple(word) =}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n+nb}{tuple}\PYG{p}{(}\PYG{n}{word}\PYG{p}{)}
\PYG{c}{\PYGZsh{} slice}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{word[2:5] =}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{word}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{]}
\PYG{c}{\PYGZsh{} len}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{len(word) =}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{word}\PYG{p}{)}
\PYG{c}{\PYGZsh{} max (similarly min)}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{max(word) =}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n+nb}{max}\PYG{p}{(}\PYG{n}{word}\PYG{p}{)}
\PYG{c}{\PYGZsh{} in (membership)}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{w}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{ in word =}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{w}\PYG{l+s}{\PYGZsq{}} \PYG{o+ow}{in} \PYG{n}{word}
\PYG{c}{\PYGZsh{} count}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{word.count(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{l}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{)=}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{word}\PYG{o}{.}\PYG{n}{count}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{l}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{c}{\PYGZsh{} index}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{word.index(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{l}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{)=}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{word}\PYG{o}{.}\PYG{n}{index}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{l}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{c}{\PYGZsh{} + (concatenation)}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{word + }\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{ again}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{=}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{word} \PYG{o}{+} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{ again}\PYG{l+s}{\PYGZsq{}}
\PYG{c}{\PYGZsh{} * (repetition)}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{word * 2=}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{word}\PYG{o}{*}\PYG{l+m+mi}{2}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
word =      hello world

tuple(word) =       (\PYGZsq{}h\PYGZsq{}, \PYGZsq{}e\PYGZsq{}, \PYGZsq{}l\PYGZsq{}, \PYGZsq{}l\PYGZsq{}, \PYGZsq{}o\PYGZsq{}, \PYGZsq{} \PYGZsq{}, \PYGZsq{}w\PYGZsq{}, \PYGZsq{}o\PYGZsq{}, \PYGZsq{}r\PYGZsq{}, \PYGZsq{}l\PYGZsq{}, \PYGZsq{}d\PYGZsq{})
word[2:5] = llo
len(word) = 11
max(word) = w
\PYGZsq{}w\PYGZsq{} in word =       True
word.count(\PYGZsq{}l\PYGZsq{})=    3
word.index(\PYGZsq{}l\PYGZsq{})=    2
word + \PYGZsq{} again\PYGZsq{}=    hello world again
word * 2=   hello worldhello world
\end{Verbatim}

This sort of consistency or operation is one of the things that makes
Python a good language to program in.


\subsubsection{list}
\label{Chapter2_Python_intro/python101:list}
\emph{lists} or \emph{sequences} are contained within square brackets \code{{[}{]}}:

The operators available for tuple work in much the same way as for lists
(more formally, sequences):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{t} \PYG{o}{=} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{It}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{was}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{the}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{best}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{of}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{times}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\PYG{k}{print} \PYG{n}{t}

\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}slicing is the same as for tuples\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{n}{t} \PYG{o}{=} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{It}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{was}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{the}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{best}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{of}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{times}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}

\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}slice\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}\PYG{l+s}{\PYGZdq{}}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{t[:4:2]:}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{t}\PYG{p}{[}\PYG{p}{:}\PYG{l+m+mi}{4}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{]}       \PYG{c}{\PYGZsh{} 0th item to 4th in steps of 2, so 0,2}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{t[::\PYGZhy{}1]:}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{t}\PYG{p}{[}\PYG{p}{:}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}       \PYG{c}{\PYGZsh{} reversal}


\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}index\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{n}{t} \PYG{o}{=} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{It}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{was}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{the}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{best}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{of}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{times}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}

\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}index\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}\PYG{l+s}{\PYGZdq{}}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{t.index(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{best}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{):}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{t}\PYG{o}{.}\PYG{n}{index}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{best}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}


\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}plus\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{n}{t} \PYG{o}{=} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{It}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{was}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{+} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{the}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{best}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{of}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{times}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}

\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}plus\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}\PYG{l+s}{\PYGZdq{}}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{t = [}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{It}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{was}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{] + [}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{the}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{best}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{of}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{times}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{]}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{t}


\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}multiply\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{n}{t} \PYG{o}{=} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{It}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{was}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{the}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{+} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{best}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{*} \PYG{l+m+mi}{3} \PYG{o}{+} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{of}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{times}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}

\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}multiply\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}\PYG{l+s}{\PYGZdq{}}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{t = [}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{It}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{was}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{the}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{] + [}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{best}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{] * 3 + [}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{of}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{times}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{]}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{t}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
[\PYGZsq{}It\PYGZsq{}, \PYGZsq{}was\PYGZsq{}, \PYGZsq{}the\PYGZsq{}, \PYGZsq{}best\PYGZsq{}, \PYGZsq{}of\PYGZsq{}, \PYGZsq{}times\PYGZsq{}]

\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}slice\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
t[:4:2]:
    [\PYGZsq{}It\PYGZsq{}, \PYGZsq{}the\PYGZsq{}]
t[::\PYGZhy{}1]:
    [\PYGZsq{}times\PYGZsq{}, \PYGZsq{}of\PYGZsq{}, \PYGZsq{}best\PYGZsq{}, \PYGZsq{}the\PYGZsq{}, \PYGZsq{}was\PYGZsq{}, \PYGZsq{}It\PYGZsq{}]

\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}index\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
t.index(\PYGZdq{}best\PYGZdq{}):
    3

\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}plus\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
t = [\PYGZsq{}It\PYGZsq{}, \PYGZsq{}was\PYGZsq{}] + [\PYGZsq{}the\PYGZsq{}, \PYGZsq{}best\PYGZsq{}, \PYGZsq{}of\PYGZsq{}, \PYGZsq{}times\PYGZsq{}]
    [\PYGZsq{}It\PYGZsq{}, \PYGZsq{}was\PYGZsq{}, \PYGZsq{}the\PYGZsq{}, \PYGZsq{}best\PYGZsq{}, \PYGZsq{}of\PYGZsq{}, \PYGZsq{}times\PYGZsq{}]

\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}multiply\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
t = [\PYGZsq{}It\PYGZsq{}, \PYGZsq{}was\PYGZsq{}, \PYGZsq{}the\PYGZsq{}] + [\PYGZsq{}best\PYGZsq{}] * 3 + [\PYGZsq{}of\PYGZsq{}, \PYGZsq{}times\PYGZsq{}]
    [\PYGZsq{}It\PYGZsq{}, \PYGZsq{}was\PYGZsq{}, \PYGZsq{}the\PYGZsq{}, \PYGZsq{}best\PYGZsq{}, \PYGZsq{}best\PYGZsq{}, \PYGZsq{}best\PYGZsq{}, \PYGZsq{}of\PYGZsq{}, \PYGZsq{}times\PYGZsq{}]
\end{Verbatim}

But there are many other things one can do with a list, e.g.:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}replace\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{n}{t} \PYG{o}{=} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{It}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{was}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{the}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{best}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{of}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{times}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}

\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}replace\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}\PYG{l+s}{\PYGZdq{}}
\PYG{n}{t}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{New}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{York}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{t[3:5] = }\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{New York}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{:}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{t}


\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}index and replace\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{n}{t} \PYG{o}{=} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{It}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{was}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{the}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{best}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{of}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{times}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}

\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}index and replace\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}\PYG{l+s}{\PYGZdq{}}
\PYG{n}{t}\PYG{p}{[}\PYG{n}{t}\PYG{o}{.}\PYG{n}{index}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{best}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{]} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{worst}\PYG{l+s}{\PYGZsq{}}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{t[t.index(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{best}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{)] = }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{worst}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{:}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{t}


\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}can delete one or more items\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{n}{t} \PYG{o}{=} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{It}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{was}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{the}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{best}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{of}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{times}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}

\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}del item\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}\PYG{l+s}{\PYGZdq{}}
\PYG{k}{del} \PYG{n}{t}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{:}\PYG{l+m+mi}{4}\PYG{p}{]}                         \PYG{c}{\PYGZsh{} delete items 2 to 4, i.e. 2, 3}
                                   \PYG{c}{\PYGZsh{} i.e. \PYGZsq{}the\PYGZsq{}, \PYGZsq{}best\PYGZsq{}}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{del t[2:4]:}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{t}


\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}can sort\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{n}{t} \PYG{o}{=} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{It}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{was}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{the}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{best}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{of}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{times}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}

\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}sort\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}\PYG{l+s}{\PYGZdq{}}
\PYG{n}{t}\PYG{o}{.}\PYG{n}{sort}\PYG{p}{(}\PYG{p}{)}                           \PYG{c}{\PYGZsh{} sort inplace}

\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{t.sort():}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{t}


\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}can insert\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{n}{t} \PYG{o}{=} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{It}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{was}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{the}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{best}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{of}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{times}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}

\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}insert\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}\PYG{l+s}{\PYGZdq{}}
\PYG{n}{t}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{really}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}               \PYG{c}{\PYGZsh{} insert inplace}

\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{t.insert(1,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{really}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{):}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{t}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}replace\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
t[3:5] = \PYGZsq{}New York\PYGZsq{}:
    [\PYGZsq{}It\PYGZsq{}, \PYGZsq{}was\PYGZsq{}, \PYGZsq{}the\PYGZsq{}, \PYGZsq{}New\PYGZsq{}, \PYGZsq{}York\PYGZsq{}, \PYGZsq{}times\PYGZsq{}]

\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}index and replace\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
t[t.index(\PYGZdq{}best\PYGZdq{})] = \PYGZdq{}worst\PYGZdq{}:
    [\PYGZsq{}It\PYGZsq{}, \PYGZsq{}was\PYGZsq{}, \PYGZsq{}the\PYGZsq{}, \PYGZsq{}worst\PYGZsq{}, \PYGZsq{}of\PYGZsq{}, \PYGZsq{}times\PYGZsq{}]

\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}del item\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
del t[2:4]:
    [\PYGZsq{}It\PYGZsq{}, \PYGZsq{}was\PYGZsq{}, \PYGZsq{}of\PYGZsq{}, \PYGZsq{}times\PYGZsq{}]

\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}sort\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
t.sort():
    [\PYGZsq{}It\PYGZsq{}, \PYGZsq{}best\PYGZsq{}, \PYGZsq{}of\PYGZsq{}, \PYGZsq{}the\PYGZsq{}, \PYGZsq{}times\PYGZsq{}, \PYGZsq{}was\PYGZsq{}]

\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}insert\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
t.insert(1,\PYGZsq{}really\PYGZsq{}):
    [\PYGZsq{}It\PYGZsq{}, \PYGZsq{}really\PYGZsq{}, \PYGZsq{}was\PYGZsq{}, \PYGZsq{}the\PYGZsq{}, \PYGZsq{}best\PYGZsq{}, \PYGZsq{}of\PYGZsq{}, \PYGZsq{}times\PYGZsq{}]
\end{Verbatim}


\subsubsection{range}
\label{Chapter2_Python_intro/python101:range}
Many functions that return multiple items will make use of a list to do
so.

An example of this that we will use below is
\code{{}`range(start,stop,step)} \textless{}\href{http://docs.python.org/2/library/functions.html\#range}{http://docs.python.org/2/library/functions.html\#range}\textgreater{}{}`\_\_
that returns a list of integers from \code{start} to (but not including)
\code{stop} in steps of \code{step}.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mi}{9}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{n+nb}{range}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{8}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{6}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} set a value 3 to the variable x}
\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{3}

\PYG{c}{\PYGZsh{} range(10) produces the lis}
\PYG{c}{\PYGZsh{} [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]}
\PYG{n}{x} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nb+bp}{True}
\end{Verbatim}


\section{2.5 Loops and Conditional Statements: if, for, while}
\label{Chapter2_Python_intro/python101:loops-and-conditional-statements-if-for-while}
So far, we have come across the ideas of variables, data types, and two
ways of grouping objects together (tuples and lists).

Another fundamental aspect of any programming language is conditional
statements. The simplest form of this is an \code{if ... else ...}
statement:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{pockets} \PYG{o}{=} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{phone}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{keys}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{wallet}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{frog}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}

\PYG{n}{this\PYGZus{}item} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nothing}\PYG{l+s}{\PYGZsq{}}

\PYG{c}{\PYGZsh{} test if something is in the list}
\PYG{k}{if} \PYG{n}{this\PYGZus{}item} \PYG{o+ow}{in} \PYG{n}{pockets}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{You do have}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{this\PYGZus{}item}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{in your pocket}\PYG{l+s}{\PYGZsq{}}
\PYG{k}{else}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{You don}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{t have}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{this\PYGZus{}item}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{in your pocket}\PYG{l+s}{\PYGZsq{}}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
You don\PYGZsq{}t have nothing in your pocket
\end{Verbatim}

Here,

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{this\PYGZus{}item} \PYG{o+ow}{in} \PYG{n}{pockets}
\end{Verbatim}

is a membership test as we have seen above (it returns \code{True} or
\code{False}).

If it's \code{True}, the code block

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{You do have}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{this\PYGZus{}item}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{in your pocket}\PYG{l+s}{\PYGZsq{}}
\end{Verbatim}

is executed. If \code{False}, then the next condition is checked.

Note the use of indentation here (using \code{tab} or spaces) to represent
the structure of the conditional statements.

Note also the use of a colon (\code{:}) to mark the end of the conditional
test.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}An if example}

\PYG{l+s+sd}{   Threshold the value of x at zero}
\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}

\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{3}

\PYG{c}{\PYGZsh{} threshold at zero}
\PYG{c}{\PYGZsh{} and print some information about what we did}

\PYG{k}{if} \PYG{n}{x} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{x less than 0}\PYG{l+s}{\PYGZsq{}}
    \PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{k}{elif} \PYG{n}{x} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{x is zero}\PYG{l+s}{\PYGZsq{}}
\PYG{k}{else}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{x is more than zero}\PYG{l+s}{\PYGZsq{}}

\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{thresholded x = }\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{x}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
x is more than zero
thresholded x =  3
\end{Verbatim}

The syntax of this is:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{n}{condition1} \PYG{o+ow}{is} \PYG{n+nb+bp}{True}\PYG{p}{:}
    \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{k}{elif} \PYG{n}{condition2} \PYG{o+ow}{is} \PYG{n+nb+bp}{True}\PYG{p}{:}
    \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{k}{else}\PYG{p}{:}
    \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\end{Verbatim}

where \code{condition1} and \code{condition2} are logical tests (e.g.
\code{this\_item in pockets}, \code{today == "Wednesday"}, \code{x \textgreater{} 10} etc.) and
the \code{is True} part of the syntax is implicit (i.e. you don't need to
type \code{is True}).

The word \code{elif} means \code{else if}. The tests are considered in the
order they are givem so that if \code{condition1} is \code{not True}, we
examine \code{condition2}. If that is \code{not True}, we fall through to the
final \code{else} block.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} nested conditional statements: If}

\PYG{n}{what\PYGZus{}you\PYGZus{}keep} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{your head}\PYG{l+s}{\PYGZsq{}}
\PYG{n}{when\PYGZus{}you\PYGZus{}do\PYGZus{}it} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{all about you are losing theirs}\PYG{l+s}{\PYGZsq{}}
\PYG{n}{whom\PYGZus{}you\PYGZus{}trust\PYGZus{}when\PYGZus{}all\PYGZus{}men\PYGZus{}doubt\PYGZus{}you} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{yourself}\PYG{l+s}{\PYGZsq{}}

\PYG{c}{\PYGZsh{} first tests}
\PYG{k}{if} \PYG{p}{(} \PYG{n}{what\PYGZus{}you\PYGZus{}keep} \PYG{o}{==} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{your head}\PYG{l+s}{\PYGZsq{}} \PYG{p}{)} \PYG{o+ow}{and} \PYGZbs{}
    \PYG{p}{(}\PYG{n}{when\PYGZus{}you\PYGZus{}do\PYGZus{}it} \PYG{o}{==} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{all about you are losing theirs}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:}

    \PYG{c}{\PYGZsh{} second level tests}
    \PYG{k}{if} \PYG{n}{whom\PYGZus{}you\PYGZus{}trust\PYGZus{}when\PYGZus{}all\PYGZus{}men\PYGZus{}doubt\PYGZus{}you} \PYG{o}{==} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{yourself}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}
        \PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Yours is the Earth and everything thats in it ...}\PYG{l+s}{\PYGZdq{}}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Nearly there ...}\PYG{l+s}{\PYGZdq{}}

\PYG{k}{else}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Have a look at http://www.poetryfoundation.org/poem/175772}\PYG{l+s}{\PYGZdq{}}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
Yours is the Earth and everything thats in it ...
\end{Verbatim}


\subsection{Exercise 2.2}
\label{Chapter2_Python_intro/python101:exercise-2-2}

\subsubsection{Exercise 2.2 A.}
\label{Chapter2_Python_intro/python101:exercise-2-2-a}
A small piece of Python code that will set the variable \code{today} to be
a string with the day of the week today is:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} This imports a module that we can use to access dates}
\PYG{k+kn}{from} \PYG{n+nn}{datetime} \PYG{k+kn}{import} \PYG{n}{datetime}

\PYG{c}{\PYGZsh{} set up a list of days of the week, starting Monday}
\PYG{c}{\PYGZsh{} Note the line continuation here with \PYGZbs{}}
\PYG{n}{week} \PYG{o}{=} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Monday}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Tuesday}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Wednesday}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Thursday}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYGZbs{}
        \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Friday}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Saturday}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Sunday}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}

\PYG{c}{\PYGZsh{} This part gives the day of the week}
\PYG{c}{\PYGZsh{} as an integer, 0 \PYGZhy{}\PYGZgt{} Monday, 1 \PYGZhy{}\PYGZgt{} Tuesday etc.}
\PYG{n}{day\PYGZus{}number} \PYG{o}{=} \PYG{n}{datetime}\PYG{o}{.}\PYG{n}{now}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{weekday}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{today} \PYG{o}{=} \PYG{n}{week}\PYG{p}{[}\PYG{n}{day\PYGZus{}number}\PYG{p}{]}

\PYG{c}{\PYGZsh{} print item day\PYGZus{}number in the list week}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{today is}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{today}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{today} \PYG{o+ow}{is} \PYG{n}{Tuesday}
\end{Verbatim}

Based on the example below, \textbf{set up a diary for youself for the week to
print out what you should be doing today, using the conditional
structure {}`{}`if .. elif ... else{}`{}`.}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{n}{day\PYGZus{}number} \PYG{o}{==} \PYG{l+m+mi}{2}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Remember to wake up early to get to the Python class at UCL}\PYG{l+s}{\PYGZdq{}}
\PYG{k}{elif} \PYG{n}{day\PYGZus{}number} \PYG{o}{==} \PYG{l+m+mi}{4}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Remember to wake up early to go to classes at Imperial College}\PYG{l+s}{\PYGZdq{}}
\PYG{k}{else}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{get some sleep}\PYG{l+s}{\PYGZdq{}}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
get some sleep
\end{Verbatim}


\subsubsection{Exercise 2.2 B.}
\label{Chapter2_Python_intro/python101:exercise-2-2-b}
You could set up the basic calendar for the week in a list, with the
first entry representing Monday, the second Tuesday etc.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{my\PYGZus{}diary} \PYG{o}{=} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Spend the day practicing Python}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYGZbs{}
            \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Do some reading in the library at UCL}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYGZbs{}
            \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Remember to wake up early to get to the Python class at UCL}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYGZbs{}
            \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Spend the day practicing Python}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYGZbs{}
            \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Remember to wake up early to go to classes at Imperial College}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYGZbs{}
            \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Work at Python exercises from home}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYGZbs{}
            \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Work at Python exercises from home}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\end{Verbatim}

Using a list of this sort, \textbf{print the diary entry for today *without*
using conditional statements.}

Criticise the code you develop and make suggestions for improvement.


\subsubsection{for}
\label{Chapter2_Python_intro/python101:for}
Very commonly, we need to iterate or `loop' over some set of items.

The basic stucture for doing this (in Python, and many other languages)
is \code{for ... in ...}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{count\PYGZus{}list} \PYG{o}{=} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}

\PYG{c}{\PYGZsh{} for loop}
\PYG{k}{for} \PYG{n}{count} \PYG{o+ow}{in} \PYG{n}{count\PYGZus{}list}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}print counter in loop\PYGZsq{}\PYGZsq{}\PYGZsq{}}
    \PYG{k}{print} \PYG{n}{count}

\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{blast off}\PYG{l+s}{\PYGZsq{}}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
1
2
3
blast off
\end{Verbatim}

which has the syntax:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{var} \PYG{o+ow}{in} \PYG{n+nb}{list}\PYG{p}{:}
    \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\end{Verbatim}

where the variable \code{var} is set to each of the items in \code{list}, in
the order in which they appear in \code{list}.


\subsubsection{xrange}
\label{Chapter2_Python_intro/python101:xrange}
When we have a loop, there nust be something that defines what it is we
loop over. In the example above, this was a list, \code{count\_list}, which
here is \code{{[}1, 2, 3{]}}.

In Python, we can use either use some explicit list, tuple etc. to
define what we loop over, or, we can use a \href{http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html\#generator-expressions-1}{generator
expression},
which is something that returns one of its members at a time.

Normally then, instead or using \code{range} above, which involves an
\emph{explicit} calculation and storage of all elements of the list, we use a
generator function,
\code{{}`xrange} \textless{}\href{http://docs.python.org/2/library/functions.html\#xrange}{http://docs.python.org/2/library/functions.html\#xrange}\textgreater{}{}`\_\_,
which, in essence, returns the elements `on demand' as needed in the
loop (and so uses less memory, though there is little real difference
except for very large loops).

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} for loop}
\PYG{k}{for} \PYG{n}{count} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}print counter in loop\PYGZsq{}\PYGZsq{}\PYGZsq{}}
    \PYG{k}{print} \PYG{n}{count}

\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{blast off}\PYG{l+s}{\PYGZsq{}}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
1
2
3
blast off
\end{Verbatim}

If you need to force an
\code{{}`iterable} \textless{}\href{http://docs.python.org/2/glossary.html\#term-iterable}{http://docs.python.org/2/glossary.html\#term-iterable}\textgreater{}{}`\_\_
to e.g. return a list, you can convert the data type to \code{list}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nb}{xrange}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n+nb}{xrange}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}
\end{Verbatim}


\subsubsection{enumerate}
\label{Chapter2_Python_intro/python101:enumerate}
Commonly, when iterating over a set of items, we also need access to a
counter, telling us which item in the list we are currently on.

This is done using the function
\code{{}`enumerate()} \textless{}\href{http://docs.python.org/2/library/functions.html\#enumerate}{http://docs.python.org/2/library/functions.html\#enumerate}\textgreater{}{}`\_\_.
This returns the \code{tuple} \code{(count,item)} where \code{count} is the index
of \code{item} in \code{list}.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{word\PYGZus{}list} \PYG{o}{=} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Call}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{me}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Ishmael}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}

\PYG{k}{for} \PYG{n}{i}\PYG{p}{,}\PYG{n}{w} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{word\PYGZus{}list}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{The}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{i}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{th}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{word is}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{w}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
The 0 th word is Call
The 1 th word is me
The 2 th word is Ishmael
\end{Verbatim}

Here the syntax:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{count}\PYG{p}{,}\PYG{n}{var} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n+nb}{list}\PYG{p}{)}\PYG{p}{:}
    \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\end{Verbatim}


\section{2.6 Strings and things}
\label{Chapter2_Python_intro/python101:strings-and-things}
We have seen the data type \code{str} above and noted some of the
operations we can use of strings.

You can look over some more \href{http://docs.python.org/2/library/string.html\_}{detailed
notes} on strings at
some point, but here we will now go through some other typical
operations you will use in scientific computing:


\subsection{2.6.1 Some basic string operations}
\label{Chapter2_Python_intro/python101:some-basic-string-operations}
As a recap, with some slightly more complicated examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{word} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{hello world}\PYG{l+s}{\PYGZsq{}}

\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{word }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{=}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{word}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}

\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{list(word) }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{=}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{word}\PYG{p}{)}

\PYG{c}{\PYGZsh{} slice}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{word[::\PYGZhy{}1] }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{=}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{word}\PYG{p}{[}\PYG{p}{:}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{c}{\PYGZsh{} len}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{len(word) }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{=}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{word}\PYG{p}{)}
\PYG{c}{\PYGZsh{} min (similarly max)}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{min(word) }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{=}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n+nb}{min}\PYG{p}{(}\PYG{n}{word}\PYG{p}{)}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{... what was printed there?}\PYG{l+s}{\PYGZsq{}}
\PYG{c}{\PYGZsh{} in (membership)}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{n}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{ in word }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{=}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{n}\PYG{l+s}{\PYGZsq{}} \PYG{o+ow}{in} \PYG{n}{word}
\PYG{c}{\PYGZsh{} count}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{word.count(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{p}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{)}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{=}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{word}\PYG{o}{.}\PYG{n}{count}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{p}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{c}{\PYGZsh{} + (concatenation)}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{hey!}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{ + word[len(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{hello}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{)::2]}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{=}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{hey!}\PYG{l+s}{\PYGZsq{}} \PYG{o}{+} \PYG{n}{word}\PYG{p}{[}\PYG{n+nb}{len}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{hello}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{c}{\PYGZsh{} * (repetition)}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{word[:6]* 3}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{=}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{word}\PYG{p}{[}\PYG{p}{:}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{o}{*}\PYG{l+m+mi}{3}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
word
    = hello world

list(word)
    = [\PYGZsq{}h\PYGZsq{}, \PYGZsq{}e\PYGZsq{}, \PYGZsq{}l\PYGZsq{}, \PYGZsq{}l\PYGZsq{}, \PYGZsq{}o\PYGZsq{}, \PYGZsq{} \PYGZsq{}, \PYGZsq{}w\PYGZsq{}, \PYGZsq{}o\PYGZsq{}, \PYGZsq{}r\PYGZsq{}, \PYGZsq{}l\PYGZsq{}, \PYGZsq{}d\PYGZsq{}]
word[::\PYGZhy{}1]
    = dlrow olleh
len(word)
    = 11
min(word)
    =
    ... what was printed there?
\PYGZsq{}n\PYGZsq{} in word
    = False
word.count(\PYGZsq{}p\PYGZsq{})
    = 0
\PYGZsq{}hey!\PYGZsq{} + word[len(\PYGZsq{}hello\PYGZsq{})::2]
    = hey! ol
word[:6]* 3
    = hello hello hello
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} look what happens if we call index}
\PYG{c}{\PYGZsh{} for something that doesn\PYGZsq{}t exist in the string}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{word.index(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{x}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{)=}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{word}\PYG{o}{.}\PYG{n}{index}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{x}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
word.index(\PYGZsq{}x\PYGZsq{})=
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
ValueError                                Traceback (most recent call last)

\PYGZlt{}ipython\PYGZhy{}input\PYGZhy{}55\PYGZhy{}515f07310ca9\PYGZgt{} in \PYGZlt{}module\PYGZgt{}()
      1 \PYGZsh{} look what happens if we call index
      2 \PYGZsh{} for something that doesn\PYGZsq{}t exist in the string
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} 3 print \PYGZdq{}word.index(\PYGZsq{}x\PYGZsq{})=\PYGZbs{}t\PYGZdq{},word.index(\PYGZsq{}x\PYGZsq{})


ValueError: substring not found
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} Sometimes, we might wish to use}
\PYG{c}{\PYGZsh{} the string operator find instead}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{word.find(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{x}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{)=}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{word}\PYG{o}{.}\PYG{n}{find}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{x}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{word}\PYG{o}{.}\PYG{n}{find}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{x}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{=}     \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}
\end{Verbatim}


\subsection{2.6.2 split}
\label{Chapter2_Python_intro/python101:split}
Suppose we have some data that are presented to us as a string with
white space separating each data element, e.g.:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{data} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{1964 1220 1974 2470 1984 2706 1994 4812 2004 2707}\PYG{l+s}{\PYGZdq{}}
\end{Verbatim}

These data are total fossil fuel emissions for Zimbabwe (thousand metric
tons of C) for selected years (dataset \href{ftp://cdiac.ornl.gov/pub/trends/emissions/zim.dat}{doi
10.3334/CDIAC/00001\_V2011}).

The even elements are the year (\code{1964}, \code{1974} etc.) and the odd
elements (\code{1220}, \code{2470}) the data for that year.

We can use the string operator \code{split()} to separate this into a list
of strings:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{data} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{1964 1220 1974 2470 1984 2706 1994 4812 2004 2707}\PYG{l+s}{\PYGZdq{}}
\PYG{n}{sdata} \PYG{o}{=} \PYG{n}{data}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{sdata}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{1964}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{1220}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{1974}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{2470}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{1984}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{2706}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{1994}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{4812}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{2004}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{2707}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\end{Verbatim}

We could the convert these to integer:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{data} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{1964 1220 1974 2470 1984 2706 1994 4812 2004 2707}\PYG{l+s}{\PYGZdq{}}
\PYG{n}{sdata} \PYG{o}{=} \PYG{n}{data}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)}

\PYG{c}{\PYGZsh{} how many items are there?}
\PYG{c}{\PYGZsh{} use len(), and divide by 2 in this case}
\PYG{n}{n\PYGZus{}items} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{sdata}\PYG{p}{)}

\PYG{c}{\PYGZsh{} create an empty list: years}
\PYG{n}{years} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}

\PYG{c}{\PYGZsh{} create an empty list: emissions}
\PYG{n}{emissions} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}

\PYG{c}{\PYGZsh{} loop over sdata in steps of 2}
\PYG{c}{\PYGZsh{} and append years and emissions}
\PYG{c}{\PYGZsh{} data as int}

\PYG{c}{\PYGZsh{} xrange(0,n\PYGZus{}items,2) because}
\PYG{c}{\PYGZsh{} we want to step every 2 in this case}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{n\PYGZus{}items}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{years}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{sdata}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{emissions}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{sdata}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{years}
\PYG{k}{print} \PYG{n}{emissions}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{l+m+mi}{1964}\PYG{p}{,} \PYG{l+m+mi}{1974}\PYG{p}{,} \PYG{l+m+mi}{1984}\PYG{p}{,} \PYG{l+m+mi}{1994}\PYG{p}{,} \PYG{l+m+mi}{2004}\PYG{p}{]}
\PYG{p}{[}\PYG{l+m+mi}{1220}\PYG{p}{,} \PYG{l+m+mi}{2470}\PYG{p}{,} \PYG{l+m+mi}{2706}\PYG{p}{,} \PYG{l+m+mi}{4812}\PYG{p}{,} \PYG{l+m+mi}{2707}\PYG{p}{]}
\end{Verbatim}


\subsection{2.6.3 join}
\label{Chapter2_Python_intro/python101:join}
The `opposite' of \code{split} is \code{join}.

This returns an iterable of the form \code{S.join(list)}, where \code{S} is
the separator and \code{list} is a \textbf{list of strings} e.g.:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{str1} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{hello}\PYG{l+s}{\PYGZsq{}}
\PYG{n}{str2} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{world}\PYG{l+s}{\PYGZsq{}}

\PYG{c}{\PYGZsh{} joint with space}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{p}{[}\PYG{n}{str1}\PYG{p}{,}\PYG{n}{str2}\PYG{p}{]}\PYG{p}{)}
\PYG{c}{\PYGZsh{} joint with no space}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{p}{[}\PYG{n}{str1}\PYG{p}{,}\PYG{n}{str2}\PYG{p}{]}\PYG{p}{)}
\PYG{c}{\PYGZsh{} join with tab}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{p}{[}\PYG{n}{str1}\PYG{p}{,}\PYG{n}{str1}\PYG{p}{,}\PYG{n}{str2}\PYG{p}{]}\PYG{p}{)}
\PYG{c}{\PYGZsh{} join with colon :}
\PYG{c}{\PYGZsh{} note what happens we pass a}
\PYG{c}{\PYGZsh{} string, rather than a list}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{:}\PYG{l+s}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{str1}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
hello world
helloworld
hello       hello   world
h:e:l:l:o
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} remember that it has to be a list}
\PYG{c}{\PYGZsh{} of strings: years here is a list}
\PYG{c}{\PYGZsh{} of integers}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{years}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
TypeError                                 Traceback (most recent call last)

\PYGZlt{}ipython\PYGZhy{}input\PYGZhy{}61\PYGZhy{}795783cbd46a\PYGZgt{} in \PYGZlt{}module\PYGZgt{}()
      2 \PYGZsh{} of strings: years here is a list
      3 \PYGZsh{} of integers
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} 4 print \PYGZsq{} \PYGZsq{}.join(years)


TypeError: sequence item 0: expected string, int found
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{data} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{1964 1220 1974 2470 1984 2706 1994 4812 2004 2707}\PYG{l+s}{\PYGZdq{}}
\PYG{n}{sdata} \PYG{o}{=} \PYG{n}{data}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{sdata}\PYG{p}{)}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{sdata}\PYG{p}{[}\PYG{n}{i}\PYG{p}{:}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
1964 1220
1974 2470
1984 2706
1994 4812
2004 2707
\end{Verbatim}


\subsection{2.6.4 listcomp}
\label{Chapter2_Python_intro/python101:listcomp}
That is a perfectly fine way to pull these data out of a string, but
it's not very
\href{http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html}{`Pythonic'}
(it does'nt make best use of some of the elegant features of this
language).

Better in this sense is what are known as
\href{http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html\#list-comprehensions}{listcomps}
(list comprehensions).

With a listcomp, you define a list (enclosed in \code{{[}}, \code{{]}}), with two
or three terms. The first term is some function \code{fn(item)}. The second
is a for statement. The third, if present, is a conditional (\code{if})
statement.

For example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{fdata} \PYG{o}{=} \PYG{p}{[}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)} \PYG{k}{for} \PYG{n}{s} \PYG{o+ow}{in} \PYG{n}{data}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}

\PYG{k}{print} \PYG{n}{fdata}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{l+m+mi}{1964}\PYG{p}{,} \PYG{l+m+mi}{1220}\PYG{p}{,} \PYG{l+m+mi}{1974}\PYG{p}{,} \PYG{l+m+mi}{2470}\PYG{p}{,} \PYG{l+m+mi}{1984}\PYG{p}{,} \PYG{l+m+mi}{2706}\PYG{p}{,} \PYG{l+m+mi}{1994}\PYG{p}{,} \PYG{l+m+mi}{4812}\PYG{p}{,} \PYG{l+m+mi}{2004}\PYG{p}{,} \PYG{l+m+mi}{2707}\PYG{p}{]}
\end{Verbatim}

This generates a list. Within this list, we iterate over the loop
\code{for s in data.split()}, and enter the result of the function
\code{int(s)}.

So this example is directly equivalent to:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{data} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{1964 1220 1974 2470 1984 2706 1994 4812 2004 2707}\PYG{l+s}{\PYGZdq{}}

\PYG{n}{fdata} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{s} \PYG{o+ow}{in} \PYG{n}{data}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{fdata}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{p}{)}

\PYG{k}{print} \PYG{n}{fdata}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{l+m+mi}{1964}\PYG{p}{,} \PYG{l+m+mi}{1220}\PYG{p}{,} \PYG{l+m+mi}{1974}\PYG{p}{,} \PYG{l+m+mi}{2470}\PYG{p}{,} \PYG{l+m+mi}{1984}\PYG{p}{,} \PYG{l+m+mi}{2706}\PYG{p}{,} \PYG{l+m+mi}{1994}\PYG{p}{,} \PYG{l+m+mi}{4812}\PYG{p}{,} \PYG{l+m+mi}{2004}\PYG{p}{,} \PYG{l+m+mi}{2707}\PYG{p}{]}
\end{Verbatim}

You will very commonly use listcomps of this nature when performing some
function over elements in a list where you have to perform the function
on each element at a time.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{data} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{1964 1220 1974 2470 1984 2706 1994 4812 2004 2707}\PYG{l+s}{\PYGZdq{}}
\PYG{n}{fdata} \PYG{o}{=} \PYG{p}{[}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)} \PYG{k}{for} \PYG{n}{s} \PYG{o+ow}{in} \PYG{n}{data}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}

\PYG{c}{\PYGZsh{} use slicing to separate the odd}
\PYG{c}{\PYGZsh{} and even data}
\PYG{n}{years}     \PYG{o}{=} \PYG{n}{fdata}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{n}{emissions} \PYG{o}{=} \PYG{n}{fdata}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{]}

\PYG{k}{print} \PYG{n}{years}
\PYG{k}{print} \PYG{n}{emissions}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{l+m+mi}{1964}\PYG{p}{,} \PYG{l+m+mi}{1974}\PYG{p}{,} \PYG{l+m+mi}{1984}\PYG{p}{,} \PYG{l+m+mi}{1994}\PYG{p}{,} \PYG{l+m+mi}{2004}\PYG{p}{]}
\PYG{p}{[}\PYG{l+m+mi}{1220}\PYG{p}{,} \PYG{l+m+mi}{2470}\PYG{p}{,} \PYG{l+m+mi}{2706}\PYG{p}{,} \PYG{l+m+mi}{4812}\PYG{p}{,} \PYG{l+m+mi}{2707}\PYG{p}{]}
\end{Verbatim}

Listcomps can be very convenient, as they are a compact way of
specifying a loop (with a conditonal statement oif required).

Don't use listcomps if they obscure the meaning of what you are doing
though.


\subsection{2.6.5 generator expressions}
\label{Chapter2_Python_intro/python101:generator-expressions}
A listcomp generates everything in the list, then returns the list.

Sometimes, you only need one element at a time (e.g. within a loop). In
such cases, it is better to use generator expressions.

These look much like listcomps but use \code{()} rather than \code{{[}{]}}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{fdata} \PYG{o}{=} \PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)} \PYG{k}{for} \PYG{n}{s} \PYG{o+ow}{in} \PYG{n}{data}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{fdata}

\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{fdata}\PYG{p}{:}
    \PYG{k}{print} \PYG{n}{i}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}generator object \PYGZlt{}genexpr\PYGZgt{} at 0x106540140\PYGZgt{}
1964
1220
1974
2470
1984
2706
1994
4812
2004
2707
\end{Verbatim}

but only return one item at a time, on demand in the loop.


\subsection{2.6.6 replace}
\label{Chapter2_Python_intro/python101:replace}
Another useful string operator is \code{replace}, e.g.:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} change white space separation to comma separation}
\PYG{n}{data} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{1964 1220 1974 2470 1984 2706 1994 4812 2004 2707}\PYG{l+s}{\PYGZdq{}}
\PYG{k}{print} \PYG{n}{data}\PYG{o}{.}\PYG{n}{replace}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{1964}\PYG{p}{,}\PYG{l+m+mi}{1220}\PYG{p}{,}\PYG{l+m+mi}{1974}\PYG{p}{,}\PYG{l+m+mi}{2470}\PYG{p}{,}\PYG{l+m+mi}{1984}\PYG{p}{,}\PYG{l+m+mi}{2706}\PYG{p}{,}\PYG{l+m+mi}{1994}\PYG{p}{,}\PYG{l+m+mi}{4812}\PYG{p}{,}\PYG{l+m+mi}{2004}\PYG{p}{,}\PYG{l+m+mi}{2707}
\end{Verbatim}


\subsection{2.6.7 format}
\label{Chapter2_Python_intro/python101:format}
The most common way you are likely to be formatting strings is using
expressions such as:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{how\PYGZus{}many} \PYG{o}{=} \PYG{l+m+mi}{10}
\PYG{n}{how\PYGZus{}much} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{hours}\PYG{l+s}{\PYGZdq{}}

\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{There are only }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{ things to learn.}\PYG{l+s+se}{\PYGZbs{}}
\PYG{l+s}{        }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{But}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{it will take you }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{ to do so.}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{how\PYGZus{}many}\PYG{p}{,}\PYG{n}{how\PYGZus{}much}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
There are only 10 things to learn.
But it will take you hours to do so.
\end{Verbatim}

Using this style of string formatting, you put control characters into
the string, e.g.:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+s}{\PYGZdq{}}\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{: hello }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZdq{}}
\end{Verbatim}

and put a tuple of variables after the string, separated by \code{\%} which
are inserted into the string in the order in which they appear:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+s}{\PYGZdq{}}\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{: hello }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{ten}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

Note that you must get the data types correct, or you will generate an
error.

The most common formatting codes are:
\begin{itemize}
\item {} 
\code{\%d} represents an integer

\item {} 
\code{\%s} represents a string

\item {} 
\code{\%f} represents a float

\item {} 
\code{\%e} represents a float in exponential form

\end{itemize}

e.g.:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}}
\PYG{l+s}{        integer     }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}}
\PYG{l+s}{        float       }\PYG{l+s+si}{\PYGZpc{}f}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}}
\PYG{l+s}{        string      }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}}
\PYG{l+s}{        exponential }\PYG{l+s+si}{\PYGZpc{}e}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mf}{3.1415926536}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{pies are squared}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+m+mf}{3.1415926536}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
integer     3
float       3.141593
string      pies are squared
exponential 3.141593e+00
\end{Verbatim}


\subsection{2.6.8 strip}
\label{Chapter2_Python_intro/python101:strip}
A useful method is \code{strip()} that strips off any unnecessary white
space and newlines e.g.:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{string} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{   hello world      }\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZsq{}}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\textbar{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\textbar{}}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{n}{string}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\textbar{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\textbar{}}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{n}{string}\PYG{o}{.}\PYG{n}{strip}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\textbar{}   hello world             \textbar{}
\textbar{}hello world\textbar{}
\end{Verbatim}


\subsection{2.6.9 Getting and splitting filenames}
\label{Chapter2_Python_intro/python101:getting-and-splitting-filenames}

\subsubsection{glob}
\label{Chapter2_Python_intro/python101:glob}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} example, with directory names}

\PYG{c}{\PYGZsh{} glob unix style pattern matching for files and directories}
\PYG{k+kn}{import} \PYG{n+nn}{glob}

\PYG{c}{\PYGZsh{} returns a list (or [] if empty)}
\PYG{c}{\PYGZsh{} to match the pattern given}
\PYG{n}{file\PYGZus{}list} \PYG{o}{=} \PYG{n}{glob}\PYG{o}{.}\PYG{n}{glob}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{files/data/*.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{file\PYGZus{}list:}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{file\PYGZus{}list}

\PYG{c}{\PYGZsh{} e.g. the first string in the list}
\PYG{n}{this\PYGZus{}file} \PYG{o}{=} \PYG{n}{file\PYGZus{}list}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
file\PYGZus{}list:
    [\PYGZsq{}files/data/HadSEEP\PYGZus{}monthly\PYGZus{}qc.txt\PYGZsq{}, \PYGZsq{}files/data/heathrowdata.txt\PYGZsq{}, \PYGZsq{}files/data/modis\PYGZus{}files.txt\PYGZsq{}, \PYGZsq{}files/data/modis\PYGZus{}files2a.txt\PYGZsq{}, \PYGZsq{}files/data/modis\PYGZus{}files2b.txt\PYGZsq{}, \PYGZsq{}files/data/some\PYGZus{}modis\PYGZus{}files.txt\PYGZsq{}]
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{this\PYGZus{}file} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/HadSEEP\PYGZus{}monthly\PYGZus{}qc.txt}\PYG{l+s}{\PYGZsq{}}

\PYG{c}{\PYGZsh{} split the filename on the field \PYGZsq{}/\PYGZsq{}}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{this\PYGZus{}file.split(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{):}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{this\PYGZus{}file}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{c}{\PYGZsh{} so the filename is just the last element in this list}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{this\PYGZus{}file.split(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{)[\PYGZhy{}1]:}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{this\PYGZus{}file}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
this\PYGZus{}file.split(\PYGZsq{}/\PYGZsq{}):
    [\PYGZsq{}files\PYGZsq{}, \PYGZsq{}data\PYGZsq{}, \PYGZsq{}HadSEEP\PYGZus{}monthly\PYGZus{}qc.txt\PYGZsq{}]

this\PYGZus{}file.split(\PYGZsq{}/\PYGZsq{})[\PYGZhy{}1]:
    HadSEEP\PYGZus{}monthly\PYGZus{}qc.txt
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} another example, with directory names}

\PYG{c}{\PYGZsh{} glob unix style pattern matching for files and directories}
\PYG{k+kn}{import} \PYG{n+nn}{glob}

\PYG{c}{\PYGZsh{} returns a list}
\PYG{n}{file\PYGZus{}list} \PYG{o}{=} \PYG{n}{glob}\PYG{o}{.}\PYG{n}{glob}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{files/data/*.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{file\PYGZus{}list:}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{file\PYGZus{}list}

\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{file names:}\PYG{l+s}{\PYGZdq{}}
\PYG{c}{\PYGZsh{} loop over the list of file namnes}
\PYG{k}{for} \PYG{n}{this\PYGZus{}file} \PYG{o+ow}{in} \PYG{n}{file\PYGZus{}list}\PYG{p}{:}
    \PYG{c}{\PYGZsh{} for each of these}
    \PYG{c}{\PYGZsh{} split the filename on the field \PYGZsq{}/\PYGZsq{}}
    \PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{this\PYGZus{}file}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
file\PYGZus{}list:
    [\PYGZsq{}files/data/HadSEEP\PYGZus{}monthly\PYGZus{}qc.txt\PYGZsq{}, \PYGZsq{}files/data/heathrowdata.txt\PYGZsq{}, \PYGZsq{}files/data/modis\PYGZus{}files.txt\PYGZsq{}, \PYGZsq{}files/data/modis\PYGZus{}files2a.txt\PYGZsq{}, \PYGZsq{}files/data/modis\PYGZus{}files2b.txt\PYGZsq{}, \PYGZsq{}files/data/some\PYGZus{}modis\PYGZus{}files.txt\PYGZsq{}]

file names:
    HadSEEP\PYGZus{}monthly\PYGZus{}qc.txt
    heathrowdata.txt
    modis\PYGZus{}files.txt
    modis\PYGZus{}files2a.txt
    modis\PYGZus{}files2b.txt
    some\PYGZus{}modis\PYGZus{}files.txt
\end{Verbatim}


\section{Exercise 2.3}
\label{Chapter2_Python_intro/python101:exercise-2-3}
The data below are fields of:

\begin{DUlineblock}{0em}
\item[] 0 year
\item[] 1 month
\item[] 2 tmax (degC)
\item[] 3 tmin (degC)
\item[] 4 air frost (days)
\item[] 5 rain (mm)
\item[] 6 sun (hours)
\end{DUlineblock}

for Lowestoft in the UK for the year 2012, taken from \href{http://www.metoffice.gov.uk/climate/uk/stationdata/lowestoftdata.txt}{Met Office
data}.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{data} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}\PYG{l+s}{   2012   1    8.7    3.1      5   33.1   53.9}
\PYG{l+s}{   2012   2    7.1    1.6     13   13.8   86.6}
\PYG{l+s}{   2012   3   11.3    3.7      2   64.2  141.3}
\PYG{l+s}{   2012   4   10.9    4.3      3  108.9  151.1}
\PYG{l+s}{   2012   5   15.1    8.6      0   46.6  171.3}
\PYG{l+s}{   2012   6   17.9   10.9      0   74.4  189.0}
\PYG{l+s}{   2012   7   20.3   12.8      0   93.6  206.9}
\PYG{l+s}{   2012   8   22.0   14.0      0   59.6  217.3}
\PYG{l+s}{   2012   9   18.9    9.5      0   38.8  200.8}
\PYG{l+s}{   2012  10   13.6    7.9      0   92.7   94.7}
\PYG{l+s}{   2012  11   10.5    4.4      2   62.1   79.6}
\PYG{l+s}{   2012  12    7.9    2.4      8   95.6   41.9  }\PYG{l+s}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}

\PYG{k}{print} \PYG{n}{data}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
2012   1    8.7    3.1      5   33.1   53.9
2012   2    7.1    1.6     13   13.8   86.6
2012   3   11.3    3.7      2   64.2  141.3
2012   4   10.9    4.3      3  108.9  151.1
2012   5   15.1    8.6      0   46.6  171.3
2012   6   17.9   10.9      0   74.4  189.0
2012   7   20.3   12.8      0   93.6  206.9
2012   8   22.0   14.0      0   59.6  217.3
2012   9   18.9    9.5      0   38.8  200.8
2012  10   13.6    7.9      0   92.7   94.7
2012  11   10.5    4.4      2   62.1   79.6
2012  12    7.9    2.4      8   95.6   41.9
\end{Verbatim}

You can use the Python package \code{pylab} to simply plot data on a graph:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} import the pylab module}
\PYG{k+kn}{import} \PYG{n+nn}{pylab} \PYG{k+kn}{as} \PYG{n+nn}{plt}

\PYG{c}{\PYGZsh{} some e.g. x and y data}
\PYG{n}{x} \PYG{o}{=} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}
\PYG{n}{y} \PYG{o}{=} \PYG{p}{[}\PYG{n}{i}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mf}{0.5} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{x}\PYG{p}{]}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{x}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{y}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Plot of sqrt(x)}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.text.Text at 0x1065d6590\PYGZgt{}
\end{Verbatim}

\includegraphics{python101_185_1.png}

\textbf{Produce a plot of the number of sunshine hours for Lowestoft for the
year 2012} using the data given above.

Hint: the data have newline chcracters \code{\textbackslash{}n} at the end of each line of
data, and are separated by white space within each line.


\section{2.7 Files}
\label{Chapter2_Python_intro/python101:files}
To open a file that already exists for \emph{reading}, we use:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{fp} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

where \code{filename} here is the name of a file and the \code{'r'} argument
tells us that we want to open in `read' mode.

This returns a file object, \code{fp} here that we can use to read data
from the file etc.

When we have finished doing what we want to do, we should close the
file:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{fp}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

To read ASCII data from a file as a list of strings for each line, use:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{fp}\PYG{o}{.}\PYG{n}{readlines}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

To write ASCII text to the file, use:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{fp}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{some text}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\end{Verbatim}

or to write a list of strings all at once:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{fp}\PYG{o}{.}\PYG{n}{writelines}\PYG{p}{(}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{some text}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{some more}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

As a first example, let's open a file for \emph{reading} from a file
\code{{}`files/data/elevation.dat} \textless{}files/data/elevation.dat\textgreater{}{}`\_\_ that
contains a list of dates, times and solar elevation angles (degrees).

\begin{Verbatim}[commandchars=\\\{\}]
!head \PYGZhy{}10 \PYGZlt{} files/data/elevation.dat
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
2013/10/8 00:00:00 \PYGZhy{}44.2719952943
2013/10/8 00:30:00 \PYGZhy{}43.5276412785
2013/10/8 00:59:59 \PYGZhy{}41.9842746582
2013/10/8 01:30:00 \PYGZhy{}39.7226999863
2013/10/8 02:00:00 \PYGZhy{}36.8452198361
2013/10/8 02:30:00 \PYGZhy{}33.459799008
2013/10/8 03:00:00 \PYGZhy{}29.6691191507
2013/10/8 03:30:00 \PYGZhy{}25.5652187709
2013/10/8 03:59:59 \PYGZhy{}21.2281801291
2013/10/8 04:30:00 \PYGZhy{}16.7272357302
\end{Verbatim}

What we are going to want to do is to create a new file which has the
time, specified in decimal hours, and the solar zenith angle (i.e. 90
degrees minus the elevation) into a new file \code{files/data/zenith.dat},
but only when the Sun is above the horizon.

Let's first concentrate on reading the data in:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{filename} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/elevation.dat}\PYG{l+s}{\PYGZsq{}}
\PYG{n}{fp} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{r}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\end{Verbatim}

Now we will use \code{readlines} to return a list of strings:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{sdata} \PYG{o}{=} \PYG{n}{fp}\PYG{o}{.}\PYG{n}{readlines}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{sdata}
\end{Verbatim}
\begin{alltt}
{[}`2013/10/8 00:00:00 -44.2719952943n', `2013/10/8 00:30:00 -43.5276412785n', `2013/10/8 00:59:59 -41.9842746582n', `2013/10/8 01:30:00 -39.7226999863n', `2013/10/8 02:00:00 -36.8452198361n', `2013/10/8 02:30:00 -33.459799008n', `2013/10/8 03:00:00 -29.6691191507n', `2013/10/8 03:30:00 -25.5652187709n', `2013/10/8 03:59:59 -21.2281801291n', `2013/10/8 04:30:00 -16.7272357302n', `2013/10/8 05:00:00 -12.1229087343n', `2013/10/8 05:30:00 -7.44278286026n', `2013/10/8 06:00:00 -1.67990284889n', `2013/10/8 06:30:00 2.07557325291n', `2013/10/8 06:59:59 6.41682356012n', `2013/10/8 07:30:00 10.718795157n', `2013/10/8 08:00:00 14.8409321418n', `2013/10/8 08:30:00 18.7041059194n', `2013/10/8 09:00:00 22.2360923619n', `2013/10/8 09:30:00 25.3625807186n', `2013/10/8 09:59:59 28.0062976444n', `2013/10/8 10:30:00 30.0911497093n', `2013/10/8 11:00:00 31.54841838n', `2013/10/8 11:30:00 32.3246113226n', `2013/10/8 12:00:00 32.389146365n', `2013/10/8 12:30:00 31.7393119221n', `2013/10/8 12:59:59 30.4007451089n', `2013/10/8 13:30:00 28.4231526272n', `2013/10/8 14:00:00 25.8729768496n', `2013/10/8 14:30:00 22.8253857155n', `2013/10/8 15:00:00 19.3576781834n', `2013/10/8 15:30:00 15.5452510038n', `2013/10/8 15:59:59 11.4587795592n', `2013/10/8 16:30:00 7.17635425621n', `2013/10/8 17:00:00 2.81567654312n', `2013/10/8 17:30:00 -1.12901415483n', `2013/10/8 18:00:00 -6.60204292249n', `2013/10/8 18:30:00 -11.3521065185n', `2013/10/8 18:59:59 -15.9844936391n', `2013/10/8 19:30:00 -20.5264294183n', `2013/10/8 20:00:00 -24.9191119037n', `2013/10/8 20:30:00 -29.0954447321n', `2013/10/8 21:00:00 -32.9777242563n', `2013/10/8 21:30:00 -36.4761369039n', `2013/10/8 21:59:59 -39.4893158374n', `2013/10/8 22:30:00 -41.9086473886n', `2013/10/8 23:00:00 -43.6280450593n', `2013/10/8 23:30:00 -44.5592559753n'{]}
\end{alltt}

We can see that each line of the file contains three fields e.g.:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{n}{sdata}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
2013/10/8 00:00:00 \PYGZhy{}44.2719952943
\end{Verbatim}

The first field is the date (year, day, month), the second is the time
(hour, minute, second), and the third is the solar elevation at UCL at
that time/date.

To decode each line then we can use \code{split()} e.g.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{n}{sdata}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{2013/10/8}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{00:00:00}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZhy{}44.2719952943}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\end{Verbatim}

what we want is the time and elevation fields, so we will make a loop to
get this, but \code{break} from the loop after the first entry at the
moment:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{filename} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/elevation.dat}\PYG{l+s}{\PYGZsq{}}
\PYG{n}{fp} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{r}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{fp}\PYG{o}{.}\PYG{n}{readlines}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{data} \PYG{o}{=} \PYG{n}{i}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{time} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
    \PYG{n}{elevation} \PYG{o}{=} \PYG{n+nb}{float}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
    \PYG{k}{print} \PYG{n}{time}\PYG{p}{,}\PYG{n}{elevation}
    \PYG{k}{break}
\PYG{n}{fp}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
00:00:00 \PYGZhy{}44.2719952943
\end{Verbatim}

We need to convert the time field to minutes. We can start this by
splitting the string on \code{:}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{time} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{:}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{time}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{00}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{00}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{00}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\end{Verbatim}

then convert these to \code{float} and add up the minutes:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{time} \PYG{o}{=} \PYG{p}{[}\PYG{n+nb}{float}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{:}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{]}
\PYG{n}{hours} \PYG{o}{=} \PYG{n}{time}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{+} \PYG{n}{time}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{/}\PYG{l+m+mf}{60.} \PYG{o}{+} \PYG{n}{time}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mf}{60.}\PYG{o}{*}\PYG{l+m+mi}{60}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{hours}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{0.0}
\end{Verbatim}

we can easily convert elevation to zenith angle.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{zenith} \PYG{o}{=} \PYG{l+m+mf}{90.} \PYG{o}{\PYGZhy{}} \PYG{n}{elevation}
\PYG{k}{print} \PYG{n}{zenith}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{134.271995294}
\end{Verbatim}

Putting this together, only printing when the zenith is less than or
equal to 90.:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{filename} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/elevation.dat}\PYG{l+s}{\PYGZsq{}}
\PYG{n}{fp} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{r}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{fp}\PYG{o}{.}\PYG{n}{readlines}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{data} \PYG{o}{=} \PYG{n}{i}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{time} \PYG{o}{=} \PYG{p}{[}\PYG{n+nb}{float}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{:}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{]}
    \PYG{n}{hours} \PYG{o}{=} \PYG{n}{time}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{+} \PYG{n}{time}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{/}\PYG{l+m+mf}{60.} \PYG{o}{+} \PYG{n}{time}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mf}{60.}\PYG{o}{*}\PYG{l+m+mi}{60}\PYG{p}{)}
    \PYG{n}{zenith} \PYG{o}{=} \PYG{l+m+mf}{90.} \PYG{o}{\PYGZhy{}} \PYG{n+nb}{float}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
    \PYG{k}{if} \PYG{n}{zenith} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mf}{90.}\PYG{p}{:}
        \PYG{k}{print} \PYG{n}{hours}\PYG{p}{,}\PYG{n}{zenith}
\PYG{n}{fp}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
6.5 87.9244267471
6.99972222222 83.5831764399
7.5 79.281204843
8.0 75.1590678582
8.5 71.2958940806
9.0 67.7639076381
9.5 64.6374192814
9.99972222222 61.9937023556
10.5 59.9088502907
11.0 58.45158162
11.5 57.6753886774
12.0 57.610853635
12.5 58.2606880779
12.9997222222 59.5992548911
13.5 61.5768473728
14.0 64.1270231504
14.5 67.1746142845
15.0 70.6423218166
15.5 74.4547489962
15.9997222222 78.5412204408
16.5 82.8236457438
17.0 87.1843234569
\end{Verbatim}

Now, writing to an output file \code{files/data/zenith.dat}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{ifilename} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/elevation.dat}\PYG{l+s}{\PYGZsq{}}
\PYG{n}{ofilename} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/zenith.dat}\PYG{l+s}{\PYGZsq{}}

\PYG{n}{ifp} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{ifilename}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{r}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{ofp} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{ofilename}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{w}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{ifp}\PYG{o}{.}\PYG{n}{readlines}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{data} \PYG{o}{=} \PYG{n}{i}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{time} \PYG{o}{=} \PYG{p}{[}\PYG{n+nb}{float}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{:}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{]}
    \PYG{n}{hours} \PYG{o}{=} \PYG{n}{time}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{+} \PYG{n}{time}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{/}\PYG{l+m+mf}{60.} \PYG{o}{+} \PYG{n}{time}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mf}{60.}\PYG{o}{*}\PYG{l+m+mi}{60}\PYG{p}{)}
    \PYG{n}{zenith} \PYG{o}{=} \PYG{l+m+mf}{90.} \PYG{o}{\PYGZhy{}} \PYG{n+nb}{float}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
    \PYG{k}{if} \PYG{n}{zenith} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mf}{90.}\PYG{p}{:}
        \PYG{n}{ofp}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+si}{\PYGZpc{}.1f}\PYG{l+s}{ }\PYG{l+s+si}{\PYGZpc{}.3f}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{hours}\PYG{p}{,}\PYG{n}{zenith}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{ifp}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{ofp}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

We could check the output file from unix:

\begin{Verbatim}[commandchars=\\\{\}]
!head \PYGZhy{}10 \PYGZlt{} files/data/zenith.dat
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
6.5 87.924
7.0 83.583
7.5 79.281
8.0 75.159
8.5 71.296
9.0 67.764
9.5 64.637
10.0 61.994
10.5 59.909
11.0 58.452
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
!ls \PYGZhy{}l files/data/zenith.dat
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{}r\PYGZhy{}\PYGZhy{}  1 plewis  staff  257 30 Sep 11:04 files/data/zenith.dat
\end{Verbatim}


\section{Exercise 2.4}
\label{Chapter2_Python_intro/python101:exercise-2-4}
The text file
files/data/modis\_files.txt contains a
listing of hdf format files that are in the directory
\code{/data/geospatial\_19/ucfajlg/fire/Angola/MOD09} on the UCL Geography
system. The contents of the file looks like (first 10 lines):

\begin{Verbatim}[commandchars=\\\{\}]
!head \PYGZhy{}10 \PYGZlt{} files/data/modis\PYGZus{}files.txt
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
/data/geospatial\PYGZus{}19/ucfajlg/fire/Angola/MOD09/MOD09GA.A2004001.h19v10.005.2008109063923.hdf
/data/geospatial\PYGZus{}19/ucfajlg/fire/Angola/MOD09/MOD09GA.A2004002.h19v10.005.2008108084250.hdf
/data/geospatial\PYGZus{}19/ucfajlg/fire/Angola/MOD09/MOD09GA.A2004003.h19v10.005.2008108054126.hdf
/data/geospatial\PYGZus{}19/ucfajlg/fire/Angola/MOD09/MOD09GA.A2004004.h19v10.005.2008108112322.hdf
/data/geospatial\PYGZus{}19/ucfajlg/fire/Angola/MOD09/MOD09GA.A2004005.h19v10.005.2008108173219.hdf
/data/geospatial\PYGZus{}19/ucfajlg/fire/Angola/MOD09/MOD09GA.A2004006.h19v10.005.2008108214033.hdf
/data/geospatial\PYGZus{}19/ucfajlg/fire/Angola/MOD09/MOD09GA.A2004007.h19v10.005.2008109081257.hdf
/data/geospatial\PYGZus{}19/ucfajlg/fire/Angola/MOD09/MOD09GA.A2004008.h19v10.005.2008109111447.hdf
/data/geospatial\PYGZus{}19/ucfajlg/fire/Angola/MOD09/MOD09GA.A2004009.h19v10.005.2008109211421.hdf
/data/geospatial\PYGZus{}19/ucfajlg/fire/Angola/MOD09/MOD09GA.A2004010.h19v10.005.2008110031925.hdf
\end{Verbatim}

Your task is to create a new file
\code{{}`files/data/some\_modis\_files.txt} \textless{}files/data/some\_modis\_files.txt\textgreater{}{}`\_\_
that contains \emph{only} the file names for the month of August.

You will notice that the file names have a field in them such as
\code{A2004006}. This is the one you will need to concentrate on, as it
specifies the year (\code{2004} here) and the day of year (\code{doy}),
(\code{006} in this example).

There are various ways to find the day of year for a particular month /
year, e,g, look on a
\href{http://www.soils.wisc.edu/cgi-bin/asig/doyCal.rb}{website}.


\section{2.8 Doing Some Science}
\label{Chapter2_Python_intro/python101:doing-some-science}

\subsection{Maximum Precipitation}
\label{Chapter2_Python_intro/python101:maximum-precipitation}

\subsubsection{The Problem}
\label{Chapter2_Python_intro/python101:the-problem}
We want to calculate the \textbf{maximum} monthly precipitation for regions
of the UK for all years in the 20th Century.


\subsubsection{The Data}
\label{Chapter2_Python_intro/python101:the-data}
We have access to monthly average precipitation data as regional totals
from the \href{http://www.metoffice.gov.uk/hadobs/hadukp/data/download.html}{UK Met
Office}.

These data are in ASCII format, available over the internet.

e.g.
\href{http://www.metoffice.gov.uk/hadobs/hadukp/data/monthly/HadSEEP\_monthly\_qc.txt}{http://www.metoffice.gov.uk/hadobs/hadukp/data/monthly/HadSEEP\_monthly\_qc.txt}

or locally as
\code{{}`files/data/HadSEEP\_monthly\_qc.txt} \textless{}files/data/HadSEEP\_monthly\_qc.txt\textgreater{}{}`\_\_.

for South East England.


\subsubsection{Solving the Problem}
\label{Chapter2_Python_intro/python101:solving-the-problem}
With just the Python skills you have learned so far, you should be able
to solve a problem of this nature.

Before diving into this though, you need to think through \textbf{what steps}
you need to go through to achieve your aim?

At a `high' level, this could be:
\begin{enumerate}
\item {} 
Examine the data

\item {} 
Read the data into the computer program

\item {} 
Select which years you want

\item {} 
Find the maximum value for each year over all months

\item {} 
Print the results

\end{enumerate}

So now we need to think about how to implement these steps.


\subsubsection{Examine the data}
\label{Chapter2_Python_intro/python101:examine-the-data}
For the first step, there are many ways you could do this.

You will probably want to look at the data set in a
browser.

You should see that the data are `white space' separated.

The first 4 lines are `header' text, giving contextual information on
the data.

Subsequent lines have the \textbf{year} in the first column, then 12 columns
of monthly precipitation, then an annual total.


\subsubsection{Read the data into the computer program}
\label{Chapter2_Python_intro/python101:read-the-data-into-the-computer-program}\begin{enumerate}
\item {} 
You could simply save the file using `Save As ...' from the browser.

\item {} 
You could, if you really wanted, just copy and paste the data into a
file on the local system.

\item {} 
You could use the unix command \code{wget}:

\end{enumerate}

\begin{DUlineblock}{0em}
\item[] \code{berlin\% mkdir -p \textasciitilde{}/Data/python/Chapter2\_Python\_intro/files/data}
\item[] \code{berlin\% cd \textasciitilde{}/Data/python/Chapter2\_Python\_intro}
\item[] \code{berlin\% wget -O files/data/HadSEEP\_monthly\_qc.txt \textbackslash{}         http://www.metoffice.gov.uk/hadobs/hadukp/data/monthly/HadSEEP\_monthly\_qc.txt}
\end{DUlineblock}
\begin{enumerate}
\setcounter{enumi}{3}
\item {} 
You could download and read the file directly from a URL within
Python

\end{enumerate}

Let us suppose that you had downloaded the file and saved it as
\code{files/data/HadSEEP\_monthly\_qc.txt}.

In this case, we would use:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{filename} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/HadSEEP\PYGZus{}monthly\PYGZus{}qc.txt}\PYG{l+s}{\PYGZsq{}}

\PYG{n}{fp} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{raw\PYGZus{}data} \PYG{o}{=} \PYG{n}{fp}\PYG{o}{.}\PYG{n}{readlines}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{fp}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}

\PYG{k}{print} \PYG{n}{raw\PYGZus{}data}\PYG{p}{[}\PYG{p}{:}\PYG{l+m+mi}{10}\PYG{p}{]}
\end{Verbatim}
\begin{alltt}
{[}'Monthly Southeast England precipitation (mm). Daily automated values used after 1996.n', `Wigley \& Jones (J.Climatol.,1987), Gregory et al. (Int.J.Clim.,1991)n', `Jones \& Conway (Int.J.Climatol.,1997), Alexander \& Jones (ASL,2001). Values may change after QC.n', `YEAR   JAN   FEB   MAR   APR   MAY   JUN   JUL   AUG   SEP   OCT   NOV   DEC   ANNn', ` 1873  87.1  50.4  52.9  19.9  41.1  63.6  53.2  56.4  62.0  86.0  59.4  15.7  647.7n', ` 1874  46.8  44.9  15.8  48.4  24.1  49.9  28.3  43.6  79.4  96.1  63.9  52.3  593.5n', ` 1875  96.9  39.7  22.9  37.0  39.1  76.1 125.1  40.8  54.7 137.7 106.4  27.1  803.5n', ` 1876  31.8  71.9  79.5  63.6  16.5  37.2  22.3  66.3 118.2  34.1  89.0 162.9  793.3n', ` 1877 146.0  47.7  56.2  66.4  62.3  24.9  78.5  82.4  38.4  58.1 144.5  54.2  859.6n', ` 1878  39.9  44.7  34.2  76.6  96.0  46.8  42.3 133.1  35.7  72.9  94.1  40.7  757.0n'{]}
\end{alltt}

So we have read the data in well enough, but it's not really in a
convenient format.

\begin{DUlineblock}{0em}
\item[] First, it has 4 lines at the top that we don't want.
\item[] Second, although the data are in a list for each line, each line is
\end{DUlineblock}

stored as a string.

Since we know about lists, we might suppose that it would be better to
have each line as a list, with each `white space' separated item being
an element of the list.

If we have a string such as:

\code{' 1873  87.1  50.4  52.9  19.9  41.1  63.6  53.2  56.4  62.0  86.0  59.4  15.7  647.7\textbackslash{}n'}

one way to achieve this would be to use \code{split()}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{line\PYGZus{}data} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{ 1873 87.1 50.4 52.9 19.9 41.1 63.6 53.2 56.4 62.0 86.0 59.4 15.7 647.7}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZsq{}}
\PYG{n}{year\PYGZus{}data} \PYG{o}{=} \PYG{n}{line\PYGZus{}data}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{year\PYGZus{}data}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{1873}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{87.1}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{50.4}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{52.9}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{19.9}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{41.1}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{63.6}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{53.2}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{56.4}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{62.0}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{86.0}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{59.4}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{15.7}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{647.7}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\end{Verbatim}

Thats useful, and we could loop over each line and perform this to get
line lists with the first element as the year, second as precipitation
in January, etc.

But each element is still a string, and really, we want these as
\code{float}.

We can convert \code{str} to \code{float} using \code{float()}, but we have to do
this for each string individually.

We can do this in a loop:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{line\PYGZus{}data} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{ 1873 87.1 50.4 52.9 19.9 41.1 63.6 53.2 56.4 62.0 86.0 59.4 15.7 647.7}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZsq{}}
\PYG{n}{year\PYGZus{}data} \PYG{o}{=} \PYG{n}{line\PYGZus{}data}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{column}\PYG{p}{,}\PYG{n}{this\PYGZus{}element} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{year\PYGZus{}data}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{year\PYGZus{}data}\PYG{p}{[}\PYG{n}{column}\PYG{p}{]} \PYG{o}{=} \PYG{n+nb}{float}\PYG{p}{(}\PYG{n}{this\PYGZus{}element}\PYG{p}{)}

\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{format now}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{year\PYGZus{}data}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{year\PYGZus{}data}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
format now \PYGZlt{}type \PYGZsq{}float\PYGZsq{}\PYGZgt{}
[1873.0, 87.1, 50.4, 52.9, 19.9, 41.1, 63.6, 53.2, 56.4, 62.0, 86.0, 59.4, 15.7, 647.7]
\end{Verbatim}

Now we know how to convert each line of data into a list of floating
point numbers.

In practice, we will see later in the course that there are simpler ways
of achieving (using \code{{}`numpy} \textless{}\href{http://www.numpy.org/}{http://www.numpy.org/}\textgreater{}{}`\_\_).

We should first chop off the first 4 lines of data:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{required\PYGZus{}data} \PYG{o}{=} \PYG{n}{raw\PYGZus{}data}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{:}\PYG{p}{]}

\PYG{c}{\PYGZsh{} lets check what the first line is now}
\PYG{k}{print} \PYG{n}{required\PYGZus{}data}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
1873  87.1  50.4  52.9  19.9  41.1  63.6  53.2  56.4  62.0  86.0  59.4  15.7  647.7
\end{Verbatim}

Putting all of this together:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} specify filename}
\PYG{n}{filename} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/HadSEEP\PYGZus{}monthly\PYGZus{}qc.txt}\PYG{l+s}{\PYGZsq{}}

\PYG{c}{\PYGZsh{} read the data, chop off first 4 lines}
\PYG{c}{\PYGZsh{} and store in required\PYGZus{}data}
\PYG{n}{fp} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{raw\PYGZus{}data} \PYG{o}{=} \PYG{n}{fp}\PYG{o}{.}\PYG{n}{readlines}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{fp}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{required\PYGZus{}data} \PYG{o}{=} \PYG{n}{raw\PYGZus{}data}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{:}\PYG{p}{]}

\PYG{c}{\PYGZsh{} set up list to store data in}
\PYG{n}{data} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}


\PYG{c}{\PYGZsh{} loop over each line}
\PYG{k}{for} \PYG{n}{line\PYGZus{}data} \PYG{o+ow}{in} \PYG{n}{required\PYGZus{}data}\PYG{p}{:}
    \PYG{c}{\PYGZsh{} split on white space}
    \PYG{n}{year\PYGZus{}data} \PYG{o}{=} \PYG{n}{line\PYGZus{}data}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)}

    \PYG{c}{\PYGZsh{} convert data to float}
    \PYG{k}{for} \PYG{n}{column}\PYG{p}{,}\PYG{n}{this\PYGZus{}element} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{year\PYGZus{}data}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{year\PYGZus{}data}\PYG{p}{[}\PYG{n}{column}\PYG{p}{]} \PYG{o}{=} \PYG{n+nb}{float}\PYG{p}{(}\PYG{n}{this\PYGZus{}element}\PYG{p}{)}
    \PYG{n}{data}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{year\PYGZus{}data}\PYG{p}{)}
\end{Verbatim}

Now we have the data read in, as floating point values, in the 2-D list
called \code{data}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{k}{print} \PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{l+m+mf}{1873.0}\PYG{p}{,} \PYG{l+m+mf}{87.1}\PYG{p}{,} \PYG{l+m+mf}{50.4}\PYG{p}{,} \PYG{l+m+mf}{52.9}\PYG{p}{,} \PYG{l+m+mf}{19.9}\PYG{p}{,} \PYG{l+m+mf}{41.1}\PYG{p}{,} \PYG{l+m+mf}{63.6}\PYG{p}{,} \PYG{l+m+mf}{53.2}\PYG{p}{,} \PYG{l+m+mf}{56.4}\PYG{p}{,} \PYG{l+m+mf}{62.0}\PYG{p}{,} \PYG{l+m+mf}{86.0}\PYG{p}{,} \PYG{l+m+mf}{59.4}\PYG{p}{,} \PYG{l+m+mf}{15.7}\PYG{p}{,} \PYG{l+m+mf}{647.7}\PYG{p}{]}
\PYG{p}{[}\PYG{l+m+mf}{1874.0}\PYG{p}{,} \PYG{l+m+mf}{46.8}\PYG{p}{,} \PYG{l+m+mf}{44.9}\PYG{p}{,} \PYG{l+m+mf}{15.8}\PYG{p}{,} \PYG{l+m+mf}{48.4}\PYG{p}{,} \PYG{l+m+mf}{24.1}\PYG{p}{,} \PYG{l+m+mf}{49.9}\PYG{p}{,} \PYG{l+m+mf}{28.3}\PYG{p}{,} \PYG{l+m+mf}{43.6}\PYG{p}{,} \PYG{l+m+mf}{79.4}\PYG{p}{,} \PYG{l+m+mf}{96.1}\PYG{p}{,} \PYG{l+m+mf}{63.9}\PYG{p}{,} \PYG{l+m+mf}{52.3}\PYG{p}{,} \PYG{l+m+mf}{593.5}\PYG{p}{]}
\end{Verbatim}

and we can compare this with the \href{http://www.metoffice.gov.uk/hadobs/hadukp/data/monthly/HadSEEP\_monthly\_qc.txt}{original data we saw on the
web}
or the file we downloaded to
check it's been read in correctly.


\subsubsection{Select which years you want}
\label{Chapter2_Python_intro/python101:select-which-years-you-want}
We want years 1900 to 1999.

The year is stored in the first column, e.g. \code{data{[}10{]}{[}0{]}}, and we
want columns \code{1} to \code{-1} (i.e. skip the first and last column):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{k}{print} \PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1883.0}
\PYG{p}{[}\PYG{l+m+mf}{60.2}\PYG{p}{,} \PYG{l+m+mf}{97.4}\PYG{p}{,} \PYG{l+m+mf}{23.6}\PYG{p}{,} \PYG{l+m+mf}{36.5}\PYG{p}{,} \PYG{l+m+mf}{48.1}\PYG{p}{,} \PYG{l+m+mf}{53.3}\PYG{p}{,} \PYG{l+m+mf}{69.7}\PYG{p}{,} \PYG{l+m+mf}{21.7}\PYG{p}{,} \PYG{l+m+mf}{100.6}\PYG{p}{,} \PYG{l+m+mf}{58.1}\PYG{p}{,} \PYG{l+m+mf}{97.8}\PYG{p}{,} \PYG{l+m+mf}{22.5}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{c20\PYGZus{}data} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n}{data}\PYG{p}{:}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{line}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{1900}\PYG{p}{)} \PYG{o+ow}{and} \PYG{p}{(}\PYG{n}{line}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{2000}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{c20\PYGZus{}data}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{line}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}


\subsubsection{Find the maximum value for each year over all months}
\label{Chapter2_Python_intro/python101:find-the-maximum-value-for-each-year-over-all-months}
We want to find the maximum value in each row of \code{c20\_data} now.

If we consider row 0, we can use e.g.:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{n}{c20\PYGZus{}data}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{k}{print} \PYG{n+nb}{max}\PYG{p}{(}\PYG{n}{c20\PYGZus{}data}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{l+m+mf}{92.8}\PYG{p}{,} \PYG{l+m+mf}{125.9}\PYG{p}{,} \PYG{l+m+mf}{23.3}\PYG{p}{,} \PYG{l+m+mf}{30.7}\PYG{p}{,} \PYG{l+m+mf}{30.0}\PYG{p}{,} \PYG{l+m+mf}{74.6}\PYG{p}{,} \PYG{l+m+mf}{31.0}\PYG{p}{,} \PYG{l+m+mf}{73.3}\PYG{p}{,} \PYG{l+m+mf}{22.3}\PYG{p}{,} \PYG{l+m+mf}{56.1}\PYG{p}{,} \PYG{l+m+mf}{72.1}\PYG{p}{,} \PYG{l+m+mf}{88.2}\PYG{p}{]}
\PYG{l+m+mf}{125.9}
\end{Verbatim}

i.e. in the year 1900 (row 0), for S.E. England, the maximum rainfall
was in February.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} Aside: show which month that was}
\PYG{n}{month\PYGZus{}names} \PYG{o}{=} \PYG{p}{[} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Jan}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Feb}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Mar}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Apr}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYGZbs{}
    \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{May}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Jun}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Jul}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Aug}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Sep}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Oct}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Nov}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Dec}\PYG{l+s}{\PYGZdq{}} \PYG{p}{]}

\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{In South East England}\PYG{l+s}{\PYGZdq{}}
\PYG{k}{for} \PYG{n}{row} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{100}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{year} \PYG{o}{=} \PYG{l+m+mi}{1900} \PYG{o}{+} \PYG{n}{row}
    \PYG{n}{max\PYGZus{}precip} \PYG{o}{=} \PYG{n+nb}{max}\PYG{p}{(}\PYG{n}{c20\PYGZus{}data}\PYG{p}{[}\PYG{n}{row}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{month} \PYG{o}{=} \PYG{n}{c20\PYGZus{}data}\PYG{p}{[}\PYG{n}{row}\PYG{p}{]}\PYG{o}{.}\PYG{n}{index}\PYG{p}{(}\PYG{n}{max\PYGZus{}precip}\PYG{p}{)}

    \PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{In the year}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{year}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{the rainiest month was}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{month\PYGZus{}names}\PYG{p}{[}\PYG{n}{month}\PYG{p}{]}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{with}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{max\PYGZus{}precip}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{mm}\PYG{l+s}{\PYGZdq{}}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
In South East England
In the year 1900 the rainiest month was Feb with 125.9 mm
In the year 1910 the rainiest month was Dec with 119.4 mm
In the year 1920 the rainiest month was Jul with 116.9 mm
In the year 1930 the rainiest month was Nov with 121.0 mm
In the year 1940 the rainiest month was Nov with 203.0 mm
In the year 1950 the rainiest month was Nov with 137.9 mm
In the year 1960 the rainiest month was Oct with 167.0 mm
In the year 1970 the rainiest month was Nov with 186.4 mm
In the year 1980 the rainiest month was Oct with 110.1 mm
In the year 1990 the rainiest month was Feb with 122.3 mm
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} max precip for all years}

\PYG{n}{result} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{row} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{result}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb}{max}\PYG{p}{(}\PYG{n}{c20\PYGZus{}data}\PYG{p}{[}\PYG{n}{row}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}


\subsubsection{Print the results}
\label{Chapter2_Python_intro/python101:print-the-results}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{In South East England, the maximum value for the years 1900 to 1999 is}\PYG{l+s}{\PYGZdq{}}
\PYG{k}{print} \PYG{n}{result}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{The highest rainfall in a month was}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n+nb}{max}\PYG{p}{(}\PYG{n}{result}\PYG{p}{)}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{mm}\PYG{l+s}{\PYGZdq{}}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{It occurred in}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{result}\PYG{o}{.}\PYG{n}{index}\PYG{p}{(}\PYG{n+nb}{max}\PYG{p}{(}\PYG{n}{result}\PYG{p}{)}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{1900}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
In South East England, the maximum value for the years 1900 to 1999 is
[125.9, 98.7, 97.2, 188.4, 96.0, 104.5, 127.3, 129.5, 83.8, 143.9, 119.4, 153.6, 151.6, 106.5, 190.2, 163.9, 110.7, 135.1, 151.1, 121.4, 116.9, 70.8, 92.2, 142.5, 110.2, 98.1, 143.8, 138.5, 137.0, 175.6, 121.0, 101.3, 146.4, 74.1, 176.3, 148.2, 112.8, 124.9, 93.6, 154.0, 203.0, 117.3, 94.3, 130.2, 117.0, 103.8, 126.7, 150.7, 125.3, 189.3, 137.9, 161.9, 99.9, 87.5, 131.0, 110.5, 113.7, 97.7, 107.4, 143.4, 167.0, 102.0, 94.0, 141.0, 97.7, 126.9, 129.1, 126.6, 135.5, 108.4, 186.4, 134.4, 94.0, 76.6, 164.7, 122.8, 141.5, 132.8, 144.9, 122.6, 110.1, 131.2, 143.0, 98.5, 112.4, 103.7, 110.1, 198.7, 143.8, 143.8, 122.3, 102.0, 132.8, 133.9, 115.6, 143.1, 122.6, 100.6, 128.1, 109.5]
The highest rainfall in a month was 203.0 mm
It occurred in 1940
\end{Verbatim}


\section{Exercise 2.5}
\label{Chapter2_Python_intro/python101:exercise-2-5}
That is quite an achievement, given the limited amount of programming
you know so far.

If you go through this though, you will (should) see that it is really
not very efficient.

For example:
\begin{itemize}
\item {} 
we read all the data in and then filter out the years we want (what
if the dataset were \textbf{huge}?)

\item {} 
we loop over the 100 years multiple times

\item {} 
we store intermediate results

\end{itemize}

For this exercise, you should look through the code we developed and try
to make it more efficient.

Efficiency should not override clarity and understanding though, so make
sure you can understand what is going on at each stage.


\section{Exercise 2.6}
\label{Chapter2_Python_intro/python101:exercise-2-6}

\subsection{Average Temperature}
\label{Chapter2_Python_intro/python101:average-temperature}
We want to calculate the long-term average temperature (tmax degC) using
observational data at one or more meteorological stations. Such data are
\href{http://www.carbonbrief.org/profiles/global-temperatures/}{relevant to understanding climate and its
dynamics}.

We choose the period 1960 to 1990 (30 years average to even out natural
variability).

We can obtain monthly average data for a number of UK stations from the
\href{http://www.metoffice.gov.uk/climate/uk/stationdata}{UK Met. Office}.

Not all station records are complete enough for this calculation, so we
select, for example
\href{http://www.metoffice.gov.uk/climate/uk/stationdata/heathrowdata.txt}{Heathrow}.

Just with the Python skills you have learned so far, you should be able
to solve a problem of this nature.

Before diving into this though, you need to think through \textbf{what steps}
you need to go through to achieve your aim?

At a `high' level, this could be:
\begin{enumerate}
\item {} 
Get hold of the data

\item {} 
Read the data into the computer program

\item {} 
Select which years you want

\item {} 
Average the data for each month over all selected years

\item {} 
Print the results

\end{enumerate}

So now we need to think about how to implement these steps.

For the first step, there are many ways you could do this.


\section{2.9 Dictionaries}
\label{Chapter2_Python_intro/python101:dictionaries}
Dictionaries (type \code{dict}) are another way of grouping objects.

These are defined within curley brackets \code{\{\}} and are distinguished by
having a \code{'key} and \code{value} for each item.

e.g.:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{a} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{one}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{two}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{three}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{3}\PYG{p}{\PYGZcb{}}

\PYG{c}{\PYGZsh{} we then refer to the keys and values in the dict as:}

\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{a:}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{a}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{a.keys():}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{a}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}     \PYG{c}{\PYGZsh{} the keys}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{a.values():}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{a}\PYG{o}{.}\PYG{n}{values}\PYG{p}{(}\PYG{p}{)} \PYG{c}{\PYGZsh{} returns the values}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{a.items():}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{a}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}   \PYG{c}{\PYGZsh{} returns a list of tuples}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
a:
    \PYGZob{}\PYGZsq{}three\PYGZsq{}: 3, \PYGZsq{}two\PYGZsq{}: 2, \PYGZsq{}one\PYGZsq{}: 1\PYGZcb{}
a.keys():
    [\PYGZsq{}three\PYGZsq{}, \PYGZsq{}two\PYGZsq{}, \PYGZsq{}one\PYGZsq{}]
a.values():
    [3, 2, 1]
a.items():
    [(\PYGZsq{}three\PYGZsq{}, 3), (\PYGZsq{}two\PYGZsq{}, 2), (\PYGZsq{}one\PYGZsq{}, 1)]
\end{Verbatim}

Notice that the order they appear in is not necessarily the same as when
we generated the dictionary.

We refer to specific items as e.g.:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{n}{a}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{one}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{1}
\end{Verbatim}

We can loop over dictionaries in various interesting ways:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n}{a}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{print} \PYG{n}{a}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{3}
\PYG{l+m+mi}{2}
\PYG{l+m+mi}{1}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{k}\PYG{p}{,}\PYG{n}{v} \PYG{o+ow}{in} \PYG{n}{a}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{print} \PYG{n}{k}\PYG{p}{,}\PYG{n}{v}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
three 3
two 2
one 1
\end{Verbatim}

If you really need to process in some order, you need to sort the keys
in some way:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n}{sort}\PYG{p}{(}\PYG{n}{a}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{print} \PYG{n}{a}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{1}
\PYG{l+m+mi}{3}
\PYG{l+m+mi}{2}
\end{Verbatim}

though in this case this still might not be what you want, so be
careful.

You can add to a list with \code{update}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{a}\PYG{o}{.}\PYG{n}{update}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{four}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{five}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{\PYGZcb{}}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{a}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{four}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{three}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{five}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{two}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{one}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}
\end{Verbatim}

or for a single item:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{a}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{six}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{6}
\PYG{k}{print} \PYG{n}{a}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{six}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{three}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{two}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{four}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{five}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{one}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}
\end{Verbatim}

or delete items:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{del} \PYG{n}{a}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{three}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\PYG{k}{print} \PYG{n}{a}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{six}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{two}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{four}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{five}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{one}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}
\end{Verbatim}

These trivial examples are useful for understanding some basic
operations on dictionaries, but don't show their real power.

A good example is to consider a configuration file.

When we have to run complicated processing jobs (e.g. on stacks of
satellite data), we will often control the processing of these jobs with
some text that we may put in a file.

This would describe the particular conditions that one subset of the
jobs would process, for example.

Following from exercise 2.4 above, we might create a configuration file
with:

\begin{Verbatim}[commandchars=\\\{\}]
[TERRA]
dir  = /data/geospatial\PYGZus{}19/ucfajlg/fire/Angola/MOD09
name = MODIS TERRA data
year = 2004
doy\PYGZus{}start = 214
doy\PYGZus{}end = 245
file\PYGZus{}list = files/data/modis\PYGZus{}files2a.txt

[AQUA]
dir  = /data/geospatial\PYGZus{}19/ucfajlg/fire/Angola/MYD09
name = MODIS AQUA data
year = 2004
doy\PYGZus{}start = 214
doy\PYGZus{}end = 245
file\PYGZus{}list = files/data/modis\PYGZus{}files2b.txt
\end{Verbatim}

This information is in the file
\code{{}`files/data/modis.cfg} \textless{}files/data/modis.cfg\textgreater{}{}`\_\_.

We could read and parse this file ourselves:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{fp} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/modis.cfg}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{c}{\PYGZsh{} empty dict}
\PYG{n}{modis} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{n}{this\PYGZus{}section} \PYG{o}{=} \PYG{n}{modis}

\PYG{c}{\PYGZsh{} loop over each line}
\PYG{k}{for} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n}{fp}\PYG{o}{.}\PYG{n}{readlines}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{c}{\PYGZsh{} strip any extra white space}
    \PYG{n}{line} \PYG{o}{=} \PYG{n}{line}\PYG{o}{.}\PYG{n}{strip}\PYG{p}{(}\PYG{p}{)}
    \PYG{c}{\PYGZsh{} check that there is some text}
    \PYG{c}{\PYGZsh{} and it starts with [ and ends with ]}
    \PYG{k}{if} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{line}\PYG{p}{)} \PYG{o+ow}{and} \PYG{n}{line}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{==} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{[}\PYG{l+s}{\PYGZsq{}} \PYG{o+ow}{and} \PYG{n}{line}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{==} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{]}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}
        \PYG{n}{section} \PYG{o}{=} \PYG{n}{line}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
        \PYG{n}{modis}\PYG{p}{[}\PYG{n}{section}\PYG{p}{]} \PYG{o}{=} \PYG{n}{this\PYGZus{}section} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
    \PYG{k}{elif} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{line}\PYG{p}{)} \PYG{o+ow}{and} \PYG{n}{line}\PYG{o}{.}\PYG{n}{find}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{=}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)} \PYG{o}{!=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{:}
        \PYG{n}{key}\PYG{p}{,}\PYG{n}{value} \PYG{o}{=} \PYG{n}{line}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{=}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
        \PYG{n}{this\PYGZus{}section}\PYG{p}{[}\PYG{n}{key}\PYG{o}{.}\PYG{n}{strip}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]} \PYG{o}{=} \PYG{n}{value}\PYG{o}{.}\PYG{n}{strip}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{fp}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{modis}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{AQUA}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{doy\PYGZus{}end}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{245}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{doy\PYGZus{}start}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{214}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{name}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MODIS AQUA data}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{year}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{2004}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{file\PYGZus{}list}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/modis\PYGZus{}files2b.txt}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{dir}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/data/geospatial\PYGZus{}19/ucfajlg/fire/Angola/MYD09}\PYG{l+s}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{TERRA}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{doy\PYGZus{}end}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{245}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{doy\PYGZus{}start}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{214}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{name}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MODIS TERRA data}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{year}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{2004}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{file\PYGZus{}list}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/modis\PYGZus{}files2a.txt}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{dir}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/data/geospatial\PYGZus{}19/ucfajlg/fire/Angola/MOD09}\PYG{l+s}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{\PYGZcb{}}
\end{Verbatim}

though in practice, we might choose to use the
\code{{}`ConfigParser} \textless{}\href{http://docs.python.org/2/library/configparser.html}{http://docs.python.org/2/library/configparser.html}\textgreater{}{}`\_\_
module:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{ConfigParser}

\PYG{n}{config} \PYG{o}{=} \PYG{n}{ConfigParser}\PYG{o}{.}\PYG{n}{ConfigParser}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{config}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/modis.cfg}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{c}{\PYGZsh{} we can convert this to a normal dictionary}
\PYG{n}{modis} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n}{config}\PYG{o}{.}\PYG{n}{sections}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{modis}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]} \PYG{o}{=} \PYG{n+nb}{dict}\PYG{p}{(}\PYG{n}{config}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{modis}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{AQUA}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{doy\PYGZus{}end}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{245}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{doy\PYGZus{}start}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{214}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{name}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MODIS AQUA data}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{year}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{2004}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{file\PYGZus{}list}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/modis\PYGZus{}files2b.txt}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{dir}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/data/geospatial\PYGZus{}19/ucfajlg/fire/Angola/MYD09}\PYG{l+s}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{TERRA}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{doy\PYGZus{}end}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{245}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{doy\PYGZus{}start}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{214}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{name}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MODIS TERRA data}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{year}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{2004}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{file\PYGZus{}list}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/modis\PYGZus{}files2a.txt}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{dir}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/data/geospatial\PYGZus{}19/ucfajlg/fire/Angola/MOD09}\PYG{l+s}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{\PYGZcb{}}
\end{Verbatim}

The text file
files/data/modis\_files2a.txt
contains a listing of hdf format files that are in the directory
\code{/data/geospatial\_19/ucfajlg/fire/Angola/MOD09} and
files/data/modis\_files2b.txt those
in \code{/data/geospatial\_19/ucfajlg/fire/Angola/MYD09} on the UCL
Geography system. The contents of the files looks like (first 10 lines):

\begin{Verbatim}[commandchars=\\\{\}]
!head \PYGZhy{}10 \PYGZlt{}  files/data/modis\PYGZus{}files2b.txt
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
MYD09GA.A2004001.h19v10.005.2008035021539.hdf
MYD09GA.A2004002.h19v10.005.2008035115941.hdf
MYD09GA.A2004003.h19v10.005.2008035223215.hdf
MYD09GA.A2004004.h19v10.005.2008036154947.hdf
MYD09GA.A2004005.h19v10.005.2008036025835.hdf
MYD09GA.A2004006.h19v10.005.2008037030304.hdf
MYD09GA.A2004007.h19v10.005.2008037072048.hdf
MYD09GA.A2004008.h19v10.005.2008037155636.hdf
MYD09GA.A2004009.h19v10.005.2008037162301.hdf
MYD09GA.A2004010.h19v10.005.2008038034819.hdf
\end{Verbatim}

Let's try to use the information in the configuration dictionary
\code{modis} to generate a list of the files we want to process:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} first, work out how to loop over config sections}
\PYG{c}{\PYGZsh{} and get the sub\PYGZhy{}dictionary}

\PYG{k}{for} \PYG{n}{k}\PYG{p}{,}\PYG{n}{v} \PYG{o+ow}{in} \PYG{n}{modis}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{examining section}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{k}
    \PYG{n}{sub\PYGZus{}dict} \PYG{o}{=} \PYG{n}{v}
    \PYG{k}{print} \PYG{n}{v}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
examining section AQUA
\PYGZob{}\PYGZsq{}doy\PYGZus{}end\PYGZsq{}: \PYGZsq{}245\PYGZsq{}, \PYGZsq{}doy\PYGZus{}start\PYGZsq{}: \PYGZsq{}214\PYGZsq{}, \PYGZsq{}name\PYGZsq{}: \PYGZsq{}MODIS AQUA data\PYGZsq{}, \PYGZsq{}year\PYGZsq{}: \PYGZsq{}2004\PYGZsq{}, \PYGZsq{}file\PYGZus{}list\PYGZsq{}: \PYGZsq{}files/data/modis\PYGZus{}files2b.txt\PYGZsq{}, \PYGZsq{}dir\PYGZsq{}: \PYGZsq{}/data/geospatial\PYGZus{}19/ucfajlg/fire/Angola/MYD09\PYGZsq{}\PYGZcb{}

examining section TERRA
\PYGZob{}\PYGZsq{}doy\PYGZus{}end\PYGZsq{}: \PYGZsq{}245\PYGZsq{}, \PYGZsq{}doy\PYGZus{}start\PYGZsq{}: \PYGZsq{}214\PYGZsq{}, \PYGZsq{}name\PYGZsq{}: \PYGZsq{}MODIS TERRA data\PYGZsq{}, \PYGZsq{}year\PYGZsq{}: \PYGZsq{}2004\PYGZsq{}, \PYGZsq{}file\PYGZus{}list\PYGZsq{}: \PYGZsq{}files/data/modis\PYGZus{}files2a.txt\PYGZsq{}, \PYGZsq{}dir\PYGZsq{}: \PYGZsq{}/data/geospatial\PYGZus{}19/ucfajlg/fire/Angola/MOD09\PYGZsq{}\PYGZcb{}
\end{Verbatim}

Next, make sure we can read the \code{file\_list}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{reading}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{sub\PYGZus{}dict}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{file\PYGZus{}list}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{fp} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{sub\PYGZus{}dict}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{file\PYGZus{}list}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{file\PYGZus{}data} \PYG{o}{=} \PYG{n}{fp}\PYG{o}{.}\PYG{n}{readlines}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{fp}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}

\PYG{c}{\PYGZsh{} print the first one, just to see what it looks like}
\PYG{n}{count} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{k}{print} \PYG{n}{file\PYGZus{}data}\PYG{p}{[}\PYG{n}{count}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
reading files/data/modis\PYGZus{}files2a.txt
MOD09GA.A2004001.h19v10.005.2008109063923.hdf
\end{Verbatim}

Make sure we can get the day of year from this:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{n}{file\PYGZus{}data}\PYG{p}{[}\PYG{n}{count}\PYG{p}{]}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{.}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}
\begin{alltt}
{[}'MOD09GA', `A2004001', `h19v10', `005', `2008109063923', `hdfn'{]}
\end{alltt}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{n}{file\PYGZus{}data}\PYG{p}{[}\PYG{n}{count}\PYG{p}{]}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{.}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{A2004001}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{doy} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{file\PYGZus{}data}\PYG{p}{[}\PYG{n}{count}\PYG{p}{]}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{.}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{:}\PYG{p}{]}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{doy}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{1}
\end{Verbatim}

whats the range of days we want?

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{doy\PYGZus{}range} \PYG{o}{=} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{sub\PYGZus{}dict}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{doy\PYGZus{}start}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{sub\PYGZus{}dict}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{doy\PYGZus{}end}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{doy\PYGZus{}range}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{l+m+mi}{214}\PYG{p}{,} \PYG{l+m+mi}{215}\PYG{p}{,} \PYG{l+m+mi}{216}\PYG{p}{,} \PYG{l+m+mi}{217}\PYG{p}{,} \PYG{l+m+mi}{218}\PYG{p}{,} \PYG{l+m+mi}{219}\PYG{p}{,} \PYG{l+m+mi}{220}\PYG{p}{,} \PYG{l+m+mi}{221}\PYG{p}{,} \PYG{l+m+mi}{222}\PYG{p}{,} \PYG{l+m+mi}{223}\PYG{p}{,} \PYG{l+m+mi}{224}\PYG{p}{,} \PYG{l+m+mi}{225}\PYG{p}{,} \PYG{l+m+mi}{226}\PYG{p}{,} \PYG{l+m+mi}{227}\PYG{p}{,} \PYG{l+m+mi}{228}\PYG{p}{,} \PYG{l+m+mi}{229}\PYG{p}{,} \PYG{l+m+mi}{230}\PYG{p}{,} \PYG{l+m+mi}{231}\PYG{p}{,} \PYG{l+m+mi}{232}\PYG{p}{,} \PYG{l+m+mi}{233}\PYG{p}{,} \PYG{l+m+mi}{234}\PYG{p}{,} \PYG{l+m+mi}{235}\PYG{p}{,} \PYG{l+m+mi}{236}\PYG{p}{,} \PYG{l+m+mi}{237}\PYG{p}{,} \PYG{l+m+mi}{238}\PYG{p}{,} \PYG{l+m+mi}{239}\PYG{p}{,} \PYG{l+m+mi}{240}\PYG{p}{,} \PYG{l+m+mi}{241}\PYG{p}{,} \PYG{l+m+mi}{242}\PYG{p}{,} \PYG{l+m+mi}{243}\PYG{p}{,} \PYG{l+m+mi}{244}\PYG{p}{]}
\end{Verbatim}

Is \code{doy} in the range?

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{n}{doy} \PYG{o+ow}{in} \PYG{n}{doy\PYGZus{}range}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nb+bp}{False}
\end{Verbatim}

So now we have all of the parts we need to create this code:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} 1. Read the configuration file}
\PYG{c}{\PYGZsh{} into the dict modis}
\PYG{k+kn}{import} \PYG{n+nn}{ConfigParser}

\PYG{n}{config} \PYG{o}{=} \PYG{n}{ConfigParser}\PYG{o}{.}\PYG{n}{ConfigParser}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{config}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/modis.cfg}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{c}{\PYGZsh{} we can convert this to a normal dictionary}
\PYG{n}{modis} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n}{config}\PYG{o}{.}\PYG{n}{sections}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{modis}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]} \PYG{o}{=} \PYG{n+nb}{dict}\PYG{p}{(}\PYG{n}{config}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}\PYG{p}{)}

\PYG{c}{\PYGZsh{} 2. Now, loop over config sections}
\PYG{c}{\PYGZsh{} and get the sub\PYGZhy{}dictionary which we call sub\PYGZus{}dict}

\PYG{c}{\PYGZsh{} 3. set up anb empty list to contain the}
\PYG{c}{\PYGZsh{} files we want to process}
\PYG{n}{wanted\PYGZus{}files} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}

\PYG{k}{for} \PYG{n}{k}\PYG{p}{,}\PYG{n}{v} \PYG{o+ow}{in} \PYG{n}{modis}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}

    \PYG{n}{sub\PYGZus{}dict} \PYG{o}{=} \PYG{n}{v}

    \PYG{c}{\PYGZsh{} 3a. Read the file list}
    \PYG{n}{fp} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{sub\PYGZus{}dict}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{file\PYGZus{}list}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{file\PYGZus{}data} \PYG{o}{=} \PYG{n}{fp}\PYG{o}{.}\PYG{n}{readlines}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{fp}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}

    \PYG{c}{\PYGZsh{} 3b. find the doy range}
    \PYG{n}{doy\PYGZus{}range} \PYG{o}{=} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{sub\PYGZus{}dict}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{doy\PYGZus{}start}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYGZbs{}
                          \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{sub\PYGZus{}dict}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{doy\PYGZus{}end}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}

    \PYG{c}{\PYGZsh{} 3c. loop over each file read from}
    \PYG{c}{\PYGZsh{}     sub\PYGZus{}dict[\PYGZsq{}file\PYGZus{}list\PYGZsq{}]}
    \PYG{k}{for} \PYG{n}{count} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{file\PYGZus{}data}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{c}{\PYGZsh{} 3d. extract doy from the file name}
        \PYG{n}{this\PYGZus{}file} \PYG{o}{=} \PYG{n}{file\PYGZus{}data}\PYG{p}{[}\PYG{n}{count}\PYG{p}{]}

        \PYG{n}{doy} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{this\PYGZus{}file}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{.}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{:}\PYG{p}{]}\PYG{p}{)}

        \PYG{c}{\PYGZsh{} 3e. see if doy is in the range we want?}
        \PYG{k}{if} \PYG{n}{doy} \PYG{o+ow}{in} \PYG{n}{doy\PYGZus{}range}\PYG{p}{:}

            \PYG{c}{\PYGZsh{} 3f. put the directory on the fornt}
            \PYG{n}{full\PYGZus{}name} \PYG{o}{=} \PYG{n}{sub\PYGZus{}dict}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{dir}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{+} \PYGZbs{}
                        \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/}\PYG{l+s}{\PYGZsq{}} \PYG{o}{+} \PYG{n}{this\PYGZus{}file}
            \PYG{n}{wanted\PYGZus{}files}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{full\PYGZus{}name}\PYG{p}{)}

\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{I found }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{ files to process}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZpc{}}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{wanted\PYGZus{}files}\PYG{p}{)}

\PYG{c}{\PYGZsh{} I won\PYGZsq{}t print the whole list as its too long}
\PYG{c}{\PYGZsh{} just the first 10}
\PYG{k}{for} \PYG{n}{f} \PYG{o+ow}{in} \PYG{n}{wanted\PYGZus{}files}\PYG{p}{[}\PYG{p}{:}\PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{:}
    \PYG{k}{print} \PYG{n}{f}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
I found 62 files to process
/data/geospatial\PYGZus{}19/ucfajlg/fire/Angola/MYD09/MYD09GA.A2004214.h19v10.005.2007299212915.hdf

/data/geospatial\PYGZus{}19/ucfajlg/fire/Angola/MYD09/MYD09GA.A2004215.h19v10.005.2007300042347.hdf

/data/geospatial\PYGZus{}19/ucfajlg/fire/Angola/MYD09/MYD09GA.A2004216.h19v10.005.2007300091257.hdf

/data/geospatial\PYGZus{}19/ucfajlg/fire/Angola/MYD09/MYD09GA.A2004217.h19v10.005.2007300153436.hdf

/data/geospatial\PYGZus{}19/ucfajlg/fire/Angola/MYD09/MYD09GA.A2004218.h19v10.005.2007300215826.hdf

/data/geospatial\PYGZus{}19/ucfajlg/fire/Angola/MYD09/MYD09GA.A2004219.h19v10.005.2007302194509.hdf

/data/geospatial\PYGZus{}19/ucfajlg/fire/Angola/MYD09/MYD09GA.A2004220.h19v10.005.2007302093547.hdf

/data/geospatial\PYGZus{}19/ucfajlg/fire/Angola/MYD09/MYD09GA.A2004221.h19v10.005.2007302222054.hdf

/data/geospatial\PYGZus{}19/ucfajlg/fire/Angola/MYD09/MYD09GA.A2004222.h19v10.005.2007303011606.hdf

/data/geospatial\PYGZus{}19/ucfajlg/fire/Angola/MYD09/MYD09GA.A2004223.h19v10.005.2007303073538.hdf
\end{Verbatim}


\section{Exercise 2.7}
\label{Chapter2_Python_intro/python101:exercise-2-7}
You should modify the example above to make it simpler, if you can spot
any places for that (don't make it more complicated!).

You should then modify it so that the list of files that we want to
process is printed to a file.


\section{2.10 Where we have reached}
\label{Chapter2_Python_intro/python101:where-we-have-reached}
That is plenty of Python for one day. We would not expect you to be able
to remember all of this the first time you go through it: you will have
to work at it and go through it multiple times. Make sure that the time
you spend going through codes and examples is profitable though: it is
all too easy to sit and stare at a section of code for hours without
\emph{learning} anything ... you need to be engaged with the learning for
this to happen, so take frequent breaks, write your own summary notes
and do whatever you need to get to grips with the basics here.

Although we have rather crammed a lot into this session, that is for
timetabling reasons more than for effectiveness. When you go through it
in your own time, break it into sections and try to get to grips with
each part.

We would not expect you to be able to develop codes of the sort we have
developed above from scratch to start with, but as you go through these
notes and do the exercises, you should start to understand something of
how we build a piece of code.

Our experience is that you should be able to get to grips with these
examples (or at least most of them). Don't start by looking at some
finished piece of code ... start by going through the simple examples to
learn the commands and syntax, then try to put the pieces together.

Once you have learned the basic tools, you will be in a much better
position to think about \emph{algorithms}, i.e. how to break a problem down
into smaller parts that you can solve with the Python that you know.


\section{2.11 Answers}
\label{Chapter2_Python_intro/python101:answers}
Answers to the exersises in this session are made available to
you, though you should obviously only consult
these when you are finished (or if you are very stuck).


\section{2.12 Advanced}
\label{Chapter2_Python_intro/python101:advanced}
Once you have got to grips with the basics in this session, you might
consider stretching yourself and going through the
advanced section.

Consult the answers to the exercises once
you have completed them, and come along to office hours if yoiu want to
go through anything.


\chapter{3. Plotting and Numerical Python}
\label{Chapter3_Scientific_Numerical_Python/Scientific_Numerical_Python:plotting-and-numerical-python}\label{Chapter3_Scientific_Numerical_Python/Scientific_Numerical_Python::doc}

\section{3.1 In this session}
\label{Chapter3_Scientific_Numerical_Python/Scientific_Numerical_Python:in-this-session}
In this session, we will introduce and use some packages that you will
commonly use in scientific programming.

These are:
\begin{itemize}
\item {} 
\href{http://www.numpy.org/}{numpy}: NumPy is the fundamental package
for scientific computing with Python

\item {} 
\href{http://matplotlib.org/}{matplotlib}: Python 2D plotting library

\end{itemize}

We will also introduce some additional programming concepts, and set an
exercise that you can do and get feedback on.


\subsection{3.2.1 Getting Started}
\label{Chapter3_Scientific_Numerical_Python/Scientific_Numerical_Python:getting-started}
To get started for this session, you should go to your \code{Data} area and
download or update your material for this course.

If you haven't previously downloaded the course, type the following at
the unix prompt (illustrated by \code{berlin\%} here):

\begin{DUlineblock}{0em}
\item[] \code{berlin\% cd Data}
\item[] \code{berlin\% git clone https://github.com/profLewis/geogg122.git}
\item[] \code{berlin\% cd geogg122/Chapter3\_Scientific\_Numerical\_Python}
\end{DUlineblock}

If you already have a clone of the course repository (which you should
have from last week):

\begin{DUlineblock}{0em}
\item[] \code{berlin\% cd Data/geogg122}
\item[] \code{berlin\% git reset -{-}hard HEAD}
\item[] \code{berlin\% git pull}
\item[] \code{berlin\% cd Chapter3\_Scientific\_Numerical\_Python}
\end{DUlineblock}

This will update your local copy with any new notes or files. Any
additional files that you yourself have created should be still where
they were.


\section{E3.1 Exercise: listing}
\label{Chapter3_Scientific_Numerical_Python/Scientific_Numerical_Python:e3-1-exercise-listing}
Using Python, produce a listing of the files in the subdirectory
\code{data} of \code{geogg122/Chapter3\_Scientific\_Numerical\_Python} that end
with \code{.nc} and put this listing in a file called
\code{files/data/data.dat} with each entry on a different line


\section{3.2 Getting and Plotting Some Data: netCDF format}
\label{Chapter3_Scientific_Numerical_Python/Scientific_Numerical_Python:getting-and-plotting-some-data-netcdf-format}

\subsection{3.2.1 GlobAlbedo data}
\label{Chapter3_Scientific_Numerical_Python/Scientific_Numerical_Python:globalbedo-data}
Before we start to use these new packages, we will start by getting some
data for you to use and show you how to read it in and do some basic
plotting.

Today, we will be using the \href{http://www.globalbedo.org}{ESA GlobAlbedo
data}.

These data come in different spatial resolutions, but here we will use
the global product at 0.5 degrees.

The files are acessible via \code{http} in the directory:

\code{http://www.globalbedo.org/GlobAlbedoXX/mosaics/YYYY/0.5/monthly}

The filenames are of the pattern:

\code{GlobAlbedo.YYYYMM.mosaic.5.nc.gz}

where \code{YYYY} is the year (e.g. 2009) and MM is the month (\code{01} is
January, \code{12} is December).

\code{XX} is a code which is given below.

The data are in \href{http://netcdf4-python.googlecode.com/svn/trunk/docs/netCDF4-module.html}{netCDF
format}
which is a common binary data format.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} versioning (?) codes. At present these are:}
\PYG{n}{XX} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1998}\PYG{p}{:}\PYG{l+m+mi}{95}\PYG{p}{,}\PYG{l+m+mi}{1999}\PYG{p}{:}\PYG{l+m+mi}{95}\PYG{p}{,}\PYG{l+m+mi}{2000}\PYG{p}{:}\PYG{l+m+mi}{97}\PYG{p}{,}\PYG{l+m+mi}{2001}\PYG{p}{:}\PYG{l+m+mi}{97}\PYG{p}{,}\PYG{l+m+mi}{2002}\PYG{p}{:}\PYG{l+m+mi}{26}\PYG{p}{,}\PYG{l+m+mi}{2003}\PYG{p}{:}\PYG{l+m+mi}{66}\PYG{p}{,}\PYG{l+m+mi}{2004}\PYG{p}{:}\PYG{l+m+mi}{54}\PYG{p}{,}\PYG{l+m+mi}{2005}\PYG{p}{:}\PYG{l+m+mi}{54}\PYG{p}{,}\PYGZbs{}
      \PYG{l+m+mi}{2006}\PYG{p}{:}\PYG{l+m+mi}{29}\PYG{p}{,}\PYG{l+m+mi}{2007}\PYG{p}{:}\PYG{l+m+mi}{25}\PYG{p}{,}\PYG{l+m+mi}{2008}\PYG{p}{:}\PYG{l+m+mi}{53}\PYG{p}{,}\PYG{l+m+mi}{2009}\PYG{p}{:}\PYG{l+m+mi}{56}\PYG{p}{,}\PYG{l+m+mi}{2010}\PYG{p}{:}\PYG{l+m+mi}{56}\PYG{p}{,}\PYG{l+m+mi}{2011}\PYG{p}{:}\PYG{l+m+mi}{78}\PYG{p}{\PYGZcb{}}

\PYG{c}{\PYGZsh{} but check on http://www.globalbedo.org by trying to order some data}

\PYG{n}{year} \PYG{o}{=} \PYG{l+m+mi}{2009}

\PYG{n}{root} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{http://www.globalbedo.org/GlobAlbedo}\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{/mosaics/}\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{/0.5/monthly/}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{XX}\PYG{p}{[}\PYG{n}{year}\PYG{p}{]}\PYG{p}{,}\PYG{n}{year}\PYG{p}{)}

\PYG{c}{\PYGZsh{} example filename : use formatting string:}
\PYG{c}{\PYGZsh{} \PYGZpc{}d\PYGZpc{}02d}
\PYG{n}{month} \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{n}{url} \PYG{o}{=} \PYG{n}{root} \PYG{o}{+} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/GlobAlbedo.}\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s+si}{\PYGZpc{}02d}\PYG{l+s}{.mosaic.5.nc.gz}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{year}\PYG{p}{,}\PYG{n}{month}\PYG{p}{)}

\PYG{k}{print} \PYG{n}{url}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
http://www.globalbedo.org/GlobAlbedo56/mosaics/2009/0.5/monthly//GlobAlbedo.200901.mosaic.5.nc.gz
\end{Verbatim}


\subsection{3.2.2 Loading from within Python}
\label{Chapter3_Scientific_Numerical_Python/Scientific_Numerical_Python:loading-from-within-python}
You \emph{could} download the data youself (explained in the
advanced section), but these files are available to
you in this case in the directory \code{files/data} for the year 2009.

\begin{Verbatim}[commandchars=\\\{\}]
!ls files/data/GlobAlbedo*.nc
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
files/data/GlobAlbedo.200901.mosaic.5.nc
files/data/GlobAlbedo.200902.mosaic.5.nc
files/data/GlobAlbedo.200903.mosaic.5.nc
files/data/GlobAlbedo.200904.mosaic.5.nc
files/data/GlobAlbedo.200905.mosaic.5.nc
files/data/GlobAlbedo.200906.mosaic.5.nc
files/data/GlobAlbedo.200907.mosaic.5.nc
files/data/GlobAlbedo.200908.mosaic.5.nc
files/data/GlobAlbedo.200909.mosaic.5.nc
files/data/GlobAlbedo.200910.mosaic.5.nc
files/data/GlobAlbedo.200911.mosaic.5.nc
files/data/GlobAlbedo.200912.mosaic.5.nc
files/data/GlobAlbedo.201001.mosaic.5.nc
files/data/GlobAlbedo.201002.mosaic.5.nc
files/data/GlobAlbedo.201003.mosaic.5.nc
files/data/GlobAlbedo.201004.mosaic.5.nc
files/data/GlobAlbedo.201005.mosaic.5.nc
files/data/GlobAlbedo.201006.mosaic.5.nc
files/data/GlobAlbedo.201007.mosaic.5.nc
files/data/GlobAlbedo.201008.mosaic.5.nc
files/data/GlobAlbedo.201009.mosaic.5.nc
files/data/GlobAlbedo.201010.mosaic.5.nc
files/data/GlobAlbedo.201011.mosaic.5.nc
files/data/GlobAlbedo.201012.mosaic.5.nc
\end{Verbatim}

We use the \code{netCDF4} module to read netCDF data:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{netCDF4} \PYG{k+kn}{import} \PYG{n}{Dataset}

\PYG{n}{root} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/}\PYG{l+s}{\PYGZsq{}}

\PYG{c}{\PYGZsh{} example filename : use formatting string:}
\PYG{c}{\PYGZsh{} \PYGZpc{}d\PYGZpc{}02d}
\PYG{n}{year} \PYG{o}{=} \PYG{l+m+mi}{2009}
\PYG{n}{month} \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{n}{local\PYGZus{}file} \PYG{o}{=} \PYG{n}{root} \PYG{o}{+} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{GlobAlbedo.}\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s+si}{\PYGZpc{}02d}\PYG{l+s}{.mosaic.5.nc}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{year}\PYG{p}{,}\PYG{n}{month}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{local\PYGZus{}file}

\PYG{c}{\PYGZsh{} load the netCDF data from the file local\PYGZus{}file}
\PYG{n}{nc} \PYG{o}{=} \PYG{n}{Dataset}\PYG{p}{(}\PYG{n}{local\PYGZus{}file}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{c}{\PYGZsh{} the netCDF file has dimensions}
\PYG{c}{\PYGZsh{} stored as a dictionary}
\PYG{k}{print} \PYG{n}{nc}\PYG{o}{.}\PYG{n}{dimensions}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}

\PYG{c}{\PYGZsh{} and variables also as a dictionary}
\PYG{k}{print} \PYG{n}{nc}\PYG{o}{.}\PYG{n}{variables}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
ImportError                               Traceback (most recent call last)

\PYGZlt{}ipython\PYGZhy{}input\PYGZhy{}3\PYGZhy{}635e408ccbf9\PYGZgt{} in \PYGZlt{}module\PYGZgt{}()
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} 1 from netCDF4 import Dataset
      2
      3 root = \PYGZsq{}files/data/\PYGZsq{}
      4
      5 \PYGZsh{} example filename : use formatting string:


ImportError: No module named netCDF4
\end{Verbatim}

Here, we will want to access \code{'DHR\_VIS'}, \code{'DHR\_NIR'} and
\code{'DHR\_SW'}, which are the bihemispherical reflectance (DHR: `black sky
albedo' -- the albedo under directional illumination conditions) for
visible, near infrared and total shortwave wavebands:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} explicitly as:}
\PYG{n}{albedo} \PYG{o}{=} \PYG{p}{[}\PYG{n}{nc}\PYG{o}{.}\PYG{n}{variables}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{DHR\PYGZus{}VIS}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{nc}\PYG{o}{.}\PYG{n}{variables}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{DHR\PYGZus{}NIR}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{nc}\PYG{o}{.}\PYG{n}{variables}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{DHR\PYGZus{}SW}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{}or more neatly as:}

\PYG{n}{data\PYGZus{}fields} \PYG{o}{=} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{DHR\PYGZus{}VIS}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{DHR\PYGZus{}NIR}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{DHR\PYGZus{}SW}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}

\PYG{n}{albedo} \PYG{o}{=} \PYG{p}{[}\PYG{n}{nc}\PYG{o}{.}\PYG{n}{variables}\PYG{p}{[}\PYG{n}{f}\PYG{p}{]} \PYG{k}{for} \PYG{n}{f} \PYG{o+ow}{in} \PYG{n}{data\PYGZus{}fields}\PYG{p}{]}
\end{Verbatim}


\subsection{3.2.3 Plotting an image}
\label{Chapter3_Scientific_Numerical_Python/Scientific_Numerical_Python:plotting-an-image}
We can plot image data using the package \code{pylab} (from
\code{matplotlib}).

If you are running this as a notebook, make sure you use:

\code{ipython notebook -{-}pylab=inline} if you want the images to appear in
the notebook.

First we have to import \code{pylab}, which we will refer to a \code{plt} (se
\code{import pylab as plt}).

The basic function for plotting an image is \code{plt.imshow}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{pylab} \PYG{k+kn}{as} \PYG{n+nn}{plt}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{albedo}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.image.AxesImage at 0x2b05430059d0\PYGZgt{}
\end{Verbatim}

\includegraphics{Scientific_Numerical_Python_21_1.png}

Thats fine, but we might apply a few modifications to make a better
plot:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{pylab} \PYG{k+kn}{as} \PYG{n+nn}{plt}

\PYG{c}{\PYGZsh{} change the figure size}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}

\PYG{c}{\PYGZsh{} use nearest neighbour interpolation}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{albedo}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nearest}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{c}{\PYGZsh{} show a colour bar}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.colorbar.Colorbar instance at 0x10bccb90\PYGZgt{}
\end{Verbatim}

\includegraphics{Scientific_Numerical_Python_23_1.png}

Albedo should lie between 0 and 1, so there are clearly a few `funnies'
that we might flag later.

For now, we might like to plot \emph{only} values between 0 and 1
(thresholding at those values).

Also if we don't like this \href{http://wiki.scipy.org/Cookbook/Matplotlib/Show\_colormaps}{colour map, we can try
another}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{pylab} \PYG{k+kn}{as} \PYG{n+nn}{plt}

\PYG{c}{\PYGZsh{} change the figure size}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}

\PYG{c}{\PYGZsh{} use nearest neighbour interpolation}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{albedo}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nearest}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{cmap}\PYG{o}{=}\PYG{n}{plt}\PYG{o}{.}\PYG{n}{get\PYGZus{}cmap}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{binary}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}\PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mf}{0.0}\PYG{p}{,}\PYG{n}{vmax}\PYG{o}{=}\PYG{l+m+mf}{1.0}\PYG{p}{)}

\PYG{c}{\PYGZsh{} show a colour bar}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.colorbar.Colorbar instance at 0x1172e5a8\PYGZgt{}
\end{Verbatim}

\includegraphics{Scientific_Numerical_Python_25_1.png}

If we wanted to save the plot and put a title on:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{pylab} \PYG{k+kn}{as} \PYG{n+nn}{plt}

\PYG{c}{\PYGZsh{} set up a month dictionary}
\PYG{n}{month\PYGZus{}list} \PYG{o}{=} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{January}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{February}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{March}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{April}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{May}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{June}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYGZbs{}
              \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{July}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{August}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{September}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{October}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{November}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{December}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\PYG{c}{\PYGZsh{} make a dictionary from 2 lists}
\PYG{n}{month\PYGZus{}dict} \PYG{o}{=} \PYG{n+nb}{dict}\PYG{p}{(}\PYG{n+nb}{zip}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{13}\PYG{p}{)}\PYG{p}{,}\PYG{n}{month\PYGZus{}list}\PYG{p}{)}\PYG{p}{)}

\PYG{c}{\PYGZsh{} change the figure size}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}
\PYG{c}{\PYGZsh{} plt.clf(): clear the figure in case anything in it before}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{clf}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{VIS BHR albedo for }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{ }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{month\PYGZus{}dict}\PYG{p}{[}\PYG{n}{month}\PYG{p}{]}\PYG{p}{,}\PYG{n}{year}\PYG{p}{)}\PYG{p}{)}
\PYG{c}{\PYGZsh{} use nearest neighbour interpolation}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{albedo}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nearest}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{cmap}\PYG{o}{=}\PYG{n}{plt}\PYG{o}{.}\PYG{n}{get\PYGZus{}cmap}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Spectral}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}\PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mf}{0.0}\PYG{p}{,}\PYG{n}{vmax}\PYG{o}{=}\PYG{l+m+mf}{1.0}\PYG{p}{)}

\PYG{c}{\PYGZsh{} show a colour bar}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/albedo.jpg}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

\includegraphics{Scientific_Numerical_Python_27_0.png}


\subsection{E3.2 Exercise: Making Movies}
\label{Chapter3_Scientific_Numerical_Python/Scientific_Numerical_Python:e3-2-exercise-making-movies}

\subsection{E3.2.1 Software}
\label{Chapter3_Scientific_Numerical_Python/Scientific_Numerical_Python:e3-2-1-software}
You can \emph{sort of} make \href{http://matplotlib.org/faq/howto\_faq.html\#make-a-movie}{movies in
pylab}, but
you generally have to make a system call to unix at some point, so it's
probably easier to do this all in unix with the utility
\code{{}`convert} \textless{}\href{http://www.imagemagick.org/script/convert.php}{http://www.imagemagick.org/script/convert.php}\textgreater{}{}`\_\_.

At the unix prompt, chack that you have access to convert:

\begin{Verbatim}[commandchars=\\\{\}]
berlin\PYGZpc{} which convert
/usr/bin/convert
\end{Verbatim}

If this doesn't come up with anything useful, there is probably a
version in \code{/usr/bin/convert} or \code{/usr/local/bin/convert} (If you
don't have it on your local machine, install
\code{{}`ImageMagick} \textless{}\href{http://www.imagemagick.org/script/index.php}{http://www.imagemagick.org/script/index.php}\textgreater{}{}`\_\_ which
contains the command line tool \code{convert}).

To use this, e.g.:

from the unix command line:

\begin{Verbatim}[commandchars=\\\{\}]
berlin\PYGZpc{} cd \PYGZti{}/Data/geogg122/Chapter3\PYGZus{}Scientific\PYGZus{}Numerical\PYGZus{}Python
berlin\PYGZpc{} convert files/data/albedo.jpg files/data/albedo.gif
\end{Verbatim}

or from within a notebook:

\begin{Verbatim}[commandchars=\\\{\}]
!convert files/data/albedo.jpg files/data/albedo.gif
\end{Verbatim}

Or, more practically here, you can run a unix command directly from
Python:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{os}
\PYG{n}{cmd} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{convert files/data/albedo.jpg files/data/albedo.gif}\PYG{l+s}{\PYGZsq{}}
\PYG{n}{os}\PYG{o}{.}\PYG{n}{system}\PYG{p}{(}\PYG{n}{cmd}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{0}
\end{Verbatim}

This will convert the file \code{files/data/albedo.jpg} (in jpeg format) to
\code{files/data/albedo.gif} (in gif format).
\begin{figure}[htbp]
\centering
\capstart

\includegraphics{Chapter3_Scientific_Numerical_Python/files/data/albedo.gif}
\caption{albedo}\end{figure}

We can also use \code{convert} to make animated gifs, which is one way of
making a movie.


\subsection{E3.2.2 Looping over a set of images}
\label{Chapter3_Scientific_Numerical_Python/Scientific_Numerical_Python:e3-2-2-looping-over-a-set-of-images}
You have all of the code you need above to be able to read a GlobAlbedo
file for a given month and waveband in Python and save a picture in jpeg
format, but to recap for \code{BHR\_VIS}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{netCDF4} \PYG{k+kn}{import} \PYG{n}{Dataset}
\PYG{k+kn}{import} \PYG{n+nn}{pylab} \PYG{k+kn}{as} \PYG{n+nn}{plt}
\PYG{k+kn}{import} \PYG{n+nn}{os}

\PYG{n}{root} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/}\PYG{l+s}{\PYGZsq{}}

\PYG{n}{month\PYGZus{}list} \PYG{o}{=} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{January}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{February}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{March}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{April}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{May}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{June}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYGZbs{}
              \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{July}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{August}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{September}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{October}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{November}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{December}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\PYG{c}{\PYGZsh{} make a dictionary from 2 lists}
\PYG{n}{month\PYGZus{}dict} \PYG{o}{=} \PYG{n+nb}{dict}\PYG{p}{(}\PYG{n+nb}{zip}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{13}\PYG{p}{)}\PYG{p}{,}\PYG{n}{month\PYGZus{}list}\PYG{p}{)}\PYG{p}{)}

\PYG{c}{\PYGZsh{} example filename : use formatting string:}
\PYG{c}{\PYGZsh{} \PYGZpc{}d\PYGZpc{}02d}
\PYG{n}{year} \PYG{o}{=} \PYG{l+m+mi}{2009}


\PYG{c}{\PYGZsh{} set the month}
\PYG{n}{month} \PYG{o}{=} \PYG{l+m+mi}{1}

\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{} Read the data \PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{n}{local\PYGZus{}file} \PYG{o}{=} \PYG{n}{root} \PYG{o}{+} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{GlobAlbedo.}\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s+si}{\PYGZpc{}02d}\PYG{l+s}{.mosaic.5.nc}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{year}\PYG{p}{,}\PYG{n}{month}\PYG{p}{)}
\PYG{c}{\PYGZsh{} load the netCDF data from the file f.filename}
\PYG{n}{nc} \PYG{o}{=} \PYG{n}{Dataset}\PYG{p}{(}\PYG{n}{local\PYGZus{}file}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{band} \PYG{o}{=} \PYG{n}{nc}\PYG{o}{.}\PYG{n}{variables}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{DHR\PYGZus{}VIS}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}

\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{} Plot the data and save as picture jpeg format \PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{c}{\PYGZsh{} make a string with the output file name}
\PYG{n}{out\PYGZus{}file} \PYG{o}{=} \PYG{n}{root} \PYG{o}{+} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{GlobAlbedo.}\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s+si}{\PYGZpc{}02d}\PYG{l+s}{.jpg}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{year}\PYG{p}{,}\PYG{n}{month}\PYG{p}{)}
\PYG{c}{\PYGZsh{} plot}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{clf}\PYG{p}{(}\PYG{p}{)}
\PYG{c}{\PYGZsh{} \PYGZpc{}9s forces the string to be 8 characters long}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{VIS BHR albedo for }\PYG{l+s+si}{\PYGZpc{}8s}\PYG{l+s}{ }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{month\PYGZus{}dict}\PYG{p}{[}\PYG{n}{month}\PYG{p}{]}\PYG{p}{,}\PYG{n}{year}\PYG{p}{)}\PYG{p}{)}
\PYG{c}{\PYGZsh{} use nearest neighbour interpolation}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{band}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nearest}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{cmap}\PYG{o}{=}\PYG{n}{plt}\PYG{o}{.}\PYG{n}{get\PYGZus{}cmap}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Spectral}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}\PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mf}{0.0}\PYG{p}{,}\PYG{n}{vmax}\PYG{o}{=}\PYG{l+m+mf}{1.0}\PYG{p}{)}
\PYG{c}{\PYGZsh{} show a colour bar}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{n}{out\PYGZus{}file}\PYG{p}{)}

\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{} Convert the file to gif \PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{c}{\PYGZsh{} set up the unix command which is of the form}
\PYG{c}{\PYGZsh{} convert input output}
\PYG{c}{\PYGZsh{} Here input will be out\PYGZus{}file}
\PYG{c}{\PYGZsh{} and output we can get with out\PYGZus{}file.replace(\PYGZsq{}.jpg\PYGZsq{},\PYGZsq{}.gif\PYGZsq{})}
\PYG{c}{\PYGZsh{} i.e. replacing where it says .jpg with .gif}
\PYG{n}{cmd} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{convert }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{ }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{out\PYGZus{}file}\PYG{p}{,}\PYG{n}{out\PYGZus{}file}\PYG{o}{.}\PYG{n}{replace}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{.jpg}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{.gif}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{os}\PYG{o}{.}\PYG{n}{system}\PYG{p}{(}\PYG{n}{cmd}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{0}
\end{Verbatim}

\includegraphics{Scientific_Numerical_Python_39_1.png}

\textbf{Modify the code above to loop over each month, so that it generates a
set of gif format files for the TOTAL SHORTWAVE ALBEDO}

You should confirm that these exist, and that the file modification time
is when you ran it (not when I generated the files for these notes,
which is Oct 10 2013).

\begin{Verbatim}[commandchars=\\\{\}]
ls \PYGZhy{}l files/data/GlobAlbedo*gif
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
[0m\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis 340658 Oct 11 20:04 [0mfiles/data/GlobAlbedo.2009.SW.1.gif[0m
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis 340658 Oct 11 20:04 [0mfiles/data/GlobAlbedo.2009.SW.gif[0m
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis  26593 Oct 14 11:54 [0mfiles/data/GlobAlbedo.200901.gif[0m
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis  28139 Oct 11 20:04 [0mfiles/data/GlobAlbedo.200902.gif[0m
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis  28259 Oct 11 20:04 [0mfiles/data/GlobAlbedo.200903.gif[0m
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis  28249 Oct 11 20:04 [0mfiles/data/GlobAlbedo.200904.gif[0m
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis  28468 Oct 11 20:04 [0mfiles/data/GlobAlbedo.200905.gif[0m
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis  28672 Oct 11 20:04 [0mfiles/data/GlobAlbedo.200906.gif[0m
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis  28656 Oct 11 20:04 [0mfiles/data/GlobAlbedo.200907.gif[0m
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis  28275 Oct 11 20:04 [0mfiles/data/GlobAlbedo.200908.gif[0m
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis  28952 Oct 11 20:04 [0mfiles/data/GlobAlbedo.200909.gif[0m
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis  28450 Oct 11 20:04 [0mfiles/data/GlobAlbedo.200910.gif[0m
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis  28570 Oct 11 20:04 [0mfiles/data/GlobAlbedo.200911.gif[0m
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis  28438 Oct 11 20:04 [0mfiles/data/GlobAlbedo.200912.gif[0m
[m
\end{Verbatim}


\subsection{E3.2.3 Make the movie}
\label{Chapter3_Scientific_Numerical_Python/Scientific_Numerical_Python:e3-2-3-make-the-movie}
The unix command to convert these files to an animated gif is:

\begin{Verbatim}[commandchars=\\\{\}]
convert \PYGZhy{}delay 100  \PYGZhy{}loop 0  files/data/GlobAlbedo.2009??.gif files/data/GlobAlbedo.2009.SW.gif
\end{Verbatim}

\textbf{Run this (ideally, from within Python) to create the animated gif
GlobAlbedo.2009.SW.gif}

Again, confirm that \emph{you} created this file (and it is not just a
version you downloaded):

\begin{Verbatim}[commandchars=\\\{\}]
ls \PYGZhy{}l files/data/GlobAlbedo.2009.SW.gif
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
[0m\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis 340658 Oct 11 20:04 [0mfiles/data/GlobAlbedo.2009.SW.gif[0m
[m
\end{Verbatim}
\begin{figure}[htbp]
\centering

\includegraphics{Chapter3_Scientific_Numerical_Python/files/data/GlobAlbedo.2009.SW.gif}
\end{figure}


\section{3.3 Numpy}
\label{Chapter3_Scientific_Numerical_Python/Scientific_Numerical_Python:numpy}

\subsection{3.3.1 Numpy Arrays}
\label{Chapter3_Scientific_Numerical_Python/Scientific_Numerical_Python:numpy-arrays}
At the heart of the
\code{{}`numpy} \textless{}\href{http://docs.scipy.org/doc/numpy/contents.html}{http://docs.scipy.org/doc/numpy/contents.html}\textgreater{}{}`\_\_ module is
a a powerful N-dimensional array object.

Among many other things, this allows us to do arithmetic (and other
operations) directly on arrays, rather than having to loop over each
element (as we did with lists for example).

Two main benefits of this are:
\begin{itemize}
\item {} 
the code is much easier to read

\item {} 
running the code is much more efficient (because, `under the hood' as
it were of the programming language, we can do fast operations such
as vector processing).

\end{itemize}

As our first example, let's read the shortwave albedo data we examined
above into a numpy array.

We will start with just one month of data:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{netCDF4} \PYG{k+kn}{import} \PYG{n}{Dataset}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}

\PYG{n}{root} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/}\PYG{l+s}{\PYGZsq{}}
\PYG{n}{year} \PYG{o}{=} \PYG{l+m+mi}{2009}


\PYG{c}{\PYGZsh{} set the month}
\PYG{n}{month} \PYG{o}{=} \PYG{l+m+mi}{1}

\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{} Read the data \PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{n}{local\PYGZus{}file} \PYG{o}{=} \PYG{n}{root} \PYG{o}{+} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{GlobAlbedo.}\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s+si}{\PYGZpc{}02d}\PYG{l+s}{.mosaic.5.nc}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{year}\PYG{p}{,}\PYG{n}{month}\PYG{p}{)}
\PYG{c}{\PYGZsh{} load the netCDF data from the file f.filename}
\PYG{n}{nc} \PYG{o}{=} \PYG{n}{Dataset}\PYG{p}{(}\PYG{n}{local\PYGZus{}file}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{band} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{nc}\PYG{o}{.}\PYG{n}{variables}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{DHR\PYGZus{}SW}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}

\PYG{c}{\PYGZsh{} some interesting things about numpy arrays}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{the array type is now}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{band}\PYG{p}{)}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{the shape of the array is}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{band}\PYG{o}{.}\PYG{n}{shape}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{the size of the array is}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{band}\PYG{o}{.}\PYG{n}{size}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{the number of dimensions is}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{band}\PYG{o}{.}\PYG{n}{ndim}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{the data type in the array is}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{band}\PYG{o}{.}\PYG{n}{dtype}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
the array type is now \PYGZlt{}type \PYGZsq{}numpy.ndarray\PYGZsq{}\PYGZgt{}
the shape of the array is (360, 720)
the size of the array is 259200
the number of dimensions is 2
the data type in the array is float32
\end{Verbatim}

A few things to notice here.

First, we imported the numpy module using

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}
\end{Verbatim}

which means that locally, we refer to this module as \code{np}.

Second, we converted from the format that was read from the netCDF file
to a numpy array with:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{band} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{nc}\PYG{o}{.}\PYG{n}{variables}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{DHR\PYGZus{}SW}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

so this is one way to convert from other data types to numpy
representation (e.g. \code{np.array({[}1,2,3{]})} for a conversion from a
list).

Then we saw at the end of this code a number of commonly used methods
for the numpy class that provide us with information on the \code{shape} of
the array (N.B. this is (rows,cols) as you might notice from the plots
we generated), the total size (number of elements), number of
dimansions.

We also saw that we could access the array data type (\code{dtype}). This
is very different to a \code{list} or \code{tuple} then, because a numpy array
can \emph{only} contain data of a single data type (but lists or tuples can
have different data types in each element).


\subsubsection{astype}
\label{Chapter3_Scientific_Numerical_Python/Scientific_Numerical_Python:astype}
We can convert \emph{between} data types using \code{astype}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{a} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{a}\PYG{o}{.}\PYG{n}{dtype}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{int64}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{b} \PYG{o}{=} \PYG{n}{a}\PYG{o}{.}\PYG{n}{astype}\PYG{p}{(}\PYG{n+nb}{float}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{b}
\PYG{k}{print} \PYG{n}{b}\PYG{o}{.}\PYG{n}{dtype}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
[ 1.  2.  3.]
float64
\end{Verbatim}


\subsubsection{slice}
\label{Chapter3_Scientific_Numerical_Python/Scientific_Numerical_Python:slice}
As you would expect, we can slice in a numpy array. All that is
different is that we set up a slice of each dimension, e.g.:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} see if you can work out why this is}
\PYG{c}{\PYGZsh{} the size, shape and ndim it is}

\PYG{k}{print} \PYG{n}{band}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{:}\PYG{l+m+mi}{30}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{]}
\PYG{k}{print} \PYG{n}{band}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{:}\PYG{l+m+mi}{30}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{o}{.}\PYG{n}{shape}
\PYG{k}{print} \PYG{n}{band}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{:}\PYG{l+m+mi}{30}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{o}{.}\PYG{n}{ndim}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
[[ 0.65842855  0.57553321  0.8013677   0.80455124]
 [ 0.66181606  0.66181606  0.6632846   0.58462834]]
(2, 4)
2
\end{Verbatim}

If you want to specify \textbf{all elements in a given dimension} you need to
use at least one \code{:}, e.g.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} what does this mean?}

\PYG{k}{print} \PYG{n}{band}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{:}\PYG{l+m+mi}{20}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{k}{print} \PYG{n}{band}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{:}\PYG{l+m+mi}{20}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{shape}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
[ nan  nan  nan  nan  nan  nan  nan  nan  nan  nan]
(10,)
\end{Verbatim}


\subsubsection{nan, inf}
\label{Chapter3_Scientific_Numerical_Python/Scientific_Numerical_Python:nan-inf}
Some of the data in the array \code{band} appear as \code{nan} (`not a
number'), which is how, in this dataset, non-valid pixels are specified.

\code{nan} is also what you would get for undefined results from
arithmetic:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{a} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{b} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{c} \PYG{o}{=} \PYG{n}{a}\PYG{o}{/}\PYG{n}{b}
\PYG{k}{print} \PYG{n}{c}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{so 0./0. =}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{c}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{so 1./0. =}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{c}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
[ nan  inf]
so 0./0. = nan
so 1./0. = inf
\end{Verbatim}

\code{inf} here means `infinity', which is what anything other than zero
divided by zero is.

We can check to see if some value is \code{nan} or \code{inf} e.g:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{is c nan?}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{isnan}\PYG{p}{(}\PYG{n}{c}\PYG{p}{)}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{is c inf?}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{isinf}\PYG{p}{(}\PYG{n}{c}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
is c nan? [ True False]
is c inf? [False  True]
\end{Verbatim}

Generally we would want to avoid processing array values that contained
\code{nan} or \code{inf} as any arithmetic involving these is unlikely tell us
more than we already know:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{inf + 1}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{=}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{inf} \PYG{o}{+} \PYG{l+m+mi}{1}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{inf \PYGZhy{} np.inf}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{=}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{inf} \PYG{o}{\PYGZhy{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{inf}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nan / 2 }\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{=}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{nan} \PYG{o}{/} \PYG{l+m+mi}{2}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{inf} \PYG{o}{+} \PYG{l+m+mi}{1}             \PYG{o}{=} \PYG{n}{inf}
\PYG{n}{inf} \PYG{o}{\PYGZhy{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{inf}        \PYG{o}{=} \PYG{n}{nan}
\PYG{n}{nan} \PYG{o}{/} \PYG{l+m+mi}{2}             \PYG{o}{=} \PYG{n}{nan}
\end{Verbatim}

Or, trying to e.g. calculate the sum of values in the array \code{band}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{n}{band}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{nan}
\end{Verbatim}

which is not really what we wanted.

We have seen above that \code{np.isnan(c)} and \code{np.isinf(c)} result in a
\code{bool} array of the same shape as the input array.

We can use these to mask out things we don't want, e.g.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{no\PYGZus{}data} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{isnan}\PYG{p}{(}\PYG{n}{band}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{no\PYGZus{}data}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
[[ True  True  True ...,  True  True  True]
 [ True  True  True ...,  True  True  True]
 [ True  True  True ...,  True  True  True]
 ...,
 [False False False ..., False False False]
 [False False False ..., False False False]
 [False False False ..., False False False]]
\end{Verbatim}

This will be \code{True} where the data in \code{band} were \code{nan} ... but
what we might often want is the opposite of this, i.e. \code{True} where
the data are valid.

We might guess that we could simply type:


\subsubsection{masked array}
\label{Chapter3_Scientific_Numerical_Python/Scientific_Numerical_Python:masked-array}
There is a special type of object in \code{numpy} called a \href{http://docs.scipy.org/doc/numpy/reference/maskedarray.html}{masked
array}.
With this array representation, operations are \emph{only} performed where
the data mask is \code{False}. We need to import the masked array module
\code{ma} from numpy:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy.ma} \PYG{k+kn}{as} \PYG{n+nn}{ma}

\PYG{n}{masked\PYGZus{}band} \PYG{o}{=} \PYG{n}{ma}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{band}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{masked\PYGZus{}band}\PYG{o}{.}\PYG{n}{mask}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nb+bp}{False}
\end{Verbatim}

When we convert the representation from a normal \code{numpy} array to a
masked array using \code{ma.array()}, the default mask is \code{False} (which
means no mask).

In this case, we want to set the mask to \code{True} where the data are
\code{nan}. We would normally do this when setting up the masked array:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{masked\PYGZus{}band} \PYG{o}{=} \PYG{n}{ma}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{band}\PYG{p}{,}\PYG{n}{mask}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{isnan}\PYG{p}{(}\PYG{n}{band}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{so the array is now}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{masked\PYGZus{}band}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{with a mask}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{masked\PYGZus{}band}\PYG{o}{.}\PYG{n}{mask}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
so the array is now
[[\PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} ..., \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{}]
 [\PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} ..., \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{}]
 [\PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} ..., \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{} \PYGZhy{}\PYGZhy{}]
 ...,
 [0.5722442269325256 0.5722442269325256 0.5722442269325256 ...,
  0.5790106058120728 0.5790106058120728 0.5790106058120728]
 [0.5722442269325256 0.5722442269325256 0.5722442269325256 ...,
  0.5790106058120728 0.5790106058120728 0.5790106058120728]
 [0.5722442269325256 0.5722442269325256 0.5722442269325256 ...,
  0.5790106058120728 0.5790106058120728 0.5790106058120728]]

with a mask
[[ True  True  True ...,  True  True  True]
 [ True  True  True ...,  True  True  True]
 [ True  True  True ...,  True  True  True]
 ...,
 [False False False ..., False False False]
 [False False False ..., False False False]
 [False False False ..., False False False]]
\end{Verbatim}


\subsection{3.3.2 Reading data from multiple files}
\label{Chapter3_Scientific_Numerical_Python/Scientific_Numerical_Python:reading-data-from-multiple-files}

\subsubsection{zeros, ones, empty}
\label{Chapter3_Scientific_Numerical_Python/Scientific_Numerical_Python:zeros-ones-empty}
Suppose we want to read in all 12 months of SW albedo data following on
from the example above.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{netCDF4} \PYG{k+kn}{import} \PYG{n}{Dataset}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}

\PYG{n}{root} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/}\PYG{l+s}{\PYGZsq{}}
\PYG{n}{year} \PYG{o}{=} \PYG{l+m+mi}{2009}

\PYG{c}{\PYGZsh{} which months?}
\PYG{n}{months} \PYG{o}{=} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{13}\PYG{p}{)}

\PYG{c}{\PYGZsh{} loop over month}
\PYG{c}{\PYGZsh{} but right now we\PYGZsq{}ll just pretend that we\PYGZsq{}re}
\PYG{c}{\PYGZsh{} doing that and consider what happens the first time}
\PYG{c}{\PYGZsh{} we are in our loop}
\PYG{c}{\PYGZsh{}}
\PYG{c}{\PYGZsh{} set i as index counter}
\PYG{c}{\PYGZsh{} set the variable month to be}
\PYG{c}{\PYGZsh{} months[0]}
\PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{month} \PYG{o}{=} \PYG{n}{months}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}

\PYG{c}{\PYGZsh{} this then is the file we want}
\PYG{n}{local\PYGZus{}file} \PYG{o}{=} \PYG{n}{root} \PYG{o}{+} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{GlobAlbedo.}\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s+si}{\PYGZpc{}02d}\PYG{l+s}{.mosaic.5.nc}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{year}\PYG{p}{,}\PYG{n}{month}\PYG{p}{)}

\PYG{c}{\PYGZsh{} load the netCDF data from the file local\PYGZus{}file}
\PYG{n}{nc} \PYG{o}{=} \PYG{n}{Dataset}\PYG{p}{(}\PYG{n}{local\PYGZus{}file}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{band} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{nc}\PYG{o}{.}\PYG{n}{variables}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{DHR\PYGZus{}SW}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

Looking at what would happen when we read the first file, we can see
that we don't actually know how large the whole dataset will be until we
have read our first file.

We know that we will want dimensions of \code{(12,nrows,ncols)} (or better
still, \code{(len(months),nrows,ncols)} in case we decide to change
months), but until we have read the data into the variable \code{band}
with:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{band} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{nc}\PYG{o}{.}\PYG{n}{variables}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{DHR\PYGZus{}SW}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

we don't know how many rows or columns the dataset has (well, we might
do ... but we want to try to design flexible code, where if the size of
the datasets changed, our code would still operate correctly!).

But, when we \emph{have} first read some data, \emph{then} we would be in a
position to say what the shape of the whole dataset should be. At that
point, we could use the method:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{np}\PYG{o}{.}\PYG{n}{empty}\PYG{p}{(}\PYG{n}{shape}\PYG{p}{)}
\end{Verbatim}

to (in essence) set aside (`allocate') some memory to store these data.
There are three main options for this:
\begin{itemize}
\item {} 
\code{np.zeros(shape)} : set up an array with shape defined by \code{shape}
and initialise with 0

\item {} 
\code{np.ones(shape)} : set up an array with shape defined by \code{shape}
and initialise with 1

\item {} 
\code{np.empty(shape)} : set up an array with shape defined by \code{shape}
but don't initialise (so, in theory, a little faster, but can be
filled with randon junk)

\end{itemize}

we can control the \code{dtype} of the array with a \code{dtype} option. e.g.:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZhy{}}\PYG{l+s}{\PYGZsq{}}\PYG{o}{*}\PYG{l+m+mi}{30}\PYG{p}{;}\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{1\PYGZhy{}D arrays}\PYG{l+s}{\PYGZsq{}}\PYG{p}{;}\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZhy{}}\PYG{l+s}{\PYGZsq{}}\PYG{o}{*}\PYG{l+m+mi}{30}\PYG{p}{;}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{np.zeros(1):}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}  \PYG{c}{\PYGZsh{} 1 : 1D array}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{np.zeros(2):}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}  \PYG{c}{\PYGZsh{} 2 : 1D array}

\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZsq{}} \PYG{o}{+} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZhy{}}\PYG{l+s}{\PYGZsq{}}\PYG{o}{*}\PYG{l+m+mi}{30}\PYG{p}{;}\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{2\PYGZhy{} and 3\PYGZhy{}D arrays}\PYG{l+s}{\PYGZsq{}}\PYG{p}{;}\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZhy{}}\PYG{l+s}{\PYGZsq{}}\PYG{o}{*}\PYG{l+m+mi}{30}\PYG{p}{;}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{np.zeros((1,2)):}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}  \PYG{c}{\PYGZsh{} default dtype is float}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{np.zeros((2,2)):}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}  \PYG{c}{\PYGZsh{} 2 X 2}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{np.zeros((2,2,3)):}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}  \PYG{c}{\PYGZsh{} 2 X 2 X 3}

\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZsq{}} \PYG{o}{+} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZhy{}}\PYG{l+s}{\PYGZsq{}}\PYG{o}{*}\PYG{l+m+mi}{30}\PYG{p}{;}\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{empty and ones}\PYG{l+s}{\PYGZsq{}}\PYG{p}{;}\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZhy{}}\PYG{l+s}{\PYGZsq{}}\PYG{o}{*}\PYG{l+m+mi}{30}\PYG{p}{;}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{np.empty((1,2)):}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{empty}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}  \PYG{c}{\PYGZsh{} default dtype is float}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{np.ones((1,2)):}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}  \PYG{c}{\PYGZsh{} default dtype is float}

\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZsq{}} \PYG{o}{+} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZhy{}}\PYG{l+s}{\PYGZsq{}}\PYG{o}{*}\PYG{l+m+mi}{30}\PYG{p}{;}\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Changing the data type}\PYG{l+s}{\PYGZsq{}}\PYG{p}{;}\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZhy{}}\PYG{l+s}{\PYGZsq{}}\PYG{o}{*}\PYG{l+m+mi}{30}\PYG{p}{;}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{np.ones((1,2),dtype=int):}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,}\PYG{n}{dtype}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{)}  \PYG{c}{\PYGZsh{}  dtype int}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{np.empty((1,2),dtype=int):}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{empty}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,}\PYG{n}{dtype}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{)}  \PYG{c}{\PYGZsh{}  dtype int}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{np.ones((1,2),dtype=bool):}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,}\PYG{n}{dtype}\PYG{o}{=}\PYG{n+nb}{bool}\PYG{p}{)}  \PYG{c}{\PYGZsh{}  dtype bool}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{np.zeros((1,2),dtype=bool):}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,}\PYG{n}{dtype}\PYG{o}{=}\PYG{n+nb}{bool}\PYG{p}{)}  \PYG{c}{\PYGZsh{}  dtype bool}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{np.empty((1,2),dtype=bool):}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{empty}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,}\PYG{n}{dtype}\PYG{o}{=}\PYG{n+nb}{bool}\PYG{p}{)}  \PYG{c}{\PYGZsh{}  dtype bool}

\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZsq{}} \PYG{o}{+} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZhy{}}\PYG{l+s}{\PYGZsq{}}\PYG{o}{*}\PYG{l+m+mi}{30}\PYG{p}{;}\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Note that we can have a string array}\PYG{l+s}{\PYGZsq{}}\PYG{p}{;}\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZhy{}}\PYG{l+s}{\PYGZsq{}}\PYG{o}{*}\PYG{l+m+mi}{30}\PYG{p}{;}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{np.ones((1,2),dtype=str):}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,}\PYG{n}{dtype}\PYG{o}{=}\PYG{n+nb}{str}\PYG{p}{)}  \PYG{c}{\PYGZsh{}  dtype str}

\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZsq{}} \PYG{o}{+} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZhy{}}\PYG{l+s}{\PYGZsq{}}\PYG{o}{*}\PYG{l+m+mi}{30}\PYG{p}{;}\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Or even e.g. a list array}\PYG{l+s}{\PYGZsq{}}\PYG{p}{;}\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZhy{}}\PYG{l+s}{\PYGZsq{}}\PYG{o}{*}\PYG{l+m+mi}{30}\PYG{p}{;}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{np.ones((2,2),dtype=list):}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,}\PYG{n}{dtype}\PYG{o}{=}\PYG{n+nb}{list}\PYG{p}{)}  \PYG{c}{\PYGZsh{}  dtype list}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{np.empty((2,2),dtype=list):}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{empty}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,}\PYG{n}{dtype}\PYG{o}{=}\PYG{n+nb}{list}\PYG{p}{)}  \PYG{c}{\PYGZsh{}  dtype list}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
1\PYGZhy{}D arrays
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
np.zeros(1): [ 0.]
np.zeros(2): [ 0.  0.]

\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
2\PYGZhy{} and 3\PYGZhy{}D arrays
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
np.zeros((1,2)):
[[ 0.  0.]]
np.zeros((2,2)):
[[ 0.  0.]
 [ 0.  0.]]
np.zeros((2,2,3)):
[[[ 0.  0.  0.]
  [ 0.  0.  0.]]

 [[ 0.  0.  0.]
  [ 0.  0.  0.]]]

\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
empty and ones
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
np.empty((1,2)):
[[  0.00000000e+000   1.56900585e\PYGZhy{}315]]
np.ones((1,2)):
[[ 1.  1.]]

\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
Changing the data type
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
np.ones((1,2),dtype=int):
[[1 1]]
np.empty((1,2),dtype=int):
[[        0 225037488]]
np.ones((1,2),dtype=bool):
[[ True  True]]
np.zeros((1,2),dtype=bool):
[[False False]]
np.empty((1,2),dtype=bool):
[[ True  True]]

\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
Note that we can have a string array
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
np.ones((1,2),dtype=str):
[[\PYGZsq{}1\PYGZsq{} \PYGZsq{}1\PYGZsq{}]]

\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
Or even e.g. a list array
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
np.ones((2,2),dtype=list):
[[1 1]
 [1 1]]
np.empty((2,2),dtype=list):
[[None None]
 [None None]]
\end{Verbatim}

So, once we have read one band, we could write:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{netCDF4} \PYG{k+kn}{import} \PYG{n}{Dataset}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}

\PYG{n}{root} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/}\PYG{l+s}{\PYGZsq{}}
\PYG{n}{year} \PYG{o}{=} \PYG{l+m+mi}{2009}

\PYG{c}{\PYGZsh{} which months?}
\PYG{n}{months} \PYG{o}{=} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{13}\PYG{p}{)}

\PYG{c}{\PYGZsh{} loop over month}
\PYG{c}{\PYGZsh{} but right now we\PYGZsq{}ll just pretend that we\PYGZsq{}re}
\PYG{c}{\PYGZsh{} doing that and consider what happens the first time}
\PYG{c}{\PYGZsh{} we are in our loop}
\PYG{c}{\PYGZsh{}}
\PYG{c}{\PYGZsh{} set i as index counter}
\PYG{c}{\PYGZsh{} set the variable month to be}
\PYG{c}{\PYGZsh{} months[0]}
\PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{month} \PYG{o}{=} \PYG{n}{months}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}

\PYG{c}{\PYGZsh{} this then is the file we want}
\PYG{n}{local\PYGZus{}file} \PYG{o}{=} \PYG{n}{root} \PYG{o}{+} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{GlobAlbedo.}\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s+si}{\PYGZpc{}02d}\PYG{l+s}{.mosaic.5.nc}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{year}\PYG{p}{,}\PYG{n}{month}\PYG{p}{)}

\PYG{c}{\PYGZsh{} load the netCDF data from the file local\PYGZus{}file}
\PYG{n}{nc} \PYG{o}{=} \PYG{n}{Dataset}\PYG{p}{(}\PYG{n}{local\PYGZus{}file}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{band} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{nc}\PYG{o}{.}\PYG{n}{variables}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{DHR\PYGZus{}SW}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{k}{if} \PYG{n}{i} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:}  \PYG{c}{\PYGZsh{} first band read}
    \PYG{c}{\PYGZsh{} set up a tuple (or list) saying what shape we want the data}
    \PYG{n}{shape} \PYG{o}{=} \PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{months}\PYG{p}{)}\PYG{p}{,}\PYG{p}{)} \PYG{o}{+} \PYG{n}{band}\PYG{o}{.}\PYG{n}{shape}
    \PYG{n}{data} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{n}{shape}\PYG{p}{)}

\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{I set up the array data of shape}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{data}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{with}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{data}\PYG{o}{.}\PYG{n}{ndim}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{dimensions}\PYG{l+s}{\PYGZdq{}}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
I set up the array data of shape (12, 360, 720) with 3 dimensions
\end{Verbatim}

We also use slicing when assigning (`loading', if you like) data into a
larger array:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{p}{:}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{n}{band}
\end{Verbatim}

But this will \emph{only} work if what you are trying to load and where you
are tryng to load it are the same \emph{shape}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{p}{:}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]}\PYG{o}{.}\PYG{n}{shape} \PYG{o}{==} \PYG{n}{band}\PYG{o}{.}\PYG{n}{shape}
\end{Verbatim}

which they are in this case.

Putting this all together then:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} this then is the file we want}
\PYG{n}{local\PYGZus{}file} \PYG{o}{=} \PYG{n}{root} \PYG{o}{+} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{GlobAlbedo.}\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s+si}{\PYGZpc{}02d}\PYG{l+s}{.mosaic.5.nc}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{year}\PYG{p}{,}\PYG{n}{month}\PYG{p}{)}

\PYG{c}{\PYGZsh{} load the netCDF data from the file local\PYGZus{}file}
\PYG{n}{nc} \PYG{o}{=} \PYG{n}{Dataset}\PYG{p}{(}\PYG{n}{local\PYGZus{}file}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{band} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{nc}\PYG{o}{.}\PYG{n}{variables}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{DHR\PYGZus{}SW}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{k}{if} \PYG{n}{i} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:}  \PYG{c}{\PYGZsh{} first band read}
    \PYG{c}{\PYGZsh{} set up a tuple (or list) saying what shape we want the data}
    \PYG{n}{shape} \PYG{o}{=} \PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{months}\PYG{p}{)}\PYG{p}{,}\PYG{p}{)} \PYG{o}{+} \PYG{n}{band}\PYG{o}{.}\PYG{n}{shape}
    \PYG{n}{data} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{empty}\PYG{p}{(}\PYG{n}{shape}\PYG{p}{)}

\PYG{c}{\PYGZsh{} load band into the data array}
\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{p}{:}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{n}{band}
\end{Verbatim}

And setting the loop around this:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{netCDF4} \PYG{k+kn}{import} \PYG{n}{Dataset}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}

\PYG{n}{root} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/}\PYG{l+s}{\PYGZsq{}}
\PYG{n}{year} \PYG{o}{=} \PYG{l+m+mi}{2009}

\PYG{c}{\PYGZsh{} which months?}
\PYG{n}{months} \PYG{o}{=} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{13}\PYG{p}{)}

\PYG{c}{\PYGZsh{} loop over month}
\PYG{c}{\PYGZsh{} use enumerate so we have an index counter}
\PYG{k}{for} \PYG{n}{i}\PYG{p}{,}\PYG{n}{month} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{months}\PYG{p}{)}\PYG{p}{:}
    \PYG{c}{\PYGZsh{} this then is the file we want}
    \PYG{n}{local\PYGZus{}file} \PYG{o}{=} \PYG{n}{root} \PYG{o}{+} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{GlobAlbedo.}\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s+si}{\PYGZpc{}02d}\PYG{l+s}{.mosaic.5.nc}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{year}\PYG{p}{,}\PYG{n}{month}\PYG{p}{)}

    \PYG{c}{\PYGZsh{} load the netCDF data from the file local\PYGZus{}file}
    \PYG{n}{nc} \PYG{o}{=} \PYG{n}{Dataset}\PYG{p}{(}\PYG{n}{local\PYGZus{}file}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{band} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{nc}\PYG{o}{.}\PYG{n}{variables}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{DHR\PYGZus{}SW}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
    \PYG{k}{if} \PYG{n}{i} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:}  \PYG{c}{\PYGZsh{} first band read}
        \PYG{c}{\PYGZsh{} set up a tuple (or list) saying what shape we want the data}
        \PYG{n}{shape} \PYG{o}{=} \PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{months}\PYG{p}{)}\PYG{p}{,}\PYG{p}{)} \PYG{o}{+} \PYG{n}{band}\PYG{o}{.}\PYG{n}{shape}
        \PYG{n}{data} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{empty}\PYG{p}{(}\PYG{n}{shape}\PYG{p}{)}

    \PYG{c}{\PYGZsh{} load band into the data array}
    \PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{p}{:}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{n}{band}
\end{Verbatim}

so now we have all of the data loaded into the array \code{data}.

An alternative way of achieving this same effect is to use a list,
creating an empty list before going into the loop and appending \code{band}
to the list each time we read a new band.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{netCDF4} \PYG{k+kn}{import} \PYG{n}{Dataset}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}

\PYG{n}{root} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/}\PYG{l+s}{\PYGZsq{}}
\PYG{n}{year} \PYG{o}{=} \PYG{l+m+mi}{2009}

\PYG{c}{\PYGZsh{} which months?}
\PYG{n}{months} \PYG{o}{=} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{13}\PYG{p}{)}

\PYG{c}{\PYGZsh{} empty list}
\PYG{n}{data} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}

\PYG{c}{\PYGZsh{} loop over month}
\PYG{c}{\PYGZsh{} use enumerate so we have an index counter}
\PYG{k}{for} \PYG{n}{i}\PYG{p}{,}\PYG{n}{month} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{months}\PYG{p}{)}\PYG{p}{:}
    \PYG{c}{\PYGZsh{} this then is the file we want}
    \PYG{n}{local\PYGZus{}file} \PYG{o}{=} \PYG{n}{root} \PYG{o}{+} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{GlobAlbedo.}\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s+si}{\PYGZpc{}02d}\PYG{l+s}{.mosaic.5.nc}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{year}\PYG{p}{,}\PYG{n}{month}\PYG{p}{)}

    \PYG{c}{\PYGZsh{} load the netCDF data from the file local\PYGZus{}file}
    \PYG{n}{nc} \PYG{o}{=} \PYG{n}{Dataset}\PYG{p}{(}\PYG{n}{local\PYGZus{}file}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
    \PYG{c}{\PYGZsh{} append what we read to the list called data}
    \PYG{n}{data}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{nc}\PYG{o}{.}\PYG{n}{variables}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{DHR\PYGZus{}SW}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}

\PYG{c}{\PYGZsh{} convert data to a numpy array (its a list of arrays at the moment)}
\PYG{n}{data} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}
\end{Verbatim}

In many ways, this is a simpler and `cleaner' way of setting up a 3-D
array from reading multiple 2-D arrays. If the array is \emph{very} large, it
can be less efficient (you have to convert a huge list to an array at
the end), but that is not normally something to worry about and this
approach is often preferable.


\subsubsection{sum}
\label{Chapter3_Scientific_Numerical_Python/Scientific_Numerical_Python:sum}
To sum data in a numpy (or masked) array, we use the function \code{sum}.

e.g.:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{n}{data}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
nan nan
\end{Verbatim}

Thats not very useful in this case, because we have \code{nan} in the
dataset ... though if we use a masked array it \emph{will} work as we expect.

\code{np.sum} here adds all of the values in the array.

We could select \emph{only} values that are \textgreater{}= 0 with the logical statement:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{not\PYGZus{}valid} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{isnan}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{not\PYGZus{}valid}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
[[[ True  True  True ...,  True  True  True]
  [ True  True  True ...,  True  True  True]
  [ True  True  True ...,  True  True  True]
  ...,
  [False False False ..., False False False]
  [False False False ..., False False False]
  [False False False ..., False False False]]

 [[ True  True  True ...,  True  True  True]
  [ True  True  True ...,  True  True  True]
  [ True  True  True ...,  True  True  True]
  ...,
  [False False False ..., False False False]
  [False False False ..., False False False]
  [False False False ..., False False False]]

 [[ True  True  True ...,  True  True  True]
  [ True  True  True ...,  True  True  True]
  [ True  True  True ...,  True  True  True]
  ...,
  [False False False ..., False False False]
  [False False False ..., False False False]
  [False False False ..., False False False]]

 ...,
 [[ True  True  True ...,  True  True  True]
  [ True  True  True ...,  True  True  True]
  [ True  True  True ...,  True  True  True]
  ...,
  [False False False ..., False False False]
  [False False False ..., False False False]
  [False False False ..., False False False]]

 [[ True  True  True ...,  True  True  True]
  [ True  True  True ...,  True  True  True]
  [ True  True  True ...,  True  True  True]
  ...,
  [False False False ..., False False False]
  [False False False ..., False False False]
  [False False False ..., False False False]]

 [[ True  True  True ...,  True  True  True]
  [ True  True  True ...,  True  True  True]
  [ True  True  True ...,  True  True  True]
  ...,
  [False False False ..., False False False]
  [False False False ..., False False False]
  [False False False ..., False False False]]]
\end{Verbatim}

so \code{not\_valid} here is an array of the same size and shape as
\code{data}, with \code{True} where the value is not valid (\code{nan}) and
\code{False} elsewhere.

We can use this to select \emph{only} data elements in \code{data} which are
\code{False} in not\_valid (not not\_valid is valid ...), or we could
change this into a \code{valid} array:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{valid} \PYG{o}{=} \PYG{n}{not\PYGZus{}valid} \PYG{o}{==} \PYG{n+nb+bp}{False}

\PYG{n}{ndata} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{n}{valid}\PYG{p}{]}
\PYG{k}{print} \PYG{n}{ndata}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
[ 0.69403636  0.74866891  0.80311614 ...,  0.58878124  0.58878124
  0.58878124]
\end{Verbatim}

Now, the array is a 1-D array. It has fewer elements that the original
\code{data} array:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{original data size}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{:}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{data}\PYG{o}{.}\PYG{n}{size}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{new data size}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{:}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{ndata}\PYG{o}{.}\PYG{n}{size}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{data shape}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{:}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{data}\PYG{o}{.}\PYG{n}{shape}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{new data shape}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{:}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{ndata}\PYG{o}{.}\PYG{n}{shape}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
original data size  : 3110400
new data size               : 1040376
data shape          : (12, 360, 720)
new data shape              : (1040376,)
\end{Verbatim}

This is however, one way we can use \code{np.sum} to add up the values in
\code{data}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{n}{data}\PYG{p}{[}\PYG{n}{valid}\PYG{p}{]}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{446890.0}
\end{Verbatim}


\subsubsection{mean}
\label{Chapter3_Scientific_Numerical_Python/Scientific_Numerical_Python:mean}
Similarly, if we wanted the \code{mean} or standard deviation and we tried
to do this on the array that has \code{nan} in it:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{n}{data}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{data}\PYG{o}{.}\PYG{n}{std}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
nan nan
\end{Verbatim}

but selecting only the values that are valid:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{n}{data}\PYG{p}{[}\PYG{n}{valid}\PYG{p}{]}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{data}\PYG{p}{[}\PYG{n}{valid}\PYG{p}{]}\PYG{o}{.}\PYG{n}{std}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
0.429546835711 0.30692650158
\end{Verbatim}

we get what we might expect.

Remember that this is for \emph{normal} (i.e. not masked) numpy arrays.
Hassles of this nature with \code{nan} in the dataset is one good reason to
use masked arrays.


\subsubsection{axis selction}
\label{Chapter3_Scientific_Numerical_Python/Scientific_Numerical_Python:axis-selction}
As used above, functions such as \code{sum}, \code{mean} and \code{std} will give
you the sum, mean and standard deviation over \emph{the whole array}.

Often though, we only want to apply these functions over a particular
dimension.

Recall that the shape of data is:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{data}\PYG{o}{.}\PYG{n}{shape}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{360}\PYG{p}{,} \PYG{l+m+mi}{720}\PYG{p}{)}
\end{Verbatim}

The first dimension here is `month' then, the second is `latitude' and
the third `longitude'.

If we wanted to know the mean albedo for each month then then, we would
want to apply \code{mean} over axis 1 and 2:

In numpy, this is done by specifying \code{axis} in the function:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{month\PYGZus{}mean} \PYG{o}{=} \PYG{n}{data}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{n}{axis}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{month\PYGZus{}mean}\PYG{o}{.}\PYG{n}{shape}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{,}\PYG{p}{)}
\end{Verbatim}

Thats the correct shape, but if we look at the values:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{n}{month\PYGZus{}mean}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
[ nan  nan  nan  nan  nan  nan  nan  nan  nan  nan  nan  nan]
\end{Verbatim}

we see that we get \code{nan} ...

That's hardly surprising, as this is the same issue we had earlier with
just calling \code{sum} or \code{mean} over the whole array.

Rather than end this section with a negative result, lets consider an
array without \code{nan}.

We have previously generated the array \code{valid}, which is a logical
array, but we could e.g. convert this to \code{float}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{gdata} \PYG{o}{=} \PYG{p}{(}\PYG{n}{valid}\PYG{p}{)}\PYG{o}{.}\PYG{n}{astype}\PYG{p}{(}\PYG{n+nb}{float}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{gdata}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{axis}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{gdata}\PYG{o}{.}\PYG{n}{std}\PYG{p}{(}\PYG{n}{axis}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{gdata}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{n}{axis}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
[ 86698.  86698.  86698.  86698.  86698.  86698.  86698.  86698.  86698.
  86698.  86698.  86698.]
[ 0.47180942  0.47180942  0.47180942  0.47180942  0.47180942  0.47180942
  0.47180942  0.47180942  0.47180942  0.47180942  0.47180942  0.47180942]
[ 0.33448302  0.33448302  0.33448302  0.33448302  0.33448302  0.33448302
  0.33448302  0.33448302  0.33448302  0.33448302  0.33448302  0.33448302]
\end{Verbatim}

There are many useful functions in \code{numpy} for manipulating array
data, from basic arithmetic through to these function here for some
basic stats.

They are all very easy to use and make for clear code, \emph{but} if you have
masks in your dataset (as we often do with geospatial data), you need to
think carefully about how you want to process in the presence of masks.

It is often a good idea when you have masks to use a masked array.


\section{E3.3 Exercise: 3D Masked Array}
\label{Chapter3_Scientific_Numerical_Python/Scientific_Numerical_Python:e3-3-exercise-3d-masked-array}
\textbf{Taking the code above as a starting point, generate a masked array of
the GlobAlbedo dataset for the year 2009.}


\section{3.4 Average Albedo}
\label{Chapter3_Scientific_Numerical_Python/Scientific_Numerical_Python:average-albedo}
If you run the exercise above, \code{data} should now be a masked array.

If you haven't (e.g. when going through this in the class), you can run
a function in the file
\code{{}`files/python/masked.py} \textless{}files/python/masked.py\textgreater{}{}`\_\_ to do this now:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{n}{sys}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/python}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{k+kn}{from} \PYG{n+nn}{masked} \PYG{k+kn}{import} \PYG{n}{masked}

\PYG{n}{data} \PYG{o}{=} \PYG{n}{masked}\PYG{p}{(}\PYG{n}{dataset}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{BHR\PYGZus{}SW}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{print} \PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{data}\PYG{o}{.}\PYG{n}{shape}
\PYG{k}{print} \PYG{n}{data}\PYG{o}{.}\PYG{n}{ndim}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}class \PYGZsq{}numpy.ma.core.MaskedArray\PYGZsq{}\PYGZgt{}
(12, 360, 720)
3
\end{Verbatim}

Now we have the albedo dataset for one year stacked in a 3-D masked
array array (assuming you sucessfully completed exercise E3.3 or ran the
code above), we can do some interesting things with it with numpy
(without the \code{nan} hassles above):


\subsection{3.4.1 Annual Mean and Standard Deviation}
\label{Chapter3_Scientific_Numerical_Python/Scientific_Numerical_Python:annual-mean-and-standard-deviation}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} calculate the mean albedo over the year}
\PYG{c}{\PYGZsh{} The axis=0 option tells numpy which}
\PYG{c}{\PYGZsh{} dimension to apply the function mean() over}
\PYG{n}{mean\PYGZus{}albedo} \PYG{o}{=} \PYG{n}{data}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}

\PYG{c}{\PYGZsh{} just confirm this is the ndim and shape we expect ...}
\PYG{k}{print} \PYG{n}{mean\PYGZus{}albedo}\PYG{o}{.}\PYG{n}{ndim}
\PYG{k}{print} \PYG{n}{mean\PYGZus{}albedo}\PYG{o}{.}\PYG{n}{shape}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{2}
\PYG{p}{(}\PYG{l+m+mi}{360}\PYG{p}{,} \PYG{l+m+mi}{720}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} do a plot}

\PYG{c}{\PYGZsh{} change the figure size}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{SW BHR mean albedo for }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{year}\PYG{p}{)}\PYG{p}{)}
\PYG{c}{\PYGZsh{} use nearest neighbour interpolation}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{mean\PYGZus{}albedo}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYGZbs{}
           \PYG{n}{cmap}\PYG{o}{=}\PYG{n}{plt}\PYG{o}{.}\PYG{n}{get\PYGZus{}cmap}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Spectral}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}\PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mf}{0.0}\PYG{p}{,}\PYG{n}{vmax}\PYG{o}{=}\PYG{l+m+mf}{1.0}\PYG{p}{)}

\PYG{c}{\PYGZsh{} show a colour bar}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.colorbar.Colorbar instance at 0x13065ea8\PYGZgt{}
\end{Verbatim}

\includegraphics{Scientific_Numerical_Python_132_1.png}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{}std}
\PYG{n}{std\PYGZus{}albedo} \PYG{o}{=} \PYG{n}{data}\PYG{o}{.}\PYG{n}{std}\PYG{p}{(}\PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{SW BHR std albedo for }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{year}\PYG{p}{)}\PYG{p}{)}
\PYG{c}{\PYGZsh{} use nearest neighbour interpolation}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{std\PYGZus{}albedo}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYGZbs{}
           \PYG{n}{cmap}\PYG{o}{=}\PYG{n}{plt}\PYG{o}{.}\PYG{n}{get\PYGZus{}cmap}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Spectral}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}\PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mf}{0.0}\PYG{p}{)}

\PYG{c}{\PYGZsh{} show a colour bar}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.colorbar.Colorbar instance at 0x129f7a28\PYGZgt{}
\end{Verbatim}

\includegraphics{Scientific_Numerical_Python_133_1.png}

We can see form this that most of the intra-annual variation in total
shortwave albedo is at high latitudes (but \emph{not} Greenland or
Antarctica, for instance).

Why do you think that is?


\subsection{3.4.2 NDVI}
\label{Chapter3_Scientific_Numerical_Python/Scientific_Numerical_Python:ndvi}
It might be interesting to look at NDVI data in this same way and to
examine a few more stats using \code{numpy}. Even though this is a
broadband albedo dataset, we would expect NDVI to give some indication
of vegetation activity.


\subsubsection{min, max}
\label{Chapter3_Scientific_Numerical_Python/Scientific_Numerical_Python:min-max}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{n}{sys}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/python}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{k+kn}{from} \PYG{n+nn}{masked} \PYG{k+kn}{import} \PYG{n}{masked}

\PYG{n}{vis} \PYG{o}{=} \PYG{n}{masked}\PYG{p}{(}\PYG{n}{dataset}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{BHR\PYGZus{}VIS}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{nir} \PYG{o}{=} \PYG{n}{masked}\PYG{p}{(}\PYG{n}{dataset}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{BHR\PYGZus{}NIR}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{ndvi} \PYG{o}{=} \PYG{p}{(}\PYG{n}{nir}\PYG{o}{\PYGZhy{}}\PYG{n}{vis}\PYG{p}{)}\PYG{o}{/}\PYG{p}{(}\PYG{n}{nir}\PYG{o}{+}\PYG{n}{vis}\PYG{p}{)}
\PYG{c}{\PYGZsh{} set negative and ndvi \PYGZgt{} 1 (error) to 0}
\PYG{c}{\PYGZsh{}ndvi[ndvi\PYGZgt{}1] = 0}
\PYG{c}{\PYGZsh{}ndvi[ndvi\PYGZlt{}0] = 0}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{mean\PYGZus{}ndvi} \PYG{o}{=} \PYG{n}{ndvi}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{max\PYGZus{}ndvi} \PYG{o}{=} \PYG{n}{ndvi}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{min\PYGZus{}ndvi} \PYG{o}{=} \PYG{n}{ndvi}\PYG{o}{.}\PYG{n}{min}\PYG{p}{(}\PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{range\PYGZus{}ndvi} \PYG{o}{=} \PYG{n}{max\PYGZus{}ndvi} \PYG{o}{\PYGZhy{}} \PYG{n}{min\PYGZus{}ndvi}
\PYG{n}{std\PYGZus{}ndvi} \PYG{o}{=} \PYG{n}{ndvi}\PYG{o}{.}\PYG{n}{std}\PYG{p}{(}\PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}

\PYG{c}{\PYGZsh{} set up a dictionary}
\PYG{n}{datasets} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{mean NDVI 2009}\PYG{l+s}{\PYGZdq{}}\PYG{p}{:}\PYG{n}{mean\PYGZus{}ndvi}\PYG{p}{,}\PYGZbs{}
            \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{max NDVI 2009}\PYG{l+s}{\PYGZdq{}}\PYG{p}{:}\PYG{n}{max\PYGZus{}ndvi}\PYG{p}{,}\PYGZbs{}
            \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{min NDVI 2009}\PYG{l+s}{\PYGZdq{}}\PYG{p}{:}\PYG{n}{min\PYGZus{}ndvi}\PYG{p}{,}\PYGZbs{}
            \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{NDVI range 2009}\PYG{l+s}{\PYGZdq{}}\PYG{p}{:}\PYG{n}{range\PYGZus{}ndvi}\PYG{p}{,}\PYGZbs{}
            \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{std NDVI 2009}\PYG{l+s}{\PYGZdq{}}\PYG{p}{:}\PYG{n}{std\PYGZus{}ndvi}\PYG{p}{\PYGZcb{}}

\PYG{n}{vmax} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{mean NDVI 2009}\PYG{l+s}{\PYGZdq{}}\PYG{p}{:}\PYG{l+m+mf}{1.0}\PYG{p}{,}\PYGZbs{}
            \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{max NDVI 2009}\PYG{l+s}{\PYGZdq{}}\PYG{p}{:}\PYG{l+m+mf}{1.}\PYG{p}{,}\PYGZbs{}
            \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{min NDVI 2009}\PYG{l+s}{\PYGZdq{}}\PYG{p}{:}\PYG{l+m+mf}{1.}\PYG{p}{,}\PYGZbs{}
            \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{NDVI range 2009}\PYG{l+s}{\PYGZdq{}}\PYG{p}{:}\PYG{l+m+mf}{1.}\PYG{p}{,}\PYGZbs{}
            \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{std NDVI 2009}\PYG{l+s}{\PYGZdq{}}\PYG{p}{:}\PYG{l+m+mf}{0.25}\PYG{p}{\PYGZcb{}}

\PYG{c}{\PYGZsh{} plotting loop}

\PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n}{datasets}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{c}{\PYGZsh{} note the order is not maintained}
    \PYG{c}{\PYGZsh{} from when we set up the dictionary}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{datasets}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYGZbs{}
               \PYG{n}{cmap}\PYG{o}{=}\PYG{n}{plt}\PYG{o}{.}\PYG{n}{get\PYGZus{}cmap}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{YlGn}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}\PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mf}{0.0}\PYG{p}{,}\PYG{n}{vmax}\PYG{o}{=}\PYG{n}{vmax}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\includegraphics{Scientific_Numerical_Python_139_0.png}

\includegraphics{Scientific_Numerical_Python_139_1.png}

\includegraphics{Scientific_Numerical_Python_139_2.png}

\includegraphics{Scientific_Numerical_Python_139_3.png}

\includegraphics{Scientific_Numerical_Python_139_4.png}

The mean and max NDVI is pretty much what you would expect (MODIS NDVI,
Nov-Dec, 2007 shown here):
\begin{figure}[htbp]
\centering
\capstart
\caption{MODIS NDVI, 2007}\end{figure}

but again we see the large variations in NDVI in the Northern
Hemisphere.


\section{3.5 Solar Radiation}
\label{Chapter3_Scientific_Numerical_Python/Scientific_Numerical_Python:solar-radiation}
One common use for albedo data is to calculate the amount of absorbed
solar radiation at the surface.

In this section, we will build a model and dataset of downwelling solar
radiation.

We can build a \emph{simple} model of solar radiation:

Incoming solar radiation, \(A\), ignoring the effect of the
atmosphere, clouds, etc is given by
\begin{gather}
\begin{split}A = E_{0}\sin\theta\end{split}\notag
\end{gather}
where \(E_{0}\) is the solar constant (given as
\(1360Wm^{-2}\)), and \(\theta\) is the \href{http://en.wikipedia.org/wiki/Solar\_elevation\_angle\#Solar\_elevation\_angle}{solar elevation
angle}.
The solar elevation angle is approximately given by
\begin{gather}
\begin{split}\sin \theta = \cos h \cos \delta \cos \varphi + \sin \delta \sin \varphi\end{split}\notag
\end{gather}
where \(h\) is the \href{http://en.wikipedia.org/wiki/Hour\_angle\#Solar\_hour\_angle}{hour
angle},
\(\delta\) is the \href{http://en.wikipedia.org/wiki/Position\_of\_the\_Sun\#Calculations}{solar declination
angle}
and \(\varphi\) is the latitude. The solar declination can be
approximated by
\begin{gather}
\begin{split}\delta = - \arcsin \left [ 0.39779 \cos \left ( 0.98565 \left (N + 10 \right ) + 1.914 \sin \left ( 0.98565 \left ( N - 2 \right ) \right ) \right ) \right ]\end{split}\notag
\end{gather}
where \(N\) is the day of year beginning with N=0 at 00:00:00 UTC on
January 1

We have the latitude associated with the dataset from:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{lat} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{nc}\PYG{o}{.}\PYG{n}{variables}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{lat}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{lat}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlim}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{lat}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylim}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{90}\PYG{p}{,}\PYG{l+m+mi}{90}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{latitude}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{column number}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{latitude}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.text.Text at 0x13e9c650\PYGZgt{}
\end{Verbatim}

\includegraphics{Scientific_Numerical_Python_145_1.png}

for day of year \code{N} then, we have a formula for solar declination.

Approximating \code{N} for each month by an average:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} mean days per month}
\PYG{n}{av\PYGZus{}days} \PYG{o}{=} \PYG{l+m+mf}{365.25} \PYG{o}{/} \PYG{l+m+mf}{12.}
\PYG{n}{half} \PYG{o}{=} \PYG{n}{av\PYGZus{}days}\PYG{o}{/}\PYG{l+m+mf}{2.}
\PYG{n}{N} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{n}{half}\PYG{p}{,}\PYG{l+m+mf}{365.25}\PYG{p}{,}\PYG{n}{av\PYGZus{}days}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{N}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
[  15.21875   45.65625   76.09375  106.53125  136.96875  167.40625
  197.84375  228.28125  258.71875  289.15625  319.59375  350.03125]
\end{Verbatim}

we can approximate the solar declination as:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{t0} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{deg2rad} \PYG{p}{(}\PYG{l+m+mf}{0.98565}\PYG{o}{*}\PYG{p}{(}\PYG{n}{N}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{t1} \PYG{o}{=} \PYG{l+m+mf}{0.39779}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(} \PYG{n}{np}\PYG{o}{.}\PYG{n}{deg2rad} \PYG{p}{(} \PYG{l+m+mf}{0.98565}\PYG{o}{*}\PYG{p}{(}\PYG{n}{N}\PYG{o}{+}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mf}{1.914}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{sin} \PYG{p}{(} \PYG{n}{t0} \PYG{p}{)} \PYG{p}{)} \PYG{p}{)}
\PYG{n}{delta} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{arcsin} \PYG{p}{(} \PYG{n}{t1} \PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{N}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{rad2deg}\PYG{p}{(}\PYG{n}{delta}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{day of year}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{solar declination angle (degrees)}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlim}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mf}{365.25}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{365.25}\PYG{p}{)}
\end{Verbatim}

\includegraphics{Scientific_Numerical_Python_150_1.png}

Although we might think the formulae a little complicated, the
translation from the formula to numpy code is really very clear and
readable. In particular, by having \code{N} as an array object, we are able
to apply the formulae to the array and not have to obfuscate the code
with loops.

Note that the formulae above are given in \emph{degrees}, but trignometric
functions in most programming languages work in \emph{radians}.

In numpy, we can use the functions \code{deg2rad} and \code{rad2deg} to
convert between degrees and radians and \emph{vice-versa} (alternatively,
multiply by \code{np.pi/180.} and \code{180./np.pi} respectively).

The trig functions cosine and sine are \code{cos} and \code{sin} respectively,
and their inverses \code{arccos} and \code{arcsin}.

For our solar energy calculations, we will set the `hour angle' to zero
(this is solar noon), so:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{h} \PYG{o}{=} \PYG{l+m+mf}{0.0}
\end{Verbatim}

To estimate the solar elevation angle then, we need to include the
latitude. At present, we have an array \code{lat} for latitude and \code{N}
for day of year:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{lat:}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{lat}\PYG{o}{.}\PYG{n}{shape}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{N:}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{N}\PYG{o}{.}\PYG{n}{shape}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
lat: (360,)
N: (12,)
\end{Verbatim}

what we need is \code{lat} and \code{N} in the full 3-D array shape
\code{(12,360,720)}.

This involves repeating, which is probably easiest to accomplish with
lists:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{N2} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{n}{N}\PYG{p}{]} \PYG{o}{*} \PYG{n}{data}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]} \PYG{o}{*} \PYG{n}{data}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{N2}\PYG{o}{.}\PYG{n}{shape}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{l+m+mi}{720}\PYG{p}{,} \PYG{l+m+mi}{360}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{)}
\end{Verbatim}

but the list repetition makes the array the `wrong way around' to whjat
we want, so we apply a transpose operation in numpy:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{N2} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{n}{N}\PYG{p}{]} \PYG{o}{*} \PYG{n}{data}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]} \PYG{o}{*} \PYG{n}{data}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{T}
\PYG{k}{print} \PYG{n}{N2}\PYG{o}{.}\PYG{n}{shape}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{360}\PYG{p}{,} \PYG{l+m+mi}{720}\PYG{p}{)}
\end{Verbatim}

Similarly then with \code{lat}, but we have to be a little more careful
with the transpose operations:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{lat2} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{n}{lat}\PYG{p}{]} \PYG{o}{*} \PYG{n}{data}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{T}\PYG{p}{]} \PYG{o}{*} \PYG{n}{data}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{T}
\PYG{k}{print} \PYG{n}{lat2}\PYG{o}{.}\PYG{n}{shape}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{360}\PYG{p}{,} \PYG{l+m+mi}{720}\PYG{p}{)}
\end{Verbatim}

At this point, we might consider it useful to write a \emph{function}.

These are of the form:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{fn\PYGZus{}name}\PYG{p}{(}\PYG{n}{args}\PYG{p}{)}\PYG{p}{:}
    \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
    \PYG{k}{return} \PYG{n}{value}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{declination}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}Calculate solar declination (in degrees)\PYGZsq{}\PYGZsq{}\PYGZsq{}}
    \PYG{n}{t0} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{deg2rad} \PYG{p}{(}\PYG{l+m+mf}{0.98565}\PYG{o}{*}\PYG{p}{(}\PYG{n}{N}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{t1} \PYG{o}{=} \PYG{l+m+mf}{0.39779}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(} \PYG{n}{np}\PYG{o}{.}\PYG{n}{deg2rad} \PYG{p}{(} \PYG{l+m+mf}{0.98565}\PYG{o}{*}\PYG{p}{(}\PYG{n}{N}\PYG{o}{+}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mf}{1.914}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{sin} \PYG{p}{(} \PYG{n}{t0} \PYG{p}{)} \PYG{p}{)} \PYG{p}{)}
    \PYG{n}{delta} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{arcsin} \PYG{p}{(} \PYG{n}{t1} \PYG{p}{)}
    \PYG{k}{return} \PYG{n}{np}\PYG{o}{.}\PYG{n}{rad2deg}\PYG{p}{(}\PYG{n}{delta}\PYG{p}{)}


\PYG{k}{def} \PYG{n+nf}{solar\PYGZus{}elevation}\PYG{p}{(}\PYG{n}{delta}\PYG{p}{,}\PYG{n}{h}\PYG{p}{,}\PYG{n}{lat}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}solar elevation in degrees\PYGZsq{}\PYGZsq{}\PYGZsq{}}
    \PYG{n}{lat} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{deg2rad}\PYG{p}{(}\PYG{n}{lat}\PYG{p}{)}
    \PYG{n}{delta} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{deg2rad}\PYG{p}{(}\PYG{n}{delta}\PYG{p}{)}
    \PYG{n}{h} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{deg2rad}\PYG{p}{(}\PYG{n}{h}\PYG{p}{)}
    \PYG{n}{sin\PYGZus{}theta} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{cos} \PYG{p}{(}\PYG{n}{h}\PYG{p}{)}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{cos} \PYG{p}{(}\PYG{n}{delta}\PYG{p}{)}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{n}{lat}\PYG{p}{)} \PYG{o}{+} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sin} \PYG{p}{(} \PYG{n}{delta}\PYG{p}{)}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{n}{lat}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{np}\PYG{o}{.}\PYG{n}{rad2deg}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{arcsin}\PYG{p}{(}\PYG{n}{sin\PYGZus{}theta}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} create numpy arrays of the right shape}

\PYG{n}{N2} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{n}{N}\PYG{p}{]} \PYG{o}{*} \PYG{n}{data}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]} \PYG{o}{*} \PYG{n}{data}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{T}
\PYG{n}{lat2} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{n}{lat}\PYG{p}{]} \PYG{o}{*} \PYG{n}{data}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{T}\PYG{p}{]} \PYG{o}{*} \PYG{n}{data}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{T}

\PYG{c}{\PYGZsh{} zeros\PYGZus{}like creates array of the same shape as N2 here}
\PYG{c}{\PYGZsh{} filled with zeros. Similarly ones\PYGZus{}like}
\PYG{n}{h2} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros\PYGZus{}like}\PYG{p}{(}\PYG{n}{N2}\PYG{p}{)} \PYG{o}{+} \PYG{n}{h}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} now put these things together}

\PYG{c}{\PYGZsh{} copy the arrays, so we don\PYGZsq{}t overwrite the data}

\PYG{n}{delta} \PYG{o}{=} \PYG{n}{declination}\PYG{p}{(}\PYG{n}{N2}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{e0} \PYG{o}{=} \PYG{l+m+mf}{1360.}
\PYG{n}{sea} \PYG{o}{=} \PYG{n}{solar\PYGZus{}elevation}\PYG{p}{(}\PYG{n}{delta}\PYG{p}{,}\PYG{n}{h2}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{lat2}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{sin\PYGZus{}theta} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{deg2rad}\PYG{p}{(}\PYG{n}{sea}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{rad} \PYG{o}{=} \PYG{n}{e0}\PYG{o}{*}\PYG{n}{sin\PYGZus{}theta}
\PYG{c}{\PYGZsh{} threshold at zero}
\PYG{n}{rad}\PYG{p}{[}\PYG{n}{rad} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{0.0}

\PYG{n}{incoming\PYGZus{}rad} \PYG{o}{=} \PYG{n}{rad}
\PYG{c}{\PYGZsh{} now mask this with data mask}
\PYG{n}{rad} \PYG{o}{=} \PYG{n}{ma}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{incoming\PYGZus{}rad}\PYG{p}{,}\PYG{n}{mask}\PYG{o}{=}\PYG{n}{data}\PYG{o}{.}\PYG{n}{mask}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} plot to visualise the data and see it looks reasonable}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Jan}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{rad}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{cmap}\PYG{o}{=}\PYG{n}{plt}\PYG{o}{.}\PYG{n}{get\PYGZus{}cmap}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{jet}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Jun}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{rad}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{cmap}\PYG{o}{=}\PYG{n}{plt}\PYG{o}{.}\PYG{n}{get\PYGZus{}cmap}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{jet}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.colorbar.Colorbar instance at 0x13aad6c8\PYGZgt{}
\end{Verbatim}

\includegraphics{Scientific_Numerical_Python_169_1.png}

\includegraphics{Scientific_Numerical_Python_169_2.png}

This sort of application really shows the power of manipulating arrays.


\section{E3.5 Exercise: Solar Radiation Code: A chance for you to get feedback}
\label{Chapter3_Scientific_Numerical_Python/Scientific_Numerical_Python:e3-5-exercise-solar-radiation-code-a-chance-for-you-to-get-feedback}
In the section above, we have developed some code to estimate solar
radiation and we have packaged some of it into functions.

\textbf{In a file called {}`{}`files/python/solar.py{}`{}`, develop some Python code
that will}
\begin{enumerate}
\item {} 
Read GlobAlbedo data \code{DHR\_SW} (shortwave directional-hemispherical
reflectance) into a masked array \code{data}

\item {} 
Generate a spatial Solar Radiation dataset \code{rad} of the same shape
as \code{data}

\item {} 
Calculate the amount of solar radiation \emph{absorbed} at the surface (W
m\textasciicircum{}-2)

\item {} 
Calculate the \emph{latitudinal total} absorbed radiation for each month
(W m\textasciicircum{}-2)

\item {} 
Calculate the \emph{global total} absorbed radiation power for each month
(W)

\end{enumerate}

Where appropriate, produce images, graphs and/or movies of your results.

Comment on the patterns of absorbed solar radiation that you see.

All of your code should be commented as well as possible.

It should indicate which parts of the code you have simply taken from
the material above and which parts you have developed yourself.

If possible, use an \code{ipython} notebook to illustrate your code and its
operation. As a miniumum, submit your code and examples of its output.

If possible, wrap your codes into functions to group things that belong
together together.

You will probably want to save the arrays you generated (\code{np.savez})
so that you can show your results later.

Hints:
\begin{itemize}
\item {} 
\emph{All} of the code you need for parts 1. and 2. can be found in the
material above ... you just need to put it together

\item {} 
Recall that albedo is the proportion of radiation \emph{reflected}.

\item {} 
Recall that in a lat/long projection the area represented by each
pixel varies as a function of latitude.

\end{itemize}

We will \emph{not} release model answers for this exercise at present.

Instead, we would like you to complete this exercise over the coming
week and submit it by the following Monday morning. If you do this,
there will be sessions run in (extended) office hours (9-12 Monday, 9-12
Tuesday, 9-10 Wednesday) when you will bve given feedback on your
submission. To get the most out of these feedback sessions, it would be
adviseable to request a time slot (You should be getting a doodle poll
email to that effect)

We \emph{strongly} recommend that you attempt this exercise on your own.
Given the amount of material you are given here, this should be
achievable for all of you.

This work does \emph{not} form part of your formal assessment. Instead it is
intended to provide you with an opportunity for feedback on how you are
getting on in the course at an early stage. So, you are \emph{not} required
to do this. If you do not though, we cannot give yuou feedback.

Come along to the feedback session prepared to \emph{explain} how your code
operates and how to run it (one reason why a notebook would be useful if
you can manage that).


\section{3.6 Saving and loading numpy data}
\label{Chapter3_Scientific_Numerical_Python/Scientific_Numerical_Python:saving-and-loading-numpy-data}
When we have gone to lots of effort (well, lots of processing time) to
do some calculation, we probably want to save the result.

In numpy, we can save one or more numpy arrays (and similar data types)
with \code{np.savez()}.

So, e.g. to save the arrays \code{data} and \code{rad}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}
\PYG{c}{\PYGZsh{} there is a problem saving masked arrays at the moment,}
\PYG{c}{\PYGZsh{} so convert and save the mask}
\PYG{n}{np}\PYG{o}{.}\PYG{n}{savez}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/solar\PYGZus{}rad\PYGZus{}data.npz}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYGZbs{}
         \PYG{n}{rad}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{rad}\PYG{p}{)}\PYG{p}{,}\PYG{n}{data}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}\PYG{p}{,}\PYG{n}{mask}\PYG{o}{=}\PYG{n}{data}\PYG{o}{.}\PYG{n}{mask}\PYG{p}{)}
\end{Verbatim}

To load this again use \code{np.load}, which returns a dictionary:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{f} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{load}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/solar\PYGZus{}rad\PYGZus{}data.npz}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{data} \PYG{o}{=} \PYG{n}{ma}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{f}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{data}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{mask}\PYG{o}{=}\PYG{n}{f}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{mask}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{rad}  \PYG{o}{=} \PYG{n}{ma}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{f}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{rad}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{mask}\PYG{o}{=}\PYG{n}{f}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{mask}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

As an aside here, we note that numpy also has convenient functions for
loading ASCII text (which is much simplerto use than the methods we
learned last session, but you need to know how to do it from scratch if
the data format is very awkward).

That said, we can deal with some awkward issues in a dataset:

\begin{Verbatim}[commandchars=\\\{\}]
!head \PYGZhy{}15 \PYGZlt{} files/data/heathrowdata.txt
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
Heathrow (London Airport)
Location 5078E 1767N 25m amsl
Estimated data is marked with a * after the value.
Missing data (more than 2 days missing in month) is marked by  \PYGZhy{}\PYGZhy{}\PYGZhy{}.
Sunshine data taken from an automatic Kipp \PYGZam{} Zonen sensor marked with a \PYGZsh{}, otherwise sunshine data taken from a Campbell Stokes recorder.
   yyyy  mm   tmax    tmin      af    rain     sun
              degC    degC    days      mm   hours
   1948   1    8.9     3.3    \PYGZhy{}\PYGZhy{}\PYGZhy{}     85.0    \PYGZhy{}\PYGZhy{}\PYGZhy{}
   1948   2    7.9     2.2    \PYGZhy{}\PYGZhy{}\PYGZhy{}     26.0    \PYGZhy{}\PYGZhy{}\PYGZhy{}
   1948   3   14.2     3.8    \PYGZhy{}\PYGZhy{}\PYGZhy{}     14.0    \PYGZhy{}\PYGZhy{}\PYGZhy{}
   1948   4   15.4     5.1    \PYGZhy{}\PYGZhy{}\PYGZhy{}     35.0    \PYGZhy{}\PYGZhy{}\PYGZhy{}
   1948   5   18.1     6.9    \PYGZhy{}\PYGZhy{}\PYGZhy{}     57.0    \PYGZhy{}\PYGZhy{}\PYGZhy{}
   1948   6   19.1    10.3    \PYGZhy{}\PYGZhy{}\PYGZhy{}     67.0    \PYGZhy{}\PYGZhy{}\PYGZhy{}
   1948   7   21.7    12.0    \PYGZhy{}\PYGZhy{}\PYGZhy{}     21.0    \PYGZhy{}\PYGZhy{}\PYGZhy{}
   1948   8   20.8    11.7    \PYGZhy{}\PYGZhy{}\PYGZhy{}     67.0    \PYGZhy{}\PYGZhy{}\PYGZhy{}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} read sun hours from the heathrow data file}

\PYG{n}{filename} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/heathrowdata.txt}\PYG{l+s}{\PYGZsq{}}

\PYG{c}{\PYGZsh{} In this dataset, we need to know what}
\PYG{c}{\PYGZsh{} to do when we get \PYGZsq{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZsq{} in the dataset}
\PYG{c}{\PYGZsh{} so we set up a}
\PYG{c}{\PYGZsh{} translation dictionary}
\PYG{k}{def} \PYG{n+nf}{awkward}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{x} \PYG{o}{==} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZhy{}\PYGZhy{}\PYGZhy{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}
        \PYG{k}{return} \PYG{n}{np}\PYG{o}{.}\PYG{n}{nan}
    \PYG{k}{return} \PYG{n}{x}

\PYG{n}{trans} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{6}\PYG{p}{:} \PYG{n}{awkward}\PYG{p}{\PYGZcb{}}

\PYG{c}{\PYGZsh{} skip the first 7 rows}
\PYG{c}{\PYGZsh{} use the awkward translation for column 6}
\PYG{c}{\PYGZsh{} unpack gets the shape the right way around}
\PYG{n}{sun\PYGZus{}hrs} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{loadtxt}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{,}\PYG{n}{skiprows}\PYG{o}{=}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{n}{usecols}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{,}\PYG{n}{converters}\PYG{o}{=}\PYG{n}{trans}\PYG{p}{,}\PYG{n}{unpack}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}

\PYG{k}{print} \PYG{n}{sun\PYGZus{}hrs}\PYG{o}{.}\PYG{n}{shape}
\PYG{c}{\PYGZsh{} plot decimal year and sun hours}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{sun\PYGZus{}hrs}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{+}\PYG{n}{sun\PYGZus{}hrs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{/}\PYG{l+m+mf}{12.}\PYG{p}{,}\PYG{n}{sun\PYGZus{}hrs}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
\PYG{c}{\PYGZsh{} zoom in to 1970 to 1990}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlim}\PYG{p}{(}\PYG{l+m+mi}{1970}\PYG{p}{,}\PYG{l+m+mi}{1990}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{785}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{l+m+mi}{1970}\PYG{p}{,} \PYG{l+m+mi}{1990}\PYG{p}{)}
\end{Verbatim}

\includegraphics{Scientific_Numerical_Python_182_2.png}

We can save this to a text file with:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{header} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{year month sun\PYGZus{}hours}\PYG{l+s}{\PYGZsq{}}
\PYG{c}{\PYGZsh{} note, we transpose it if we want the data as columns}
\PYG{n}{np}\PYG{o}{.}\PYG{n}{savetxt}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/sunshine.txt}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{sun\PYGZus{}hrs}\PYG{o}{.}\PYG{n}{T}\PYG{p}{,}\PYG{n}{header}\PYG{o}{=}\PYG{n}{header}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
!head \PYGZhy{}10 \PYGZlt{} files/data/sunshine.txt
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{} year month sun\PYGZus{}hours
1.948000000000000000e+03 1.000000000000000000e+00 nan
1.948000000000000000e+03 2.000000000000000000e+00 nan
1.948000000000000000e+03 3.000000000000000000e+00 nan
1.948000000000000000e+03 4.000000000000000000e+00 nan
1.948000000000000000e+03 5.000000000000000000e+00 nan
1.948000000000000000e+03 6.000000000000000000e+00 nan
1.948000000000000000e+03 7.000000000000000000e+00 nan
1.948000000000000000e+03 8.000000000000000000e+00 nan
1.948000000000000000e+03 9.000000000000000000e+00 nan
\end{Verbatim}


\section{E3.6 Exercise: awkward reading}
\label{Chapter3_Scientific_Numerical_Python/Scientific_Numerical_Python:e3-6-exercise-awkward-reading}
The file \code{files/data/elevation.dat} look like:

\begin{Verbatim}[commandchars=\\\{\}]
!head \PYGZhy{}10 \PYGZlt{} files/data/elevation.dat
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
2013/10/8 00:00:00 \PYGZhy{}44.2719952943
2013/10/8 00:30:00 \PYGZhy{}43.5276412785
2013/10/8 00:59:59 \PYGZhy{}41.9842746582
2013/10/8 01:30:00 \PYGZhy{}39.7226999863
2013/10/8 02:00:00 \PYGZhy{}36.8452198361
2013/10/8 02:30:00 \PYGZhy{}33.459799008
2013/10/8 03:00:00 \PYGZhy{}29.6691191507
2013/10/8 03:30:00 \PYGZhy{}25.5652187709
2013/10/8 03:59:59 \PYGZhy{}21.2281801291
2013/10/8 04:30:00 \PYGZhy{}16.7272357302
\end{Verbatim}

\textbf{Write some code to read these data in using np.loadtxt}

Hint: You will need to write a function that decodes column 0 and 1, for
example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{col0}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{:}
    \PYG{c}{\PYGZsh{} interpret column 1 as a sort of}
    \PYG{c}{\PYGZsh{} decimal year}
    \PYG{c}{\PYGZsh{} NB this is very rough ...}
    \PYG{c}{\PYGZsh{} not all months have 30 days ...}
    \PYG{n}{y}\PYG{p}{,}\PYG{n}{m}\PYG{p}{,}\PYG{n}{d} \PYG{o}{=} \PYG{n}{x}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{dec\PYGZus{}year} \PYG{o}{=} \PYG{n}{y} \PYG{o}{+} \PYG{p}{(}\PYG{n}{m}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mf}{12.} \PYG{o}{+} \PYG{p}{(}\PYG{n}{d}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mf}{30.}
    \PYG{k}{return} \PYG{n}{dec\PYGZus{}year}

\PYG{c}{\PYGZsh{} translation ... just for column 1 here}
\PYG{c}{\PYGZsh{} you\PYGZsq{}d need to define your own for column 2}
\PYG{n}{trans} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{0} \PYG{p}{:} \PYG{n}{col0}\PYG{p}{\PYGZcb{}}
\end{Verbatim}


\section{Advanced and Answers}
\label{Chapter3_Scientific_Numerical_Python/Scientific_Numerical_Python:advanced-and-answers}
If you feel comfortable with the contents of this session, or simply
would like something a little more challenging, examine the notes in the
advanced section.

Answers for the exercises in this session are
available, as are the answers for the advanced
section.


\chapter{Chapter 4. Geospatial data}
\label{Chapter4_GDAL/GDAL_HDF:chapter-4-geospatial-data}\label{Chapter4_GDAL/GDAL_HDF::doc}
In this session, we will introduced the \code{gdal} geospatial module which
can read a wide range of scientific data formats. You will find that
using it to read data is quite similar to the work we did last week on
netCDF datasets.

The main challenges are also much the same: very often, you need to be
able to read data from a `stack' of image files and generate a useful 3D
(space and time) dataset from these. Once you have the data in such a
form, there are \emph{many} things we can do with it, and very many of these
are convenient to do using array-based expressions such as in numpy
(consider the simplicity of the expression
\code{absorbed = rad * (1 - albedo)} from last week's exercise).

That said, it can sometimes be quite an effort to prepare datasets in
this form. Last week, we developed a `valid data' mask from the
GlobAlbedo dataset, as invalid data were stored as \code{nan}. Very often
though, scientific datasets have more complex `Quality Control' (QC)
information, that gives per-pixel information describing the quality of
the product at that location (e.g. it was very cloudy so the results are
not so good).

To explore this, we will first consider the \href{http://modis.gsfc.nasa.gov/data/dataprod/dataproducts.php?MOD\_NUMBER=15}{MODIS Leaf Area Index
(LAI)}
product taht is mapped at 1 km resolution, every 8 days from the year
2000.

We will learn how to read in these data (in \code{hdf} format) using
\code{gdal}, and how to interpret the QC information in such products to
produce valid data masks. As an exercise, you will wrap some code around
that to form a 3D masked array of the dataset.

Next, we will consider how to download such data. This should be a
reinforcement of material from last week, but it is useful to know how
to conveniently access NASA data products. A challenge in the exercise
then is to download a different dataset (MODIS snow cover) for the UK,
and form a masked 3D dataset from this.

Finally, we will introduce vector datasets and show you python tools
that allow you (among many other things) to build a mask in the
projection and sampling of your spatial dataset (MODIS LAI in this
case).

There are many features and as many complexities to the Python tools we
will deal with today, but in this material, we cover some very typical
tasks you will want to do. They all revolve around generating masked 3D
datasets from NASA MODIS datasets, which is a very useful form of global
biophysical information over the last decade+. We also provide much
material for further reading and use when you are more confident in your
programming.

A final point here is that the material we cover today is very closely
related to what you will need to do in the first section of your
assessed practical that we will introduce next week, so you really need
to get to grips with this now.

There is not as much `new' material as in previous weeks now, but we
assume that you have understood, and can make use of, material from
those lectures.

First, we will examine data from a NASA MODIS product on Leaf Area Index
(LAI).
\begin{itemize}
\item {} 
4.1 {\hyperref[Chapter4_GDAL/GDAL_HDF:4.1-MODIS-LAI-product]{MODIS LAI product}}

\item {} 
4.2 {\hyperref[Chapter4_GDAL/GDAL_HDF:4.2-Downloading-data]{Downloading data}}

\item {} 
4.3 {\hyperref[Chapter4_GDAL/GDAL_HDF:4.3-Vector-masking]{Vector masking}}

\end{itemize}


\section{4.1 MODIS LAI product}
\label{Chapter4_GDAL/GDAL_HDF:modis-lai-product}
GDAL covers a much wider set of file formats and methods than the netCDF
library that we previously used.

Basic operation involves:
\begin{itemize}
\item {} 
load gdal

\item {} 
open a spatial dataset (an hdf format file here)

\item {} 
specify which subsets you want.

\end{itemize}

We can explore the subsets in the file with \code{GetSubDatasets()}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} how to find out which datasets are in the file}

\PYG{k+kn}{import} \PYG{n+nn}{gdal} \PYG{c}{\PYGZsh{} Import GDAL library bindings}

\PYG{c}{\PYGZsh{} The file that we shall be using}
\PYG{c}{\PYGZsh{} Needs to be on current directory}
\PYG{n}{filename} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MCD15A2.A2011185.h09v05.005.2011213154534.hdf}\PYG{l+s}{\PYGZsq{}}

\PYG{n}{g} \PYG{o}{=} \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{Open}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{)}
\PYG{c}{\PYGZsh{} g should now be a GDAL dataset, but if the file isn\PYGZsq{}t found}
\PYG{c}{\PYGZsh{} g will be none. Let\PYGZsq{}s test this:}
\PYG{k}{if} \PYG{n}{g} \PYG{o+ow}{is} \PYG{n+nb+bp}{None}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Problem opening file }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{!}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n}{filename}
\PYG{k}{else}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{File }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{ opened fine}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n}{filename}


\PYG{n}{subdatasets} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{GetSubDatasets}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{fname}\PYG{p}{,} \PYG{n}{name} \PYG{o+ow}{in} \PYG{n}{subdatasets}\PYG{p}{:}
    \PYG{k}{print} \PYG{n}{name}
    \PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{fname}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
File files/data/MCD15A2.A2011185.h09v05.005.2011213154534.hdf opened fine
[1200x1200] Fpar\PYGZus{}1km MOD\PYGZus{}Grid\PYGZus{}MOD15A2 (8\PYGZhy{}bit unsigned integer)
    HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:\PYGZdq{}files/data/MCD15A2.A2011185.h09v05.005.2011213154534.hdf\PYGZdq{}:MOD\PYGZus{}Grid\PYGZus{}MOD15A2:Fpar\PYGZus{}1km
[1200x1200] Lai\PYGZus{}1km MOD\PYGZus{}Grid\PYGZus{}MOD15A2 (8\PYGZhy{}bit unsigned integer)
    HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:\PYGZdq{}files/data/MCD15A2.A2011185.h09v05.005.2011213154534.hdf\PYGZdq{}:MOD\PYGZus{}Grid\PYGZus{}MOD15A2:Lai\PYGZus{}1km
[1200x1200] FparLai\PYGZus{}QC MOD\PYGZus{}Grid\PYGZus{}MOD15A2 (8\PYGZhy{}bit unsigned integer)
    HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:\PYGZdq{}files/data/MCD15A2.A2011185.h09v05.005.2011213154534.hdf\PYGZdq{}:MOD\PYGZus{}Grid\PYGZus{}MOD15A2:FparLai\PYGZus{}QC
[1200x1200] FparExtra\PYGZus{}QC MOD\PYGZus{}Grid\PYGZus{}MOD15A2 (8\PYGZhy{}bit unsigned integer)
    HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:\PYGZdq{}files/data/MCD15A2.A2011185.h09v05.005.2011213154534.hdf\PYGZdq{}:MOD\PYGZus{}Grid\PYGZus{}MOD15A2:FparExtra\PYGZus{}QC
[1200x1200] FparStdDev\PYGZus{}1km MOD\PYGZus{}Grid\PYGZus{}MOD15A2 (8\PYGZhy{}bit unsigned integer)
    HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:\PYGZdq{}files/data/MCD15A2.A2011185.h09v05.005.2011213154534.hdf\PYGZdq{}:MOD\PYGZus{}Grid\PYGZus{}MOD15A2:FparStdDev\PYGZus{}1km
[1200x1200] LaiStdDev\PYGZus{}1km MOD\PYGZus{}Grid\PYGZus{}MOD15A2 (8\PYGZhy{}bit unsigned integer)
    HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:\PYGZdq{}files/data/MCD15A2.A2011185.h09v05.005.2011213154534.hdf\PYGZdq{}:MOD\PYGZus{}Grid\PYGZus{}MOD15A2:LaiStdDev\PYGZus{}1km
\end{Verbatim}

In the previous code snippet we have done a number of different things:
\begin{enumerate}
\item {} 
Import the GDAL library

\item {} 
Open a file with GDAL, storing a handler to the file in \code{g}

\item {} 
Test that \code{g} is not \code{None} (as this indicates failure opening
the file. Try changing \code{filename} above to something else)

\item {} 
We then use the \code{GetSubDatasets()} method to read out information
on the different subdatasets available from this file (compare to the
output of \code{gdalinfo} on the shelf earlier)

\item {} 
Loop over the retrieved subdatasets to print the name (human-readable
information) and the GDAL filename. This last item is the filename
that you need to use to tell GDAL to open a particular data layer of
the 6 layers present in this example

\end{enumerate}

Let's say that we want to access the LAI information. By contrasting the
output of the above code (or \code{gdalinfo}) to the contents of the
\href{https://lpdaac.usgs.gov/products/modis\_products\_table/leaf\_area\_index\_fraction\_of\_photosynthetically\_active\_radiation/8\_day\_l4\_global\_1km/mod15a2}{LAI/fAPAR product information
page},
we find out that we want the layers for \code{Lai\_1km}, \code{FparLai\_Qc},
\code{FparExtra\_QC} and \code{LaiStdDev\_1km}.

To read these individual datasets, we need to open each of them
individually using GDAL, and the GDAL filenames used above:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} How to access specific datasets in gdal}

\PYG{c}{\PYGZsh{} Let\PYGZsq{}s create a list with the selected layer names}
\PYG{n}{selected\PYGZus{}layers} \PYG{o}{=} \PYG{p}{[}  \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{FparLai\PYGZus{}QC}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{LaiStdDev\PYGZus{}1km}\PYG{l+s}{\PYGZdq{}} \PYG{p}{]}

\PYG{c}{\PYGZsh{} We will store the data in a dictionary}
\PYG{c}{\PYGZsh{} Initialise an empty dictionary}
\PYG{n}{data} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}

\PYG{c}{\PYGZsh{} for convenience, we will use string substitution to create a}
\PYG{c}{\PYGZsh{} template for GDAL filenames, which we\PYGZsq{}ll substitute on the fly:}
\PYG{n}{file\PYGZus{}template} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{:MOD\PYGZus{}Grid\PYGZus{}MOD15A2:}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZsq{}}
\PYG{c}{\PYGZsh{} This has two substitutions (the \PYGZpc{}s parts) which will refer to:}
\PYG{c}{\PYGZsh{}\PYGZhy{} the filename}
\PYG{c}{\PYGZsh{} \PYGZhy{} the data layer}

\PYG{k}{for} \PYG{n}{i}\PYG{p}{,} \PYG{n}{layer} \PYG{o+ow}{in} \PYG{n+nb}{enumerate} \PYG{p}{(} \PYG{n}{selected\PYGZus{}layers} \PYG{p}{)}\PYG{p}{:}
    \PYG{n}{this\PYGZus{}file} \PYG{o}{=} \PYG{n}{file\PYGZus{}template} \PYG{o}{\PYGZpc{}} \PYG{p}{(} \PYG{n}{filename}\PYG{p}{,} \PYG{n}{layer} \PYG{p}{)}
    \PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Opening Layer }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{: }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{this\PYGZus{}file} \PYG{p}{)}
    \PYG{n}{g} \PYG{o}{=} \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{Open} \PYG{p}{(} \PYG{n}{this\PYGZus{}file} \PYG{p}{)}

    \PYG{k}{if} \PYG{n}{g} \PYG{o+ow}{is} \PYG{n+nb+bp}{None}\PYG{p}{:}
        \PYG{k}{raise} \PYG{n+ne}{IOError}
    \PYG{n}{data}\PYG{p}{[}\PYG{n}{layer}\PYG{p}{]} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{ReadAsArray}\PYG{p}{(}\PYG{p}{)}
    \PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZgt{}\PYGZgt{}\PYGZgt{} Read }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{!}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n}{layer}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
Opening Layer 1: HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:\PYGZdq{}files/data/MCD15A2.A2011185.h09v05.005.2011213154534.hdf\PYGZdq{}:MOD\PYGZus{}Grid\PYGZus{}MOD15A2:Lai\PYGZus{}1km
    \PYGZgt{}\PYGZgt{}\PYGZgt{} Read Lai\PYGZus{}1km!
Opening Layer 2: HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:\PYGZdq{}files/data/MCD15A2.A2011185.h09v05.005.2011213154534.hdf\PYGZdq{}:MOD\PYGZus{}Grid\PYGZus{}MOD15A2:FparLai\PYGZus{}QC
    \PYGZgt{}\PYGZgt{}\PYGZgt{} Read FparLai\PYGZus{}QC!
Opening Layer 3: HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:\PYGZdq{}files/data/MCD15A2.A2011185.h09v05.005.2011213154534.hdf\PYGZdq{}:MOD\PYGZus{}Grid\PYGZus{}MOD15A2:LaiStdDev\PYGZus{}1km
    \PYGZgt{}\PYGZgt{}\PYGZgt{} Read LaiStdDev\PYGZus{}1km!
\end{Verbatim}

In the previous code, we have seen a way of neatly creating the
filenames required by GDAL to access the independent datasets: a
template string that gets substituted with the \code{filename} and the
\code{layer} name. Note that the presence of double quotes in the template
requires us to use single quotes around it. The data is now stored in a
dictionary, and can be accessed as e.g. \code{data{[}'Lai\_1km'{]}} which is a
numpy array:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{numpy}\PYG{o}{.}\PYG{n}{ndarray}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
[[ 3  3  2 ...,  6  8 21]
 [ 4  3  6 ...,  8 18 14]
 [ 3 12 11 ..., 12  8  8]
 ...,
 [ 2  3  2 ..., 18 11 17]
 [ 2  3  3 ..., 16 19 15]
 [ 3  2  2 ..., 15 16 15]]
\end{Verbatim}

Now we have to translate the LAI values into meaningful quantities.
According to the
\href{https://lpdaac.usgs.gov/products/modis\_products\_table/leaf\_area\_index\_fraction\_of\_photosynthetically\_active\_radiation/8\_day\_l4\_global\_1km/mod15a2}{LAI}
webpage, there is a scale factor of 0.1 involved for LAI and SD LAI:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{lai} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{*} \PYG{l+m+mf}{0.1}
\PYG{n}{lai\PYGZus{}sd} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{LaiStdDev\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{*} \PYG{l+m+mf}{0.1}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{LAI}\PYG{l+s}{\PYGZdq{}}
\PYG{k}{print} \PYG{n}{lai}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{SD}\PYG{l+s}{\PYGZdq{}}
\PYG{k}{print} \PYG{n}{lai\PYGZus{}sd}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
LAI
[[ 0.3  0.3  0.2 ...,  0.6  0.8  2.1]
 [ 0.4  0.3  0.6 ...,  0.8  1.8  1.4]
 [ 0.3  1.2  1.1 ...,  1.2  0.8  0.8]
 ...,
 [ 0.2  0.3  0.2 ...,  1.8  1.1  1.7]
 [ 0.2  0.3  0.3 ...,  1.6  1.9  1.5]
 [ 0.3  0.2  0.2 ...,  1.5  1.6  1.5]]
SD
[[ 0.2  0.2  0.1 ...,  0.2  0.1  0.3]
 [ 0.2  0.2  0.2 ...,  0.2  0.3  0.2]
 [ 0.   0.1  0.2 ...,  0.1  0.2  0.2]
 ...,
 [ 0.1  0.1  0.1 ...,  0.3  0.   0.1]
 [ 0.1  0.1  0.1 ...,  0.2  0.2  0.1]
 [ 0.1  0.1  0.1 ...,  0.1  0.2  0.1]]
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} plot the LAI}

\PYG{k+kn}{import} \PYG{n+nn}{pylab} \PYG{k+kn}{as} \PYG{n+nn}{plt}

\PYG{c}{\PYGZsh{} colormap}
\PYG{n}{cmap} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{cm}\PYG{o}{.}\PYG{n}{Greens}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{lai}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mf}{0.1}\PYG{p}{,}\PYG{n}{vmax}\PYG{o}{=}\PYG{l+m+mf}{4.}\PYG{p}{,}\PYG{n}{cmap}\PYG{o}{=}\PYG{n}{cmap}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MODIS LAI data: DOY 185 2011}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.colorbar.Colorbar instance at 0x2adc680e1830\PYGZgt{}
\end{Verbatim}

\includegraphics{GDAL_HDF_13_1.png}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} plot the LAI std}

\PYG{k+kn}{import} \PYG{n+nn}{pylab} \PYG{k+kn}{as} \PYG{n+nn}{plt}

\PYG{c}{\PYGZsh{} colormap}
\PYG{n}{cmap} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{cm}\PYG{o}{.}\PYG{n}{spectral}
\PYG{c}{\PYGZsh{} this sets the no data colour. \PYGZsq{}k\PYGZsq{} is black}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{lai\PYGZus{}sd}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{vmax}\PYG{o}{=}\PYG{l+m+mf}{1.}\PYG{p}{,}\PYG{n}{cmap}\PYG{o}{=}\PYG{n}{cmap}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MODIS LAI STD data: DOY 185 2011}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.colorbar.Colorbar instance at 0x2adc6954c098\PYGZgt{}
\end{Verbatim}

\includegraphics{GDAL_HDF_14_1.png}

It is not possible to produce LAI estimates if it is persistently
cloudy, so the dataset may contain some gaps.

These are identified in the dataset using the QC (Quality Control)
information.

We should then examine this.

The codes for this are also given on the LAI product page. They are
described as bit combinations:

Bit No.

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}th\PYGZgt{}Parameter Name\PYGZlt{}/th\PYGZgt{}\PYGZlt{}th\PYGZgt{} Bit Combination\PYGZlt{}/th\PYGZgt{}\PYGZlt{}th\PYGZgt{}Explanation\PYGZlt{}/th\PYGZgt{}
\end{Verbatim}

0

MODLAND\_QC bits

0

Good quality (main algorithm with or without saturation)

1

Other Quality (back-up algorithm or fill values)

1

Sensor

\begin{Verbatim}[commandchars=\\\{\}]
0\PYGZlt{}/td\PYGZgt{}\PYGZlt{}td\PYGZgt{}  TERRA\PYGZlt{}/td\PYGZgt{}
\end{Verbatim}

1

AQUA

2

DeadDetector

0

Detectors apparently fine for up to 50\% of channels 1 2

1

Dead detectors caused \textgreater{}50\% adjacent detector retrieval

3-4

CloudState

00

Significant clouds NOT present (clear)

01

Significant clouds WERE present

10

Mixed clouds present on pixel

11

Cloud state not defined assumed clear

5-7

CF\_QC

000

\begin{Verbatim}[commandchars=\\\{\}]
Main (RT) method used   best result possible (no saturation)     \PYGZlt{}/td\PYGZgt{}
\end{Verbatim}

001

Main (RT) method used with saturation. Good very usable

010

Main (RT) method failed due to bad geometry empirical algorithm used

011

Main (RT) method failed due to problems other than geometry empirical
algorithm used

100

Pixel not produced at all value coudnt be retrieved (possible reasons:
bad L1B data unusable MODAGAGG data)

In using this information, it is up to the use which data he/she wants
to pass through for any further processing. There are clearly
trade-offs: if you look for only the highest quality data, then the
number of samples is likely to be lower than if you were more tolerant.
But if you are too tolerant, you will get spurious results. You may find
useful information on how to convert from actual QA flags to diagnostics
in \href{http://gis.cri.fmach.it/modis-ndvi-evi/}{this page} (they focus
on NDVI/EVI, but the theory is the same).

But let's just say that we want to use only the highest quality data.

This means we want bit 0 to be 0 ...

Let's have a look at the QC data:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{qc} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{FparLai\PYGZus{}QC}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]} \PYG{c}{\PYGZsh{} Get the QC data which is an unsigned 8 bit byte}
\PYG{k}{print} \PYG{n}{qc} \PYG{p}{,} \PYG{n}{qc}\PYG{o}{.}\PYG{n}{dtype}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
[[2 2 0 ..., 0 2 2]
[2 2 0 ..., 2 0 2]
[0 2 0 ..., 0 0 0]
...,
[0 0 2 ..., 0 8 0]
[0 0 0 ..., 0 0 2]
[0 2 0 ..., 2 2 2]] uint8
\end{Verbatim}

We see various byte values:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{np}\PYG{o}{.}\PYG{n}{unique}\PYG{p}{(}\PYG{n}{qc}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}  \PYG{l+m+mi}{0}\PYG{p}{,}   \PYG{l+m+mi}{2}\PYG{p}{,}   \PYG{l+m+mi}{8}\PYG{p}{,}  \PYG{l+m+mi}{10}\PYG{p}{,}  \PYG{l+m+mi}{16}\PYG{p}{,}  \PYG{l+m+mi}{18}\PYG{p}{,}  \PYG{l+m+mi}{32}\PYG{p}{,}  \PYG{l+m+mi}{34}\PYG{p}{,}  \PYG{l+m+mi}{40}\PYG{p}{,}  \PYG{l+m+mi}{42}\PYG{p}{,}  \PYG{l+m+mi}{48}\PYG{p}{,}  \PYG{l+m+mi}{50}\PYG{p}{,}  \PYG{l+m+mi}{97}\PYG{p}{,}
        \PYG{l+m+mi}{99}\PYG{p}{,} \PYG{l+m+mi}{105}\PYG{p}{,} \PYG{l+m+mi}{107}\PYG{p}{,} \PYG{l+m+mi}{113}\PYG{p}{,} \PYG{l+m+mi}{115}\PYG{p}{,} \PYG{l+m+mi}{157}\PYG{p}{]}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n}{uint8}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} translated into binary using bin()}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{np}\PYG{o}{.}\PYG{n}{unique}\PYG{p}{(}\PYG{n}{qc}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{print} \PYG{n}{i}\PYG{p}{,}\PYG{n+nb}{bin}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
0 0b0
2 0b10
8 0b1000
10 0b1010
16 0b10000
18 0b10010
32 0b100000
34 0b100010
40 0b101000
42 0b101010
48 0b110000
50 0b110010
97 0b1100001
99 0b1100011
105 0b1101001
107 0b1101011
113 0b1110001
115 0b1110011
157 0b10011101
\end{Verbatim}

We could try to come up with an interpretation of each of these ... or
we could try to mask the qc bytes to see bit 0 only if that's what we
are interested in. This is quite possibly a new concept for most of you,
but it is very common that when interpreting QC data in data products,
you need to think about bit masking. You will find more details on this
in the advanced section of Chapter 1, but we will consider the minimum
we need right now.

Byte data are formed of 8 bits, e.g.:

\code{105 ==  (1 * 2**6) +          (1 * 2**5) +          (0 * 2**4) +          (1 * 2**3) +          (0 * 2**2) +          (0 * 2**1) +          (1 * 2**0)}

So, in binary, we represent the decimal number \code{105} by \code{1101001} as
we saw above.

The QC values are to be interpreted in this manner.

If we want \emph{only} bit 1, we can perform a \emph{bitwise} operation with the
byte data.

In this case, it would be an `and' operation (\code{\&}) with the value
\code{1}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} suppose we consider the value 105}
\PYG{c}{\PYGZsh{} which from above, we know to have}
\PYG{c}{\PYGZsh{} bit 0 set as 1}
\PYG{n}{test} \PYG{o}{=} \PYG{l+m+mi}{105}
\PYG{n}{bit\PYGZus{}zero} \PYG{o}{=} \PYG{n}{test} \PYG{o}{\PYGZam{}} \PYG{l+m+mi}{1}
\PYG{k}{print} \PYG{n}{bit\PYGZus{}zero}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{1}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} suppose we consider the value 104}
\PYG{c}{\PYGZsh{} which we could work out has bit 1 as 0}
\PYG{n}{test} \PYG{o}{=} \PYG{l+m+mi}{104}
\PYG{n}{bit\PYGZus{}zero} \PYG{o}{=} \PYG{n}{test} \PYG{o}{\PYGZam{}} \PYG{l+m+mi}{1}
\PYG{k}{print} \PYG{n}{bit\PYGZus{}zero}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{0}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} other bit fields are a \PYGZsq{}little\PYGZsq{} more complicated}
\PYG{n}{tests} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{unique}\PYG{p}{(}\PYG{n}{qc}\PYG{p}{)}


\PYG{k}{for} \PYG{n}{t} \PYG{o+ow}{in} \PYG{n}{tests}\PYG{p}{:}
    \PYG{c}{\PYGZsh{} if we want bit field 5\PYGZhy{}7}
    \PYG{c}{\PYGZsh{} we form a binary mask}
    \PYG{n}{mask57} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{n}{b11100000}
    \PYG{c}{\PYGZsh{} but 0}
    \PYG{n}{mask0} \PYG{o}{=}  \PYG{l+m+mi}{0}\PYG{n}{b00000001}
    \PYG{c}{\PYGZsh{} and use \PYGZam{} as before and right shift 5 (\PYGZgt{}\PYGZgt{} 5)}
    \PYG{n}{qa57} \PYG{o}{=} \PYG{p}{(}\PYG{n}{t} \PYG{o}{\PYGZam{}} \PYG{n}{mask57}\PYG{p}{)} \PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{l+m+mi}{5}
    \PYG{n}{qa0}  \PYG{o}{=} \PYG{p}{(}\PYG{n}{t} \PYG{o}{\PYGZam{}} \PYG{n}{mask0}\PYG{p}{)} \PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{l+m+mi}{0}
    \PYG{k}{print} \PYG{n}{t}\PYG{p}{,}\PYG{n}{qa57}\PYG{p}{,}\PYG{n}{qa0}\PYG{p}{,}\PYG{n+nb}{bin}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
0 0 0 0b0
2 0 0 0b10
8 0 0 0b1000
10 0 0 0b1010
16 0 0 0b10000
18 0 0 0b10010
32 1 0 0b100000
34 1 0 0b100010
40 1 0 0b101000
42 1 0 0b101010
48 1 0 0b110000
50 1 0 0b110010
97 3 1 0b1100001
99 3 1 0b1100011
105 3 1 0b1101001
107 3 1 0b1101011
113 3 1 0b1110001
115 3 1 0b1110011
157 4 1 0b10011101
\end{Verbatim}

So, for example (examining the table above) \code{105} is interpreted at
\code{0b011} in fields 5 to 7 (which is 3 in decimal). This indicates that
`Main (RT) method failed due to problems other than geometry empirical
algorithm used'. Here, bit zero is set to \code{1}, so this is a `bad'
pixel.

In this case, we are only interested in bit 0, which is an easier task
than inmterpreting all of the bits.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} the good data are where qc bit 1 is 0}

\PYG{n}{qc} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{FparLai\PYGZus{}QC}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]} \PYG{c}{\PYGZsh{} Get the QC data}
\PYG{c}{\PYGZsh{} find bit 0}
\PYG{n}{qc} \PYG{o}{=} \PYG{n}{qc} \PYG{o}{\PYGZam{}} \PYG{l+m+mi}{1}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{qc}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{QC bit 1}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.colorbar.Colorbar instance at 0xc6b71b8\PYGZgt{}
\end{Verbatim}

\includegraphics{GDAL_HDF_26_1.png}

We can use this mask to generate a masked array. Masked arrays, as we
have seen before, are like normal arrays, but they have an associated
mask.

Remember that the mask in a masked array should be \code{False} for good
data, so we can directly use \code{qc} as defined above.

We shall also choose another colormap (there are \href{http://wiki.scipy.org/Cookbook/Matplotlib/Show\_colormaps}{lots to choose
from}), and
set values outside the 0.1 and 4 to be shown as black pixels.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} colormap}
\PYG{n}{cmap} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{cm}\PYG{o}{.}\PYG{n}{Greens}
\PYG{n}{cmap}\PYG{o}{.}\PYG{n}{set\PYGZus{}bad} \PYG{p}{(} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{k}\PYG{l+s}{\PYGZsq{}} \PYG{p}{)}
\PYG{c}{\PYGZsh{} this sets the no data colour. \PYGZsq{}k\PYGZsq{} is black}

\PYG{c}{\PYGZsh{} generate the masked array}
\PYG{n}{laim} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ma}\PYG{o}{.}\PYG{n}{array} \PYG{p}{(} \PYG{n}{lai}\PYG{p}{,} \PYG{n}{mask}\PYG{o}{=}\PYG{n}{qc} \PYG{p}{)}

\PYG{c}{\PYGZsh{} and plot it}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow} \PYG{p}{(} \PYG{n}{laim}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{n}{cmap}\PYG{p}{,} \PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{n}{vmax}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.colorbar.Colorbar instance at 0x2adc6b8dd5a8\PYGZgt{}
\end{Verbatim}

\includegraphics{GDAL_HDF_28_1.png}

Similarly, we can do a similar thing for Standard Deviation

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{cmap} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{cm}\PYG{o}{.}\PYG{n}{spectral}
\PYG{n}{cmap}\PYG{o}{.}\PYG{n}{set\PYGZus{}bad} \PYG{p}{(} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{k}\PYG{l+s}{\PYGZsq{}} \PYG{p}{)}
\PYG{n}{stdm} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ma}\PYG{o}{.}\PYG{n}{array} \PYG{p}{(} \PYG{n}{lai\PYGZus{}sd}\PYG{p}{,} \PYG{n}{mask}\PYG{o}{=}\PYG{n}{qc} \PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow} \PYG{p}{(} \PYG{n}{stdm}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{n}{cmap}\PYG{p}{,} \PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mf}{0.001}\PYG{p}{,} \PYG{n}{vmax}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.colorbar.Colorbar instance at 0x2adc70725878\PYGZgt{}
\end{Verbatim}

\includegraphics{GDAL_HDF_30_1.png}

For convenience, we might wrap all of this up into a function:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{gdal}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{numpy.ma} \PYG{k+kn}{as} \PYG{n+nn}{ma}


\PYG{k}{def} \PYG{n+nf}{getLAI}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{,} \PYGZbs{}
           \PYG{n}{qc\PYGZus{}layer} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{FparLai\PYGZus{}QC}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYGZbs{}
           \PYG{n}{scale} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{l+m+mf}{0.1}\PYG{p}{]}\PYG{p}{,}\PYGZbs{}
           \PYG{n}{selected\PYGZus{}layers} \PYG{o}{=} \PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{LaiStdDev\PYGZus{}1km}\PYG{l+s}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{:}

    \PYG{c}{\PYGZsh{} get the QC layer too}
    \PYG{n}{selected\PYGZus{}layers}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{qc\PYGZus{}layer}\PYG{p}{)}
    \PYG{n}{scale}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{c}{\PYGZsh{} We will store the data in a dictionary}
    \PYG{c}{\PYGZsh{} Initialise an empty dictionary}
    \PYG{n}{data} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
    \PYG{c}{\PYGZsh{} for convenience, we will use string substitution to create a}
    \PYG{c}{\PYGZsh{} template for GDAL filenames, which we\PYGZsq{}ll substitute on the fly:}
    \PYG{n}{file\PYGZus{}template} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{:MOD\PYGZus{}Grid\PYGZus{}MOD15A2:}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZsq{}}
    \PYG{c}{\PYGZsh{} This has two substitutions (the \PYGZpc{}s parts) which will refer to:}
    \PYG{c}{\PYGZsh{} \PYGZhy{} the filename}
    \PYG{c}{\PYGZsh{} \PYGZhy{} the data layer}
    \PYG{k}{for} \PYG{n}{i}\PYG{p}{,}\PYG{n}{layer} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{selected\PYGZus{}layers}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{this\PYGZus{}file} \PYG{o}{=} \PYG{n}{file\PYGZus{}template} \PYG{o}{\PYGZpc{}} \PYG{p}{(} \PYG{n}{filename}\PYG{p}{,} \PYG{n}{layer} \PYG{p}{)}
        \PYG{n}{g} \PYG{o}{=} \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{Open} \PYG{p}{(} \PYG{n}{this\PYGZus{}file} \PYG{p}{)}

        \PYG{k}{if} \PYG{n}{g} \PYG{o+ow}{is} \PYG{n+nb+bp}{None}\PYG{p}{:}
            \PYG{k}{raise} \PYG{n+ne}{IOError}

        \PYG{n}{data}\PYG{p}{[}\PYG{n}{layer}\PYG{p}{]} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{ReadAsArray}\PYG{p}{(}\PYG{p}{)} \PYG{o}{*} \PYG{n}{scale}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}

    \PYG{n}{qc} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{n}{qc\PYGZus{}layer}\PYG{p}{]} \PYG{c}{\PYGZsh{} Get the QC data}
    \PYG{c}{\PYGZsh{} find bit 0}
    \PYG{n}{qc} \PYG{o}{=} \PYG{n}{qc} \PYG{o}{\PYGZam{}} \PYG{l+m+mi}{1}

    \PYG{n}{odata} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
    \PYG{k}{for} \PYG{n}{layer} \PYG{o+ow}{in} \PYG{n}{selected\PYGZus{}layers}\PYG{p}{[}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{:}
        \PYG{n}{odata}\PYG{p}{[}\PYG{n}{layer}\PYG{p}{]} \PYG{o}{=} \PYG{n}{ma}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{n}{layer}\PYG{p}{]}\PYG{p}{,}\PYG{n}{mask}\PYG{o}{=}\PYG{n}{qc}\PYG{p}{)}

    \PYG{k}{return} \PYG{n}{odata}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{filename} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MCD15A2.A2011185.h09v05.005.2011213154534.hdf}\PYG{l+s}{\PYGZsq{}}

\PYG{n}{lai\PYGZus{}data} \PYG{o}{=} \PYG{n}{getLAI}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{)}

\PYG{c}{\PYGZsh{} colormap}
\PYG{n}{cmap} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{cm}\PYG{o}{.}\PYG{n}{Greens}
\PYG{n}{cmap}\PYG{o}{.}\PYG{n}{set\PYGZus{}bad} \PYG{p}{(} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{k}\PYG{l+s}{\PYGZsq{}} \PYG{p}{)}
\PYG{c}{\PYGZsh{} this sets the no data colour. \PYGZsq{}k\PYGZsq{} is black}

\PYG{c}{\PYGZsh{} and plot it}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow} \PYG{p}{(} \PYG{n}{lai\PYGZus{}data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{n}{cmap}\PYG{p}{,} \PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nearest}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{n}{vmax}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.colorbar.Colorbar instance at 0x2adc709ffe18\PYGZgt{}
\end{Verbatim}

\includegraphics{GDAL_HDF_33_1.png}


\section{Exercise 4.1}
\label{Chapter4_GDAL/GDAL_HDF:exercise-4-1}
You are given the MODIS LAI data files for the year 2012 in the
directory \code{files/data} for the UK (MODIS tile h17v03).

Read these LAI datasets into a masked array, using QA bit 0 to mask the
data (i.e. good quality data only) and generate a movie of LAI.

You should end up with something like:
\begin{figure}[htbp]
\centering

\includegraphics{Chapter4_GDAL/files/images/lai_uk02.gif}
\end{figure}


\section{4.2 Downloading data}
\label{Chapter4_GDAL/GDAL_HDF:downloading-data}
For the exercise and notes above, you were supplied with several
datasets that had been previously downloaded.


\subsection{4.2.1 Reverb}
\label{Chapter4_GDAL/GDAL_HDF:reverb}
These NASA data can be accessed in several ways (except on Wednesdays
when they go down for maintainance (or when there is a Government
shutdown ...)). The most direct way is to use
\href{http://reverb.echo.nasa.gov/reverb/\#utf8=\%E2\%9C\%93\&spatial\_map=satellite\&spatial\_type=rectangle}{Reverb}
to explore and access data. If you do this, you can, for example \href{http://reverb.echo.nasa.gov/reverb/\#utf8=\%E2\%9C\%93\&spatial\_map=satellite\&spatial\_type=rectangle\&spatial=47.517\%2C\%202.813\%2C\%2056.907\%2C\%20-10.547\&keywords=modis\%20snow\%20cover\%20mod10\&temporal\_start=2013-02-21\%2000\%3A00\%3A00\&temporal\_end=2013-03-21\%2023\%3A59\%3A59}{search
for MODIS snow cover MOD10 datasets covering the
UK}
for some given time period. If you follow this through, e.g. selecting
\href{http://reverb.echo.nasa.gov/reverb/granules?utf8=\%E2\%9C\%93\&new\_view=true\&spatial\_map=satellite\&spatial\_type=rectangle\&spatial=47.517\%2C+2.813\%2C+56.907\%2C+-10.547\&keywords=modis+snow+cover+mod10\&temporal\_start=2013-02-21+00\%3A00\%3A00\&temporal\_end=2013-03-21+23\%3A59\%3A59\&datasets=C92711294-NSIDC\_ECS}{MODIS/Terra Snow Cover Daily L3 Global 500m SIN Grid
V005}
and then search for `granules', you should get access to the datasets
you want (select e.g. one of the files for gid \code{h17v03} and save to
cart). You then view the items in your cart, click `download' and then
`save'.

This should give you a text file with some urls in it, e.g.:

\code{ftp://n4ftl01u.ecs.nasa.gov/DP0/MOST/MOD10A1.005/2013.02.21/MOD10A1.A2013052.h17v03.005.2013054054219.hdf ftp://n4ftl01u.ecs.nasa.gov/DP0/MOST/MOD10A1.005/2013.02.21/MOD10A1.A2013052.h17v03.005.2013054054219.hdf.xml ftp://n4ftl01u.ecs.nasa.gov/DP0/BRWS/Browse.001/2013.02.23/BROWSE.MOD10A1.A2013052.h17v03.005.2013054054219.1.jpg http://browse.echo.nasa.gov/NSIDC\_ECS/2013/02/23/:BR:Browse.001:46841269:1.BINARY}

Here, we can note that one of them is a jpeg file:
\begin{figure}[htbp]
\centering
\end{figure}

which is the quicklook (BROWSE file) for that tile / date.

The hdf dataset is, in this case
\code{ftp://n4ftl01u.ecs.nasa.gov/DP0/MOST/MOD10A1.005/2013.02.21/MOD10A1.A2013052.h17v03.005.2013054054219.hdf}.

From this, we see that the data server is \code{n4ftl01u.ecs.nasa.gov} and
that the MODIS snow products for the MODIS Terra instrument are in the
directory:

\code{ftp://n4ftl01u.ecs.nasa.gov/DP0/MOST}.

If we explored that, we would find the datasets from the MODIS Aqua
platform were in:

\code{ftp://n4ftl01u.ecs.nasa.gov/DP0/MOSA}.

The directories below that give the date and filename.


\subsection{4.2.2 FTP access}
\label{Chapter4_GDAL/GDAL_HDF:ftp-access}
Now we have discovered something about the directory structure on the
server, we could explore this to get the datasets we want (rather than
having to go through Reverb).

Some of the datasets on Reverb are acessible only through \code{http}, but
the snow products (at present) are availble by \code{ftp}.

In either case, if we want to run some `batch' process to download many
files (e.g. all files for a year for some tile), the first thing we need
is the set of urls for the files we want.

We won't go into detail here about how to get this, but it is covered in
the advanced section (at the very least, you could always get the set of
urls from Reverb).

So, let's suppose now that we have a file containing some urls that we
want to pull:

\begin{Verbatim}[commandchars=\\\{\}]
!head \PYGZhy{}10 \PYGZlt{} files/data/robot\PYGZus{}snow.2012.txt
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
ftp://n4ftl01u.ecs.nasa.gov/MOSA/MYD10A1.005/2012.01.01/MYD10A1.A2012001.h00v08.005.2012006235251.hdf
ftp://n4ftl01u.ecs.nasa.gov/MOSA/MYD10A1.005/2012.01.01/MYD10A1.A2012001.h00v09.005.2012006235244.hdf
ftp://n4ftl01u.ecs.nasa.gov/MOSA/MYD10A1.005/2012.01.01/MYD10A1.A2012001.h00v10.005.2012006234603.hdf
ftp://n4ftl01u.ecs.nasa.gov/MOSA/MYD10A1.005/2012.01.01/MYD10A1.A2012001.h01v08.005.2012006234607.hdf
ftp://n4ftl01u.ecs.nasa.gov/MOSA/MYD10A1.005/2012.01.01/MYD10A1.A2012001.h01v09.005.2012006234607.hdf
ftp://n4ftl01u.ecs.nasa.gov/MOSA/MYD10A1.005/2012.01.01/MYD10A1.A2012001.h01v10.005.2012006235245.hdf
ftp://n4ftl01u.ecs.nasa.gov/MOSA/MYD10A1.005/2012.01.01/MYD10A1.A2012001.h01v11.005.2012006234656.hdf
ftp://n4ftl01u.ecs.nasa.gov/MOSA/MYD10A1.005/2012.01.01/MYD10A1.A2012001.h02v06.005.2012006235323.hdf
ftp://n4ftl01u.ecs.nasa.gov/MOSA/MYD10A1.005/2012.01.01/MYD10A1.A2012001.h02v08.005.2012006234419.hdf
ftp://n4ftl01u.ecs.nasa.gov/MOSA/MYD10A1.005/2012.01.01/MYD10A1.A2012001.h02v09.005.2012006234416.hdf
\end{Verbatim}

This is a file containing the filenames of \emph{all} \code{MOD10A1} (daily snow
cover) files for a given year, pulled from the ftp server. It is
possible to do this in Python (see advanced section), but actually must
easier and faster with an ftp script
{}`files/python/zat-snow. You don't need to
run this, as it has already been run for you and the results put in the
files:

\begin{Verbatim}[commandchars=\\\{\}]
ls \PYGZhy{}l files/data/robot\PYGZus{}snow*txt
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
[0m\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis  9034752 Oct 22 09:25 [0mfiles/data/robot\PYGZus{}snow.2000.txt[0m
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis 10820568 Oct 22 09:25 [0mfiles/data/robot\PYGZus{}snow.2001.txt[0m
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis 16321938 Oct 22 09:25 [0mfiles/data/robot\PYGZus{}snow.2002.txt[0m
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis 22423068 Oct 22 09:25 [0mfiles/data/robot\PYGZus{}snow.2003.txt[0m
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis  7633374 Oct 22 09:25 [0mfiles/data/robot\PYGZus{}snow.2004.txt[0m
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis 18872448 Oct 22 09:25 [0mfiles/data/robot\PYGZus{}snow.2005.txt[0m
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis 11433078 Oct 22 09:25 [0mfiles/data/robot\PYGZus{}snow.2006.txt[0m
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis 22663686 Oct 22 09:25 [0mfiles/data/robot\PYGZus{}snow.2007.txt[0m
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis 22668990 Oct 22 09:25 [0mfiles/data/robot\PYGZus{}snow.2008.txt[0m
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis 22705317 Oct 22 09:25 [0mfiles/data/robot\PYGZus{}snow.2009.txt[0m
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis 22712370 Oct 22 09:25 [0mfiles/data/robot\PYGZus{}snow.2010.txt[0m
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis 17129166 Oct 22 09:25 [0mfiles/data/robot\PYGZus{}snow.2011.txt[0m
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis 22756824 Oct 22 09:25 [0mfiles/data/robot\PYGZus{}snow.2012.txt[0m
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis 18104898 Oct 22 09:25 [0mfiles/data/robot\PYGZus{}snow.2013.txt[0m
[m
\end{Verbatim}

We can do similar things for http, but that is a little more complicated
(again, see advanced notes or
\code{{}`files/zat \textgreater{} files/data/robot.txt} \textless{}files/zat\textgreater{}{}`\_\_ for the MODIS LAI
product.

\begin{Verbatim}[commandchars=\\\{\}]
!head \PYGZhy{}10 \PYGZlt{} files/data/robot.txt
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2002.07.04/MCD15A2.A2002185.h00v08.005.2007172150237.hdf
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2002.07.04/MCD15A2.A2002185.h00v09.005.2007172150920.hdf
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2002.07.04/MCD15A2.A2002185.h00v10.005.2007172151610.hdf
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2002.07.04/MCD15A2.A2002185.h01v07.005.2007172152152.hdf
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2002.07.04/MCD15A2.A2002185.h01v08.005.2007172150246.hdf
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2002.07.04/MCD15A2.A2002185.h01v09.005.2007172150923.hdf
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2002.07.04/MCD15A2.A2002185.h01v10.005.2007177210359.hdf
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2002.07.04/MCD15A2.A2002185.h01v11.005.2007172151611.hdf
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2002.07.04/MCD15A2.A2002185.h02v06.005.2007172144545.hdf
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2002.07.04/MCD15A2.A2002185.h02v08.005.2007172150221.hdf
\end{Verbatim}

The file \code{files/data/robot\_snow.2012.txt} contains the names for all
tiles and all files.

So if we want just e.g. tile \code{h17v03} and sensor (\code{MOST}), we can
most easily filter this in unix:

\begin{Verbatim}[commandchars=\\\{\}]
tile=h17v03
year=2012
type=MOST

file=files/data/robot\PYGZus{}snow.\PYGZdl{}\PYGZob{}year\PYGZcb{}\PYGZus{}\PYGZdl{}\PYGZob{}type\PYGZcb{}\PYGZus{}\PYGZdl{}\PYGZob{}tile\PYGZcb{}.txt

grep \PYGZdl{}tile \PYGZlt{} files/data/robot\PYGZus{}snow.\PYGZdl{}year.txt \textbar{} grep \PYGZdl{}type \PYGZgt{} \PYGZdl{}file

\PYGZsh{} how many files?
wc \PYGZhy{}l \PYGZlt{} \PYGZdl{}file

\PYGZsh{} look at the first 10 ...
head \PYGZhy{}10 \PYGZlt{} \PYGZdl{}file
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
366
ftp://n4ftl01u.ecs.nasa.gov/MOST/MOD10A1.005/2012.01.01/MOD10A1.A2012001.h17v03.005.2012003054416.hdf
ftp://n4ftl01u.ecs.nasa.gov/MOST/MOD10A1.005/2012.01.02/MOD10A1.A2012002.h17v03.005.2012004061011.hdf
ftp://n4ftl01u.ecs.nasa.gov/MOST/MOD10A1.005/2012.01.03/MOD10A1.A2012003.h17v03.005.2012005061244.hdf
ftp://n4ftl01u.ecs.nasa.gov/MOST/MOD10A1.005/2012.01.04/MOD10A1.A2012004.h17v03.005.2012006054639.hdf
ftp://n4ftl01u.ecs.nasa.gov/MOST/MOD10A1.005/2012.01.05/MOD10A1.A2012005.h17v03.005.2012007052708.hdf
ftp://n4ftl01u.ecs.nasa.gov/MOST/MOD10A1.005/2012.01.06/MOD10A1.A2012006.h17v03.005.2012008070328.hdf
ftp://n4ftl01u.ecs.nasa.gov/MOST/MOD10A1.005/2012.01.07/MOD10A1.A2012007.h17v03.005.2012011144012.hdf
ftp://n4ftl01u.ecs.nasa.gov/MOST/MOD10A1.005/2012.01.08/MOD10A1.A2012008.h17v03.005.2012011154609.hdf
ftp://n4ftl01u.ecs.nasa.gov/MOST/MOD10A1.005/2012.01.09/MOD10A1.A2012009.h17v03.005.2012011222125.hdf
ftp://n4ftl01u.ecs.nasa.gov/MOST/MOD10A1.005/2012.01.10/MOD10A1.A2012010.h17v03.005.2012012062821.hdf
\end{Verbatim}

With a more sensible set of urls now (only a few hundred), we can
consider how to download them.

We can (of course) do this in Python (see advanced notes), but we can
also use unix tools such as \code{curl} or \code{wget}, which may be easier.

For example, in \code{bash}:

\begin{Verbatim}[commandchars=\\\{\}]
tile=h17v03
year=2012
type=MOST

file=snow\PYGZus{}list\PYGZus{}\PYGZdl{}\PYGZob{}tile\PYGZcb{}\PYGZus{}\PYGZdl{}\PYGZob{}year\PYGZcb{}\PYGZus{}\PYGZdl{}\PYGZob{}type\PYGZcb{}.txt

\PYGZsh{} cd temporarily to the local directory
pushd files/data
\PYGZsh{} \PYGZhy{}nc : no clobber : dont download if its there already
\PYGZsh{} \PYGZhy{}nH \PYGZhy{}\PYGZhy{}cut\PYGZhy{}dirs=3 : ignore the directories
wget \PYGZhy{}nc \PYGZhy{}i \PYGZdl{}file \PYGZhy{}nH \PYGZhy{}\PYGZhy{}cut\PYGZhy{}dirs=3
popd
\end{Verbatim}

or in \code{tcsh}:

\begin{Verbatim}[commandchars=\\\{\}]
set tile=h17v03
set year=2012
set type=MOST

file=snow\PYGZus{}list\PYGZus{}\PYGZdl{}\PYGZob{}tile\PYGZcb{}\PYGZus{}\PYGZdl{}\PYGZob{}year\PYGZcb{}\PYGZus{}\PYGZdl{}\PYGZob{}type\PYGZcb{}.txt

\PYGZsh{} cd temporarily to the local directory
pushd files/data
\PYGZsh{} \PYGZhy{}nc : no clobber : dont download if its there already
\PYGZsh{} \PYGZhy{}nH \PYGZhy{}\PYGZhy{}cut\PYGZhy{}dirs=3 : ignore the directories
wget \PYGZhy{}nc \PYGZhy{}i \PYGZdl{}file \PYGZhy{}nH \PYGZhy{}\PYGZhy{}cut\PYGZhy{}dirs=3
popd
\end{Verbatim}

For the moment, let's just pull only some of these by filtering the
month as well:

\begin{Verbatim}[commandchars=\\\{\}]
tile=h17v03
year=2012
type=MOST
month=01

file=files/data/robot\PYGZus{}snow.\PYGZdl{}\PYGZob{}year\PYGZcb{}\PYGZus{}\PYGZdl{}\PYGZob{}type\PYGZcb{}\PYGZus{}\PYGZdl{}\PYGZob{}tile\PYGZcb{}\PYGZus{}\PYGZdl{}\PYGZob{}month\PYGZcb{}.txt

\PYGZsh{} the dot in the year / month grep need to be escaped
\PYGZsh{} because dot means something special to grep
grep \PYGZdl{}tile \PYGZlt{} files/data/robot\PYGZus{}snow.\PYGZdl{}year.txt \textbar{} grep \PYGZdl{}type \textbar{} grep \PYGZdq{}\PYGZdl{}\PYGZob{}year\PYGZcb{}\PYGZbs{}.\PYGZdl{}\PYGZob{}month\PYGZcb{}\PYGZdq{} \PYGZgt{} \PYGZdl{}file

\PYGZsh{} how many files?
wc \PYGZhy{}l \PYGZlt{} \PYGZdl{}file

\PYGZsh{} look at the first 10 ...
head \PYGZhy{}10 \PYGZlt{} \PYGZdl{}file
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
31
ftp://n4ftl01u.ecs.nasa.gov/MOST/MOD10A1.005/2012.01.01/MOD10A1.A2012001.h17v03.005.2012003054416.hdf
ftp://n4ftl01u.ecs.nasa.gov/MOST/MOD10A1.005/2012.01.02/MOD10A1.A2012002.h17v03.005.2012004061011.hdf
ftp://n4ftl01u.ecs.nasa.gov/MOST/MOD10A1.005/2012.01.03/MOD10A1.A2012003.h17v03.005.2012005061244.hdf
ftp://n4ftl01u.ecs.nasa.gov/MOST/MOD10A1.005/2012.01.04/MOD10A1.A2012004.h17v03.005.2012006054639.hdf
ftp://n4ftl01u.ecs.nasa.gov/MOST/MOD10A1.005/2012.01.05/MOD10A1.A2012005.h17v03.005.2012007052708.hdf
ftp://n4ftl01u.ecs.nasa.gov/MOST/MOD10A1.005/2012.01.06/MOD10A1.A2012006.h17v03.005.2012008070328.hdf
ftp://n4ftl01u.ecs.nasa.gov/MOST/MOD10A1.005/2012.01.07/MOD10A1.A2012007.h17v03.005.2012011144012.hdf
ftp://n4ftl01u.ecs.nasa.gov/MOST/MOD10A1.005/2012.01.08/MOD10A1.A2012008.h17v03.005.2012011154609.hdf
ftp://n4ftl01u.ecs.nasa.gov/MOST/MOD10A1.005/2012.01.09/MOD10A1.A2012009.h17v03.005.2012011222125.hdf
ftp://n4ftl01u.ecs.nasa.gov/MOST/MOD10A1.005/2012.01.10/MOD10A1.A2012010.h17v03.005.2012012062821.hdf
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
tile=h17v03
year=2012
type=MOST
month=01

file=robot\PYGZus{}snow.\PYGZdl{}\PYGZob{}year\PYGZcb{}\PYGZus{}\PYGZdl{}\PYGZob{}type\PYGZcb{}\PYGZus{}\PYGZdl{}\PYGZob{}tile\PYGZcb{}\PYGZus{}\PYGZdl{}\PYGZob{}month\PYGZcb{}.txt

\PYGZsh{} cd temporarily to the local directory
pushd files/data
\PYGZsh{} \PYGZhy{}nc : no clobber : dont download if its there already
\PYGZsh{} \PYGZhy{}nH \PYGZhy{}\PYGZhy{}cut\PYGZhy{}dirs=3 : ignore the directories
wget \PYGZhy{}nc \PYGZhy{}i \PYGZdl{}file \PYGZhy{}nH \PYGZhy{}\PYGZhy{}cut\PYGZhy{}dirs=3
\PYGZsh{} cd back again
popd
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
Process is terminated.
\end{Verbatim}


\section{Exercise 4.2 A Different Dataset}
\label{Chapter4_GDAL/GDAL_HDF:exercise-4-2-a-different-dataset}
We have now dowloaded a different dataset, the \href{http://www.icess.ucsb.edu/modis/SnowUsrGuide/usrguide\_1dtil.html}{MOD10A
product},
which is the 500 m MODIS daily snow cover product, over the UK.

This is a good opportunity to see if you can apply what was learned
above about interpreting QC information and using \code{gdal} to examine a
dataset.

If you examine the \href{http://nsidc.org/data/docs/daac/modis\_v5/mod10a1\_modis\_terra\_snow\_daily\_global\_500m\_grid.gd.html}{data description
page},
you will see that the data are in HDF EOS format (the same as the LAI
product).


\subsection{E4.2.1 Download}
\label{Chapter4_GDAL/GDAL_HDF:e4-2-1-download}
Download the MODIS Terra daily snow product for the UK for the year 2012
for the month of February using the urls in
files/data/robot\_snow.2012.txt and
put them in the directory \code{files/data}.


\subsection{E4.2.1 Explore}
\label{Chapter4_GDAL/GDAL_HDF:e4-2-1-explore}
Show all of the subset data layers in this dataset.


\subsection{E4.3.3 Read a dataset}
\label{Chapter4_GDAL/GDAL_HDF:e4-3-3-read-a-dataset}
Suppose we are interested in the dataset \code{Fractional\_Snow\_Cover} over
the land surface.

Read this dataset for one of the files into a numpy array and show a
plot of the dataset.


\subsection{E4.3.4 Water mask}
\label{Chapter4_GDAL/GDAL_HDF:e4-3-4-water-mask}
The \href{http://nsidc.org/data/docs/daac/modis\_v5/mod10a1\_modis\_terra\_snow\_daily\_global\_500m\_grid.gd.html}{data description
page}
tells us that values of \code{239} will indicate whether the data is ocean.
You can use this information to build the water mask.

Demonstrate how to build a water mask from one of these files, setting
the mask \code{False} for land and \code{True} for water.

Produce a plot of this.


\subsection{E3.4.5 Valid pixel mask}
\label{Chapter4_GDAL/GDAL_HDF:e3-4-5-valid-pixel-mask}
As well as having a land/water mask, we should generate a mask for valid
pixels. For the snow dataset, values between 0 and 100 (inclusive)
represent valid snow cover data values. Other values are not valid for
some reason. Set the mask to \code{False} for valid pixels and \code{True} for
others. Produce a plot of the mask.


\subsection{E4.3.6 3D dataset}
\label{Chapter4_GDAL/GDAL_HDF:e4-3-6-3d-dataset}
Generate a 3D masked numpy array using the valid pixel mask for masking,
of \code{Fractional\_Snow\_Cover} for each day of February 2012.

You might like to produce a movie of the result.

Hint: you will need a list of filenames for this. You can either use
\code{glob} as in previous exercises, or you might notice that you have the
file \code{files/data/robot\_snow.2012\_MOST\_h17v03\_02.txt} with the urls,
from which you should be able to derive the file names. However you get
your list of filenames, you should probably apply a \code{sort()} to the
result to make sure they are in the correct order.


\section{4.3 Vector masking}
\label{Chapter4_GDAL/GDAL_HDF:vector-masking}
In this section, we will use a pre-defined function to generate a mask
from some vector boundary data.

In this case, we will generate a mask for Ireland, projected into the
coordinate system of the MODIS LAI dataset, and use that to generate a
new LAI data only for Ireland.

Sometimes, geospatial data is acquired and recorded for particular
geometric objects such as polygons or lines. An example is a road
layout, where each road is represented as a geometric object (a line,
with points given in a geographical projection), with a number of added
\emph{features} associated with it, such as the road name, whether it is a
toll road, or whether it is dual-carriageway, etc. This data is quite
different to a raster, where the entire scene is tessellated into
pixels, and each pixel holds a value (or an array of value in the case
of multiband rasterfiles).

If you are familiar with databases, vector files are effectively a
database, where one of the fields is a geometry object (a line in our
previous road example, or a polygon if you consider a cadastral system).
We can thus select different records by writing queries on the features.
Some of these queries might be spatial (e.g. check whether a point is
inside a particular country polygon).

The most common format for vector data is the \textbf{ESRI Shapfile}, which
is a multifile format (i.e., several files are needed in order to access
the data). We'll start by getting hold of a shapefile that contains the
countries of the world as polygons, together with information on country
name, capital name, population, etc. The file is available
\href{http://aprsworld.net/gisdata/world/world.zip}{here}.
\begin{figure}[htbp]
\centering
\capstart
\caption{World}\end{figure}

We will download the file with wget (or curl if you want to), and
uncompress it using unzip in the shell:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{} Downloads the data using wget
!wget \PYGZhy{}nc http://aprsworld.net/gisdata/world/world.zip \PYGZhy{}O files/data/world.zip
\PYGZsh{} or if you want to use curl...
\PYGZsh{}! curl http://aprsworld.net/gisdata/world/world.zip \PYGZhy{}o world.zip
!pushd files/data;unzip \PYGZhy{}o \PYGZhy{}x world.zip;popd
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZhy{}\PYGZhy{}2013\PYGZhy{}10\PYGZhy{}22 15:32:06\PYGZhy{}\PYGZhy{}  http://aprsworld.net/gisdata/world/world.zip
Resolving aprsworld.net... 72.251.203.219
Connecting to aprsworld.net\textbar{}72.251.203.219\textbar{}:80... connected.
HTTP request sent, awaiting response... 200 OK
Length: 3436277 (3.3M) [application/zip]
Saving to: {}`files/data/world.zip\PYGZsq{}

100\PYGZpc{}[======================================\PYGZgt{}] 3,436,277   3.38M/s   in 1.0s

2013\PYGZhy{}10\PYGZhy{}22 15:32:07 (3.38 MB/s) \PYGZhy{} {}`files/data/world.zip\PYGZsq{} saved [3436277/3436277]

/archive/rsu\PYGZus{}raid\PYGZus{}0/plewis/public\PYGZus{}html/geogg122\PYGZus{}local/geogg122/Chapter4\PYGZus{}GDAL/files/data /archive/rsu\PYGZus{}raid\PYGZus{}0/plewis/public\PYGZus{}html/geogg122\PYGZus{}local/geogg122/Chapter4\PYGZus{}GDAL
Archive:  world.zip
  inflating: world.dbf
  inflating: world.shp
  inflating: world.shx
/archive/rsu\PYGZus{}raid\PYGZus{}0/plewis/public\PYGZus{}html/geogg122\PYGZus{}local/geogg122/Chapter4\PYGZus{}GDAL
\end{Verbatim}

We need to import \code{ogr}, and then open the file. As with GDAL, we get
a handler to the file, (\code{g} in this case). OGR files can have
different layers, although Shapefiles only have one. We need to select
the layer using \code{GetLayer(0)} (selecting the first layer).

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{osgeo} \PYG{k+kn}{import} \PYG{n}{ogr}

\PYG{n}{g} \PYG{o}{=} \PYG{n}{ogr}\PYG{o}{.}\PYG{n}{Open}\PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{files/data/world.shp}\PYG{l+s}{\PYGZdq{}} \PYG{p}{)}
\PYG{n}{layer} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{GetLayer}\PYG{p}{(} \PYG{l+m+mi}{0} \PYG{p}{)}
\end{Verbatim}

In order to see a field (the field \code{NAME}) we can loop over the
features in the layer, and use the \code{GetField('NAME')} method. We'll
only do ten features here:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{n\PYGZus{}feat} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{k}{for} \PYG{n}{feat} \PYG{o+ow}{in} \PYG{n}{layer}\PYG{p}{:}

    \PYG{k}{print} \PYG{n}{feat}\PYG{o}{.}\PYG{n}{GetField}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{NAME}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

    \PYG{n}{n\PYGZus{}feat} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
    \PYG{k}{if} \PYG{n}{n\PYGZus{}feat} \PYG{o}{==} \PYG{l+m+mi}{10}\PYG{p}{:}
        \PYG{k}{break}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
GUATEMALA
BOLIVIA
PARAGUAY
URUGUAY
SURINAME
FRENCH GUIANA
WESTERN SAHARA
GAMBIA
MOROCCO
MALI
\end{Verbatim}

If you wanted to see the different layers, we could do this using:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{layerDefinition} \PYG{o}{=} \PYG{n}{layer}\PYG{o}{.}\PYG{n}{GetLayerDefn}\PYG{p}{(}\PYG{p}{)}


\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{layerDefinition}\PYG{o}{.}\PYG{n}{GetFieldCount}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Field }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{: }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{p}{(} \PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{layerDefinition}\PYG{o}{.}\PYG{n}{GetFieldDefn}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{o}{.}\PYG{n}{GetName}\PYG{p}{(}\PYG{p}{)} \PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
Field 1: NAME
Field 2: CAPITAL
Field 3: APPROX
Field 4: AREA
Field 5: SOURCETHM
\end{Verbatim}

There is much more information on using \code{ogr} on the associated
notebook OGR\_Python that you should explore at
some point.

One thing we may often wish to dowith such vector datsets is produce a
mask, e.g. for national boundaries. One of the complexities of this is
changing the projection that the vector data come in to that of the
raster dataset.

This is too involved to go over in this session, so we will simply
present you with a function to achieve this.

This is available as
files/python/raster\_mask.py.

Most of the code below should be familiar from above (we make use of the
\code{getLAI()} function we developed).

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{n}{sys}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/python}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{k+kn}{from} \PYG{n+nn}{raster\PYGZus{}mask} \PYG{k+kn}{import} \PYG{n}{raster\PYGZus{}mask}\PYG{p}{,}\PYG{n}{getLAI}

\PYG{c}{\PYGZsh{} test this on an LAI file}

\PYG{c}{\PYGZsh{} the data file name}
\PYG{n}{filename} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MCD15A2.A2012273.h17v03.005.2012297134400.hdf}\PYG{l+s}{\PYGZsq{}}

\PYG{c}{\PYGZsh{} a layer (doesn\PYGZsq{}t matter so much which: use for geometry info)}
\PYG{n}{layer} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}
\PYG{c}{\PYGZsh{} the full dataset specification}
\PYG{n}{file\PYGZus{}template} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{:MOD\PYGZus{}Grid\PYGZus{}MOD15A2:}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZsq{}}
\PYG{n}{file\PYGZus{}spec} \PYG{o}{=} \PYG{n}{file\PYGZus{}template}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{,}\PYG{n}{layer}\PYG{p}{)}

\PYG{c}{\PYGZsh{} make a raster mask}
\PYG{c}{\PYGZsh{} from the layer IRELAND in world.shp}
\PYG{n}{mask} \PYG{o}{=} \PYG{n}{raster\PYGZus{}mask}\PYG{p}{(}\PYG{n}{file\PYGZus{}spec}\PYG{p}{,}\PYGZbs{}
                   \PYG{n}{target\PYGZus{}vector\PYGZus{}file} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{files/data/world.shp}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYGZbs{}
                   \PYG{n}{attribute\PYGZus{}filter} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{NAME = }\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{IRELAND}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}

\PYG{c}{\PYGZsh{} get the LAI data}
\PYG{n}{data} \PYG{o}{=} \PYG{n}{getLAI}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{)}

\PYG{c}{\PYGZsh{} reset the data mask}
\PYG{c}{\PYGZsh{} \PYGZsq{}mask\PYGZsq{} is True for Ireland}
\PYG{c}{\PYGZsh{} so take the opposite}
\PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{ma}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{mask}\PYG{o}{=}\PYG{n}{mask}\PYG{p}{)}
\PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{LaiStdDev\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{ma}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{mask}\PYG{o}{=}\PYG{n}{mask}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{LAI for Eire: 2012273}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{vmax}\PYG{o}{=}\PYG{l+m+mi}{6}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.colorbar.Colorbar instance at 0x7153878\PYGZgt{}
\end{Verbatim}

\includegraphics{GDAL_HDF_65_1.png}


\section{Exercise 4.3}
\label{Chapter4_GDAL/GDAL_HDF:exercise-4-3}
Apply the concepts above to generate a 3D masked numpy data array of LAI
and std LAI for Eire for the year 2012.

Plot your results and make a move of LAI.

Plot average LAI for Eire as a function of day of year for 2012.


\chapter{Summary}
\label{Chapter4_GDAL/GDAL_HDF:summary}
In this session, we have learned to use some geospatial tools using GDAL
in Python. A good set of \href{http://jgomezdans.github.io/gdal\_notes/}{working notes on how to use
GDAL} has been developed
that you will find useful for further reading, as well as looking at the
advanced section.

We have also very briefly introduced dealing with vector datasets in
\code{ogr}, but this was mainly through the use of a pre-defined function
that will take an ESRI shapefile (vector dataset), warp this to the
projection of a raster dataset, and produce a mask for a given layer in
the vector file.

If there is time in the class, we will develop some exercises to examine
the datasets we have generated and/or to explore some different datasets
or different locations.


\chapter{GDAL and OGR libraries}
\label{Chapter4_GDAL/GDAL_Python_bindings::doc}\label{Chapter4_GDAL/GDAL_Python_bindings:gdal-and-ogr-libraries}
In the previous session, we used the GDAL library to open HDF files.
GDAL is not limited to a single file format, but can actually cope with
many different raster file formats semalessly. For \emph{vector} data (i.e.,
data that is stored by features, each being made up of fields containing
different types of information, one of them being a \emph{geometry}, such as
polygon, line or point), GDAL has a sister library called OGR. The
usefulness of these two libraries is that they allow the user to deal
with many of the different file formats in a consistent way.

It is important to note that both GDAL and OGR come with a suite of
command line tools that let you do many complex tasks on the command
line directly. A listing of the GDAL command line tools is available
\href{http://www.gdal.org/gdal\_utilities.html}{here}, but bear in mind
that many blogs etc. carry out examples of using GDAL tools in practice.
For OGR, most of the library can be accessed using
\href{http://www.gdal.org/ogr2ogr.html}{ogr2ogr}, but as usual, you might
find more useful information on
\href{http://www.bostongis.com/PrinterFriendly.aspx?content\_name=ogr\_cheatsheet}{blogs}
etc.


\section{GDAL data type}
\label{Chapter4_GDAL/GDAL_Python_bindings:gdal-data-type}
GDAL provides a very handy way of dealing with raster data in many
different formats, not only by making access to the data easy, but also
abstracting the nuances and complications of different file formats. In
GDAL, a raster file is made up of the actual raster data (i.e., the
values of each pixel of LAI that we saw before), and of some \emph{metadata}.
Metadata is data that describes something, and in this case it could be
the projection, the location of corners and pixel spacing, etc.


\subsection{The GeoTransform}
\label{Chapter4_GDAL/GDAL_Python_bindings:the-geotransform}
GDAL stores information about the location of each pixel using the
GeoTransform. The GeoTransform contains the coordinates (in some
projection) of the upper left (UL) corner of the image (taken to be the
\textbf{borders of the pixel} in the UL corner, not the center), the pixel
spacing and an additional rotation. By knowing these figures, we can
calculate the location of each pixel in the image easily. Let's see how
this works with an easy example. We have prepared a GeoTIFF file
(GeoTIFF is the more ubiquitous file format for EO data) of the MODIS
landcover product for the UK. The data has been extracted from the
HDF-EOS files that are similar to the LAI product that we have seen
before, and converted. The file is
\code{{}`lc\_h17v03.tif} \textless{}\href{https://raw.github.com/jgomezdans/geogg122/master/ChapterX\_GDAL/lc\_h17v03.tif}{https://raw.github.com/jgomezdans/geogg122/master/ChapterX\_GDAL/lc\_h17v03.tif}\textgreater{}{}`\_\_.
We will open the file in Python, and have a look at finding a particular
location.

Assume we are interested in locating \href{http://toolserver.org/~rhaworth/os/coor\_g.php?pagename=Kinder\_Scout\&params=SK086875\_region\%3AGB\_scale\%3A25000}{Kinder
Scout},
a moorland in the Peak District National Park. Its coordinates are
1.871417W, 53.384726N. In the MODIS integerised sinusoidal projection,
the coordinates are (-124114.3, 5936117.4) (you can use the \href{http://landweb.nascom.nasa.gov/cgi-bin/developer/tilemap.cgi}{MODLAND
tile calculator
website}
to do this calculation yourself).

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{gdal} \PYG{c}{\PYGZsh{} Import GDAL library}
\PYG{n}{g} \PYG{o}{=} \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{Open} \PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{lc\PYGZus{}h17v03.tif}\PYG{l+s}{\PYGZdq{}} \PYG{p}{)} \PYG{c}{\PYGZsh{} Open the file}
\PYG{k}{if} \PYG{n}{g} \PYG{o+ow}{is} \PYG{n+nb+bp}{None}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Could not open the file!}\PYG{l+s}{\PYGZdq{}}
\PYG{n}{geo\PYGZus{}transform} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{GetGeoTransform} \PYG{p}{(}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{geo\PYGZus{}transform}
\PYG{k}{print} \PYG{n}{g}\PYG{o}{.}\PYG{n}{RasterXSize}\PYG{p}{,} \PYG{n}{g}\PYG{o}{.}\PYG{n}{RasterYSize}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
(\PYGZhy{}1111950.519667, 463.3127165279167, 0.0, 6671703.118, 0.0, \PYGZhy{}463.3127165279165)
2400 2400
\end{Verbatim}

In the previous code, we open the file (we just use the filename), and
then query the object for its GeoTransform, which we then print out. The
6-element tuple comprises
\begin{enumerate}
\item {} 
The Upper Left \emph{easting} coordinate (i.e., \emph{horizontal})

\item {} 
The E-W pixel spacing

\item {} 
The rotation (0 degrees if image is ``North Up'')

\item {} 
The Upper left \emph{northing} coordinate (i.e., \emph{vertical})

\item {} 
The rotation (0 degrees)

\item {} 
The N-S pixel spacing, negative as we will be counting from the UL
corner

\end{enumerate}

We have also seen that the dataset is of size 2400x2400, using
\code{RasterXSize} and \code{RasterYSize}. The goal is to find the pixel
number \((i,j), \;\;0\le i,j < 2400\) that corresponds to Kinder
Scout. To do this, we use the following calculations:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{pixel\PYGZus{}x} \PYG{o}{=} \PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{124114.3} \PYG{o}{\PYGZhy{}} \PYG{n}{geo\PYGZus{}transform}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{o}{/}\PYG{n}{geo\PYGZus{}transform}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYGZbs{}
        \PYG{c}{\PYGZsh{} The difference in distance between the UL corner (geot[0] \PYGZbs{}}
        \PYG{c}{\PYGZsh{}and point of interest. Scaled by geot[1] to get pixel number}

\PYG{n}{pixel\PYGZus{}y} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mf}{5936117.4} \PYG{o}{\PYGZhy{}} \PYG{n}{geo\PYGZus{}transform}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}\PYG{o}{/}\PYG{p}{(}\PYG{n}{geo\PYGZus{}transform}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{)} \PYG{c}{\PYGZsh{} Like for pixel\PYGZus{}x, \PYGZbs{}}
        \PYG{c}{\PYGZsh{}but in vertical direction. Note the different elements of geot \PYGZbs{}}
        \PYG{c}{\PYGZsh{}being used}

\PYG{k}{print} \PYG{n}{pixel\PYGZus{}x}\PYG{p}{,} \PYG{n}{pixel\PYGZus{}y}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
2132.11549009 1587.66572071
\end{Verbatim}

So the pixel number is a floating point number, which we might need to
round off as an integer. Let's plot the entire raster map (with minimum
value 0 to ignore the ocean) using
\code{{}`plt.imshow} \textless{}\href{http://matplotlib.org/api/pyplot\_api.html\#matplotlib.pyplot.imshow}{http://matplotlib.org/api/pyplot\_api.html\#matplotlib.pyplot.imshow}\textgreater{}{}`\_\_
and plot the location of Kinder Scout using
\code{{}`plt.plot} \textless{}\href{http://matplotlib.org/api/pyplot\_api.html\#matplotlib.pyplot.plt}{http://matplotlib.org/api/pyplot\_api.html\#matplotlib.pyplot.plt}\textgreater{}{}`\_\_.
We will also use
\code{{}`plt.annotate} \textless{}\href{http://matplotlib.org/api/pyplot\_api.html\#matplotlib.pyplot.annotate}{http://matplotlib.org/api/pyplot\_api.html\#matplotlib.pyplot.annotate}\textgreater{}{}`\_\_
to add a label with an arrow:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{lc} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{ReadAsArray}\PYG{p}{(}\PYG{p}{)} \PYG{c}{\PYGZsh{} Read raster data}
\PYG{c}{\PYGZsh{} Now plot the raster data using gist\PYGZus{}earth palette}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow} \PYG{p}{(} \PYG{n}{lc}\PYG{p}{,} \PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nearest}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{n}{plt}\PYG{o}{.}\PYG{n}{cm}\PYG{o}{.}\PYG{n}{gist\PYGZus{}earth} \PYG{p}{)}
\PYG{c}{\PYGZsh{} Plot location of our area of interest as a red dot (\PYGZsq{}ro\PYGZsq{})}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot} \PYG{p}{(} \PYG{n}{pixel\PYGZus{}x}\PYG{p}{,} \PYG{n}{pixel\PYGZus{}y}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{ro}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{c}{\PYGZsh{} Annotate}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{annotate}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Kinder Scout}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{xy}\PYG{o}{=}\PYG{p}{(}\PYG{n}{pixel\PYGZus{}x}\PYG{p}{,} \PYG{n}{pixel\PYGZus{}y}\PYG{p}{)}\PYG{p}{,}  \PYGZbs{}
        \PYG{n}{xycoords}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{data}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{xytext}\PYG{o}{=}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{150}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{60}\PYG{p}{)}\PYG{p}{,} \PYGZbs{}
        \PYG{n}{textcoords}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{offset points}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}  \PYG{n}{size}\PYG{o}{=}\PYG{l+m+mi}{12}\PYG{p}{,} \PYGZbs{}
        \PYG{n}{bbox}\PYG{o}{=}\PYG{n+nb}{dict}\PYG{p}{(}\PYG{n}{boxstyle}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{round4,pad=.5}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{fc}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0.8}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,} \PYGZbs{}
        \PYG{n}{arrowprops}\PYG{o}{=}\PYG{n+nb}{dict}\PYG{p}{(}\PYG{n}{arrowstyle}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}\PYGZgt{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYGZbs{}
        \PYG{n}{connectionstyle}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{angle,angleA=0,angleB=\PYGZhy{}90,rad=10}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYGZbs{}
        \PYG{n}{color}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{w}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,} \PYG{p}{)}
\PYG{c}{\PYGZsh{} Remove vertical and horizontal ticks}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xticks}\PYG{p}{(}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{yticks}\PYG{p}{(}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
([], \PYGZlt{}a list of 0 Text yticklabel objects\PYGZgt{})
\end{Verbatim}

\includegraphics{GDAL_Python_bindings_10_1.svg}


\subsubsection{Try it out in some other places!}
\label{Chapter4_GDAL/GDAL_Python_bindings:try-it-out-in-some-other-places}
Find the longitude and latitude of some places of interest in the
British isles (West of Greenwich!) and using the MODLAND MODIS tile
calculator and the geotransform, repeat the above experiment. Note that
the \href{http://landweb.nascom.nasa.gov/cgi-bin/developer/tilemap.cgi}{MODIS
calculator}
calculates both the projected coordinates in the MODIS sinusoidal
projection, as well as the pixel number, so it is a helpful way to check
whether you got the right result.

Park name

Longitude {[}deg{]}

Latitude {[}deg{]}

Dartmoor national park

-3.904

50.58

New forest national park

-1.595

50.86

Exmoor national park

-3.651

51.14

Pembrokeshire coast national park

-4.694

51.64

Brecon beacons national park

-3.432

\begin{Verbatim}[commandchars=\\\{\}]
51.88\PYGZlt{}/td\PYGZgt{}
\end{Verbatim}

Pembrokeshire coast national park

-4.79

51.99

Norfolk and suffolk broads

1.569

52.62

Snowdonia national park

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZhy{}3.898  \PYGZlt{}/td\PYGZgt{}\PYGZlt{}td\PYGZgt{}52.9\PYGZlt{}/td\PYGZgt{}
\end{Verbatim}

Peak district national park

-1.802

53.3

Yorkshire dales national park

-2.157

54.23

North yorkshire moors national park

-0.8855

54.37

Lake district national park

-3.084

54.47

Galloway forest park

-4.171

54.87

Northumberland national park

-2.228

55.28

Loch lomond and the trossachs national park

-4.593

56.24

Tay forest park

-4.025

\begin{Verbatim}[commandchars=\\\{\}]
56.59\PYGZlt{}/td\PYGZgt{}
\end{Verbatim}

Cairngorms national park

-3.545

57.08


\section{The projection}
\label{Chapter4_GDAL/GDAL_Python_bindings:the-projection}
Projections in GDAL objects are stored can be accessed by querying the
dataset using the \code{GetProjection()} method. If we do that on the
currently opened dataset (stored in variable \code{g}), we get:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{n}{g}\PYG{o}{.}\PYG{n}{GetProjection}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{PROJCS}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{unnamed}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{GEOGCS}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Unknown datum based upon the custom spheroid}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{DATUM}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Not\PYGZus{}specified\PYGZus{}based\PYGZus{}on\PYGZus{}custom\PYGZus{}spheroid}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{SPHEROID}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Custom spheroid}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+m+mf}{6371007.181}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,}\PYG{n}{PRIMEM}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Greenwich}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{UNIT}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{degree}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+m+mf}{0.0174532925199433}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,}\PYG{n}{PROJECTION}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Sinusoidal}\PYG{l+s}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{PARAMETER}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{longitude\PYGZus{}of\PYGZus{}center}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{PARAMETER}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{false\PYGZus{}easting}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{PARAMETER}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{false\PYGZus{}northing}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{UNIT}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{metre}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{AUTHORITY}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{EPSG}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{9001}\PYG{l+s}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{]}\PYG{p}{]}
\end{Verbatim}

The above is the description of the projection (in this case, MODIS
sinusoidal) in \code{WKT} (well-known text) format. There are a number of
different ways of specifying projections, the most important being
\begin{itemize}
\item {} 
WKT

\item {} 
Proj4

\item {} 
EPSG codes

\end{itemize}

The site \href{http://spatialreference.org}{spatialreference.org} allows
you to search a large collection of projections, and get the
representation that you want to use.


\section{Saving files}
\label{Chapter4_GDAL/GDAL_Python_bindings:saving-files}
So far, we have read data from files, but lets see how we can save
raster data \textbf{to} a new file. We will use the previous landcover map as
an example. We will write a method to save the data in a format provided
by the user. The procedure is fairly straightforward: we get a handler
to a driver (e.g. a GeoTIFF or Erdas Imagine format), we create the
output file (giving a filename, number of rows, columns, bands, the data
type), and then add the relevant metadata (projection, geotransform,
...). We then select a band from the output and copy the array that we
want to write to that band.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{g} \PYG{o}{=} \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{Open} \PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{lc\PYGZus{}h17v03.tif}\PYG{l+s}{\PYGZdq{}} \PYG{p}{)} \PYG{c}{\PYGZsh{} Open original file}
\PYG{c}{\PYGZsh{} Get the x, y and number of bands from the original file}
\PYG{n}{x\PYGZus{}size}\PYG{p}{,} \PYG{n}{y\PYGZus{}size}\PYG{p}{,} \PYG{n}{n\PYGZus{}bands} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{RasterXSize}\PYG{p}{,} \PYG{n}{g}\PYG{o}{.}\PYG{n}{RasterYSize}\PYG{p}{,} \PYG{n}{g}\PYG{o}{.}\PYG{n}{RasterCount}
\PYG{n}{data} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{ReadAsArray} \PYG{p}{(}\PYG{p}{)}
\PYG{n}{driver} \PYG{o}{=} \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{GetDriverByName} \PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{HFA}\PYG{l+s}{\PYGZdq{}} \PYG{p}{)} \PYG{c}{\PYGZsh{} Get a handler to a driver}
                                        \PYG{c}{\PYGZsh{} Maybe try \PYGZdq{}GeoTIFF\PYGZdq{} here}
\PYG{c}{\PYGZsh{} Next line creates the output dataset with}
\PYG{c}{\PYGZsh{} 1. The filename (\PYGZdq{}test\PYGZus{}lc\PYGZus{}h17v03.img\PYGZdq{})}
\PYG{c}{\PYGZsh{} 2. The raster size (x\PYGZus{}size, y\PYGZus{}size)}
\PYG{c}{\PYGZsh{} 3. The number of bands}
\PYG{c}{\PYGZsh{} 4.The data type (in this case, Byte.}
\PYG{c}{\PYGZsh{}     Other typical values might be gdal.GDT\PYGZus{}Int16}
\PYG{c}{\PYGZsh{}     or gdal.GDT\PYGZus{}Float32)}

\PYG{n}{dataset\PYGZus{}out} \PYG{o}{=} \PYG{n}{driver}\PYG{o}{.}\PYG{n}{Create} \PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{test\PYGZus{}lc\PYGZus{}h17v03.img}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{x\PYGZus{}size}\PYG{p}{,} \PYG{n}{y\PYGZus{}size}\PYG{p}{,} \PYG{n}{n\PYGZus{}bands}\PYG{p}{,} \PYGZbs{}
                             \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{GDT\PYGZus{}Byte} \PYG{p}{)}
\PYG{c}{\PYGZsh{} Set the output geotransform by reading the input one}
\PYG{n}{dataset\PYGZus{}out}\PYG{o}{.}\PYG{n}{SetGeoTransform} \PYG{p}{(} \PYG{n}{g}\PYG{o}{.}\PYG{n}{GetGeoTransform}\PYG{p}{(}\PYG{p}{)} \PYG{p}{)}
\PYG{c}{\PYGZsh{} Set the output projection by reading the input one}
\PYG{n}{dataset\PYGZus{}out}\PYG{o}{.}\PYG{n}{SetProjection} \PYG{p}{(} \PYG{n}{g}\PYG{o}{.}\PYG{n}{GetProjectionRef}\PYG{p}{(}\PYG{p}{)} \PYG{p}{)}
\PYG{c}{\PYGZsh{} Now, get band \PYGZsh{} 1, and write our data array.}
\PYG{c}{\PYGZsh{} Note that the data array needs to have the same type}
\PYG{c}{\PYGZsh{} as the one specified for dataset\PYGZus{}out}
\PYG{n}{dataset\PYGZus{}out}\PYG{o}{.}\PYG{n}{GetRasterBand} \PYG{p}{(} \PYG{l+m+mi}{1} \PYG{p}{)}\PYG{o}{.}\PYG{n}{WriteArray} \PYG{p}{(} \PYG{n}{data} \PYG{p}{)}
\PYG{c}{\PYGZsh{} This bit forces GDAL to close the file and write to it}
\PYG{n}{dataset\PYGZus{}out} \PYG{o}{=} \PYG{n+nb+bp}{None}
\end{Verbatim}

The output file should hopefully exist in this directory. Let's use
\code{{}`gdalinfo} \textless{}\href{http://www.gdal.org/gdalinfo.html}{http://www.gdal.org/gdalinfo.html}\textgreater{}{}`\_\_ to find out about
it

\begin{Verbatim}[commandchars=\\\{\}]
!gdalinfo test\PYGZus{}lc\PYGZus{}h17v03.img
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
Driver: HFA/Erdas Imagine Images (.img)
Files: test\PYGZus{}lc\PYGZus{}h17v03.img
Size is 2400, 2400
Coordinate System is:
PROJCS[\PYGZdq{}Sinusoidal\PYGZdq{},
    GEOGCS[\PYGZdq{}GCS\PYGZus{}Unknown datum based upon the custom spheroid\PYGZdq{},
        DATUM[\PYGZdq{}Not\PYGZus{}specified\PYGZus{}based\PYGZus{}on\PYGZus{}custom\PYGZus{}spheroid\PYGZdq{},
            SPHEROID[\PYGZdq{}Custom\PYGZus{}spheroid\PYGZdq{},6371007.181,0]],
        PRIMEM[\PYGZdq{}Greenwich\PYGZdq{},0],
        UNIT[\PYGZdq{}Degree\PYGZdq{},0.017453292519943295]],
    PROJECTION[\PYGZdq{}Sinusoidal\PYGZdq{}],
    PARAMETER[\PYGZdq{}longitude\PYGZus{}of\PYGZus{}center\PYGZdq{},0],
    PARAMETER[\PYGZdq{}false\PYGZus{}easting\PYGZdq{},0],
    PARAMETER[\PYGZdq{}false\PYGZus{}northing\PYGZdq{},0],
    UNIT[\PYGZdq{}Meter\PYGZdq{},1]]
Origin = (\PYGZhy{}1111950.519667000044137,6671703.117999999783933)
Pixel Size = (463.312716527916677,\PYGZhy{}463.312716527916507)
Corner Coordinates:
Upper Left  (\PYGZhy{}1111950.520, 6671703.118) ( 20d 0\PYGZsq{} 0.00\PYGZdq{}W, 60d 0\PYGZsq{} 0.00\PYGZdq{}N)
Lower Left  (\PYGZhy{}1111950.520, 5559752.598) ( 15d33\PYGZsq{}26.06\PYGZdq{}W, 50d 0\PYGZsq{} 0.00\PYGZdq{}N)
Upper Right (       0.000, 6671703.118) (  0d 0\PYGZsq{} 0.01\PYGZdq{}E, 60d 0\PYGZsq{} 0.00\PYGZdq{}N)
Lower Right (       0.000, 5559752.598) (  0d 0\PYGZsq{} 0.01\PYGZdq{}E, 50d 0\PYGZsq{} 0.00\PYGZdq{}N)
Center      ( \PYGZhy{}555975.260, 6115727.858) (  8d43\PYGZsq{} 2.04\PYGZdq{}W, 55d 0\PYGZsq{} 0.00\PYGZdq{}N)
Band 1 Block=64x64 Type=Byte, ColorInterp=Undefined
  Description = Layer\PYGZus{}1
  Metadata:
    LAYER\PYGZus{}TYPE=athematic
\end{Verbatim}

So the previous code works. Since this is something we typically do
(read some data from one or more files, manipulate it and save the
result in output files), it makes a lot of sense to try to put this code
in a method that is more or less generic, that we can test and then
re-use. Here's a first attempt at it:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{save\PYGZus{}raster} \PYG{p}{(} \PYG{n}{output\PYGZus{}name}\PYG{p}{,} \PYG{n}{raster\PYGZus{}data}\PYG{p}{,} \PYG{n}{dataset}\PYG{p}{,} \PYG{n}{driver}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{GTiff}\PYG{l+s}{\PYGZdq{}} \PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    A function to save a 1\PYGZhy{}band raster using GDAL to the file indicated}
\PYG{l+s+sd}{    by {}`{}`output\PYGZus{}name{}`{}`. It requires a GDAL\PYGZhy{}accesible dataset to collect}
\PYG{l+s+sd}{    the projection and geotransform.}

\PYG{l+s+sd}{    Parameters}
\PYG{l+s+sd}{    \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{l+s+sd}{    output\PYGZus{}name: str}
\PYG{l+s+sd}{        The output filename, with full path and extension if required}
\PYG{l+s+sd}{    raster\PYGZus{}data: array}
\PYG{l+s+sd}{        The array that we want to save}
\PYG{l+s+sd}{    dataset: str}
\PYG{l+s+sd}{        Filename of a GDAL\PYGZhy{}friendly dataset that we want to use to}
\PYG{l+s+sd}{        read geotransform \PYGZam{} projection information}
\PYG{l+s+sd}{    driver: str}
\PYG{l+s+sd}{        A GDAL driver string, like GTiff or HFA.}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}

    \PYG{c}{\PYGZsh{} Open the reference dataset}
    \PYG{n}{g} \PYG{o}{=} \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{Open} \PYG{p}{(} \PYG{n}{dataset} \PYG{p}{)}
    \PYG{c}{\PYGZsh{} Get the Geotransform vector}
    \PYG{n}{geo\PYGZus{}transform} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{GetGeoTransform} \PYG{p}{(}\PYG{p}{)}
    \PYG{n}{x\PYGZus{}size} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{RasterXSize} \PYG{c}{\PYGZsh{} Raster xsize}
    \PYG{n}{y\PYGZus{}size} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{RasterYSize} \PYG{c}{\PYGZsh{} Raster ysize}
    \PYG{n}{srs} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{GetProjectionRef} \PYG{p}{(}\PYG{p}{)} \PYG{c}{\PYGZsh{} Projection}
    \PYG{c}{\PYGZsh{} Need a driver object. By default, we use GeoTIFF}
    \PYG{n}{driver} \PYG{o}{=} \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{GetDriverByName} \PYG{p}{(} \PYG{n}{driver} \PYG{p}{)}
    \PYG{n}{dataset\PYGZus{}out} \PYG{o}{=} \PYG{n}{driver}\PYG{o}{.}\PYG{n}{Create} \PYG{p}{(} \PYG{n}{output\PYGZus{}name}\PYG{p}{,} \PYG{n}{x\PYGZus{}size}\PYG{p}{,} \PYG{n}{y\PYGZus{}size}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYGZbs{}
            \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{GDT\PYGZus{}Float32} \PYG{p}{)}
    \PYG{n}{dataset\PYGZus{}out}\PYG{o}{.}\PYG{n}{SetGeoTransform} \PYG{p}{(} \PYG{n}{geo\PYGZus{}transform} \PYG{p}{)}
    \PYG{n}{dataset\PYGZus{}out}\PYG{o}{.}\PYG{n}{SetProjection} \PYG{p}{(} \PYG{n}{srs} \PYG{p}{)}
    \PYG{n}{dataset\PYGZus{}out}\PYG{o}{.}\PYG{n}{GetRasterBand} \PYG{p}{(} \PYG{l+m+mi}{1} \PYG{p}{)}\PYG{o}{.}\PYG{n}{WriteArray} \PYG{p}{(} \PYGZbs{}
            \PYG{n}{raster\PYGZus{}data}\PYG{o}{.}\PYG{n}{astype}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{float32}\PYG{p}{)} \PYG{p}{)}
    \PYG{n}{dataset\PYGZus{}out} \PYG{o}{=} \PYG{n+nb+bp}{None}
\end{Verbatim}

Now try modifying that method so that you can
\begin{enumerate}
\item {} 
Select the output data type diffrent to Float32

\item {} 
Provide a given projection and geotransform (e.g. if you don't have a
GDAL filename)

\end{enumerate}


\section{Reprojecting things}
\label{Chapter4_GDAL/GDAL_Python_bindings:reprojecting-things}
Previously, we have used the \href{http://landweb.nascom.nasa.gov/cgi-bin/developer/tilemap.cgi}{MODLAND grid
converter}
site to go from latitude/longitude pairs to MODIS projection. However,
in practice, we might want to use a range of different projections, and
convert many points at the same time, so how do we go about that?

In GDAL/OGR, most projection-related tools are in the \code{osr} package,
which needs to be imported like e.g. \code{gdal} itself. The main tools are
the \code{osr.SpatialReference} object, which defines a projection object
(with no projection to start with), and the
\code{osr.CoordinateTransformation} object.

Once you instantiate \code{osr.SpatialReference}, it holds no projection
information. You need to use methods to set it up, using EPSG codes,
Proj4 strings, or whatever. These methods typically start by
\code{ImportFrom} (e.g. \code{ImportFromEPSG}, \code{ImportFromProj4}, ...).

The \code{CoordinateTransformation} requires a source and destination
spatial references that have been configured. Once this is done, it
expose the method \code{TransformPoint} to convert coordinates from the
source to the destination projection.

Let's see how this works by converting some latitude/longitude pairs to
the Ordnance Survey's \href{http://en.wikipedia.org/wiki/Ordnance\_Survey\_National\_Grid}{National
Grid}
projection. The projection is also available in
\href{http://spatialreference.org/ref/epsg/27700/}{spatialreference.org},
where we can gleam its EPSG code (27700). The EPSG code for longitude
latitude is \href{http://spatialreference.org/ref/epsg/4326/}{4326}. Let's
see this in practice:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{osgeo} \PYG{k+kn}{import} \PYG{n}{osr}

\PYG{c}{\PYGZsh{} Define the source projection, WGS84 lat/lon.}
\PYG{n}{wgs84} \PYG{o}{=} \PYG{n}{osr}\PYG{o}{.}\PYG{n}{SpatialReference}\PYG{p}{(} \PYG{p}{)} \PYG{c}{\PYGZsh{} Define a SpatialReference object}
\PYG{n}{wgs84}\PYG{o}{.}\PYG{n}{ImportFromEPSG}\PYG{p}{(} \PYG{l+m+mi}{4326} \PYG{p}{)} \PYG{c}{\PYGZsh{} And set it to WGS84 using the EPSG code}

\PYG{c}{\PYGZsh{} Now for the target projection, Ordnance Survey\PYGZsq{}s British National Grid}
\PYG{n}{osng} \PYG{o}{=} \PYG{n}{osr}\PYG{o}{.}\PYG{n}{SpatialReference}\PYG{p}{(}\PYG{p}{)} \PYG{c}{\PYGZsh{} define the SpatialReference object}
\PYG{c}{\PYGZsh{} In this case, we get the projection from a Proj4 string}
\PYG{n}{osng}\PYG{o}{.}\PYG{n}{ImportFromEPSG}\PYG{p}{(} \PYG{l+m+mi}{27700}\PYG{p}{)}
\PYG{c}{\PYGZsh{} or, if using the proj4 representation}
\PYG{n}{osng}\PYG{o}{.}\PYG{n}{ImportFromProj4} \PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{+proj=tmerc +lat\PYGZus{}0=49 +lon\PYGZus{}0=\PYGZhy{}2 }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYGZbs{}
                      \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{+k=0.9996012717 +x\PYGZus{}0=400000 +y\PYGZus{}0=\PYGZhy{}100000 }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYGZbs{}
                      \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{+ellps=airy +datum=OSGB36 +units=m +no\PYGZus{}defs}\PYG{l+s}{\PYGZdq{}} \PYG{p}{)}


\PYG{c}{\PYGZsh{} Now, we define a coordinate transformtion object, *from* wgs84 *to* OSNG}
\PYG{n}{tx} \PYG{o}{=} \PYG{n}{osr}\PYG{o}{.}\PYG{n}{CoordinateTransformation}\PYG{p}{(} \PYG{n}{wgs84}\PYG{p}{,} \PYG{n}{osng}\PYG{p}{)}
\PYG{c}{\PYGZsh{} We loop over the lines of park\PYGZus{}data,}
\PYG{c}{\PYGZsh{}         using the split method to split by newline characters}
\PYG{n}{park\PYGZus{}name}\PYG{p}{,} \PYG{n}{lon}\PYG{p}{,} \PYG{n}{lat} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Snowdonia national park}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{3.898}\PYG{p}{,}    \PYG{l+m+mf}{52.9}

\PYG{c}{\PYGZsh{} Actually do the transformation using the TransformPoint method}
\PYG{n}{osng\PYGZus{}x}\PYG{p}{,} \PYG{n}{osng\PYGZus{}y}\PYG{p}{,} \PYG{n}{osng\PYGZus{}z} \PYG{o}{=} \PYG{n}{tx}\PYG{o}{.}\PYG{n}{TransformPoint} \PYG{p}{(} \PYG{n}{lon}\PYG{p}{,} \PYG{n}{lat} \PYG{p}{)}
\PYG{c}{\PYGZsh{} Print out}
\PYG{k}{print} \PYG{n}{park\PYGZus{}name}\PYG{p}{,} \PYG{n}{lon}\PYG{p}{,} \PYG{n}{lat}\PYG{p}{,} \PYG{n}{osng\PYGZus{}x}\PYG{p}{,} \PYG{n}{osng\PYGZus{}y}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
Snowdonia national park \PYGZhy{}3.898 52.9 272430.180112 335304.936823
\end{Verbatim}

You can test the result is reasonable by feeding the data for \code{osng\_x}
and \code{osng\_y} in the OS own \href{http://www.ordnancesurvey.co.uk/gps/transformation}{coordinate conversion
website} and
making sure that the calculated longitude latitude pair is the same as
the one you started with.


\section{Reprojecting whole rasters}
\label{Chapter4_GDAL/GDAL_Python_bindings:reprojecting-whole-rasters}

\subsection{Using command line tools}
\label{Chapter4_GDAL/GDAL_Python_bindings:using-command-line-tools}
The easiest way to reproject a raster file is to use GDAL's
\code{{}`gdalwarp} \textless{}\href{http://www.gdal.org/gdalwarp.html}{http://www.gdal.org/gdalwarp.html}\textgreater{}{}`\_\_ tool. As an
example, let's say we want to reproject the landcover file from earlier
on into latitude/longitude (WGS84):

\begin{Verbatim}[commandchars=\\\{\}]
!gdalwarp \PYGZhy{}of GTiff \PYGZhy{}t\PYGZus{}srs \PYGZdq{}EPSG:4326\PYGZdq{} \PYGZhy{}ts 2400 2400 test\PYGZus{}lc\PYGZus{}h17v03.img  lc\PYGZus{}h17v03\PYGZus{}wgs84.tif
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
Output dataset lc\PYGZus{}h17v03\PYGZus{}wgs84.tif exists,
but some commandline options were provided indicating a new dataset
should be created.  Please delete existing dataset and run again.
\end{Verbatim}

We see here that the command takes a number of arguments:
\begin{enumerate}
\item {} 
\code{-of GTiff} is the outut format (in this case GeoTIFF)

\item {} 
\code{-t\_srs "EPSG:4326"} is the \textbf{to} projection (the \textbf{from}
projection is already specified in the source dataset), in this case,
lat/long WGS84, known by its \href{http://spatialreference.org/ref/epsg/4326/}{EPSG
code}

\item {} 
\code{-ts 2400 2400} instructs \code{gdalwarp} to use an output of size
\code{2400*2400}.

\item {} 
\code{test\_lc\_h17v03.img} is the \textbf{input dataset}

\item {} 
\code{lc\_h17v03\_wgs84.tif} is the \textbf{output dataset}

\end{enumerate}

Note that \code{gdalwarp} will reproject the data, and decide on the pixel
size based on some considerations. This can result in the size of the
raster changing. If you wanted to still keep the same raster size, we
use the \code{-ts 2400 2400} option, or select an appropriate pixel size
using \code{-tr xres yres} (note it has to be in the target projection, so
degrees in this case). We can use \code{gdalinfo} to see what we've done.

\begin{Verbatim}[commandchars=\\\{\}]
!gdalinfo test\PYGZus{}lc\PYGZus{}h17v03.img
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
Driver: HFA/Erdas Imagine Images (.img)
Files: test\PYGZus{}lc\PYGZus{}h17v03.img
Size is 2400, 2400
Coordinate System is:
PROJCS[\PYGZdq{}Sinusoidal\PYGZdq{},
    GEOGCS[\PYGZdq{}GCS\PYGZus{}Unknown datum based upon the custom spheroid\PYGZdq{},
        DATUM[\PYGZdq{}Not\PYGZus{}specified\PYGZus{}based\PYGZus{}on\PYGZus{}custom\PYGZus{}spheroid\PYGZdq{},
            SPHEROID[\PYGZdq{}Custom\PYGZus{}spheroid\PYGZdq{},6371007.181,0]],
        PRIMEM[\PYGZdq{}Greenwich\PYGZdq{},0],
        UNIT[\PYGZdq{}Degree\PYGZdq{},0.017453292519943295]],
    PROJECTION[\PYGZdq{}Sinusoidal\PYGZdq{}],
    PARAMETER[\PYGZdq{}longitude\PYGZus{}of\PYGZus{}center\PYGZdq{},0],
    PARAMETER[\PYGZdq{}false\PYGZus{}easting\PYGZdq{},0],
    PARAMETER[\PYGZdq{}false\PYGZus{}northing\PYGZdq{},0],
    UNIT[\PYGZdq{}Meter\PYGZdq{},1]]
Origin = (\PYGZhy{}1111950.519667000044137,6671703.117999999783933)
Pixel Size = (463.312716527916677,\PYGZhy{}463.312716527916507)
Corner Coordinates:
Upper Left  (\PYGZhy{}1111950.520, 6671703.118) ( 20d 0\PYGZsq{} 0.00\PYGZdq{}W, 60d 0\PYGZsq{} 0.00\PYGZdq{}N)
Lower Left  (\PYGZhy{}1111950.520, 5559752.598) ( 15d33\PYGZsq{}26.06\PYGZdq{}W, 50d 0\PYGZsq{} 0.00\PYGZdq{}N)
Upper Right (       0.000, 6671703.118) (  0d 0\PYGZsq{} 0.01\PYGZdq{}E, 60d 0\PYGZsq{} 0.00\PYGZdq{}N)
Lower Right (       0.000, 5559752.598) (  0d 0\PYGZsq{} 0.01\PYGZdq{}E, 50d 0\PYGZsq{} 0.00\PYGZdq{}N)
Center      ( \PYGZhy{}555975.260, 6115727.858) (  8d43\PYGZsq{} 2.04\PYGZdq{}W, 55d 0\PYGZsq{} 0.00\PYGZdq{}N)
Band 1 Block=64x64 Type=Byte, ColorInterp=Undefined
  Description = Layer\PYGZus{}1
  Metadata:
    LAYER\PYGZus{}TYPE=athematic
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
!gdalinfo lc\PYGZus{}h17v03\PYGZus{}wgs84.tif
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
Driver: GTiff/GeoTIFF
Files: lc\PYGZus{}h17v03\PYGZus{}wgs84.tif
Size is 2400, 2400
Coordinate System is:
GEOGCS[\PYGZdq{}WGS 84\PYGZdq{},
    DATUM[\PYGZdq{}WGS\PYGZus{}1984\PYGZdq{},
        SPHEROID[\PYGZdq{}WGS 84\PYGZdq{},6378137,298.257223563,
            AUTHORITY[\PYGZdq{}EPSG\PYGZdq{},\PYGZdq{}7030\PYGZdq{}]],
        AUTHORITY[\PYGZdq{}EPSG\PYGZdq{},\PYGZdq{}6326\PYGZdq{}]],
    PRIMEM[\PYGZdq{}Greenwich\PYGZdq{},0],
    UNIT[\PYGZdq{}degree\PYGZdq{},0.0174532925199433],
    AUTHORITY[\PYGZdq{}EPSG\PYGZdq{},\PYGZdq{}4326\PYGZdq{}]]
Origin = (\PYGZhy{}19.999999994952233,59.999999994611805)
Pixel Size = (0.008333919248404,\PYGZhy{}0.004166959624202)
Metadata:
  AREA\PYGZus{}OR\PYGZus{}POINT=Area
Image Structure Metadata:
  INTERLEAVE=BAND
Corner Coordinates:
Upper Left  ( \PYGZhy{}20.0000000,  60.0000000) ( 20d 0\PYGZsq{} 0.00\PYGZdq{}W, 60d 0\PYGZsq{} 0.00\PYGZdq{}N)
Lower Left  ( \PYGZhy{}20.0000000,  49.9992969) ( 20d 0\PYGZsq{} 0.00\PYGZdq{}W, 49d59\PYGZsq{}57.47\PYGZdq{}N)
Upper Right (   0.0014062,  60.0000000) (  0d 0\PYGZsq{} 5.06\PYGZdq{}E, 60d 0\PYGZsq{} 0.00\PYGZdq{}N)
Lower Right (   0.0014062,  49.9992969) (  0d 0\PYGZsq{} 5.06\PYGZdq{}E, 49d59\PYGZsq{}57.47\PYGZdq{}N)
Center      (  \PYGZhy{}9.9992969,  54.9996484) (  9d59\PYGZsq{}57.47\PYGZdq{}W, 54d59\PYGZsq{}58.73\PYGZdq{}N)
Band 1 Block=2400x3 Type=Byte, ColorInterp=Gray
  Description = Layer\PYGZus{}1
  Metadata:
    LAYER\PYGZus{}TYPE=athematic
\end{Verbatim}

Let's see how different these two datasets are:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{g} \PYG{o}{=} \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{Open} \PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{lc\PYGZus{}h17v03\PYGZus{}wgs84.tif}\PYG{l+s}{\PYGZdq{}} \PYG{p}{)}
\PYG{n}{wgs84} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{ReadAsArray}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{g} \PYG{o}{=} \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{Open}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{test\PYGZus{}lc\PYGZus{}h17v03.img}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{modis} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{ReadAsArray}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplot} \PYG{p}{(} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1} \PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow} \PYG{p}{(} \PYG{n}{modis}\PYG{p}{,} \PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nearest}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{n}{plt}\PYG{o}{.}\PYG{n}{cm}\PYG{o}{.}\PYG{n}{gist\PYGZus{}earth} \PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplot} \PYG{p}{(} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2} \PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow} \PYG{p}{(} \PYG{n}{wgs84}\PYG{p}{,} \PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nearest}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{n}{plt}\PYG{o}{.}\PYG{n}{cm}\PYG{o}{.}\PYG{n}{gist\PYGZus{}earth} \PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.image.AxesImage at 0xe566950\PYGZgt{}
\end{Verbatim}

\includegraphics{GDAL_Python_bindings_39_1.svg}


\subsection{Reprojecting using the Python bindings}
\label{Chapter4_GDAL/GDAL_Python_bindings:reprojecting-using-the-python-bindings}
The previous section demonstrated how you can reproject raster files
using command line tools. Sometimes, you might want to do this from
inside a Python script. Ideally, you would have a python method that
would perform the projection for you. GDAL allows this by defining
in-memory raster files. These are normal GDAL datasets, but that dont
exist on the filesystem, only in the computers memory. They are a
convenient scratchpad for quick intermediate calculations. GDAL also
makes available a function, gdal.ReprojectImage that exposes most of the
abilities of gdalwarp. We shall combine these two tricks to carry out
the reprojection. As an example, we shall look at the case where the
landcover data for the British Isles mentioned in the previous section
needs to be reprojected to the Ordnance Survey National Grid, an
appropriate projection for the UK.

The main complication comes from the need of gdal.ReprojectImage to
operate on GDAL datasets. In the previous section, we saved the data to
a GeoTIFF file, so this gives us a starting dataset. We still need to
create the output dataset. This means that we need to define the
geotransform and size of the output dataset before the projection is
made. This entails gathering information on the extent of the original
dataset, projecting it to the destination projection, and calculating
the number of pixels and geotransform parameters from there. This is a
(heavily commented) function that performs just that task:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{reproject\PYGZus{}dataset} \PYG{p}{(} \PYG{n}{dataset}\PYG{p}{,} \PYGZbs{}
            \PYG{n}{pixel\PYGZus{}spacing}\PYG{o}{=}\PYG{l+m+mf}{463.}\PYG{p}{,} \PYG{n}{epsg\PYGZus{}from}\PYG{o}{=}\PYG{l+m+mi}{4326}\PYG{p}{,} \PYG{n}{epsg\PYGZus{}to}\PYG{o}{=}\PYG{l+m+mi}{27700} \PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    A sample function to reproject and resample a GDAL dataset from within}
\PYG{l+s+sd}{    Python. The idea here is to reproject from one system to another, as well}
\PYG{l+s+sd}{    as to change the pixel size. The procedure is slightly long\PYGZhy{}winded, but}
\PYG{l+s+sd}{    goes like this:}

\PYG{l+s+sd}{    1. Set up the two Spatial Reference systems.}
\PYG{l+s+sd}{    2. Open the original dataset, and get the geotransform}
\PYG{l+s+sd}{    3. Calculate bounds of new geotransform by projecting the UL corners}
\PYG{l+s+sd}{    4. Calculate the number of pixels with the new projection \PYGZam{} spacing}
\PYG{l+s+sd}{    5. Create an in\PYGZhy{}memory raster dataset}
\PYG{l+s+sd}{    6. Perform the projection}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{c}{\PYGZsh{} Define the UK OSNG, see \PYGZlt{}http://spatialreference.org/ref/epsg/27700/\PYGZgt{}}
    \PYG{n}{osng} \PYG{o}{=} \PYG{n}{osr}\PYG{o}{.}\PYG{n}{SpatialReference} \PYG{p}{(}\PYG{p}{)}
    \PYG{n}{osng}\PYG{o}{.}\PYG{n}{ImportFromEPSG} \PYG{p}{(} \PYG{n}{epsg\PYGZus{}to} \PYG{p}{)}
    \PYG{n}{wgs84} \PYG{o}{=} \PYG{n}{osr}\PYG{o}{.}\PYG{n}{SpatialReference} \PYG{p}{(}\PYG{p}{)}
    \PYG{n}{wgs84}\PYG{o}{.}\PYG{n}{ImportFromEPSG} \PYG{p}{(} \PYG{n}{epsg\PYGZus{}from} \PYG{p}{)}
    \PYG{n}{tx} \PYG{o}{=} \PYG{n}{osr}\PYG{o}{.}\PYG{n}{CoordinateTransformation} \PYG{p}{(} \PYG{n}{wgs84}\PYG{p}{,} \PYG{n}{osng} \PYG{p}{)}
    \PYG{c}{\PYGZsh{} Up to here, all  the projection have been defined, as well as a}
    \PYG{c}{\PYGZsh{} transformation from the from to the  to :)}
    \PYG{c}{\PYGZsh{} We now open the dataset}
    \PYG{n}{g} \PYG{o}{=} \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{Open} \PYG{p}{(} \PYG{n}{dataset} \PYG{p}{)}

    \PYG{c}{\PYGZsh{} Get the Geotransform vector}
    \PYG{n}{geo\PYGZus{}t} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{GetGeoTransform} \PYG{p}{(}\PYG{p}{)}
    \PYG{n}{x\PYGZus{}size} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{RasterXSize} \PYG{c}{\PYGZsh{} Raster xsize}
    \PYG{n}{y\PYGZus{}size} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{RasterYSize} \PYG{c}{\PYGZsh{} Raster ysize}

    \PYG{c}{\PYGZsh{} Work out the boundaries of the new dataset in the target projection}
    \PYG{p}{(}\PYG{n}{ulx}\PYG{p}{,} \PYG{n}{uly}\PYG{p}{,} \PYG{n}{ulz} \PYG{p}{)} \PYG{o}{=} \PYG{n}{tx}\PYG{o}{.}\PYG{n}{TransformPoint}\PYG{p}{(} \PYG{n}{geo\PYGZus{}t}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{geo\PYGZus{}t}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}
    \PYG{p}{(}\PYG{n}{lrx}\PYG{p}{,} \PYG{n}{lry}\PYG{p}{,} \PYG{n}{lrz} \PYG{p}{)} \PYG{o}{=} \PYG{n}{tx}\PYG{o}{.}\PYG{n}{TransformPoint}\PYG{p}{(} \PYG{n}{geo\PYGZus{}t}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{+} \PYG{n}{geo\PYGZus{}t}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{*}\PYG{n}{x\PYGZus{}size}\PYG{p}{,} \PYGZbs{}
                                          \PYG{n}{geo\PYGZus{}t}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]} \PYG{o}{+} \PYG{n}{geo\PYGZus{}t}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{o}{*}\PYG{n}{y\PYGZus{}size} \PYG{p}{)}
    \PYG{k}{print} \PYG{n}{ulx}\PYG{p}{,} \PYG{n}{uly}\PYG{p}{,} \PYG{n}{ulz}
    \PYG{k}{print} \PYG{n}{lrx}\PYG{p}{,} \PYG{n}{lry}\PYG{p}{,} \PYG{n}{lrz}
    \PYG{c}{\PYGZsh{} See how using 27700 and WGS84 introduces a z\PYGZhy{}value!}
    \PYG{c}{\PYGZsh{} Now, we create an in\PYGZhy{}memory raster}
    \PYG{n}{mem\PYGZus{}drv} \PYG{o}{=} \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{GetDriverByName}\PYG{p}{(} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MEM}\PYG{l+s}{\PYGZsq{}} \PYG{p}{)}
    \PYG{c}{\PYGZsh{} The size of the raster is given the new projection and pixel spacing}
    \PYG{c}{\PYGZsh{} Using the values we calculated above. Also, setting it to store one band}
    \PYG{c}{\PYGZsh{} and to use Float32 data type.}
    \PYG{n}{dest} \PYG{o}{=} \PYG{n}{mem\PYGZus{}drv}\PYG{o}{.}\PYG{n}{Create}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{int}\PYG{p}{(}\PYG{p}{(}\PYG{n}{lrx} \PYG{o}{\PYGZhy{}} \PYG{n}{ulx}\PYG{p}{)}\PYG{o}{/}\PYG{n}{pixel\PYGZus{}spacing}\PYG{p}{)}\PYG{p}{,} \PYGZbs{}
            \PYG{n+nb}{int}\PYG{p}{(}\PYG{p}{(}\PYG{n}{uly} \PYG{o}{\PYGZhy{}} \PYG{n}{lry}\PYG{p}{)}\PYG{o}{/}\PYG{n}{pixel\PYGZus{}spacing}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{GDT\PYGZus{}Float32}\PYG{p}{)}
    \PYG{c}{\PYGZsh{} Calculate the new geotransform}
    \PYG{n}{new\PYGZus{}geo} \PYG{o}{=} \PYG{p}{(} \PYG{n}{ulx}\PYG{p}{,} \PYG{n}{pixel\PYGZus{}spacing}\PYG{p}{,} \PYG{n}{geo\PYGZus{}t}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYGZbs{}
                \PYG{n}{uly}\PYG{p}{,} \PYG{n}{geo\PYGZus{}t}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{pixel\PYGZus{}spacing} \PYG{p}{)}
    \PYG{c}{\PYGZsh{} Set the geotransform}
    \PYG{n}{dest}\PYG{o}{.}\PYG{n}{SetGeoTransform}\PYG{p}{(} \PYG{n}{new\PYGZus{}geo} \PYG{p}{)}
    \PYG{n}{dest}\PYG{o}{.}\PYG{n}{SetProjection} \PYG{p}{(} \PYG{n}{osng}\PYG{o}{.}\PYG{n}{ExportToWkt}\PYG{p}{(}\PYG{p}{)} \PYG{p}{)}
    \PYG{c}{\PYGZsh{} Perform the projection/resampling}
    \PYG{n}{res} \PYG{o}{=} \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{ReprojectImage}\PYG{p}{(} \PYG{n}{g}\PYG{p}{,} \PYG{n}{dest}\PYG{p}{,} \PYGZbs{}
                \PYG{n}{wgs84}\PYG{o}{.}\PYG{n}{ExportToWkt}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{osng}\PYG{o}{.}\PYG{n}{ExportToWkt}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYGZbs{}
                \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{GRA\PYGZus{}Bilinear} \PYG{p}{)}
    \PYG{k}{return} \PYG{n}{dest}
\end{Verbatim}

The function returns a GDAL in-memory file object, where you can
\code{ReadAsArray} etc. As it stands, \code{reproject\_dataset} does not write
to disk. However, we can save the in-memory raster to any format
supported by GDAL very conveniently by making a copy of the dataset.
This takes a few lines of code:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} Do in memory reprojection}
\PYG{n}{reprojected\PYGZus{}dataset} \PYG{o}{=} \PYG{n}{reproject\PYGZus{}dataset} \PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{lc\PYGZus{}h17v03\PYGZus{}wgs84.tif}\PYG{l+s}{\PYGZdq{}} \PYG{p}{)}
\PYG{c}{\PYGZsh{} Output driver, as before}
\PYG{n}{driver} \PYG{o}{=} \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{GetDriverByName} \PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{GTiff}\PYG{l+s}{\PYGZdq{}} \PYG{p}{)}
\PYG{c}{\PYGZsh{} Create a copy of the in memory dataset {}`reprojected\PYGZus{}dataset{}`, and save it}
\PYG{n}{dst\PYGZus{}ds} \PYG{o}{=} \PYG{n}{driver}\PYG{o}{.}\PYG{n}{CreateCopy}\PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{test\PYGZus{}lc\PYGZus{}h17v03\PYGZus{}OSNG.tif}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{reprojected\PYGZus{}dataset}\PYG{p}{,} \PYG{l+m+mi}{0} \PYG{p}{)}
\PYG{n}{dst\PYGZus{}ds} \PYG{o}{=} \PYG{n+nb+bp}{None} \PYG{c}{\PYGZsh{} Flush the dataset to disk}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZhy{}595472.202548 1261034.77555 \PYGZhy{}55.2326775854
543532.18509 12933.1712342 \PYGZhy{}43.993001678
\end{Verbatim}

Let's see how the different projections look like by plotting them side
by side

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplot} \PYG{p}{(} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{1} \PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MODIS sinusoidal}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow} \PYG{p}{(} \PYG{n}{modis}\PYG{p}{,} \PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nearest}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{n}{plt}\PYG{o}{.}\PYG{n}{cm}\PYG{o}{.}\PYG{n}{gist\PYGZus{}earth} \PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplot} \PYG{p}{(} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{2} \PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow} \PYG{p}{(} \PYG{n}{wgs84}\PYG{p}{,} \PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nearest}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{n}{plt}\PYG{o}{.}\PYG{n}{cm}\PYG{o}{.}\PYG{n}{gist\PYGZus{}earth} \PYG{p}{)}
\PYG{n}{g} \PYG{o}{=} \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{Open}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{test\PYGZus{}lc\PYGZus{}h17v03\PYGZus{}OSNG.tif}\PYG{l+s}{\PYGZdq{}} \PYG{p}{)}
\PYG{n}{osng} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{ReadAsArray}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{WGS84, Lat/Long}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplot} \PYG{p}{(} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{3} \PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow} \PYG{p}{(} \PYG{n}{osng}\PYG{p}{,} \PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nearest}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{n}{plt}\PYG{o}{.}\PYG{n}{cm}\PYG{o}{.}\PYG{n}{gist\PYGZus{}earth} \PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{OSNG}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.text.Text at 0x2b9eac0b4ed0\PYGZgt{}
\end{Verbatim}

\includegraphics{GDAL_Python_bindings_46_1.svg}


\chapter{Working with vector data: OGR}
\label{Chapter4_GDAL/OGR_Python:working-with-vector-data-ogr}\label{Chapter4_GDAL/OGR_Python::doc}

\section{Vector data}
\label{Chapter4_GDAL/OGR_Python:vector-data}
Sometimes, geospatial data is acquired and recorded for particular
geometric objects such as polygons or lines. An example is a road
layout, where each road is represented as a geometric object (a line,
with points given in a geographical projection), with a number of added
\emph{features} associated with it, such as the road name, whether it is a
toll road, or whether it is dual-carriageway, etc. This data is quite
different to a raster, where the entire scene is tessellated into
pixels, and each pixel holds a value (or an array of value in the case
of multiband rasterfiles).

If you are familiar with databases, vector files are effectively a
database, where one of the fields is a geometry object (a line in our
previous road example, or a polygon if you consider a cadastral system).
We can thus select different records by writing queries on the features.
Some of these queries might be spatial (e.g. check whether a point is
inside a particular country polygon).

The most common format for vector data is the \textbf{ESRI Shapfile}, which
is a multifile format (i.e., several files are needed in order to access
the data). We'll start by getting hold of a shapefile that contains the
countries of the world as polygons, together with information on country
name, capital name, population, etc. The file is available
\href{http://aprsworld.net/gisdata/world/world.zip}{here}.
\begin{figure}[htbp]
\centering
\capstart
\caption{World}\end{figure}

We will download the file with \code{wget} (or \code{curl} if you want to),
and uncompress it using \code{unzip} in the shell:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{} Downloads the data using wget
!wget http://aprsworld.net/gisdata/world/world.zip
\PYGZsh{} or if you want to use curl...
\PYGZsh{}! curl http://aprsworld.net/gisdata/world/world.zip \PYGZhy{}o world.zip
!unzip \PYGZhy{}o \PYGZhy{}x world.zip
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZhy{}\PYGZhy{}2013\PYGZhy{}10\PYGZhy{}22 15:47:43\PYGZhy{}\PYGZhy{}  http://aprsworld.net/gisdata/world/world.zip
Resolving aprsworld.net... 72.251.203.219
Connecting to aprsworld.net\textbar{}72.251.203.219\textbar{}:80... connected.
HTTP request sent, awaiting response... 200 OK
Length: 3436277 (3.3M) [application/zip]
Saving to: {}`world.zip.1\PYGZsq{}

100\PYGZpc{}[======================================\PYGZgt{}] 3,436,277   3.28M/s   in 1.0s

2013\PYGZhy{}10\PYGZhy{}22 15:47:45 (3.28 MB/s) \PYGZhy{} {}`world.zip.1\PYGZsq{} saved [3436277/3436277]

Archive:  world.zip
  inflating: world.dbf
  inflating: world.shp
  inflating: world.shx
\end{Verbatim}

We need to import \code{ogr}, and then open the file. As with GDAL, we get
a handler to the file, (\code{g} in this case). OGR files can have
different layers, although Shapefiles only have one. We need to select
the layer using \code{GetLayer(0)} (selecting the first layer).

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{osgeo} \PYG{k+kn}{import} \PYG{n}{ogr}

\PYG{n}{g} \PYG{o}{=} \PYG{n}{ogr}\PYG{o}{.}\PYG{n}{Open}\PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{world.shp}\PYG{l+s}{\PYGZdq{}} \PYG{p}{)}
\PYG{n}{layer} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{GetLayer}\PYG{p}{(} \PYG{l+m+mi}{0} \PYG{p}{)}
\end{Verbatim}

In order to see a field (the field \code{NAME}) we can loop over the
features in the layer, and use the \code{GetField('NAME')} method. We'll
only do ten features here:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{n\PYGZus{}feat} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{k}{for} \PYG{n}{feat} \PYG{o+ow}{in} \PYG{n}{layer}\PYG{p}{:}

    \PYG{k}{print} \PYG{n}{feat}\PYG{o}{.}\PYG{n}{GetField}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{NAME}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

    \PYG{n}{n\PYGZus{}feat} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
    \PYG{k}{if} \PYG{n}{n\PYGZus{}feat} \PYG{o}{==} \PYG{l+m+mi}{10}\PYG{p}{:}
        \PYG{k}{break}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
GUATEMALA
BOLIVIA
PARAGUAY
URUGUAY
SURINAME
FRENCH GUIANA
WESTERN SAHARA
GAMBIA
MOROCCO
MALI
\end{Verbatim}

If you wanted to see the different layers, we could do this using:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{layerDefinition} \PYG{o}{=} \PYG{n}{layer}\PYG{o}{.}\PYG{n}{GetLayerDefn}\PYG{p}{(}\PYG{p}{)}


\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{layerDefinition}\PYG{o}{.}\PYG{n}{GetFieldCount}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Field }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{: }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{p}{(} \PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{layerDefinition}\PYG{o}{.}\PYG{n}{GetFieldDefn}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{o}{.}\PYG{n}{GetName}\PYG{p}{(}\PYG{p}{)} \PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
Field 1: NAME
Field 2: CAPITAL
Field 3: APPROX
Field 4: AREA
Field 5: SOURCETHM
\end{Verbatim}

Each feature, in addition to the fields shown agove, will have a
\code{Geometry} field. We get a handle to this using the
\code{GetGeometryRef()} method. Geometries have many methods, such as
\code{ExportToKML()} to export to KML (Google Maps/Earth format):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{the\PYGZus{}geometry} \PYG{o}{=} \PYG{n}{feat}\PYG{o}{.}\PYG{n}{GetGeometryRef}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{the\PYGZus{}geometry}\PYG{o}{.}\PYG{n}{ExportToKML}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZlt{}Polygon\PYGZgt{}\PYGZlt{}outerBoundaryIs\PYGZgt{}\PYGZlt{}LinearRing\PYGZgt{}\PYGZlt{}coordinates\PYGZgt{}\PYGZhy{}12.0443,14.669667 \PYGZhy{}11.87845,14.8252 \PYGZhy{}11.76455,15.039033 \PYGZhy{}11.63345,15.335633 \PYGZhy{}11.58515,15.634533 \PYGZhy{}11.52995,15.6713 \PYGZhy{}11.34705,15.6736 \PYGZhy{}11.26425,15.6529 \PYGZhy{}11.2125,15.549433 \PYGZhy{}11.1849,15.3092 \PYGZhy{}11.0503,15.097667 \PYGZhy{}10.9675,15.086167 \PYGZhy{}10.53275,15.365533 \PYGZhy{}9.70465,15.364367 \PYGZhy{}9.52175,15.373567 \PYGZhy{}9.4631,15.440233 \PYGZhy{}9.43205,15.619567 \PYGZhy{}9.37685,15.658667 \PYGZhy{}9.13185,15.656367 \PYGZhy{}9.1385,15.489433 \PYGZhy{}8.1165,15.487567 \PYGZhy{}6.83415,15.504167 \PYGZhy{}5.513,15.483867 \PYGZhy{}5.25265,16.2627 \PYGZhy{}5.2693,16.3033 \PYGZhy{}5.58505,16.439867 \PYGZhy{}5.63765,16.5635 \PYGZhy{}5.7623,17.728033 \PYGZhy{}5.8814,18.589933 \PYGZhy{}6.02265,19.525633 \PYGZhy{}6.1362,20.697567 \PYGZhy{}6.3107,21.8621 \PYGZhy{}6.4575,22.952833 \PYGZhy{}6.4686,23.543433 \PYGZhy{}6.52675,23.8627 \PYGZhy{}6.7123,24.997733 \PYGZhy{}5.05065,24.9834 \PYGZhy{}5.00065,24.982967 \PYGZhy{}4.51805,24.628633 \PYGZhy{}2.77295,23.4557 \PYGZhy{}2.17905,23.0869 \PYGZhy{}1.6281,22.7265 \PYGZhy{}0.5692,22.030967 0.6009,21.241133 1.0281,21.001933 1.10095,20.985233 1.21475,20.9807 1.21475,20.807767 1.24435,20.7486 1.40825,20.609033 1.5517,20.5514 1.6678,20.3724 1.9421,20.185067 2.0514,20.172933 2.2221,20.168367 2.27785,20.157 2.3348,20.1312 2.4031,20.028033 2.4486,20.009833 2.6307,19.971933 2.8208,19.887733 3.12355,19.778533 3.21345,19.6458 3.19755,19.4501 3.15885,19.3242 3.10535,19.174767 3.13495,19.065567 3.2738,18.875933 3.3091,18.853933 3.3774,18.852433 3.52535,18.9131 3.82355,18.996533 4.34825,19.149 4.34725,19.115667 4.3451,19.045533 4.29825,18.466367 4.23895,17.8664 4.1984,17.276833 4.1766,16.666467 4.1423,16.331633 3.97065,16.208933 3.8864,16.099767 3.85205,15.8315 3.8146,15.700467 3.6305,15.5809 3.4245,15.5081 3.07805,15.428033 2.75035,15.396833 2.3197,15.323 2.10435,15.2731 1.8297,15.216967 1.62995,15.213833 1.41145,15.120267 1.05565,15.0402 0.8809,15.046433 0.6905,15.0402 0.61245,14.965333 0.52195,14.890467 0.419,14.856167 0.238,14.858267 0.1196,14.8782 \PYGZhy{}0.2863,15.048533 \PYGZhy{}0.614,15.108833 \PYGZhy{}0.75445,15.1109 \PYGZhy{}0.82935,15.094267 \PYGZhy{}0.94485,15.018367 \PYGZhy{}1.285,14.7418 \PYGZhy{}1.4754,14.625333 \PYGZhy{}1.6439,14.5723 \PYGZhy{}1.94035,14.462067 \PYGZhy{}2.16195,14.312333 \PYGZhy{}2.24625,14.2094 \PYGZhy{}2.3118,14.0472 \PYGZhy{}2.42415,13.939067 \PYGZhy{}2.69255,13.824667 \PYGZhy{}2.77995,13.596967 \PYGZhy{}3.1014,13.524167 \PYGZhy{}3.3573,13.452433 \PYGZhy{}3.53205,13.248633 \PYGZhy{}3.6725,13.2341 \PYGZhy{}3.84105,13.232 \PYGZhy{}4.0564,13.2653 \PYGZhy{}4.1001,13.256967 \PYGZhy{}4.22805,13.0386 \PYGZhy{}4.24135,12.8486 \PYGZhy{}4.5398,12.277633 \PYGZhy{}4.72495,12.088433 \PYGZhy{}4.7833,12.04 \PYGZhy{}4.8209,12.017533 \PYGZhy{}4.8687,12.0 \PYGZhy{}5.03205,11.943633 \PYGZhy{}5.40485,11.807433 \PYGZhy{}5.4576,11.7805 \PYGZhy{}5.46435,11.758033 \PYGZhy{}5.39025,11.609867 \PYGZhy{}5.38015,11.431733 \PYGZhy{}5.43175,11.337433 \PYGZhy{}5.443,11.246133 \PYGZhy{}5.39135,11.051533 \PYGZhy{}5.40035,10.9767 \PYGZhy{}5.5171,10.836 \PYGZhy{}5.52835,10.806067 \PYGZhy{}5.5073,10.733367 \PYGZhy{}5.5285,10.681033 \PYGZhy{}5.5168,10.6259 \PYGZhy{}5.46805,10.575 \PYGZhy{}5.4553,10.5029 \PYGZhy{}5.46805,10.409567 \PYGZhy{}5.50265,10.376233 \PYGZhy{}5.5873,10.2946 \PYGZhy{}5.72715,10.208567 \PYGZhy{}5.8078,10.1817 \PYGZhy{}5.96645,10.1602 \PYGZhy{}6.0444,10.1602 \PYGZhy{}6.13045,10.187067 \PYGZhy{}6.1466,10.212167 \PYGZhy{}6.1466,10.260567 \PYGZhy{}6.0928,10.3466 \PYGZhy{}6.13855,10.4595 \PYGZhy{}6.17615,10.486367 \PYGZhy{}6.20305,10.486367 \PYGZhy{}6.238,10.477433 \PYGZhy{}6.2837,10.429033 \PYGZhy{}6.3469,10.4165 \PYGZhy{}6.40875,10.421867 \PYGZhy{}6.5405,10.4595 \PYGZhy{}6.5835,10.450533 \PYGZhy{}6.6319,10.423667 \PYGZhy{}6.6561,10.3878 \PYGZhy{}6.66415,10.307167 \PYGZhy{}6.7018,10.267733 \PYGZhy{}6.74755,10.256967 \PYGZhy{}6.8228,10.256967 \PYGZhy{}6.87255,10.239033 \PYGZhy{}6.9801,10.151233 \PYGZhy{}7.06885,10.1315 \PYGZhy{}7.20595,10.1315 \PYGZhy{}7.30005,10.1602 \PYGZhy{}7.33095,10.194267 \PYGZhy{}7.35785,10.310767 \PYGZhy{}7.41165,10.341233 \PYGZhy{}7.45735,10.353767 \PYGZhy{}7.7101,10.351967 \PYGZhy{}7.7531,10.4882 \PYGZhy{}7.8284,10.525833 \PYGZhy{}7.9427,10.529433 \PYGZhy{}8.19545,10.5366 \PYGZhy{}8.26805,10.545533 \PYGZhy{}8.33525,10.5814 \PYGZhy{}8.3339,10.619033 \PYGZhy{}8.28015,10.7176 \PYGZhy{}8.17795,10.921933 \PYGZhy{}8.20755,10.9524 \PYGZhy{}8.3124,10.982867 \PYGZhy{}8.385,10.9739 \PYGZhy{}8.42265,10.947033 \PYGZhy{}8.51945,10.807233 \PYGZhy{}8.627,10.771367 \PYGZhy{}8.67,10.7696 \PYGZhy{}8.68615,10.783933 \PYGZhy{}8.68615,10.8162 \PYGZhy{}8.6458,10.889667 \PYGZhy{}8.6458,10.904 \PYGZhy{}8.68885,10.9273 \PYGZhy{}8.6915,10.9775 \PYGZhy{}8.68615,11.038433 \PYGZhy{}8.666,11.102967 \PYGZhy{}8.6176,11.149567 \PYGZhy{}8.28955,11.3449 \PYGZhy{}8.4401,11.4435 \PYGZhy{}8.77625,11.5761 \PYGZhy{}8.86635,11.6263 \PYGZhy{}8.8986,11.674667 \PYGZhy{}8.88245,11.7123 \PYGZhy{}8.76415,11.8969 \PYGZhy{}8.748,11.998 \PYGZhy{}8.75615,12.0537 \PYGZhy{}8.9702,12.136333 \PYGZhy{}8.90365,12.335867 \PYGZhy{}9.1426,12.388267 \PYGZhy{}9.36645,12.279433 \PYGZhy{}9.7355,12.1323 \PYGZhy{}9.80655,12.0866 \PYGZhy{}9.96635,12.0 \PYGZhy{}10.0388,11.958267 \PYGZhy{}10.1407,11.925833 \PYGZhy{}10.31445,11.925867 \PYGZhy{}10.3944,11.966 \PYGZhy{}10.4546,11.986067 \PYGZhy{}10.4917,11.987633 \PYGZhy{}10.5241,11.975267 \PYGZhy{}10.5465,11.9559 \PYGZhy{}10.5583,11.948633 \PYGZhy{}10.56825,11.944533 \PYGZhy{}10.5777,11.943933 \PYGZhy{}10.58715,11.9458 \PYGZhy{}10.6018,11.9581 \PYGZhy{}10.6155,11.973867 \PYGZhy{}10.6342,12.0 \PYGZhy{}10.6706,12.034 \PYGZhy{}10.6969,12.058533 \PYGZhy{}10.72995,12.058533 \PYGZhy{}10.8209,12.019967 \PYGZhy{}10.8457,12.019967 \PYGZhy{}10.8953,12.053 \PYGZhy{}10.92835,12.149433 \PYGZhy{}10.91185,12.3257 \PYGZhy{}10.9201,12.3615 \PYGZhy{}10.97385,12.358733 \PYGZhy{}11.12265,12.237567 \PYGZhy{}11.17225,12.033733 \PYGZhy{}11.4244,12.141167 \PYGZhy{}11.56495,12.254067 \PYGZhy{}11.60215,12.303667 \PYGZhy{}11.3913,12.429 \PYGZhy{}11.4946,12.489567 \PYGZhy{}11.4326,12.610767 \PYGZhy{}11.5401,12.6824 \PYGZhy{}11.5649,12.7237 \PYGZhy{}11.57315,12.756767 \PYGZhy{}11.4905,12.988133 \PYGZhy{}11.5194,13.096933 \PYGZhy{}11.7385,13.336567 \PYGZhy{}11.8625,13.325567 \PYGZhy{}11.9989,13.344833 \PYGZhy{}12.08155,13.416433 \PYGZhy{}12.08985,13.4798 \PYGZhy{}12.0774,13.866767 \PYGZhy{}12.0443,14.669667\PYGZlt{}/coordinates\PYGZgt{}\PYGZlt{}/LinearRing\PYGZgt{}\PYGZlt{}/outerBoundaryIs\PYGZgt{}\PYGZlt{}/Polygon\PYGZgt{}}\PYG{l+s}{\PYGZsq{}}
\end{Verbatim}

Many of the methods that don't start with \code{\_\_} are interesting. Let's
see what these are. typically, the interesting methods start with an
upper case letter, so we'll only show those:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{m} \PYG{o+ow}{in} \PYG{n+nb}{dir} \PYG{p}{(} \PYG{n}{the\PYGZus{}geometry} \PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{m}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{isupper}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{print} \PYG{n}{m}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{AddGeometry}
\PYG{n}{AddGeometryDirectly}
\PYG{n}{AddPoint}
\PYG{n}{AddPoint\PYGZus{}2D}
\PYG{n}{Area}
\PYG{n}{AssignSpatialReference}
\PYG{n}{Boundary}
\PYG{n}{Buffer}
\PYG{n}{Centroid}
\PYG{n}{Clone}
\PYG{n}{CloseRings}
\PYG{n}{Contains}
\PYG{n}{ConvexHull}
\PYG{n}{Crosses}
\PYG{n}{Destroy}
\PYG{n}{Difference}
\PYG{n}{Disjoint}
\PYG{n}{Distance}
\PYG{n}{Empty}
\PYG{n}{Equal}
\PYG{n}{Equals}
\PYG{n}{ExportToGML}
\PYG{n}{ExportToJson}
\PYG{n}{ExportToKML}
\PYG{n}{ExportToWkb}
\PYG{n}{ExportToWkt}
\PYG{n}{FlattenTo2D}
\PYG{n}{GetArea}
\PYG{n}{GetBoundary}
\PYG{n}{GetCoordinateDimension}
\PYG{n}{GetDimension}
\PYG{n}{GetEnvelope}
\PYG{n}{GetEnvelope3D}
\PYG{n}{GetGeometryCount}
\PYG{n}{GetGeometryName}
\PYG{n}{GetGeometryRef}
\PYG{n}{GetGeometryType}
\PYG{n}{GetPoint}
\PYG{n}{GetPointCount}
\PYG{n}{GetPoint\PYGZus{}2D}
\PYG{n}{GetPoints}
\PYG{n}{GetSpatialReference}
\PYG{n}{GetX}
\PYG{n}{GetY}
\PYG{n}{GetZ}
\PYG{n}{Intersect}
\PYG{n}{Intersection}
\PYG{n}{Intersects}
\PYG{n}{IsEmpty}
\PYG{n}{IsRing}
\PYG{n}{IsSimple}
\PYG{n}{IsValid}
\PYG{n}{Length}
\PYG{n}{Overlaps}
\PYG{n}{PointOnSurface}
\PYG{n}{Segmentize}
\PYG{n}{SetCoordinateDimension}
\PYG{n}{SetPoint}
\PYG{n}{SetPoint\PYGZus{}2D}
\PYG{n}{Simplify}
\PYG{n}{SimplifyPreserveTopology}
\PYG{n}{SymDifference}
\PYG{n}{SymmetricDifference}
\PYG{n}{Touches}
\PYG{n}{Transform}
\PYG{n}{TransformTo}
\PYG{n}{Union}
\PYG{n}{UnionCascaded}
\PYG{n}{Within}
\PYG{n}{WkbSize}
\end{Verbatim}

You'll notice that many of these mechanisms e.g. \code{Overlaps} or
\code{Touches} are effectively geoprocessing operations (they operate on
geometries and return \code{True} if one geometry overlaps or touches,
respectively, the other). Other operations, such as \code{Buffer} return a
buffered version of the same geometry. This allows you to actually do
fairly complicated geoprocessing operations with OGR. However, if you
want to do geoprocessing in earnest, you should really be using
\href{http://toblerity.org/shapely/manual.html}{Shapely}.

A particularly useful webpage for this section is \href{http://pcjericks.github.io/py-gdalogr-cookbook/}{available in the OGR
cookbook}. Have a
look through that if you want more in depth information.


\section{Selecting attributes and/or data extents}
\label{Chapter4_GDAL/OGR_Python:selecting-attributes-and-or-data-extents}
OGR provides an easy way to select attributes on a given layer. This is
done using a SQL-like syntax (you can read more on \href{http://www.gdal.org/ogr/ogr\_sql.html}{OGR's SQL subset
here}. The main point is that
the \emph{attribute filter} is applied to a complete layer. For example,
let's say that we want to select only countries with a population (field
APPROX) larger than 90 000 000 inhabitants:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{g} \PYG{o}{=} \PYG{n}{ogr}\PYG{o}{.}\PYG{n}{Open} \PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{world.shp}\PYG{l+s}{\PYGZdq{}} \PYG{p}{)}
\PYG{n}{lyr} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{GetLayer}\PYG{p}{(} \PYG{l+m+mi}{0} \PYG{p}{)}
\PYG{n}{lyr}\PYG{o}{.}\PYG{n}{SetAttributeFilter} \PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{APPROX \PYGZgt{} 90000000}\PYG{l+s}{\PYGZdq{}} \PYG{p}{)}
\PYG{k}{for} \PYG{n}{feat} \PYG{o+ow}{in} \PYG{n}{lyr}\PYG{p}{:}
    \PYG{k}{print} \PYG{n}{feat}\PYG{o}{.}\PYG{n}{GetFieldAsString} \PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{NAME}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ has }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{ inhabitants}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYGZbs{}
        \PYG{n}{feat}\PYG{o}{.}\PYG{n}{GetFieldAsInteger}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{APPROX}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
PAKISTAN has 123490000 inhabitants
JAPAN has 124710000 inhabitants
RUSSIAN FEDERATION has 150500000 inhabitants
INDIA has 873850000 inhabitants
BANGLADESH has 120850000 inhabitants
BRAZIL has 159630000 inhabitants
NIGERIA has 91700000 inhabitants
CHINA has 1179030000 inhabitants
INDONESIA has 186180000 inhabitants
JOHNSTON ATOLL has 256420000 inhabitants
KINGMAN REEF \PYGZhy{} PALMYRA ATOLL has 256420000 inhabitants
UNITED STATES has 256420000 inhabitants
\end{Verbatim}

So we get a list of popoulous countries (note that Johnston Atoll and
Palmyra are part of the US, and report the sample popuation as the US!)

An additional way to filter the data is by geographical extent. Let's
say we wanted a list of all the countries in (broadly speaking) Europe,
\emph{i.e.} a geographical extent in longitude from 14W to 37E, and in
latitude from 72N to 38N. We can use \code{SetSpatialFilterRect} to do
this:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{g} \PYG{o}{=} \PYG{n}{ogr}\PYG{o}{.}\PYG{n}{Open} \PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{world.shp}\PYG{l+s}{\PYGZdq{}} \PYG{p}{)}
\PYG{n}{lyr} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{GetLayer}\PYG{p}{(} \PYG{l+m+mi}{0} \PYG{p}{)}
\PYG{n}{lyr}\PYG{o}{.}\PYG{n}{SetSpatialFilterRect} \PYG{p}{(} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{14}\PYG{p}{,} \PYG{l+m+mi}{37}\PYG{p}{,} \PYG{l+m+mi}{38}\PYG{p}{,} \PYG{l+m+mi}{72}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{feat} \PYG{o+ow}{in} \PYG{n}{lyr}\PYG{p}{:}
    \PYG{k}{print} \PYG{n}{feat}\PYG{o}{.}\PYG{n}{GetFieldAsString} \PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{NAME}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{feat}\PYG{o}{.}\PYG{n}{GetFieldAsString} \PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{CAPITAL}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
ALGERIA \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} ALGIERS
BELGIUM \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} BRUSSELS
LUXEMBOURG \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} LUXEMBOURG
SAN MARINO \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} SAN MARINO
AUSTRIA \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} VIENNA
CZECH REPUBLIC \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} PRAGUE
SLOVENIA \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} LJUBLJANA
HUNGARY \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} BUDAPEST
SLOVAKIA \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} BRATISLAVA
YUGOSLAVIA \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} BELGRADE [BEOGRADE]
BOSNIA AND HERZEGOVINA \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} SARAJEVO
ALBANIA \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} TIRANE
MACEDONIA, THE FORMER YUGOSLAV REPUBLIC \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} SKOPJE
LITHUANIA \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} VILNIUS
LATVIA \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} RIGA
BULGARIA \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} SOFIA
BELARUS \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} MINSK
MOLDOVA, REPUBLIC OF \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} KISHINEV
IRELAND \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} DUBLIN
ICELAND \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} REYKJAVIK
SPAIN \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} MADRID
SWEDEN \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} STOCKHOLM
FINLAND \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} HELSINKI
TURKEY \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} ANKARA
RUSSIAN FEDERATION \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} MOSCOW
GREECE \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} ATHENS
PORTUGAL \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} LISBON
POLAND \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} WARSAW
NORWAY \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} OSLO
GERMANY \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} BERLIN
ESTONIA \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} TALLINN
TUNISIA \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} TUNIS
CROATIA \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} ZAGREB
ROMANIA \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} BUCURESTI
UKRAINE \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} KIEV
NETHERLANDS \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} AMSTERDAM
JERSEY \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} SAINT HELIER
GUERNSEY \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} SAINT PETER PORT
FAROE ISLANDS \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} TORSHAVN
DENMARK \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} COPENHAGEN
MONACO \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} MONACO
ANDORRA \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} ANDORRA LA VELLA
LIECHTENSTEIN \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} VADUZ
SWITZERLAND \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} BERN
ISLE OF MAN \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} DOUGLAS
UNITED KINGDOM \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} LONDON
FRANCE \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} PARIS
VATICAN CITY (HOLY SEE) \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} VATICAN CITY
ITALY \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} ROME
\end{Verbatim}


\section{Saving a vector file}
\label{Chapter4_GDAL/OGR_Python:saving-a-vector-file}
Saving a vector file using OGR requires a number of steps:
\begin{enumerate}
\item {} 
Definition of the format

\item {} 
Definition of the layer projection and geometry type (e.g. lines,
polygons...)

\item {} 
Definition of the data type of the different fields

\item {} 
Creation of a feature, population of the different fields, and
setting a geometry

\item {} 
Addition of the feature to the layer

\item {} 
Destruction of the feature

\end{enumerate}

This appears quite involved, but let's see how this works. Note that
when you generate a new vector file, OGR will fail if the file already
exists. You might want to use \code{os.remove()} to get rid of the file if
it exists.

Let's see how this is done with an example which is a snippet that
creates a GeoJSON file with the location of the different national
parks. GeoJSON is a nice geographic format, and \href{https://github.com/blog/1528-there-s-a-map-for-that}{github allows you to
display it easily as a
map}.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} National park information, separated by TABs}
\PYG{k+kn}{import} \PYG{n+nn}{os}
\PYG{k+kn}{from} \PYG{n+nn}{osgeo} \PYG{k+kn}{import} \PYG{n}{ogr}\PYG{p}{,}\PYG{n}{osr}


\PYG{n}{parks} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}\PYG{l+s}{Dartmoor national park}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZhy{}3.904}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{50.58}
\PYG{l+s}{New forest national park}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZhy{}1.595}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{50.86}
\PYG{l+s}{Exmoor national park}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZhy{}3.651}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{51.14}
\PYG{l+s}{Pembrokeshire coast national park}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZhy{}4.694}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{51.64}
\PYG{l+s}{Brecon beacons national park}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZhy{}3.432}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{51.88}
\PYG{l+s}{Pembrokeshire coast national park}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZhy{}4.79}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{51.99}
\PYG{l+s}{Norfolk and suffolk broads}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{1.569}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{52.62}
\PYG{l+s}{Snowdonia national park}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZhy{}3.898}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{52.9}
\PYG{l+s}{Peak district national park}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZhy{}1.802}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{53.3}
\PYG{l+s}{Yorkshire dales national park}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZhy{}2.157}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{54.23}
\PYG{l+s}{North yorkshire moors national park}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZhy{}0.8855}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{54.37}
\PYG{l+s}{Lake district national park}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZhy{}3.084}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{54.47}
\PYG{l+s}{Galloway forest park}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZhy{}4.171}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{54.87}
\PYG{l+s}{Northumberland national park}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZhy{}2.228}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{55.28}
\PYG{l+s}{Loch lomond and the trossachs national park}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZhy{}4.593}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{56.24}
\PYG{l+s}{Tay forest park}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZhy{}4.025}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{56.59}
\PYG{l+s}{Cairngorms national park}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZhy{}3.545}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{57.08}\PYG{l+s}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}

\PYG{c}{\PYGZsh{} See if the file exists from a previous run of this snippet}
\PYG{k}{if} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{exists} \PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{parks.json}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{:}
    \PYG{c}{\PYGZsh{} It does exist, so remove it}
    \PYG{n}{os}\PYG{o}{.}\PYG{n}{remove} \PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{parks.json}\PYG{l+s}{\PYGZdq{}} \PYG{p}{)}

\PYG{c}{\PYGZsh{} We need the output projection to bet set to Lat/Long}
\PYG{n}{latlong} \PYG{o}{=} \PYG{n}{osr}\PYG{o}{.}\PYG{n}{SpatialReference}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{latlong}\PYG{o}{.}\PYG{n}{ImportFromEPSG}\PYG{p}{(} \PYG{l+m+mi}{4326} \PYG{p}{)}

\PYG{c}{\PYGZsh{} Invoke the GeoJSON driver}
\PYG{n}{drv} \PYG{o}{=} \PYG{n}{ogr}\PYG{o}{.}\PYG{n}{GetDriverByName}\PYG{p}{(} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{GeoJSON}\PYG{l+s}{\PYGZsq{}} \PYG{p}{)}
\PYG{c}{\PYGZsh{} This is the output filename}
\PYG{n}{dst\PYGZus{}ds} \PYG{o}{=} \PYG{n}{drv}\PYG{o}{.}\PYG{n}{CreateDataSource}\PYG{p}{(} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{parks.json}\PYG{l+s}{\PYGZsq{}} \PYG{p}{)}
\PYG{c}{\PYGZsh{} This is a single layer dataset. The layer needs to be of points}
\PYG{c}{\PYGZsh{} and needs to have the WGS84 projection, which we defined above}
\PYG{n}{dst\PYGZus{}layer} \PYG{o}{=} \PYG{n}{dst\PYGZus{}ds}\PYG{o}{.}\PYG{n}{CreateLayer}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{srs} \PYG{o}{=}\PYG{n}{latlong} \PYG{p}{,} \PYGZbs{}
                               \PYG{n}{geom\PYGZus{}type}\PYG{o}{=}\PYG{n}{ogr}\PYG{o}{.}\PYG{n}{wkbPoint} \PYG{p}{)}

\PYG{c}{\PYGZsh{} We just need a field with the Park\PYGZsq{}s name, and its type is a String}
\PYG{n}{field\PYGZus{}defn}\PYG{o}{=}\PYG{n}{ogr}\PYG{o}{.}\PYG{n}{FieldDefn}\PYG{p}{(} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{name}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{ogr}\PYG{o}{.}\PYG{n}{OFTString} \PYG{p}{)}
\PYG{n}{dst\PYGZus{}layer}\PYG{o}{.}\PYG{n}{CreateField}\PYG{p}{(} \PYG{n}{field\PYGZus{}defn} \PYG{p}{)}


\PYG{c}{\PYGZsh{} Algorithm is as follows:}
\PYG{c}{\PYGZsh{} 1. Loop over lines}
\PYG{c}{\PYGZsh{} 2. Split line into park name, longitude, latitude}
\PYG{c}{\PYGZsh{} 3. Create WKT of the point}
\PYG{c}{\PYGZsh{} 4. Set the attribute name to name of park}
\PYG{c}{\PYGZsh{} 5. Clean up}

\PYG{k}{for} \PYG{n}{park\PYGZus{}id}\PYG{p}{,} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(} \PYG{n}{parks}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{p}{)} \PYG{p}{)}\PYG{p}{:}
    \PYG{c}{\PYGZsh{} Get the relevant information}
    \PYG{n}{park\PYGZus{}name}\PYG{p}{,} \PYG{n}{lon}\PYG{p}{,} \PYG{n}{lat} \PYG{o}{=} \PYG{n}{line}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
    \PYG{c}{\PYGZsh{} Create a geogrpahical representation of the current park}
    \PYG{n}{wkt} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{POINT ( }\PYG{l+s+si}{\PYGZpc{}f}\PYG{l+s}{ }\PYG{l+s+si}{\PYGZpc{}f}\PYG{l+s}{ )}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{p}{(} \PYG{n+nb}{float}\PYG{p}{(}\PYG{n}{lon}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{float}\PYG{p}{(}\PYG{n}{lat}\PYG{p}{)} \PYG{p}{)}
    \PYG{c}{\PYGZsh{} Create a feature, using the attributes/fields that are}
    \PYG{c}{\PYGZsh{} required for this layer}
    \PYG{n}{feat} \PYG{o}{=} \PYG{n}{ogr}\PYG{o}{.}\PYG{n}{Feature}\PYG{p}{(}\PYG{n}{feature\PYGZus{}def}\PYG{o}{=}\PYG{n}{dst\PYGZus{}layer}\PYG{o}{.}\PYG{n}{GetLayerDefn}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{c}{\PYGZsh{} Feed the WKT into a geometry}
    \PYG{n}{p} \PYG{o}{=} \PYG{n}{ogr}\PYG{o}{.}\PYG{n}{CreateGeometryFromWkt}\PYG{p}{(} \PYG{n}{wkt} \PYG{p}{)}
    \PYG{c}{\PYGZsh{} Feed the geometry into a WKT}
    \PYG{n}{feat}\PYG{o}{.}\PYG{n}{SetGeometryDirectly}\PYG{p}{(} \PYG{n}{p} \PYG{p}{)}
    \PYG{c}{\PYGZsh{} Set the name field to its value}
    \PYG{n}{feat}\PYG{o}{.}\PYG{n}{SetField} \PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{name}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{park\PYGZus{}name} \PYG{p}{)}
    \PYG{c}{\PYGZsh{} Attach the feature to the layer}
    \PYG{n}{dst\PYGZus{}layer}\PYG{o}{.}\PYG{n}{CreateFeature}\PYG{p}{(} \PYG{n}{feat} \PYG{p}{)}
    \PYG{c}{\PYGZsh{} Clean up}
    \PYG{n}{feat}\PYG{o}{.}\PYG{n}{Destroy}\PYG{p}{(}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Close file}
\PYG{n}{dst\PYGZus{}ds} \PYG{o}{=} \PYG{n+nb+bp}{None}
\end{Verbatim}

You can see the result of this on
\href{https://gist.github.com/jgomezdans/6811102}{github}.

Additionally, note that if we had defined a coordinate transformation as
in the raster session, we could apply this transformation to an OGR
geometry entity (in the snippet above, \code{p} would be such), and it
would be reprojected.

\textbf{Exercise} Modify the above snippet to output a GeoJSON file for the
Peak District National Park, whose UTM30N (\href{http://spatialreference.org/ref/epsg/32630/}{EPSG code:
32630}) co-ordinates are
\(577659, 5911841\).


\section{Rasterising}
\label{Chapter4_GDAL/OGR_Python:rasterising}
A very frequent problem one finds is how to mask out an area in a raster
file that is defined as polygon in a shapefile. For example, if you have
a raster of the worlds population density, and you want to extract all
the pixels that belong to one particular country, how do you go about
that? One way around this is to \emph{rasterise} the polygon(s), which
translates into ``burning'' pixels that fall within the polygon with a
number, resulting in a mask.

The way to do this is to use GDAL's \code{RasterizeLayer} method. The
method takes a handle to a GDAL dataset (one that you create yourself,
with the right projection and geotransform, as you've seen above), and a
OGR layer. The syntax for \code{RasterizeLayer} is

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{err} \PYG{o}{=} \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{RasterizeLayer} \PYG{p}{(} \PYG{n}{raster\PYGZus{}ds}\PYG{p}{,} \PYG{p}{[}\PYG{n}{raster\PYGZus{}band\PYGZus{}no}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ogr\PYGZus{}layer}\PYG{p}{,} \PYG{n}{burn\PYGZus{}values}\PYG{o}{=}\PYG{p}{[}\PYG{n}{burn\PYGZus{}val}\PYG{p}{]} \PYG{p}{)}
\end{Verbatim}

where \code{raster\_ds} is the GDAL raster datasource (note that it needs to
be georreferenced, \emph{i.e.} it requires projection and geotransform),
\code{raster\_band\_no} is the band of the GDAL dataset where we want to burn
pixels, \code{ogr\_layer} is the vector layer object, and \code{burn\_val} is
the value that we want to burn.

Let's use \code{gdal.RasterizeLayer} in conjunction with all that we have
covered above. Say we want to create a mask that only selects the UK or
Ireland in \code{world.shp}, and we want to apply this mask to the MODIS
landcover product that we used in the GDAL session (h17v03 tile ), file
\code{lc\_h17v03.tif}. We find that in this case, \code{world.shp} is in
longitude latitude, and the MODIS data is in the MODIS projection, so we
will reproject the vector data to match the MODIS data (so the latter is
not interpolated and artifacts introduced). To make this efficient and
avoid saving to disk, we shall use \emph{in-memory vector and rasters}, and
we will output a numpy array as our mask. Note then the steps:
\begin{enumerate}
\item {} 
Crate the projection conversion object (as for GDAL before)

\item {} 
Create an in memory \textbf{raster} dataset to store the mask, using
\code{lc\_h17v03.tif} as a reference for geotransforms, array size and
projection.

\item {} 
Create an in memory \textbf{vector} dataset to hold the features that will
be reprojected

\item {} 
Open \code{world.shp} and apply an \code{AttributeFilter} to select a
country

\item {} 
Select a geometry from \code{world.shp}, project it and store it in the
destination in memory vector layer

\item {} 
Once this is done, use \code{gdal.RasterizeLayer} with both in-memory
raster and vector datasets

\item {} 
Read the in memory raster into an array

\end{enumerate}

This is a particularly good exercise that will stress all that we have
learned so far.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{osgeo} \PYG{k+kn}{import} \PYG{n}{ogr}\PYG{p}{,}\PYG{n}{osr}
\PYG{k+kn}{import} \PYG{n+nn}{gdal}

\PYG{n}{reference\PYGZus{}filename} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{lc\PYGZus{}h17v03.tif}\PYG{l+s}{\PYGZdq{}}
\PYG{n}{target\PYGZus{}vector\PYGZus{}file} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{world.shp}\PYG{l+s}{\PYGZdq{}}
\PYG{n}{attribute\PYGZus{}filter} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{NAME = }\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{IRELAND}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZdq{}}
\PYG{n}{burn\PYGZus{}value} \PYG{o}{=} \PYG{l+m+mi}{1}

\PYG{c}{\PYGZsh{} First, open the file that we\PYGZsq{}ll be taking as a reference}
\PYG{c}{\PYGZsh{} We will need to gleam the size in pixels, as well as projection}
\PYG{c}{\PYGZsh{} and geotransform.}

\PYG{n}{g} \PYG{o}{=} \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{Open}\PYG{p}{(} \PYG{n}{reference\PYGZus{}filename} \PYG{p}{)}

\PYG{c}{\PYGZsh{} We now create an in\PYGZhy{}memory raster, with the appropriate dimensions}
\PYG{n}{drv} \PYG{o}{=} \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{GetDriverByName}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MEM}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{target\PYGZus{}ds} \PYG{o}{=} \PYG{n}{drv}\PYG{o}{.}\PYG{n}{Create}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{g}\PYG{o}{.}\PYG{n}{RasterXSize}\PYG{p}{,} \PYG{n}{g}\PYG{o}{.}\PYG{n}{RasterXSize}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,}  \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{GDT\PYGZus{}Byte}\PYG{p}{)}
\PYG{n}{target\PYGZus{}ds}\PYG{o}{.}\PYG{n}{SetGeoTransform}\PYG{p}{(} \PYG{n}{g}\PYG{o}{.}\PYG{n}{GetGeoTransform}\PYG{p}{(}\PYG{p}{)} \PYG{p}{)}

\PYG{c}{\PYGZsh{} We set up a transform object as we saw in the previous notebook.}
\PYG{c}{\PYGZsh{} This goes from WGS84 to the projection in the reference datasets}

\PYG{n}{wgs84} \PYG{o}{=} \PYG{n}{osr}\PYG{o}{.}\PYG{n}{SpatialReference}\PYG{p}{(} \PYG{p}{)} \PYG{c}{\PYGZsh{} Define a SpatialReference object}
\PYG{n}{wgs84}\PYG{o}{.}\PYG{n}{ImportFromEPSG}\PYG{p}{(} \PYG{l+m+mi}{4326} \PYG{p}{)} \PYG{c}{\PYGZsh{} And set it to WGS84 using the EPSG code}

\PYG{c}{\PYGZsh{} Now for the target projection, Ordnance Survey\PYGZsq{}s British National Grid}
\PYG{n}{to\PYGZus{}proj} \PYG{o}{=} \PYG{n}{osr}\PYG{o}{.}\PYG{n}{SpatialReference}\PYG{p}{(}\PYG{p}{)} \PYG{c}{\PYGZsh{} define the SpatialReference object}
\PYG{c}{\PYGZsh{} In this case, we get the projection from a Proj4 string}

\PYG{c}{\PYGZsh{} or, if using the proj4 representation}
\PYG{n}{to\PYGZus{}proj}\PYG{o}{.}\PYG{n}{ImportFromWkt}\PYG{p}{(} \PYG{n}{g}\PYG{o}{.}\PYG{n}{GetProjectionRef}\PYG{p}{(}\PYG{p}{)} \PYG{p}{)}
\PYG{n}{target\PYGZus{}ds}\PYG{o}{.}\PYG{n}{SetProjection} \PYG{p}{(} \PYG{n}{to\PYGZus{}proj}\PYG{o}{.}\PYG{n}{ExportToWkt}\PYG{p}{(}\PYG{p}{)} \PYG{p}{)}
\PYG{c}{\PYGZsh{} Now, we define a coordinate transformtion object, *from* wgs84 *to* OSNG}
\PYG{n}{tx} \PYG{o}{=} \PYG{n}{osr}\PYG{o}{.}\PYG{n}{CoordinateTransformation}\PYG{p}{(} \PYG{n}{wgs84}\PYG{p}{,} \PYG{n}{to\PYGZus{}proj} \PYG{p}{)}

\PYG{c}{\PYGZsh{} We define an output in\PYGZhy{}memory OGR dataset}
\PYG{c}{\PYGZsh{} You could also do select a driver for an eg \PYGZdq{}ESRI Shapefile\PYGZdq{} here}
\PYG{c}{\PYGZsh{} and give it a sexier name than out!}

\PYG{n}{drv} \PYG{o}{=} \PYG{n}{ogr}\PYG{o}{.}\PYG{n}{GetDriverByName}\PYG{p}{(} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Memory}\PYG{l+s}{\PYGZsq{}} \PYG{p}{)}
\PYG{n}{dst\PYGZus{}ds} \PYG{o}{=} \PYG{n}{drv}\PYG{o}{.}\PYG{n}{CreateDataSource}\PYG{p}{(} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{out}\PYG{l+s}{\PYGZsq{}} \PYG{p}{)}
\PYG{c}{\PYGZsh{} This is a single layer dataset. The layer needs to be of polygons}
\PYG{c}{\PYGZsh{} and needs to have the target files\PYGZsq{} projection}
\PYG{n}{dst\PYGZus{}layer} \PYG{o}{=} \PYG{n}{dst\PYGZus{}ds}\PYG{o}{.}\PYG{n}{CreateLayer}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{srs} \PYG{o}{=} \PYG{n}{to\PYGZus{}proj}\PYG{p}{,} \PYG{n}{geom\PYGZus{}type}\PYG{o}{=}\PYG{n}{ogr}\PYG{o}{.}\PYG{n}{wkbPolygon} \PYG{p}{)}

\PYG{c}{\PYGZsh{} Open the original shapefile, get the first layer, and filter by attribute}
\PYG{n}{vector\PYGZus{}ds} \PYG{o}{=} \PYG{n}{ogr}\PYG{o}{.}\PYG{n}{Open}\PYG{p}{(} \PYG{n}{target\PYGZus{}vector\PYGZus{}file} \PYG{p}{)}
\PYG{n}{lyr} \PYG{o}{=} \PYG{n}{vector\PYGZus{}ds}\PYG{o}{.}\PYG{n}{GetLayer} \PYG{p}{(} \PYG{l+m+mi}{0} \PYG{p}{)}
\PYG{n}{lyr}\PYG{o}{.}\PYG{n}{SetAttributeFilter}\PYG{p}{(} \PYG{n}{attribute\PYGZus{}filter} \PYG{p}{)}


\PYG{c}{\PYGZsh{} Get a field definition from the original vector file.}
\PYG{c}{\PYGZsh{} We don\PYGZsq{}t need much more detail here}
\PYG{n}{feature} \PYG{o}{=} \PYG{n}{lyr}\PYG{o}{.}\PYG{n}{GetFeature}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{field} \PYG{o}{=} \PYG{n}{feature}\PYG{o}{.}\PYG{n}{GetFieldDefnRef}\PYG{p}{(} \PYG{l+m+mi}{0} \PYG{p}{)}
\PYG{c}{\PYGZsh{} Apply the field definition from the original to the output}
\PYG{n}{dst\PYGZus{}layer}\PYG{o}{.}\PYG{n}{CreateField}\PYG{p}{(} \PYG{n}{field} \PYG{p}{)}
\PYG{n}{feature\PYGZus{}defn} \PYG{o}{=} \PYG{n}{dst\PYGZus{}layer}\PYG{o}{.}\PYG{n}{GetLayerDefn}\PYG{p}{(}\PYG{p}{)}
\PYG{c}{\PYGZsh{} Reset the original layer so we can read all features}
\PYG{n}{lyr}\PYG{o}{.}\PYG{n}{ResetReading}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{feat} \PYG{o+ow}{in} \PYG{n}{lyr}\PYG{p}{:}
    \PYG{c}{\PYGZsh{} For each feature, get the geometry}
    \PYG{n}{geom} \PYG{o}{=} \PYG{n}{feat}\PYG{o}{.}\PYG{n}{GetGeometryRef}\PYG{p}{(}\PYG{p}{)}
    \PYG{c}{\PYGZsh{} transform it to the reference projection}
    \PYG{n}{geom}\PYG{o}{.}\PYG{n}{Transform} \PYG{p}{(} \PYG{n}{tx} \PYG{p}{)}
    \PYG{c}{\PYGZsh{} Create an output feature}
    \PYG{n}{out\PYGZus{}geom} \PYG{o}{=} \PYG{n}{ogr}\PYG{o}{.}\PYG{n}{Feature} \PYG{p}{(} \PYG{n}{feature\PYGZus{}defn} \PYG{p}{)}
    \PYG{c}{\PYGZsh{} Set the geometry to be the reprojected/transformed geometry}
    \PYG{n}{out\PYGZus{}geom}\PYG{o}{.}\PYG{n}{SetGeometry} \PYG{p}{(} \PYG{n}{geom} \PYG{p}{)}
    \PYG{c}{\PYGZsh{} Add the feature with its geometry to the output yaer}
    \PYG{n}{dst\PYGZus{}layer}\PYG{o}{.}\PYG{n}{CreateFeature}\PYG{p}{(}\PYG{n}{out\PYGZus{}geom} \PYG{p}{)}
    \PYG{c}{\PYGZsh{} Clear things up}
    \PYG{n}{out\PYGZus{}geom}\PYG{o}{.}\PYG{n}{Destroy}
    \PYG{n}{geom}\PYG{o}{.}\PYG{n}{Destroy}
\PYG{c}{\PYGZsh{} Done adding geometries}
\PYG{c}{\PYGZsh{} Reset the output layer to the 0th geometry}
\PYG{n}{dst\PYGZus{}layer}\PYG{o}{.}\PYG{n}{ResetReading}\PYG{p}{(}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Now, we rastertize the output vector in\PYGZhy{}memory file}
\PYG{c}{\PYGZsh{} into the in\PYGZhy{}memory output raster file}

\PYG{n}{err} \PYG{o}{=} \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{RasterizeLayer}\PYG{p}{(}\PYG{n}{target\PYGZus{}ds}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{dst\PYGZus{}layer}\PYG{p}{,}
            \PYG{n}{burn\PYGZus{}values}\PYG{o}{=}\PYG{p}{[}\PYG{n}{burn\PYGZus{}value}\PYG{p}{]}\PYG{p}{)}
\PYG{k}{if} \PYG{n}{err} \PYG{o}{!=} \PYG{l+m+mi}{0}\PYG{p}{:}
    \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{error:}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{err}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Read the data from the raster, this is your mask}
\PYG{n}{data} \PYG{o}{=} \PYG{n}{target\PYGZus{}ds}\PYG{o}{.}\PYG{n}{ReadAsArray}\PYG{p}{(}\PYG{p}{)}



\PYG{c}{\PYGZsh{} Plotting to see whether this makes sense.}

\PYG{n}{ndata} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{ReadAsArray}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow} \PYG{p}{(} \PYG{n}{ndata}\PYG{p}{,} \PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nearest}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{n}{plt}\PYG{o}{.}\PYG{n}{cm}\PYG{o}{.}\PYG{n}{gray}\PYG{p}{,} \PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{vmax}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{alpha}\PYG{o}{=}\PYG{l+m+mf}{0.3} \PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{hold} \PYG{p}{(} \PYG{n+nb+bp}{True} \PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow} \PYG{p}{(} \PYG{n}{data}\PYG{p}{,} \PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nearest}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{n}{plt}\PYG{o}{.}\PYG{n}{cm}\PYG{o}{.}\PYG{n}{gray}\PYG{p}{,} \PYG{n}{alpha}\PYG{o}{=}\PYG{l+m+mf}{0.7} \PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{grid} \PYG{p}{(} \PYG{n+nb+bp}{False} \PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\includegraphics{OGR_Python_28_0.png}


\section{Using matplotlib to plot geometries}
\label{Chapter4_GDAL/OGR_Python:using-matplotlib-to-plot-geometries}
Using matplotlib to plot geometries from OGR can be quite tedious.
Here's an example of plotting a map of Angola from the \code{world.shp}. In
the same vein of recommending Shapely and Fiona above for serious
geoprocessing of vector data, you are encouraged to use
\href{https://bitbucket.org/sgillies/descartes/}{descartes} for plotting
vector data!

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib.path} \PYG{k+kn}{as} \PYG{n+nn}{mpath}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib.patches} \PYG{k+kn}{as} \PYG{n+nn}{mpatches}


\PYG{c}{\PYGZsh{} Extract first layer of features from shapefile using OGR}
\PYG{n}{ds} \PYG{o}{=} \PYG{n}{ogr}\PYG{o}{.}\PYG{n}{Open}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{world.shp}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{lyr} \PYG{o}{=} \PYG{n}{ds}\PYG{o}{.}\PYG{n}{GetLayer}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}


\PYG{c}{\PYGZsh{} Prepare figure}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ioff}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplot}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{gca}\PYG{p}{(}\PYG{p}{)}


\PYG{n}{paths} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{lyr}\PYG{o}{.}\PYG{n}{ResetReading}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{lyr}\PYG{o}{.}\PYG{n}{SetAttributeFilter} \PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ NAME = }\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{ANGOLA}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlim}\PYG{p}{(}\PYG{l+m+mi}{11}\PYG{p}{,} \PYG{l+m+mf}{24.5} \PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylim}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{c}{\PYGZsh{} Read all features in layer and store as paths}

\PYG{k}{for} \PYG{n}{feat} \PYG{o+ow}{in} \PYG{n}{lyr}\PYG{p}{:}

    \PYG{k}{for} \PYG{n}{geom} \PYG{o+ow}{in} \PYG{n}{feat}\PYG{o}{.}\PYG{n}{GetGeometryRef}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{envelope} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(} \PYG{n}{geom}\PYG{o}{.}\PYG{n}{GetEnvelope}\PYG{p}{(}\PYG{p}{)} \PYG{p}{)}
        \PYG{c}{\PYGZsh{} check if geom is polygon}
        \PYG{k}{if} \PYG{n}{geom}\PYG{o}{.}\PYG{n}{GetGeometryType}\PYG{p}{(}\PYG{p}{)} \PYG{o}{==} \PYG{n}{ogr}\PYG{o}{.}\PYG{n}{wkbPolygon}\PYG{p}{:}
            \PYG{n}{codes} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
            \PYG{n}{all\PYGZus{}x} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
            \PYG{n}{all\PYGZus{}y} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
            \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{geom}\PYG{o}{.}\PYG{n}{GetGeometryCount}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                \PYG{c}{\PYGZsh{} Read ring geometry and create path}
                \PYG{n}{r} \PYG{o}{=} \PYG{n}{geom}\PYG{o}{.}\PYG{n}{GetGeometryRef}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}
                \PYG{n}{x} \PYG{o}{=} \PYG{p}{[}\PYG{n}{r}\PYG{o}{.}\PYG{n}{GetX}\PYG{p}{(}\PYG{n}{j}\PYG{p}{)} \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{r}\PYG{o}{.}\PYG{n}{GetPointCount}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{]}
                \PYG{n}{y} \PYG{o}{=} \PYG{p}{[}\PYG{n}{r}\PYG{o}{.}\PYG{n}{GetY}\PYG{p}{(}\PYG{n}{j}\PYG{p}{)} \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{r}\PYG{o}{.}\PYG{n}{GetPointCount}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{]}
                \PYG{c}{\PYGZsh{} skip boundary between individual rings}
                \PYG{n}{codes} \PYG{o}{+}\PYG{o}{=} \PYG{p}{[}\PYG{n}{mpath}\PYG{o}{.}\PYG{n}{Path}\PYG{o}{.}\PYG{n}{MOVETO}\PYG{p}{]} \PYG{o}{+} \PYGZbs{}
                             \PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{p}{[}\PYG{n}{mpath}\PYG{o}{.}\PYG{n}{Path}\PYG{o}{.}\PYG{n}{LINETO}\PYG{p}{]}
                \PYG{n}{all\PYGZus{}x} \PYG{o}{+}\PYG{o}{=} \PYG{n}{x}
                \PYG{n}{all\PYGZus{}y} \PYG{o}{+}\PYG{o}{=} \PYG{n}{y}
            \PYG{n}{path} \PYG{o}{=} \PYG{n}{mpath}\PYG{o}{.}\PYG{n}{Path}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{column\PYGZus{}stack}\PYG{p}{(}\PYG{p}{(}\PYG{n}{all\PYGZus{}x}\PYG{p}{,}\PYG{n}{all\PYGZus{}y}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{n}{codes}\PYG{p}{)}
            \PYG{n}{paths}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{path}\PYG{p}{)}
    \PYG{c}{\PYGZsh{} Add paths as patches to axes}
    \PYG{k}{for} \PYG{n}{path} \PYG{o+ow}{in} \PYG{n}{paths}\PYG{p}{:}
        \PYG{n}{patch} \PYG{o}{=} \PYG{n}{mpatches}\PYG{o}{.}\PYG{n}{PathPatch}\PYG{p}{(}\PYG{n}{path}\PYG{p}{,} \PYGZbs{}
                \PYG{n}{facecolor}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{0.8}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{edgecolor}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{black}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{ax}\PYG{o}{.}\PYG{n}{add\PYGZus{}patch}\PYG{p}{(}\PYG{n}{patch}\PYG{p}{)}



\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}aspect}\PYG{p}{(}\PYG{l+m+mf}{1.0}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\includegraphics{OGR_Python_31_0.png}


\chapter{5. Function fitting and Interpolation}
\label{Chapter5_Interpolation/Interpolation:function-fitting-and-interpolation}\label{Chapter5_Interpolation/Interpolation::doc}
In today's session, we will be using some of the LAI datasets we
examined last week (masked by national boundaries) and doing some
analysis on them.
\begin{itemize}
\item {} 
{\hyperref[Chapter5_Interpolation/Interpolation:5.1-Making-3D-datasets-and-Movies]{5.1 Making 3D datasets and
Movies}} First, we will examine
how to improve our data reading function by extracting only the area
we are interested in. This involves querying the `country' mask to
find its limits and passing this information through to the reader.

\item {} 
{\hyperref[Chapter5_Interpolation/Interpolation:5.2-Interpolation]{5.2 Interpolation}} Then we will look at
methods to interpolate and smooth over gaps in datasets using various
methods.

\item {} 
{\hyperref[Chapter5_Interpolation/Interpolation:5.3-Function-fitting]{5.3 Function Fitting}} Finally, we will
look at fitting models to datasets, in this case a model describing
LAI phenology.

\end{itemize}


\section{5.1 Making 3D datasets and Movies}
\label{Chapter5_Interpolation/Interpolation:making-3d-datasets-and-movies}
First though, we will briefly go over once more the work we did on
downloading data (ussssing \code{wget}), generating 3D masked datasets, and
making movies.

This time, we will concentrate more on generating functions that we can
re-use for other purposes.


\subsection{5.1.1 Downloading data}
\label{Chapter5_Interpolation/Interpolation:downloading-data}
We start by filtering the file \code{files/data/robot.txt} to get only
lines (containing urls) for a particular tile and year.

We might easily do this in unix:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{} filter LAI MODIS files for this year and tile (in bash)
tile=\PYGZsq{}h17v03\PYGZsq{}
year=\PYGZsq{}2005\PYGZsq{}
ofile=files/data/modis\PYGZus{}lai\PYGZus{}\PYGZdl{}\PYGZob{}tile\PYGZcb{}\PYGZus{}\PYGZdl{}\PYGZob{}year\PYGZcb{}.txt

grep \PYGZdl{}tile \PYGZlt{} files/data/robot.txt \textbar{} grep \PYGZbs{}/\PYGZdl{}year \PYGZgt{} \PYGZdl{}ofile

\PYGZsh{} have a look at the first few
head \PYGZhy{}4 \PYGZlt{} \PYGZdl{}ofile
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2005.01.01/MCD15A2.A2005001.h17v03.005.2007350235547.hdf
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2005.01.09/MCD15A2.A2005009.h17v03.005.2007351235445.hdf
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2005.01.17/MCD15A2.A2005017.h17v03.005.2007352033411.hdf
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2005.01.25/MCD15A2.A2005025.h17v03.005.2007353055037.hdf
\end{Verbatim}

Now download the datasets:

\begin{Verbatim}[commandchars=\\\{\}]
tile=\PYGZsq{}h17v03\PYGZsq{}
year=\PYGZsq{}2005\PYGZsq{}
ofile=files/data/modis\PYGZus{}lai\PYGZus{}\PYGZdl{}\PYGZob{}tile\PYGZcb{}\PYGZus{}\PYGZdl{}\PYGZob{}year\PYGZcb{}.txt

\PYGZsh{} go into the directory we want the data
pushd files/data
\PYGZsh{} get the urls from the file
\PYGZsh{} \PYGZhy{}\PYGZhy{}cut\PYGZhy{}dirs=4 this time as there are 4 laters of directory we
\PYGZsh{} wish to ignore with this dataset
wget \PYGZhy{}\PYGZhy{}quiet \PYGZhy{}nc \PYGZhy{}nH \PYGZhy{}\PYGZhy{}cut\PYGZhy{}dirs=4 \PYGZhy{}i ../\PYGZdl{}ofile
\PYGZsh{} go back to where we were
popd
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
/archive/rsu\PYGZus{}raid\PYGZus{}0/plewis/public\PYGZus{}html/geogg122\PYGZus{}local/geogg122/Chapter5\PYGZus{}Interpolation/files/data /archive/rsu\PYGZus{}raid\PYGZus{}0/plewis/public\PYGZus{}html/geogg122\PYGZus{}local/geogg122/Chapter5\PYGZus{}Interpolation
/archive/rsu\PYGZus{}raid\PYGZus{}0/plewis/public\PYGZus{}html/geogg122\PYGZus{}local/geogg122/Chapter5\PYGZus{}Interpolation
\end{Verbatim}


\subsection{5.1.2 Read from an ASCII file}
\label{Chapter5_Interpolation/Interpolation:read-from-an-ascii-file}
The ASCII file \code{files/data/modis\_lai\_\$\{tile\}\_\$\{year\}.txt} contains
lines of urls.

Each line (each url) is a string such as:

\code{http://e4ftl01.cr.usgs.gov/MODIS\_Composites/MOTA/MCD15A2.005/2005.01.25/MCD15A2.A2005025.h17v03.005.2007353055037.hdf}

The \emph{filename} here is
\code{MCD15A2.A2005025.h17v03.005.2007353055037.hdf}, so we can split the
url on the field \code{/} to get this:

Let's read the filenames from the text file that has the urls in it and
load it into a list that we will call \code{filelist}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}

\PYG{n}{tile} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{h17v03}\PYG{l+s}{\PYGZsq{}}
\PYG{n}{year} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{2005}\PYG{l+s}{\PYGZsq{}}

\PYG{c}{\PYGZsh{} specify the file with the urls in}
\PYG{n}{ifile}\PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/modis\PYGZus{}lai\PYGZus{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZus{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{.txt}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{tile}\PYG{p}{,}\PYG{n}{year}\PYG{p}{)}

\PYG{c}{\PYGZsh{} one way to read the data from the file}
\PYG{n}{fp} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{ifile}\PYG{p}{)}
\PYG{n}{lines} \PYG{o}{=} \PYG{n}{fp}\PYG{o}{.}\PYG{n}{readlines}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{filelist} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{url} \PYG{o+ow}{in} \PYG{n}{lines}\PYG{p}{:}
    \PYG{n}{filename} \PYG{o}{=} \PYG{n}{url}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{strip}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{filelist}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{)}
\PYG{n}{fp}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}

\PYG{c}{\PYGZsh{} show the first few}
\PYG{k}{print} \PYG{n}{filelist}\PYG{p}{[}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MCD15A2.A2005001.h17v03.005.2007350235547.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MCD15A2.A2005009.h17v03.005.2007351235445.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MCD15A2.A2005017.h17v03.005.2007352033411.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MCD15A2.A2005025.h17v03.005.2007353055037.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MCD15A2.A2005033.h17v03.005.2007355050158.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} a neater way:}
\PYG{n}{fp} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{ifile}\PYG{p}{)}
\PYG{n}{filelist} \PYG{o}{=} \PYG{p}{[}\PYG{n}{url}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{strip}\PYG{p}{(}\PYG{p}{)} \PYG{k}{for} \PYG{n}{url} \PYG{o+ow}{in} \PYG{n}{fp}\PYG{o}{.}\PYG{n}{readlines}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}
\PYG{n}{fp}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}

\PYG{c}{\PYGZsh{} show the first few}
\PYG{k}{print} \PYG{n}{filelist}\PYG{p}{[}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MCD15A2.A2005001.h17v03.005.2007350235547.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MCD15A2.A2005009.h17v03.005.2007351235445.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MCD15A2.A2005017.h17v03.005.2007352033411.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MCD15A2.A2005025.h17v03.005.2007353055037.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MCD15A2.A2005033.h17v03.005.2007355050158.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} an even neater way using np.loadtxt}
\PYG{c}{\PYGZsh{} But don\PYGZsq{}t worry if you don\PYGZsq{}t quite get this one yet!}

\PYG{c}{\PYGZsh{} define a function get\PYGZus{}filename(f)}
\PYG{c}{\PYGZsh{} When a function is \PYGZsq{}small\PYGZsq{} its easier to use a lambda definition!}
\PYG{n}{get\PYGZus{}filename} \PYG{o}{=} \PYG{k}{lambda} \PYG{n}{f}\PYG{p}{:} \PYG{n}{f}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{filelist} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{loadtxt}\PYG{p}{(}\PYG{n}{ifile}\PYG{p}{,}\PYG{n}{dtype}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{str}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{converters}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{n}{get\PYGZus{}filename}\PYG{p}{\PYGZcb{}}\PYG{p}{)}

\PYG{k}{print} \PYG{n}{filelist}\PYG{p}{[}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MCD15A2.A2005001.h17v03.005.2007350235547.hdf}\PYG{l+s}{\PYGZsq{}}
 \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MCD15A2.A2005009.h17v03.005.2007351235445.hdf}\PYG{l+s}{\PYGZsq{}}
 \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MCD15A2.A2005017.h17v03.005.2007352033411.hdf}\PYG{l+s}{\PYGZsq{}}
 \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MCD15A2.A2005025.h17v03.005.2007353055037.hdf}\PYG{l+s}{\PYGZsq{}}
 \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MCD15A2.A2005033.h17v03.005.2007355050158.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\end{Verbatim}


\subsection{5.1.3 Read Just The Data We Want}
\label{Chapter5_Interpolation/Interpolation:read-just-the-data-we-want}
Last time, we generated a function to read MODIS LAI data.

We have now included such a function in the directory
\code{{}`files/python} \textless{}files/python\textgreater{}{}`\_\_ called
\code{{}`get\_lai.py} \textless{}files/python/get\_lai.py\textgreater{}{}`\_\_.

The only added sophistication is that when we call \code{ReadAsArray}, we
give it the starting cols, rows, and number of cols and rows to read
(e.g. \code{xsize=600,yoff=300,xoff=300,ysize=600}):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} Now we have a list of filenames}
\PYG{c}{\PYGZsh{} load read\PYGZus{}lai}
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{n}{sys}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/python}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{k+kn}{from} \PYG{n+nn}{get\PYGZus{}lai} \PYG{k+kn}{import} \PYG{n}{get\PYGZus{}lai}

\PYG{n}{help}\PYG{p}{(}\PYG{n}{get\PYGZus{}lai}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
Help on function get\PYGZus{}lai in module get\PYGZus{}lai:

get\PYGZus{}lai(filename, qc\PYGZus{}layer=\PYGZsq{}FparLai\PYGZus{}QC\PYGZsq{}, scale=[0.1, 0.1], mincol=0, minrow=0, ncol=None, nrow=None, selected\PYGZus{}layers=[\PYGZsq{}Lai\PYGZus{}1km\PYGZsq{}, \PYGZsq{}LaiStdDev\PYGZus{}1km\PYGZsq{}])
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} e.g. for reading a single file:}

\PYG{n}{lai\PYGZus{}file0} \PYG{o}{=} \PYG{n}{get\PYGZus{}lai}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{n}{filelist}\PYG{p}{[}\PYG{l+m+mi}{20}\PYG{p}{]}\PYG{p}{,}\PYG{n}{ncol}\PYG{o}{=}\PYG{l+m+mi}{600}\PYG{p}{,}\PYG{n}{mincol}\PYG{o}{=}\PYG{l+m+mi}{300}\PYG{p}{,}\PYG{n}{minrow}\PYG{o}{=}\PYG{l+m+mi}{400}\PYG{p}{,}\PYG{n}{nrow}\PYG{o}{=}\PYG{l+m+mi}{800}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{lai\PYGZus{}file0}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.image.AxesImage at 0x10342b50\PYGZgt{}
\end{Verbatim}

\includegraphics{Interpolation_13_1.png}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{lai\PYGZus{}file0}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{lai\PYGZus{}file0}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}type \PYGZsq{}dict\PYGZsq{}\PYGZgt{}
[\PYGZsq{}Lai\PYGZus{}1km\PYGZsq{}, \PYGZsq{}LaiStdDev\PYGZus{}1km\PYGZsq{}]
\end{Verbatim}

The function returns a dictionary with has keys
\code{{[}'Lai\_1km', 'LaiStdDev\_1km', 'FparLai\_QC'{]}}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{n}{lai\PYGZus{}file0}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{shape}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{l+m+mi}{800}\PYG{p}{,} \PYG{l+m+mi}{600}\PYG{p}{)}
\end{Verbatim}

Each of these datasets is of shape \code{(1200, 1200)}, but we have read
only 600 (columns) and 800 (rows) in this case. Note that the numpy
indexing is \code{(rows,cols)}.

We know how to create a mask from a vector dataset from thelast session:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{raster\PYGZus{}mask} \PYG{k+kn}{import} \PYG{n}{raster\PYGZus{}mask}

\PYG{c}{\PYGZsh{} make a raster mask}
\PYG{c}{\PYGZsh{} from the layer IRELAND in world.shp}
\PYG{n}{filename} \PYG{o}{=} \PYG{n}{filelist}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{file\PYGZus{}template} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{:MOD\PYGZus{}Grid\PYGZus{}MOD15A2:}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZsq{}}
\PYG{n}{file\PYGZus{}spec} \PYG{o}{=} \PYG{n}{file\PYGZus{}template}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{n}{filename}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{mask} \PYG{o}{=} \PYG{n}{raster\PYGZus{}mask}\PYG{p}{(}\PYG{n}{file\PYGZus{}spec}\PYG{p}{,}\PYGZbs{}
                   \PYG{n}{target\PYGZus{}vector\PYGZus{}file} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{files/data/world.shp}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYGZbs{}
                   \PYG{n}{attribute\PYGZus{}filter} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{NAME = }\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{IRELAND}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}


\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{mask}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.colorbar.Colorbar instance at 0x10ae5bd8\PYGZgt{}
\end{Verbatim}

\includegraphics{Interpolation_18_1.png}

In this case, the data we want is only a small section of the whole
spatial dataset.

It would be convenient to extract \emph{only} the part we want.

We can use \code{numpy.where()} to help with this:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} The mask is False for the area we want}
\PYG{n}{rowpix}\PYG{p}{,}\PYG{n}{colpix} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{where}\PYG{p}{(}\PYG{n}{mask} \PYG{o}{==} \PYG{n+nb+bp}{False}\PYG{p}{)}

\PYG{k}{print} \PYG{n}{rowpix}\PYG{p}{,}\PYG{n}{colpix}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
[ 548  548  548 ..., 1024 1025 1025] [693 694 695 ..., 476 473 474]
\end{Verbatim}

\code{rowpix} and \code{colpix} are lists of pixel coordinates where the
condition we specified is \code{True} (i.e. where \code{mask} is \code{False}).

If we wanted to find the bounds of this area, we simply need to know the
minimum and maximum column and row in these lists:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{mincol}\PYG{p}{,}\PYG{n}{maxcol} \PYG{o}{=} \PYG{n+nb}{min}\PYG{p}{(}\PYG{n}{colpix}\PYG{p}{)}\PYG{p}{,}\PYG{n+nb}{max}\PYG{p}{(}\PYG{n}{colpix}\PYG{p}{)}
\PYG{n}{minrow}\PYG{p}{,}\PYG{n}{maxrow} \PYG{o}{=} \PYG{n+nb}{min}\PYG{p}{(}\PYG{n}{rowpix}\PYG{p}{)}\PYG{p}{,}\PYG{n+nb}{max}\PYG{p}{(}\PYG{n}{rowpix}\PYG{p}{)}

\PYG{c}{\PYGZsh{} think about why the + 1 here!!!}
\PYG{c}{\PYGZsh{} what if maxcol and mincol were the same?}
\PYG{n}{ncol} \PYG{o}{=} \PYG{n}{maxcol} \PYG{o}{\PYGZhy{}} \PYG{n}{mincol} \PYG{o}{+} \PYG{l+m+mi}{1}
\PYG{n}{nrow} \PYG{o}{=} \PYG{n}{maxrow} \PYG{o}{\PYGZhy{}} \PYG{n}{minrow} \PYG{o}{+} \PYG{l+m+mi}{1}

\PYG{k}{print} \PYG{n}{minrow}\PYG{p}{,}\PYG{n}{mincol}\PYG{p}{,}\PYG{n}{nrow}\PYG{p}{,}\PYG{n}{ncol}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
548 422 478 348
\end{Verbatim}

We could use this information to extract \emph{only} the area we want when we
read the data:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{lai\PYGZus{}file0} \PYG{o}{=} \PYG{n}{get\PYGZus{}lai}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{n}{filelist}\PYG{p}{[}\PYG{l+m+mi}{20}\PYG{p}{]}\PYG{p}{,}\PYGZbs{}
                    \PYG{n}{ncol}\PYG{o}{=}\PYG{n}{ncol}\PYG{p}{,}\PYG{n}{nrow}\PYG{o}{=}\PYG{n}{nrow}\PYG{p}{,}\PYG{n}{mincol}\PYG{o}{=}\PYG{n}{mincol}\PYG{p}{,}\PYG{n}{minrow}\PYG{o}{=}\PYG{n}{minrow}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{lai\PYGZus{}file0}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.image.AxesImage at 0x10ddc2d0\PYGZgt{}
\end{Verbatim}

\includegraphics{Interpolation_24_1.png}

Now, lets extract this portion of the mask:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{small\PYGZus{}mask} \PYG{o}{=} \PYG{n}{mask}\PYG{p}{[}\PYG{n}{minrow}\PYG{p}{:}\PYG{n}{minrow}\PYG{o}{+}\PYG{n}{nrow}\PYG{p}{,}\PYG{n}{mincol}\PYG{p}{:}\PYG{n}{mincol}\PYG{o}{+}\PYG{n}{ncol}\PYG{p}{]}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{small\PYGZus{}mask}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.image.AxesImage at 0x2ae9e41a3750\PYGZgt{}
\end{Verbatim}

\includegraphics{Interpolation_26_1.png}

And combine the country mask with the small dataset:

As a recap, we can use the function \code{raster\_mask} that we gave you
last time to develop a raster mask (!) from an ESRI shapefile
(\code{files/data/world.shp} here).

We can then combine this mask with the QC-derived mask in the LAI
dataset.

The LAI mask (that will be \code{lai.mask} in the code below) is \code{False}
for good data, as is the coutry mask.

To combine them, we want some operator \code{X} for which:

\begin{DUlineblock}{0em}
\item[] \code{True  X True  == True}
\item[] \code{True  X False == True}
\item[] \code{False X True  == True}
\item[] \code{False X False == False}
\end{DUlineblock}

The operator to use then is an \emph{or}, here, a bitwise or, \code{\textbar{}}.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{lai\PYGZus{}file0} \PYG{o}{=} \PYG{n}{get\PYGZus{}lai}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{n}{filelist}\PYG{p}{[}\PYG{l+m+mi}{20}\PYG{p}{]}\PYG{p}{,}\PYGZbs{}
                    \PYG{n}{ncol}\PYG{o}{=}\PYG{n}{ncol}\PYG{p}{,}\PYG{n}{nrow}\PYG{o}{=}\PYG{n}{nrow}\PYG{p}{,}\PYG{n}{mincol}\PYG{o}{=}\PYG{n}{mincol}\PYG{p}{,}\PYG{n}{minrow}\PYG{o}{=}\PYG{n}{minrow}\PYG{p}{)}

\PYG{n}{layer} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}
\PYG{n}{lai} \PYG{o}{=} \PYG{n}{lai\PYGZus{}file0}\PYG{p}{[}\PYG{n}{layer}\PYG{p}{]}
\PYG{n}{small\PYGZus{}mask} \PYG{o}{=} \PYG{n}{mask}\PYG{p}{[}\PYG{n}{minrow}\PYG{p}{:}\PYG{n}{minrow}\PYG{o}{+}\PYG{n}{nrow}\PYG{p}{,}\PYG{n}{mincol}\PYG{p}{:}\PYG{n}{mincol}\PYG{o}{+}\PYG{n}{ncol}\PYG{p}{]}

\PYG{c}{\PYGZsh{} combined mask}
\PYG{n}{new\PYGZus{}mask} \PYG{o}{=} \PYG{n}{small\PYGZus{}mask} \PYG{o}{\textbar{}} \PYG{n}{lai}\PYG{o}{.}\PYG{n}{mask}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{new\PYGZus{}mask}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{lai} \PYG{o}{=} \PYG{n}{ma}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{lai}\PYG{p}{,}\PYG{n}{mask}\PYG{o}{=}\PYG{n}{new\PYGZus{}mask}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{lai}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.image.AxesImage at 0x2ae9e4275f50\PYGZgt{}
\end{Verbatim}

\includegraphics{Interpolation_29_1.png}

\includegraphics{Interpolation_29_2.png}

We should be used to writing loops around such functions.

In this case, we read \emph{all} of the files in \code{filelist} and put the
data into the dictionary called \code{lai} here.

Because there are multiple layers in the datasets, we loop over layer
and append to each list indiviually:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} load \PYGZsq{}em all ...}

\PYG{c}{\PYGZsh{} for United Kingdom here}

\PYG{k+kn}{import} \PYG{n+nn}{numpy.ma} \PYG{k+kn}{as} \PYG{n+nn}{ma}
\PYG{k+kn}{from} \PYG{n+nn}{raster\PYGZus{}mask} \PYG{k+kn}{import} \PYG{n}{raster\PYGZus{}mask}

\PYG{n}{country} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{UNITED KINGDOM}\PYG{l+s}{\PYGZsq{}}

\PYG{c}{\PYGZsh{} make a raster mask}
\PYG{c}{\PYGZsh{} from the layer UNITED KINGDOM in world.shp}
\PYG{n}{filename} \PYG{o}{=} \PYG{n}{filelist}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{file\PYGZus{}template} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{:MOD\PYGZus{}Grid\PYGZus{}MOD15A2:}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZsq{}}
\PYG{n}{file\PYGZus{}spec} \PYG{o}{=} \PYG{n}{file\PYGZus{}template}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{n}{filename}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{mask} \PYG{o}{=} \PYG{n}{raster\PYGZus{}mask}\PYG{p}{(}\PYG{n}{file\PYGZus{}spec}\PYG{p}{,}\PYGZbs{}
                   \PYG{n}{target\PYGZus{}vector\PYGZus{}file} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{files/data/world.shp}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYGZbs{}
                   \PYG{n}{attribute\PYGZus{}filter} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{NAME = }\PYG{l+s}{\PYGZsq{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZpc{}}\PYG{n}{country}\PYG{p}{)}
\PYG{c}{\PYGZsh{} extract just the area we want}
\PYG{c}{\PYGZsh{} by getting the min/max rows/cols}
\PYG{c}{\PYGZsh{} of the data mask}
\PYG{c}{\PYGZsh{} The mask is False for the area we want}
\PYG{n}{rowpix}\PYG{p}{,}\PYG{n}{colpix} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{where}\PYG{p}{(}\PYG{n}{mask} \PYG{o}{==} \PYG{n+nb+bp}{False}\PYG{p}{)}
\PYG{n}{mincol}\PYG{p}{,}\PYG{n}{maxcol} \PYG{o}{=} \PYG{n+nb}{min}\PYG{p}{(}\PYG{n}{colpix}\PYG{p}{)}\PYG{p}{,}\PYG{n+nb}{max}\PYG{p}{(}\PYG{n}{colpix}\PYG{p}{)}
\PYG{n}{minrow}\PYG{p}{,}\PYG{n}{maxrow} \PYG{o}{=} \PYG{n+nb}{min}\PYG{p}{(}\PYG{n}{rowpix}\PYG{p}{)}\PYG{p}{,}\PYG{n+nb}{max}\PYG{p}{(}\PYG{n}{rowpix}\PYG{p}{)}
\PYG{n}{ncol} \PYG{o}{=} \PYG{n}{maxcol} \PYG{o}{\PYGZhy{}} \PYG{n}{mincol} \PYG{o}{+} \PYG{l+m+mi}{1}
\PYG{n}{nrow} \PYG{o}{=} \PYG{n}{maxrow} \PYG{o}{\PYGZhy{}} \PYG{n}{minrow} \PYG{o}{+} \PYG{l+m+mi}{1}
\PYG{c}{\PYGZsh{} and make a small mask}
\PYG{n}{small\PYGZus{}mask} \PYG{o}{=} \PYG{n}{mask}\PYG{p}{[}\PYG{n}{minrow}\PYG{p}{:}\PYG{n}{minrow}\PYG{o}{+}\PYG{n}{nrow}\PYG{p}{,}\PYG{n}{mincol}\PYG{p}{:}\PYG{n}{mincol}\PYG{o}{+}\PYG{n}{ncol}\PYG{p}{]}


\PYG{c}{\PYGZsh{} data\PYGZus{}fields with empty lists}
\PYG{n}{data\PYGZus{}fields} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{LaiStdDev\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{p}{[}\PYG{p}{]}\PYG{p}{\PYGZcb{}}

\PYG{c}{\PYGZsh{} make a dictionary and put the filenames in it}
\PYG{c}{\PYGZsh{} along with the mask and min/max info}
\PYG{n}{lai} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{filenames}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{n}{np}\PYG{o}{.}\PYG{n}{sort}\PYG{p}{(}\PYG{n}{filelist}\PYG{p}{)}\PYG{p}{,}\PYGZbs{}
       \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{minrow}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{n}{minrow}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{mincol}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{n}{mincol}\PYG{p}{,}\PYGZbs{}
       \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{mask}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{n}{small\PYGZus{}mask}\PYG{p}{\PYGZcb{}}

\PYG{c}{\PYGZsh{} combine the dictionaries}
\PYG{n}{lai}\PYG{o}{.}\PYG{n}{update}\PYG{p}{(}\PYG{n}{data\PYGZus{}fields}\PYG{p}{)}

\PYG{c}{\PYGZsh{} loop over each filename}
\PYG{k}{for} \PYG{n}{f} \PYG{o+ow}{in} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sort}\PYG{p}{(}\PYG{n}{lai}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{filenames}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{this\PYGZus{}lai} \PYG{o}{=} \PYG{n}{get\PYGZus{}lai}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{n}{f}\PYG{p}{,}\PYGZbs{}
                       \PYG{n}{mincol}\PYG{o}{=}\PYG{n}{mincol}\PYG{p}{,}\PYG{n}{ncol}\PYG{o}{=}\PYG{n}{ncol}\PYG{p}{,}\PYGZbs{}
                       \PYG{n}{minrow}\PYG{o}{=}\PYG{n}{minrow}\PYG{p}{,}\PYG{n}{nrow}\PYG{o}{=}\PYG{n}{nrow}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{layer} \PYG{o+ow}{in} \PYG{n}{data\PYGZus{}fields}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
        \PYG{c}{\PYGZsh{} apply the mask}
        \PYG{n}{new\PYGZus{}mask} \PYG{o}{=} \PYG{n}{this\PYGZus{}lai}\PYG{p}{[}\PYG{n}{layer}\PYG{p}{]}\PYG{o}{.}\PYG{n}{mask} \PYG{o}{\textbar{}} \PYG{n}{small\PYGZus{}mask}
        \PYG{n}{this\PYGZus{}lai}\PYG{p}{[}\PYG{n}{layer}\PYG{p}{]} \PYG{o}{=} \PYG{n}{ma}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{this\PYGZus{}lai}\PYG{p}{[}\PYG{n}{layer}\PYG{p}{]}\PYG{p}{,}\PYG{n}{mask}\PYG{o}{=}\PYG{n}{new\PYGZus{}mask}\PYG{p}{)}
        \PYG{n}{lai}\PYG{p}{[}\PYG{n}{layer}\PYG{p}{]}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{this\PYGZus{}lai}\PYG{p}{[}\PYG{n}{layer}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} have a look at one of these}

\PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{20}

\PYG{k+kn}{import} \PYG{n+nn}{pylab} \PYG{k+kn}{as} \PYG{n+nn}{plt}

\PYG{c}{\PYGZsh{} just see what the shape is ...}
\PYG{k}{print} \PYG{n}{lai}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{.}\PYG{n}{shape}

\PYG{n}{root} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/images/lai\PYGZus{}uk}\PYG{l+s}{\PYGZsq{}}

\PYG{n}{cmap} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{cm}\PYG{o}{.}\PYG{n}{Greens}

\PYG{n}{f} \PYG{o}{=} \PYG{n}{lai}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{filenames}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
\PYG{n}{fig} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{)}\PYG{p}{)}
\PYG{c}{\PYGZsh{} get some info from filename}
\PYG{n}{file\PYGZus{}id} \PYG{o}{=} \PYG{n}{f}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{.}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{p}{]}
\PYG{k}{print} \PYG{n}{file\PYGZus{}id}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{lai}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,}\PYG{n}{cmap}\PYG{o}{=}\PYG{n}{cmap}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{vmax}\PYG{o}{=}\PYG{l+m+mf}{4.}\PYG{p}{,}\PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mf}{0.0}\PYG{p}{)}
\PYG{c}{\PYGZsh{} plot a jpg}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{n}{file\PYGZus{}id}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/images/lai\PYGZus{}uk\PYGZus{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{.jpg}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{n}{file\PYGZus{}id}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{l+m+mi}{1200}\PYG{p}{,} \PYG{l+m+mi}{566}\PYG{p}{)}
\PYG{l+m+mi}{2005161}
\end{Verbatim}

\includegraphics{Interpolation_32_1.png}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} thats quite good, so put as a function:}
\PYG{k+kn}{import} \PYG{n+nn}{numpy.ma} \PYG{k+kn}{as} \PYG{n+nn}{ma}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{n}{sys}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/python}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{k+kn}{from} \PYG{n+nn}{get\PYGZus{}lai} \PYG{k+kn}{import} \PYG{n}{get\PYGZus{}lai}
\PYG{k+kn}{from} \PYG{n+nn}{raster\PYGZus{}mask} \PYG{k+kn}{import} \PYG{n}{raster\PYGZus{}mask}


\PYG{k}{def} \PYG{n+nf}{read\PYGZus{}lai}\PYG{p}{(}\PYG{n}{filelist}\PYG{p}{,}\PYG{n}{datadir}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{country}\PYG{o}{=}\PYG{n+nb+bp}{None}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+sd}{    Read MODIS LAI data from a set of files}
\PYG{l+s+sd}{    in the list filelist. Data assumed to be in}
\PYG{l+s+sd}{    directory datadir.}

\PYG{l+s+sd}{    Parameters:}
\PYG{l+s+sd}{    filelist : list of LAI files}

\PYG{l+s+sd}{    Options:}
\PYG{l+s+sd}{    datadir  : data directory}
\PYG{l+s+sd}{    country  : country name (in files/data/world.shp)}

\PYG{l+s+sd}{    Returns:}
\PYG{l+s+sd}{    lai dictionary}
\PYG{l+s+sd}{    \PYGZsq{}\PYGZsq{}\PYGZsq{}}
    \PYG{k}{if} \PYG{n}{country}\PYG{p}{:}
        \PYG{c}{\PYGZsh{} make a raster mask}
        \PYG{c}{\PYGZsh{} from the layer UNITED KINGDOM in world.shp}
        \PYG{n}{file\PYGZus{}template} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{:MOD\PYGZus{}Grid\PYGZus{}MOD15A2:}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZsq{}}
        \PYG{n}{file\PYGZus{}spec} \PYG{o}{=} \PYG{n}{file\PYGZus{}template}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{n}{filelist}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

        \PYG{n}{mask} \PYG{o}{=} \PYG{n}{raster\PYGZus{}mask}\PYG{p}{(}\PYG{n}{file\PYGZus{}spec}\PYG{p}{,}\PYGZbs{}
                           \PYG{n}{target\PYGZus{}vector\PYGZus{}file} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{files/data/world.shp}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYGZbs{}
                           \PYG{n}{attribute\PYGZus{}filter} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{NAME = }\PYG{l+s}{\PYGZsq{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZpc{}}\PYG{n}{country}\PYG{p}{)}
        \PYG{c}{\PYGZsh{} extract just the area we want}
        \PYG{c}{\PYGZsh{} by getting the min/max rows/cols}
        \PYG{c}{\PYGZsh{} of the data mask}
        \PYG{c}{\PYGZsh{} The mask is False for the area we want}
        \PYG{n}{rowpix}\PYG{p}{,}\PYG{n}{colpix} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{where}\PYG{p}{(}\PYG{n}{mask} \PYG{o}{==} \PYG{n+nb+bp}{False}\PYG{p}{)}
        \PYG{n}{mincol}\PYG{p}{,}\PYG{n}{maxcol} \PYG{o}{=} \PYG{n+nb}{min}\PYG{p}{(}\PYG{n}{colpix}\PYG{p}{)}\PYG{p}{,}\PYG{n+nb}{max}\PYG{p}{(}\PYG{n}{colpix}\PYG{p}{)}
        \PYG{n}{minrow}\PYG{p}{,}\PYG{n}{maxrow} \PYG{o}{=} \PYG{n+nb}{min}\PYG{p}{(}\PYG{n}{rowpix}\PYG{p}{)}\PYG{p}{,}\PYG{n+nb}{max}\PYG{p}{(}\PYG{n}{rowpix}\PYG{p}{)}
        \PYG{n}{ncol} \PYG{o}{=} \PYG{n}{maxcol} \PYG{o}{\PYGZhy{}} \PYG{n}{mincol} \PYG{o}{+} \PYG{l+m+mi}{1}
        \PYG{n}{nrow} \PYG{o}{=} \PYG{n}{maxrow} \PYG{o}{\PYGZhy{}} \PYG{n}{minrow} \PYG{o}{+} \PYG{l+m+mi}{1}
        \PYG{c}{\PYGZsh{} and make a small mask}
        \PYG{n}{small\PYGZus{}mask} \PYG{o}{=} \PYG{n}{mask}\PYG{p}{[}\PYG{n}{minrow}\PYG{p}{:}\PYG{n}{minrow}\PYG{o}{+}\PYG{n}{nrow}\PYG{p}{,}\PYG{n}{mincol}\PYG{p}{:}\PYG{n}{mincol}\PYG{o}{+}\PYG{n}{ncol}\PYG{p}{]}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{c}{\PYGZsh{} no country}
        \PYG{n}{mincol} \PYG{o}{=} \PYG{l+m+mi}{0}
        \PYG{n}{maxcol} \PYG{o}{=} \PYG{l+m+mi}{0}
        \PYG{n}{ncol} \PYG{o}{=} \PYG{n+nb+bp}{None}
        \PYG{n}{nrow} \PYG{o}{=} \PYG{n+nb+bp}{None}

    \PYG{c}{\PYGZsh{} data\PYGZus{}fields with empty lists}
    \PYG{n}{data\PYGZus{}fields} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{LaiStdDev\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{p}{[}\PYG{p}{]}\PYG{p}{\PYGZcb{}}

    \PYG{c}{\PYGZsh{} make a dictionary and put the filenames in it}
    \PYG{c}{\PYGZsh{} along with the mask and min/max info}
    \PYG{n}{lai} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{filenames}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{n}{np}\PYG{o}{.}\PYG{n}{sort}\PYG{p}{(}\PYG{n}{filelist}\PYG{p}{)}\PYG{p}{,}\PYGZbs{}
           \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{minrow}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{n}{minrow}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{mincol}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{n}{mincol}\PYG{p}{,}\PYGZbs{}
           \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{mask}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{n}{small\PYGZus{}mask}\PYG{p}{\PYGZcb{}}

    \PYG{c}{\PYGZsh{} combine the dictionaries}
    \PYG{n}{lai}\PYG{o}{.}\PYG{n}{update}\PYG{p}{(}\PYG{n}{data\PYGZus{}fields}\PYG{p}{)}

    \PYG{c}{\PYGZsh{} loop over each filename}
    \PYG{k}{for} \PYG{n}{f} \PYG{o+ow}{in} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sort}\PYG{p}{(}\PYG{n}{lai}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{filenames}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{this\PYGZus{}lai} \PYG{o}{=} \PYG{n}{get\PYGZus{}lai}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{n}{f}\PYG{p}{,}\PYGZbs{}
                           \PYG{n}{mincol}\PYG{o}{=}\PYG{n}{mincol}\PYG{p}{,}\PYG{n}{ncol}\PYG{o}{=}\PYG{n}{ncol}\PYG{p}{,}\PYGZbs{}
                           \PYG{n}{minrow}\PYG{o}{=}\PYG{n}{minrow}\PYG{p}{,}\PYG{n}{nrow}\PYG{o}{=}\PYG{n}{nrow}\PYG{p}{)}
        \PYG{k}{for} \PYG{n}{layer} \PYG{o+ow}{in} \PYG{n}{data\PYGZus{}fields}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
            \PYG{c}{\PYGZsh{} apply the mask}
            \PYG{k}{if} \PYG{n}{country}\PYG{p}{:}
                \PYG{n}{new\PYGZus{}mask} \PYG{o}{=} \PYG{n}{this\PYGZus{}lai}\PYG{p}{[}\PYG{n}{layer}\PYG{p}{]}\PYG{o}{.}\PYG{n}{mask} \PYG{o}{\textbar{}} \PYG{n}{small\PYGZus{}mask}
                \PYG{n}{this\PYGZus{}lai}\PYG{p}{[}\PYG{n}{layer}\PYG{p}{]} \PYG{o}{=} \PYG{n}{ma}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{this\PYGZus{}lai}\PYG{p}{[}\PYG{n}{layer}\PYG{p}{]}\PYG{p}{,}\PYG{n}{mask}\PYG{o}{=}\PYG{n}{new\PYGZus{}mask}\PYG{p}{)}
            \PYG{n}{lai}\PYG{p}{[}\PYG{n}{layer}\PYG{p}{]}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{this\PYGZus{}lai}\PYG{p}{[}\PYG{n}{layer}\PYG{p}{]}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{layer} \PYG{o+ow}{in} \PYG{n}{data\PYGZus{}fields}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{lai}\PYG{p}{[}\PYG{n}{layer}\PYG{p}{]} \PYG{o}{=} \PYG{n}{ma}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{lai}\PYG{p}{[}\PYG{n}{layer}\PYG{p}{]}\PYG{p}{)}

    \PYG{k}{return} \PYG{n}{lai}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} test this ... the one in the file}
\PYG{c}{\PYGZsh{} does a cutout of the data area as well}
\PYG{c}{\PYGZsh{} which will keep the memory}
\PYG{c}{\PYGZsh{} requirements down}
\PYG{k+kn}{from} \PYG{n+nn}{get\PYGZus{}lai} \PYG{k+kn}{import} \PYG{n}{read\PYGZus{}lai}

\PYG{n}{lai} \PYG{o}{=} \PYG{n}{read\PYGZus{}lai}\PYG{p}{(}\PYG{n}{filelist}\PYG{p}{,}\PYG{n}{country}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{IRELAND}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{verbose}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}

\PYG{c}{\PYGZsh{} have a look at one of these}

\PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{20}

\PYG{c}{\PYGZsh{} just see what the shape is ...}
\PYG{k}{print} \PYG{n}{lai}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{.}\PYG{n}{shape}

\PYG{n}{root} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/images/lai\PYGZus{}eire}\PYG{l+s}{\PYGZsq{}}

\PYG{n}{cmap} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{cm}\PYG{o}{.}\PYG{n}{Greens}

\PYG{n}{f} \PYG{o}{=} \PYG{n}{lai}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{filenames}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
\PYG{n}{fig} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{)}\PYG{p}{)}
\PYG{c}{\PYGZsh{} get some info from filename}
\PYG{n}{file\PYGZus{}id} \PYG{o}{=} \PYG{n}{f}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{.}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{p}{]}
\PYG{k}{print} \PYG{n}{file\PYGZus{}id}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{lai}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,}\PYG{n}{cmap}\PYG{o}{=}\PYG{n}{cmap}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{vmax}\PYG{o}{=}\PYG{l+m+mf}{4.}\PYG{p}{,}\PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mf}{0.0}\PYG{p}{)}
\PYG{c}{\PYGZsh{} plot a jpg}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{n}{file\PYGZus{}id}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZus{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{.jpg}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{root}\PYG{p}{,}\PYG{n}{file\PYGZus{}id}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
creating mask of IRELAND
... MCD15A2.A2005001.h17v03.005.2007350235547.hdf
... MCD15A2.A2005009.h17v03.005.2007351235445.hdf
... MCD15A2.A2005017.h17v03.005.2007352033411.hdf
... MCD15A2.A2005025.h17v03.005.2007353055037.hdf
... MCD15A2.A2005033.h17v03.005.2007355050158.hdf
... MCD15A2.A2005041.h17v03.005.2007357014602.hdf
... MCD15A2.A2005049.h17v03.005.2007360165724.hdf
... MCD15A2.A2005057.h17v03.005.2007361230641.hdf
... MCD15A2.A2005065.h17v03.005.2007365024202.hdf
... MCD15A2.A2005073.h17v03.005.2008001043631.hdf
... MCD15A2.A2005081.h17v03.005.2008003173048.hdf
... MCD15A2.A2005089.h17v03.005.2008005154542.hdf
... MCD15A2.A2005097.h17v03.005.2008007175837.hdf
... MCD15A2.A2005105.h17v03.005.2008018085544.hdf
... MCD15A2.A2005113.h17v03.005.2008021020137.hdf
... MCD15A2.A2005121.h17v03.005.2008021193749.hdf
... MCD15A2.A2005129.h17v03.005.2008024061330.hdf
... MCD15A2.A2005137.h17v03.005.2008032075236.hdf
... MCD15A2.A2005145.h17v03.005.2008033192556.hdf
... MCD15A2.A2005153.h17v03.005.2008035054421.hdf
... MCD15A2.A2005161.h17v03.005.2008036173810.hdf
... MCD15A2.A2005169.h17v03.005.2008039132812.hdf
... MCD15A2.A2005177.h17v03.005.2008042090537.hdf
... MCD15A2.A2005185.h17v03.005.2008044115459.hdf
... MCD15A2.A2005193.h17v03.005.2008046140018.hdf
... MCD15A2.A2005201.h17v03.005.2008050015227.hdf
... MCD15A2.A2005209.h17v03.005.2008052203557.hdf
... MCD15A2.A2005217.h17v03.005.2008055145215.hdf
... MCD15A2.A2005225.h17v03.005.2008057010213.hdf
... MCD15A2.A2005233.h17v03.005.2008060214119.hdf
... MCD15A2.A2005241.h17v03.005.2008063115631.hdf
... MCD15A2.A2005249.h17v03.005.1998144165707.hdf
... MCD15A2.A2005257.h17v03.005.2008067051936.hdf
... MCD15A2.A2005265.h17v03.005.2008069073121.hdf
... MCD15A2.A2005273.h17v03.005.2008071050025.hdf
... MCD15A2.A2005281.h17v03.005.2008072202421.hdf
... MCD15A2.A2005289.h17v03.005.2008074194126.hdf
... MCD15A2.A2005297.h17v03.005.2008077061121.hdf
... MCD15A2.A2005305.h17v03.005.2008080055607.hdf
... MCD15A2.A2005313.h17v03.005.2008083165435.hdf
... MCD15A2.A2005321.h17v03.005.2008084043211.hdf
... MCD15A2.A2005329.h17v03.005.2008086063619.hdf
... MCD15A2.A2005337.h17v03.005.2008087175845.hdf
... MCD15A2.A2005345.h17v03.005.2008088144615.hdf
... MCD15A2.A2005353.h17v03.005.2008091004441.hdf
... MCD15A2.A2005361.h17v03.005.2008091025114.hdf
... done
(478, 348)
2005161
\end{Verbatim}

\includegraphics{Interpolation_34_1.png}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} make a movie}

\PYG{k+kn}{import} \PYG{n+nn}{pylab} \PYG{k+kn}{as} \PYG{n+nn}{plt}
\PYG{k+kn}{import} \PYG{n+nn}{os}

\PYG{c}{\PYGZsh{} just see what the shape is ...}
\PYG{k}{print} \PYG{n}{lai}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{shape}

\PYG{n}{root} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/images/lai\PYGZus{}country\PYGZus{}eire}\PYG{l+s}{\PYGZsq{}}

\PYG{n}{cmap} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{cm}\PYG{o}{.}\PYG{n}{Greens}

\PYG{k}{for} \PYG{n}{i}\PYG{p}{,}\PYG{n}{f} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{lai}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{filenames}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{fig} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{)}\PYG{p}{)}
    \PYG{c}{\PYGZsh{} get some info from filename}
    \PYG{n}{file\PYGZus{}id} \PYG{o}{=} \PYG{n}{f}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{.}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{p}{]}
    \PYG{k}{print} \PYG{n}{file\PYGZus{}id}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{lai}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,}\PYG{n}{cmap}\PYG{o}{=}\PYG{n}{cmap}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{vmax}\PYG{o}{=}\PYG{l+m+mf}{4.}\PYG{p}{,}\PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mf}{0.0}\PYG{p}{)}
    \PYG{c}{\PYGZsh{} plot a jpg}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{n}{file\PYGZus{}id}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZus{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{.jpg}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{root}\PYG{p}{,}\PYG{n}{file\PYGZus{}id}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{n}{fig}\PYG{p}{)}

\PYG{n}{cmd} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{convert \PYGZhy{}delay 100 \PYGZhy{}loop 0 \PYGZob{}0\PYGZcb{}\PYGZus{}*.jpg \PYGZob{}0\PYGZcb{}\PYGZus{}movie.gif}\PYG{l+s}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{root}\PYG{p}{)}
\PYG{n}{os}\PYG{o}{.}\PYG{n}{system}\PYG{p}{(}\PYG{n}{cmd}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{l+m+mi}{46}\PYG{p}{,} \PYG{l+m+mi}{478}\PYG{p}{,} \PYG{l+m+mi}{348}\PYG{p}{)}
\PYG{l+m+mi}{2005001}
\PYG{l+m+mi}{2005009}
\PYG{l+m+mi}{2005017}
\PYG{l+m+mi}{2005025}
\PYG{l+m+mi}{2005033}
\PYG{l+m+mi}{2005041}
\PYG{l+m+mi}{2005049}
\PYG{l+m+mi}{2005057}
\PYG{l+m+mi}{2005065}
\PYG{l+m+mi}{2005073}
\PYG{l+m+mi}{2005081}
\PYG{l+m+mi}{2005089}
\PYG{l+m+mi}{2005097}
\PYG{l+m+mi}{2005105}
\PYG{l+m+mi}{2005113}
\PYG{l+m+mi}{2005121}
\PYG{l+m+mi}{2005129}
\PYG{l+m+mi}{2005137}
\PYG{l+m+mi}{2005145}
\PYG{l+m+mi}{2005153}
\PYG{l+m+mi}{2005161}
\PYG{l+m+mi}{2005169}
\PYG{l+m+mi}{2005177}
\PYG{l+m+mi}{2005185}
\PYG{l+m+mi}{2005193}
\PYG{l+m+mi}{2005201}
\PYG{l+m+mi}{2005209}
\PYG{l+m+mi}{2005217}
\PYG{l+m+mi}{2005225}
\PYG{l+m+mi}{2005233}
\PYG{l+m+mi}{2005241}
\PYG{l+m+mi}{2005249}
\PYG{l+m+mi}{2005257}
\PYG{l+m+mi}{2005265}
\PYG{l+m+mi}{2005273}
\PYG{l+m+mi}{2005281}
\PYG{l+m+mi}{2005289}
\PYG{l+m+mi}{2005297}
\PYG{l+m+mi}{2005305}
\PYG{l+m+mi}{2005313}
\PYG{l+m+mi}{2005321}
\PYG{l+m+mi}{2005329}
\PYG{l+m+mi}{2005337}
\PYG{l+m+mi}{2005345}
\PYG{l+m+mi}{2005353}
\PYG{l+m+mi}{2005361}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{0}
\end{Verbatim}
\begin{figure}[htbp]
\centering

\includegraphics{Chapter5_Interpolation/files/images/lai_country_eire_movie.gif}
\end{figure}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} The movie making works, so pack that into a function}

\PYG{k+kn}{import} \PYG{n+nn}{pylab} \PYG{k+kn}{as} \PYG{n+nn}{plt}
\PYG{k+kn}{import} \PYG{n+nn}{os}

\PYG{n}{root} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/images/lai\PYGZus{}eire}\PYG{l+s}{\PYGZsq{}}

\PYG{k}{def} \PYG{n+nf}{make\PYGZus{}movie}\PYG{p}{(}\PYG{n}{lai}\PYG{p}{,}\PYG{n}{root}\PYG{p}{,}\PYG{n}{layer}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{vmax}\PYG{o}{=}\PYG{l+m+mf}{4.}\PYG{p}{,}\PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{n}{do\PYGZus{}plot}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+sd}{    Make an animated gif from MODIS LAI data in}
\PYG{l+s+sd}{    dictionary \PYGZsq{}lai\PYGZsq{}.}

\PYG{l+s+sd}{    Parameters:}
\PYG{l+s+sd}{    lai    : data dictionary}
\PYG{l+s+sd}{    root   : root file /directory name of frames and movie}

\PYG{l+s+sd}{    layer  : data layer to plot}
\PYG{l+s+sd}{    vmax   : max value for plotting}
\PYG{l+s+sd}{    vmin   : min value for plotting}
\PYG{l+s+sd}{    do\PYGZus{}plot: set True if you want the individual plots}
\PYG{l+s+sd}{             to display}

\PYG{l+s+sd}{    Returns:}
\PYG{l+s+sd}{    movie name}

\PYG{l+s+sd}{    \PYGZsq{}\PYGZsq{}\PYGZsq{}}
    \PYG{n}{cmap} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{cm}\PYG{o}{.}\PYG{n}{Greens}

    \PYG{k}{for} \PYG{n}{i}\PYG{p}{,}\PYG{n}{f} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{lai}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{filenames}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{fig} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{)}\PYG{p}{)}
        \PYG{c}{\PYGZsh{} get some info from filename}
        \PYG{n}{file\PYGZus{}id} \PYG{o}{=} \PYG{n}{f}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{.}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{p}{]}
        \PYG{k}{print} \PYG{n}{file\PYGZus{}id}
        \PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{lai}\PYG{p}{[}\PYG{n}{layer}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,}\PYG{n}{cmap}\PYG{o}{=}\PYG{n}{cmap}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYGZbs{}
                   \PYG{n}{vmax}\PYG{o}{=}\PYG{n}{vmax}\PYG{p}{,}\PYG{n}{vmin}\PYG{o}{=}\PYG{n}{vmin}\PYG{p}{)}
        \PYG{c}{\PYGZsh{} plot a jpg}
        \PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{n}{file\PYGZus{}id}\PYG{p}{)}
        \PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{plt}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZus{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{.jpg}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{root}\PYG{p}{,}\PYG{n}{file\PYGZus{}id}\PYG{p}{)}\PYG{p}{)}
        \PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{do\PYGZus{}plot}\PYG{p}{:}
            \PYG{n}{plt}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{n}{fig}\PYG{p}{)}

    \PYG{n}{cmd} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{convert \PYGZhy{}delay 100 \PYGZhy{}loop 0 \PYGZob{}0\PYGZcb{}\PYGZus{}*.jpg \PYGZob{}0\PYGZcb{}\PYGZus{}movie.gif}\PYG{l+s}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{root}\PYG{p}{)}
    \PYG{n}{os}\PYG{o}{.}\PYG{n}{system}\PYG{p}{(}\PYG{n}{cmd}\PYG{p}{)}
    \PYG{k}{return} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZob{}0\PYGZcb{}\PYGZus{}movie.gif}\PYG{l+s}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{root}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} test it}

\PYG{n}{lai\PYGZus{}uk} \PYG{o}{=} \PYG{n}{read\PYGZus{}lai}\PYG{p}{(}\PYG{n}{filelist}\PYG{p}{,}\PYG{n}{country}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{UNITED KINGDOM}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{root} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/images/lai\PYGZus{}UK}\PYG{l+s}{\PYGZsq{}}
\PYG{n}{movie} \PYG{o}{=} \PYG{n}{make\PYGZus{}movie}\PYG{p}{(}\PYG{n}{lai\PYGZus{}uk}\PYG{p}{,}\PYG{n}{root}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{movie}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{2005001}
\PYG{l+m+mi}{2005009}
\PYG{l+m+mi}{2005017}
\PYG{l+m+mi}{2005025}
\PYG{l+m+mi}{2005033}
\PYG{l+m+mi}{2005041}
\PYG{l+m+mi}{2005049}
\PYG{l+m+mi}{2005057}
\PYG{l+m+mi}{2005065}
\PYG{l+m+mi}{2005073}
\PYG{l+m+mi}{2005081}
\PYG{l+m+mi}{2005089}
\PYG{l+m+mi}{2005097}
\PYG{l+m+mi}{2005105}
\PYG{l+m+mi}{2005113}
\PYG{l+m+mi}{2005121}
\PYG{l+m+mi}{2005129}
\PYG{l+m+mi}{2005137}
\PYG{l+m+mi}{2005145}
\PYG{l+m+mi}{2005153}
\PYG{l+m+mi}{2005161}
\PYG{l+m+mi}{2005169}
\PYG{l+m+mi}{2005177}
\PYG{l+m+mi}{2005185}
\PYG{l+m+mi}{2005193}
\PYG{l+m+mi}{2005201}
\PYG{l+m+mi}{2005209}
\PYG{l+m+mi}{2005217}
\PYG{l+m+mi}{2005225}
\PYG{l+m+mi}{2005233}
\PYG{l+m+mi}{2005241}
\PYG{l+m+mi}{2005249}
\PYG{l+m+mi}{2005257}
\PYG{l+m+mi}{2005265}
\PYG{l+m+mi}{2005273}
\PYG{l+m+mi}{2005281}
\PYG{l+m+mi}{2005289}
\PYG{l+m+mi}{2005297}
\PYG{l+m+mi}{2005305}
\PYG{l+m+mi}{2005313}
\PYG{l+m+mi}{2005321}
\PYG{l+m+mi}{2005329}
\PYG{l+m+mi}{2005337}
\PYG{l+m+mi}{2005345}
\PYG{l+m+mi}{2005353}
\PYG{l+m+mi}{2005361}
\PYG{n}{files}\PYG{o}{/}\PYG{n}{images}\PYG{o}{/}\PYG{n}{lai\PYGZus{}UK\PYGZus{}movie}\PYG{o}{.}\PYG{n}{gif}
\end{Verbatim}
\begin{figure}[htbp]
\centering

\includegraphics{Chapter5_Interpolation/files/images/lai_UK_movie.gif}
\end{figure}


\section{5.2 Interpolation}
\label{Chapter5_Interpolation/Interpolation:interpolation}

\subsection{5.2.1 Univariate interpolation}
\label{Chapter5_Interpolation/Interpolation:univariate-interpolation}
So, we can load the data we want from multiple MODIS hdf files that we
have downloaded from the NASA server into a 3D masked numpy array, with
a country boundary mask (projected int the raster data coordinate
system) from a vector dataset.

Let's start to explore the data then.

You should have an array of LAI for Ireland:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{lai}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{numpy}\PYG{o}{.}\PYG{n}{ma}\PYG{o}{.}\PYG{n}{core}\PYG{o}{.}\PYG{n}{MaskedArray}
\end{Verbatim}

Let's plot the LAI for some given pixels.

First, we might like to identify which pixels actually have any data.

A convenient function for this would be \code{np.where} that returns the
indices of items that are \code{True}.

Since the data mask is \code{False} for good data, we take the complement
\code{\textasciitilde{}} so that good data are {}`True:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{data} \PYG{o}{=} \PYG{n}{lai}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{np}\PYG{o}{.}\PYG{n}{where}\PYG{p}{(}\PYG{o}{\PYGZti{}}\PYG{n}{data}\PYG{o}{.}\PYG{n}{mask}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[} \PYG{l+m+mi}{3}\PYG{p}{,}  \PYG{l+m+mi}{3}\PYG{p}{,}  \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,} \PYG{l+m+mi}{39}\PYG{p}{,} \PYG{l+m+mi}{39}\PYG{p}{,} \PYG{l+m+mi}{39}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}
 \PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{326}\PYG{p}{,} \PYG{l+m+mi}{328}\PYG{p}{,} \PYG{l+m+mi}{329}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,} \PYG{l+m+mi}{472}\PYG{p}{,} \PYG{l+m+mi}{472}\PYG{p}{,} \PYG{l+m+mi}{475}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}
 \PYG{n}{array}\PYG{p}{(}\PYG{p}{[} \PYG{l+m+mi}{82}\PYG{p}{,} \PYG{l+m+mi}{145}\PYG{p}{,}  \PYG{l+m+mi}{83}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,}  \PYG{l+m+mi}{86}\PYG{p}{,}  \PYG{l+m+mi}{87}\PYG{p}{,}  \PYG{l+m+mi}{51}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

An example good pixel this is (3,329,145). Let's look at this for all
time periods:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{data} \PYG{o}{=} \PYG{n}{lai}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}

\PYG{n}{r} \PYG{o}{=} \PYG{l+m+mi}{329}
\PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{83}

\PYG{n}{pixel} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{]}

\PYG{c}{\PYGZsh{} plot red stars at the data points}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{pixel}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{n}{pixel}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r*}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{c}{\PYGZsh{} plot a black (k) dashed line (\PYGZhy{}\PYGZhy{})}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{pixel}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{n}{pixel}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{k\PYGZhy{}\PYGZhy{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{doy}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{LAI}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{pixel }\PYG{l+s+si}{\PYGZpc{}03d}\PYG{l+s}{ }\PYG{l+s+si}{\PYGZpc{}03d}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.text.Text at 0x11e77950\PYGZgt{}
\end{Verbatim}

\includegraphics{Interpolation_47_1.png}

The data follow the trend of what we might expect for LAI development,
but they are clearly a little noisy.

We also have access to uncertainty information (standard deviation):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} copy the data in case we change it any}

\PYG{n}{data} \PYG{o}{=} \PYG{n}{lai}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{sd}   \PYG{o}{=} \PYG{n}{lai}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{LaiStdDev\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{r} \PYG{o}{=} \PYG{l+m+mi}{329}
\PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{83}

\PYG{n}{pixel}    \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{]}
\PYG{n}{pixel\PYGZus{}sd} \PYG{o}{=}   \PYG{n}{sd}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{]}

\PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{pixel}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{8}

\PYG{c}{\PYGZsh{} plot red stars at the data points}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{pixel}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r*}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{c}{\PYGZsh{} plot a black (k) dashed line (\PYGZhy{}\PYGZhy{})}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{pixel}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{k\PYGZhy{}\PYGZhy{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{c}{\PYGZsh{} plot error bars:}
\PYG{c}{\PYGZsh{} 1.96 because that is the 95\PYGZpc{} confidence interval}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{errorbar}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{pixel}\PYG{p}{,}\PYG{n}{yerr}\PYG{o}{=}\PYG{n}{pixel\PYGZus{}sd}\PYG{o}{*}\PYG{l+m+mf}{1.96}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{doy}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{LAI}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{pixel }\PYG{l+s+si}{\PYGZpc{}03d}\PYG{l+s}{ }\PYG{l+s+si}{\PYGZpc{}03d}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.text.Text at 0x2ae9e53409d0\PYGZgt{}
\end{Verbatim}

\includegraphics{Interpolation_49_1.png}

We would generally expect LAI to be quite smoothly varying over time.
Visualising the data with 95\% confidence intervals is quite useful as we
can now `imagine' some smooth line that would generally go within these
bounds.

Some of the uncertainty estimates are really rather small though, which
are probably not reliable.

Let's inflate them:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{data} \PYG{o}{=} \PYG{n}{lai}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{sd}   \PYG{o}{=} \PYG{n}{lai}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{LaiStdDev\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{r} \PYG{o}{=} \PYG{l+m+mi}{329}
\PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{83}

\PYG{n}{pixel}    \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{]}
\PYG{n}{pixel\PYGZus{}sd} \PYG{o}{=}   \PYG{n}{sd}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{]}
\PYG{c}{\PYGZsh{} threshold}
\PYG{n}{thresh} \PYG{o}{=} \PYG{l+m+mf}{0.25}
\PYG{n}{pixel\PYGZus{}sd}\PYG{p}{[}\PYG{n}{pixel\PYGZus{}sd}\PYG{o}{\PYGZlt{}}\PYG{n}{thresh}\PYG{p}{]} \PYG{o}{=} \PYG{n}{thresh}

\PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{pixel}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{8}

\PYG{c}{\PYGZsh{} plot red stars at the data points}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{pixel}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r*}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{c}{\PYGZsh{} plot a black (k) dashed line (\PYGZhy{}\PYGZhy{})}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{pixel}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{k\PYGZhy{}\PYGZhy{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{c}{\PYGZsh{} plot error bars:}
\PYG{c}{\PYGZsh{} 1.96 because that is the 95\PYGZpc{} confidence interval}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{errorbar}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{pixel}\PYG{p}{,}\PYG{n}{yerr}\PYG{o}{=}\PYG{n}{pixel\PYGZus{}sd}\PYG{o}{*}\PYG{l+m+mf}{1.96}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{doy}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{LAI}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{pixel }\PYG{l+s+si}{\PYGZpc{}03d}\PYG{l+s}{ }\PYG{l+s+si}{\PYGZpc{}03d}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.text.Text at 0x2ae9e5554910\PYGZgt{}
\end{Verbatim}

\includegraphics{Interpolation_51_1.png}

This is perhaps a bit more realistic ...

The data now have some missing values (data gaps) and, as we have noted,
are a little noisy.

A Python module we can use for many scientific functions is
\code{{}`scipy} \textless{}\href{http://docs.scipy.org/doc/scipy}{http://docs.scipy.org/doc/scipy}\textgreater{}{}`\_\_, in particular here, the
\code{{}`scipy} interpolation
functions \textless{}\href{http://docs.scipy.org/doc/scipy/reference/interpolate.html}{http://docs.scipy.org/doc/scipy/reference/interpolate.html}\textgreater{}{}`\_\_.

We need to make a careful choice of the interpolation functions.

We might, in many circumstances simply want something that interpolates
between data points, i.e. that goes through the data points that we
have.

Many interpolators will not provide extrapolation, so in the example
above we could not get an estimate of LAI prior to the first sample and
after the last.

The best way to deal with that would be to have multiple years of data.

Instead here, we will repeat the dataset three times to mimic this:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{scipy} \PYG{k+kn}{import} \PYG{n}{interpolate}

\PYG{n}{pixel} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{]}

\PYG{c}{\PYGZsh{} original x,y}
\PYG{n}{y\PYGZus{}} \PYG{o}{=} \PYG{n}{pixel}
\PYG{n}{x\PYGZus{}} \PYG{o}{=} \PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{y\PYGZus{}}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mf}{8.}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{[}\PYG{o}{\PYGZti{}}\PYG{n}{pixel}\PYG{o}{.}\PYG{n}{mask}\PYG{p}{]}
\PYG{n}{y\PYGZus{}} \PYG{o}{=} \PYG{n}{y\PYGZus{}}\PYG{p}{[}\PYG{o}{\PYGZti{}}\PYG{n}{pixel}\PYG{o}{.}\PYG{n}{mask}\PYG{p}{]}

\PYG{c}{\PYGZsh{} extend: using np.tile() to repeat data}
\PYG{n}{y\PYGZus{}extend} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{tile}\PYG{p}{(}\PYG{n}{y\PYGZus{}}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{c}{\PYGZsh{} extend: using vstack to stack 3 different arrays}
\PYG{n}{x\PYGZus{}extend} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{hstack}\PYG{p}{(}\PYG{p}{(}\PYG{n}{x\PYGZus{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{46}\PYG{o}{*}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{n}{x\PYGZus{}}\PYG{p}{,}\PYG{n}{x\PYGZus{}}\PYG{o}{+}\PYG{l+m+mi}{46}\PYG{o}{*}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} plot the extended dataset}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x\PYGZus{}extend}\PYG{p}{,}\PYG{n}{y\PYGZus{}extend}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{b}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x\PYGZus{}}\PYG{p}{,}\PYG{n}{y\PYGZus{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{k+}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{l+m+mf}{0.}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{l+m+mf}{2.5}\PYG{p}{]}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{365.}\PYG{p}{,}\PYG{l+m+mf}{365.}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{l+m+mf}{2.5}\PYG{p}{]}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlim}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{356}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{l+m+mi}{365}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{day of year}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{LAI}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.text.Text at 0x2ae9e6108550\PYGZgt{}
\end{Verbatim}

\includegraphics{Interpolation_54_1.png}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} define xnew at 1 day interval}
\PYG{n}{xnew} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{p}{,}\PYG{l+m+mf}{366.}\PYG{p}{)}

\PYG{c}{\PYGZsh{} linear interpolation}
\PYG{n}{f} \PYG{o}{=} \PYG{n}{interpolate}\PYG{o}{.}\PYG{n}{interp1d}\PYG{p}{(}\PYG{n}{x\PYGZus{}extend}\PYG{p}{,}\PYG{n}{y\PYGZus{}extend}\PYG{p}{,}\PYG{n}{kind}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{linear}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ynew} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{n}{xnew}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{xnew}\PYG{p}{,}\PYG{n}{ynew}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x\PYGZus{}}\PYG{p}{,}\PYG{n}{y\PYGZus{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r+}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlim}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{366}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{366}\PYG{p}{)}
\end{Verbatim}

\includegraphics{Interpolation_56_1.png}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} cubic interpolation}
\PYG{n}{f} \PYG{o}{=} \PYG{n}{interpolate}\PYG{o}{.}\PYG{n}{interp1d}\PYG{p}{(}\PYG{n}{x\PYGZus{}extend}\PYG{p}{,}\PYG{n}{y\PYGZus{}extend}\PYG{p}{,}\PYG{n}{kind}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{cubic}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ynew} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{n}{xnew}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{xnew}\PYG{p}{,}\PYG{n}{ynew}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x\PYGZus{}}\PYG{p}{,}\PYG{n}{y\PYGZus{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r+}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlim}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{366}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{366}\PYG{p}{)}
\end{Verbatim}

\includegraphics{Interpolation_57_1.png}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} nearest neighbour interpolation}
\PYG{n}{f} \PYG{o}{=} \PYG{n}{interpolate}\PYG{o}{.}\PYG{n}{interp1d}\PYG{p}{(}\PYG{n}{x\PYGZus{}extend}\PYG{p}{,}\PYG{n}{y\PYGZus{}extend}\PYG{p}{,}\PYG{n}{kind}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nearest}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ynew} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{n}{xnew}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{xnew}\PYG{p}{,}\PYG{n}{ynew}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x\PYGZus{}}\PYG{p}{,}\PYG{n}{y\PYGZus{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r+}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlim}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{366}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{366}\PYG{p}{)}
\end{Verbatim}

\includegraphics{Interpolation_58_1.png}

Depending on the problem you are trying to solve, different
interpolation schemes will be appropriate. For categorical data (e.g.
`snow', coded as 1 and `no snow' coded as 1), for instance, a nearest
neighbour interpolation might be a good idea.


\subsection{5.2.2 Smoothing}
\label{Chapter5_Interpolation/Interpolation:smoothing}
One issue with the schemes above is that they go exactly through the
data points, but a more realistic description of the data might be one
that incorporated the uncertainty information we have. Visually, this is
quite easy to imagine, but how can we implement such ideas?

One way of thinking about this is to think about other sources of
information that we might bring to bear on the problem. One such would
be that we expect the function to be `quite smooth'. This allows us to
consider applying smoothness as an additional constraint to the
solution.

Many such problems can be phrased as convolution operations.

Convolution is a form of digital filtering that combines two sequences
of numbers \(y\) and \(w\) to give a third, the result \(z\)
that is a filtered version of \(y\), where for each element
\(j\) of \(y\):
\begin{gather}
\begin{split}z_j = \sum_{i=-n}^{i=n}{w_i y_{j+i}}\end{split}\notag
\end{gather}
where \(n\) is the half width of the filter \(w\). For a
smoothing filter, the elements of this will sum to 1 (so that the
magnitude of \(y\) is not changed).

To illustrate this in Python:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} a simple box smoothing filter}
\PYG{c}{\PYGZsh{} filter width 11}
\PYG{n}{w} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}\PYG{l+m+mi}{11}\PYG{p}{)}
\PYG{c}{\PYGZsh{} normalise}
\PYG{n}{w} \PYG{o}{=} \PYG{n}{w}\PYG{o}{/}\PYG{n}{w}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{p}{)}
\PYG{c}{\PYGZsh{} half width}
\PYG{n}{n} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{2}

\PYG{c}{\PYGZsh{} Take the linear interpolation of the LAI above as the signal}
\PYG{c}{\PYGZsh{} linear interpolation}
\PYG{n}{x} \PYG{o}{=} \PYG{n}{xnew}
\PYG{n}{f} \PYG{o}{=} \PYG{n}{interpolate}\PYG{o}{.}\PYG{n}{interp1d}\PYG{p}{(}\PYG{n}{x\PYGZus{}extend}\PYG{p}{,}\PYG{n}{y\PYGZus{}extend}\PYG{p}{,}\PYG{n}{kind}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{linear}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{y} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}

\PYG{c}{\PYGZsh{} where we will put the result}
\PYG{n}{z} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros\PYGZus{}like}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}

\PYG{c}{\PYGZsh{} This is a straight implementation of the}
\PYG{c}{\PYGZsh{} equation above}
\PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{n}{n}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{n}\PYG{p}{,}\PYG{n}{n}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{z}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{w}\PYG{p}{[}\PYG{n}{n}\PYG{o}{+}\PYG{n}{i}\PYG{p}{]} \PYG{o}{*} \PYG{n}{y}\PYG{p}{[}\PYG{n}{j}\PYG{o}{+}\PYG{n}{i}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{k\PYGZhy{}\PYGZhy{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{label}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{y}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{z}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{label}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{z}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlim}\PYG{p}{(}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{x}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{n}{loc}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{best}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{smoothing with filter width }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.text.Text at 0x2ae9e579e3d0\PYGZgt{}
\end{Verbatim}

\includegraphics{Interpolation_63_1.png}

As we suggested, the result of convolving \(y\) with the filter
\(w\) (of width 31 here) is \(z\), a smoothed version of
\(y\).

You might notice that the filter is only applied once we are \code{n}
samples into the signal, so we get `edge effects'. There are various
ways of dealing with edge effects, such as repeating the signal (as we
did above, for much the same reason), reflecting the signal, or assuming
the signal to be some constant value (e.g. 0) outside of its defined
domain.

If we make the filter wider (width 31 now):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} a simple box smoothing filter}
\PYG{c}{\PYGZsh{} filter width 31}
\PYG{n}{w} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}\PYG{l+m+mi}{31}\PYG{p}{)}
\PYG{c}{\PYGZsh{} normalise}
\PYG{n}{w} \PYG{o}{=} \PYG{n}{w}\PYG{o}{/}\PYG{n}{w}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{p}{)}
\PYG{c}{\PYGZsh{} half width}
\PYG{n}{n} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{2}

\PYG{c}{\PYGZsh{} Take the linear interpolation of the LAI above as the signal}
\PYG{c}{\PYGZsh{} linear interpolation}
\PYG{n}{x} \PYG{o}{=} \PYG{n}{xnew}
\PYG{n}{f} \PYG{o}{=} \PYG{n}{interpolate}\PYG{o}{.}\PYG{n}{interp1d}\PYG{p}{(}\PYG{n}{x\PYGZus{}extend}\PYG{p}{,}\PYG{n}{y\PYGZus{}extend}\PYG{p}{,}\PYG{n}{kind}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{linear}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{y} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}

\PYG{c}{\PYGZsh{} where we will put the result}
\PYG{n}{z} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros\PYGZus{}like}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}

\PYG{c}{\PYGZsh{} This is a straight implementation of the}
\PYG{c}{\PYGZsh{} equation above}
\PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{n}{n}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{n}\PYG{p}{,}\PYG{n}{n}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{z}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{w}\PYG{p}{[}\PYG{n}{n}\PYG{o}{+}\PYG{n}{i}\PYG{p}{]} \PYG{o}{*} \PYG{n}{y}\PYG{p}{[}\PYG{n}{j}\PYG{o}{+}\PYG{n}{i}\PYG{p}{]}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{k\PYGZhy{}\PYGZhy{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{label}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{y}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{z}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{label}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{z}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlim}\PYG{p}{(}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{x}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{n}{loc}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{best}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{smoothing with filter width }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.text.Text at 0x2ae9e61f8cd0\PYGZgt{}
\end{Verbatim}

\includegraphics{Interpolation_65_1.png}

Then the signal is `more' smoothed.

There are \emph{many} filters implemented in
\code{{}`scipy.signal} \textless{}\href{http://docs.scipy.org/doc/scipy/reference/signal.html}{http://docs.scipy.org/doc/scipy/reference/signal.html}\textgreater{}{}`\_\_
that you should look over.

A very commonly used smoothing filter is the
\href{http://en.wikipedia.org/wiki/SavitzkyGolay\_filter\_for\_smoothing\_and\_differentiation}{Savitsky-Golay}
filter for which you define the window size and filter order.

As with most filters, the filter width controls the degree of smoothing
(see examples above). The filter order (related to polynomial order) in
essence controls the shape of the filter and defines the `peakiness' of
the response.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{n}{sys}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/python}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{c}{\PYGZsh{} see http://wiki.scipy.org/Cookbook/SavitzkyGolay}
\PYG{k+kn}{from} \PYG{n+nn}{savitzky\PYGZus{}golay} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{n}{window\PYGZus{}size} \PYG{o}{=} \PYG{l+m+mi}{31}
\PYG{n}{order} \PYG{o}{=} \PYG{l+m+mi}{1}

\PYG{c}{\PYGZsh{} Take the linear interpolation of the LAI above as the signal}
\PYG{c}{\PYGZsh{} linear interpolation}
\PYG{n}{x} \PYG{o}{=} \PYG{n}{xnew}
\PYG{n}{f} \PYG{o}{=} \PYG{n}{interpolate}\PYG{o}{.}\PYG{n}{interp1d}\PYG{p}{(}\PYG{n}{x\PYGZus{}extend}\PYG{p}{,}\PYG{n}{y\PYGZus{}extend}\PYG{p}{,}\PYG{n}{kind}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{linear}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{y} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}

\PYG{n}{z} \PYG{o}{=} \PYG{n}{savitzky\PYGZus{}golay}\PYG{p}{(}\PYG{n}{y}\PYG{p}{,}\PYG{n}{window\PYGZus{}size}\PYG{p}{,}\PYG{n}{order}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{k\PYGZhy{}\PYGZhy{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{label}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{y}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{z}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{label}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{z}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlim}\PYG{p}{(}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{x}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{n}{loc}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{best}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{smoothing with filter width }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{ order }\PYG{l+s+si}{\PYGZpc{}.2f}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{window\PYGZus{}size}\PYG{p}{,}\PYG{n}{order}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.text.Text at 0x2ae9e65e6890\PYGZgt{}
\end{Verbatim}

\includegraphics{Interpolation_68_1.png}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{n}{sys}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/python}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{c}{\PYGZsh{} see http://wiki.scipy.org/Cookbook/SavitzkyGolay}
\PYG{k+kn}{from} \PYG{n+nn}{savitzky\PYGZus{}golay} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{n}{window\PYGZus{}size} \PYG{o}{=} \PYG{l+m+mi}{61}
\PYG{n}{order} \PYG{o}{=} \PYG{l+m+mi}{2}

\PYG{c}{\PYGZsh{} Take the linear interpolation of the LAI above as the signal}
\PYG{c}{\PYGZsh{} linear interpolation}
\PYG{n}{x} \PYG{o}{=} \PYG{n}{xnew}
\PYG{n}{f} \PYG{o}{=} \PYG{n}{interpolate}\PYG{o}{.}\PYG{n}{interp1d}\PYG{p}{(}\PYG{n}{x\PYGZus{}extend}\PYG{p}{,}\PYG{n}{y\PYGZus{}extend}\PYG{p}{,}\PYG{n}{kind}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{linear}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{y} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}

\PYG{n}{z} \PYG{o}{=} \PYG{n}{savitzky\PYGZus{}golay}\PYG{p}{(}\PYG{n}{y}\PYG{p}{,}\PYG{n}{window\PYGZus{}size}\PYG{p}{,}\PYG{n}{order}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{k\PYGZhy{}\PYGZhy{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{label}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{y}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{z}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{label}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{z}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlim}\PYG{p}{(}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{x}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{n}{loc}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{best}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{smoothing with filter width }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{ order }\PYG{l+s+si}{\PYGZpc{}.2f}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{window\PYGZus{}size}\PYG{p}{,}\PYG{n}{order}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.text.Text at 0x2ae9e663bb50\PYGZgt{}
\end{Verbatim}

\includegraphics{Interpolation_69_1.png}

If the samples \(y\) have uncertainty (standard deviation
\(\sigma_j\) for sample \(j\)) associated with them, we can
incorporate this into smoothing, although many of the methods in
\code{scipy} and \code{numpy} do not directly allow for this.

Instead, we call an optimal interpolation scheme (a regulariser) here
that achieves this. This also has the advantage of giving an estimate of
uncertainty for the smoothed samples.

In this case, the parameters are: \code{order} (as above, but only integer
in this implementation) and \code{wsd} which is an estimate of the
variation (standard deviation) in the signal that control smoothness.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{tile} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{h17v03}\PYG{l+s}{\PYGZsq{}}
\PYG{n}{year} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{2005}\PYG{l+s}{\PYGZsq{}}

\PYG{c}{\PYGZsh{} specify the file with the urls in}
\PYG{n}{ifile}\PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/modis\PYGZus{}lai\PYGZus{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZus{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{.txt}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{tile}\PYG{p}{,}\PYG{n}{year}\PYG{p}{)}

\PYG{n}{fp} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{ifile}\PYG{p}{)}
\PYG{n}{filelist} \PYG{o}{=} \PYG{p}{[}\PYG{n}{url}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{strip}\PYG{p}{(}\PYG{p}{)} \PYG{k}{for} \PYG{n}{url} \PYG{o+ow}{in} \PYG{n}{fp}\PYG{o}{.}\PYG{n}{readlines}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}
\PYG{n}{fp}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{n}{sys}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/python}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{k+kn}{from} \PYG{n+nn}{get\PYGZus{}lai} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{k}{try}\PYG{p}{:}
    \PYG{n}{data} \PYG{o}{=} \PYG{n}{lai}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
    \PYG{n}{sd} \PYG{o}{=} \PYG{n}{lai}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{LaiStdDev\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\PYG{k}{except}\PYG{p}{:}
    \PYG{n}{lai} \PYG{o}{=} \PYG{n}{read\PYGZus{}lai}\PYG{p}{(}\PYG{n}{filelist}\PYG{p}{,}\PYG{n}{country}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{IRELAND}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{data} \PYG{o}{=} \PYG{n}{lai}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
    \PYG{n}{sd} \PYG{o}{=} \PYG{n}{lai}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{LaiStdDev\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}

\PYG{n}{thresh} \PYG{o}{=} \PYG{l+m+mf}{0.25}
\PYG{n}{sd}\PYG{p}{[}\PYG{n}{sd}\PYG{o}{\PYGZlt{}}\PYG{n}{thresh}\PYG{p}{]} \PYG{o}{=} \PYG{n}{thresh}

\PYG{n}{r} \PYG{o}{=} \PYG{l+m+mi}{472}
\PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{84}
\PYG{k+kn}{from} \PYG{n+nn}{smoothn} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{c}{\PYGZsh{} this is about the right amount of smoothing here}
\PYG{n}{gamma} \PYG{o}{=} \PYG{l+m+mf}{5.}

\PYG{n}{pixel} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{]}
\PYG{n}{pixel\PYGZus{}sd} \PYG{o}{=}   \PYG{n}{sd}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{]}

\PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{46}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{8}\PYG{o}{+}\PYG{l+m+mi}{1}

\PYG{n}{order} \PYG{o}{=} \PYG{l+m+mi}{2}
\PYG{n}{z} \PYG{o}{=} \PYG{n}{smoothn}\PYG{p}{(}\PYG{n}{pixel}\PYG{p}{,}\PYG{n}{s}\PYG{o}{=}\PYG{n}{gamma}\PYG{p}{,}\PYG{n}{sd}\PYG{o}{=}\PYG{n}{pixel\PYGZus{}sd}\PYG{p}{,}\PYG{n}{smoothOrder}\PYG{o}{=}\PYG{l+m+mf}{2.0}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}

\PYG{c}{\PYGZsh{} plot}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{pixel}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{k*}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{label}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{y}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{errorbar}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{pixel}\PYG{p}{,}\PYG{n}{pixel\PYGZus{}sd}\PYG{o}{*}\PYG{l+m+mf}{1.96}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{z}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{label}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{z}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{c}{\PYGZsh{} lower and upper bounds of 95\PYGZpc{} CI}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlim}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{366}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylim}\PYG{p}{(}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{l+m+mf}{2.5}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{n}{loc}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{best}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.legend.Legend at 0x2b75e4be2790\PYGZgt{}
\end{Verbatim}

\includegraphics{Interpolation_71_1.png}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} test it on a new pixel}

\PYG{n}{r} \PYG{o}{=} \PYG{l+m+mi}{472}
\PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{86}

\PYG{n}{gamma} \PYG{o}{=} \PYG{l+m+mi}{5}

\PYG{n}{pixel} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{]}
\PYG{n}{pixel\PYGZus{}sd} \PYG{o}{=}   \PYG{n}{sd}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{]}

\PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{46}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{8}\PYG{o}{+}\PYG{l+m+mi}{1}

\PYG{n}{order} \PYG{o}{=} \PYG{l+m+mi}{2}
\PYG{n}{z} \PYG{o}{=} \PYG{n}{smoothn}\PYG{p}{(}\PYG{n}{pixel}\PYG{p}{,}\PYG{n}{s}\PYG{o}{=}\PYG{n}{gamma}\PYG{p}{,}\PYG{n}{sd}\PYG{o}{=}\PYG{n}{pixel\PYGZus{}sd}\PYG{p}{,}\PYG{n}{smoothOrder}\PYG{o}{=}\PYG{l+m+mf}{2.0}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}

\PYG{c}{\PYGZsh{} plot}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{pixel}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{k*}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{label}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{y}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{errorbar}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{pixel}\PYG{p}{,}\PYG{n}{pixel\PYGZus{}sd}\PYG{o}{*}\PYG{l+m+mf}{1.96}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{z}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{label}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{z}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlim}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{366}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{n}{loc}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{best}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{z}\PYG{o}{.}\PYG{n}{ndim}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{1}
\end{Verbatim}

\includegraphics{Interpolation_72_1.png}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} and test it on a new pixel}

\PYG{n}{r} \PYG{o}{=} \PYG{l+m+mi}{472}
\PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{84}

\PYG{c}{\PYGZsh{}r = 9}
\PYG{c}{\PYGZsh{}c = 277}
\PYG{n}{gamma} \PYG{o}{=} \PYG{l+m+mf}{5.}

\PYG{n}{pixel} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{]}
\PYG{n}{pixel\PYGZus{}sd} \PYG{o}{=}   \PYG{n}{sd}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{]}

\PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{46}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{8}\PYG{o}{+}\PYG{l+m+mi}{1}

\PYG{n}{order} \PYG{o}{=} \PYG{l+m+mi}{2}
\PYG{c}{\PYGZsh{} solve for gamma \PYGZhy{} degree of smoothness}
\PYG{n}{zz} \PYG{o}{=} \PYG{n}{smoothn}\PYG{p}{(}\PYG{n}{pixel}\PYG{p}{,}\PYG{n}{sd}\PYG{o}{=}\PYG{n}{pixel\PYGZus{}sd}\PYG{p}{,}\PYG{n}{smoothOrder}\PYG{o}{=}\PYG{l+m+mf}{2.0}\PYG{p}{)}
\PYG{n}{z} \PYG{o}{=} \PYG{n}{zz}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{k}{print} \PYG{n}{zz}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{n}{zz}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}

\PYG{n}{gamma} \PYG{o}{=} \PYG{n}{zz}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}

\PYG{c}{\PYGZsh{} plot}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{pixel}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{k*}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{label}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{y}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{errorbar}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{pixel}\PYG{p}{,}\PYG{n}{pixel\PYGZus{}sd}\PYG{o}{*}\PYG{l+m+mf}{1.96}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{z}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{label}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{z}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlim}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{366}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{n}{loc}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{best}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
7.56265788653 True
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.legend.Legend at 0x2b75e6878890\PYGZgt{}
\end{Verbatim}

\includegraphics{Interpolation_73_2.png}

To apply this approach to our 3D dataset, we could simply loop over all
pixels.

Note that \emph{any} per-pixel processing will be slow ... but this is quite
a fast smoothing method, so is feasible here.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} we have put in an axis control to smoothn}
\PYG{c}{\PYGZsh{} here so it will only smooth over doy}
\PYG{c}{\PYGZsh{} This will take a few minutes to process}
\PYG{c}{\PYGZsh{} we switch on verbose mode to get some feedback}
\PYG{c}{\PYGZsh{} on progress}

\PYG{c}{\PYGZsh{} make a mask of pixels where there is at least 1 sample}
\PYG{c}{\PYGZsh{} over the time period}
\PYG{n}{mask} \PYG{o}{=} \PYG{p}{(}\PYG{n}{data}\PYG{o}{.}\PYG{n}{mask}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{mask} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{n}{mask}\PYG{p}{]}\PYG{o}{*}\PYG{n}{data}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{z} \PYG{o}{=} \PYG{n}{smoothn}\PYG{p}{(}\PYG{n}{data}\PYG{p}{,}\PYG{n}{s}\PYG{o}{=}\PYG{l+m+mf}{5.0}\PYG{p}{,}\PYG{n}{sd}\PYG{o}{=}\PYG{n}{sd}\PYG{p}{,}\PYG{n}{smoothOrder}\PYG{o}{=}\PYG{l+m+mf}{2.0}\PYG{p}{,}\PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{TolZ}\PYG{o}{=}\PYG{l+m+mf}{0.05}\PYG{p}{,}\PYG{n}{verbose}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{z} \PYG{o}{=} \PYG{n}{ma}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{z}\PYG{p}{,}\PYG{n}{mask}\PYG{o}{=}\PYG{n}{mask}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
tol 1.0 nit 0
tol 1.03767913976 nit 1
tol 0.695375818129 nit 2
tol 0.55340286659 nit 3
tol 0.379048609608 nit 4
tol 0.297133997656 nit 5
tol 0.211254020382 nit 6
tol 0.161703395437 nit 7
tol 0.118022633002 nit 8
tol 0.089141179031 nit 9
tol 0.0662378920796 nit 10
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{9}\PYG{p}{,}\PYG{l+m+mi}{9}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{z}\PYG{p}{[}\PYG{l+m+mi}{20}\PYG{p}{]}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{vmax}\PYG{o}{=}\PYG{l+m+mi}{6}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.colorbar.Colorbar instance at 0x2b75d2d9fd40\PYGZgt{}
\end{Verbatim}

\includegraphics{Interpolation_76_1.png}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} similarly, take frame 20}
\PYG{c}{\PYGZsh{} and smooth that}

\PYG{n}{ZZ} \PYG{o}{=} \PYG{n}{smoothn}\PYG{p}{(}\PYG{n}{z}\PYG{p}{[}\PYG{l+m+mi}{20}\PYG{p}{]}\PYG{p}{,}\PYG{n}{smoothOrder}\PYG{o}{=}\PYG{l+m+mf}{2.}\PYG{p}{)}
\PYG{c}{\PYGZsh{} self\PYGZhy{}calibrated smoothness term}
\PYG{n}{s} \PYG{o}{=} \PYG{n}{ZZ}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{s =}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{s}
\PYG{n}{Z} \PYG{o}{=} \PYG{n}{ZZ}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{9}\PYG{p}{,}\PYG{l+m+mi}{9}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{Z}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{vmax}\PYG{o}{=}\PYG{l+m+mi}{6}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{s} \PYG{o}{=} \PYG{l+m+mf}{0.731142059593}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.colorbar.Colorbar instance at 0x1857ee18\PYGZgt{}
\end{Verbatim}

\includegraphics{Interpolation_77_2.png}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} similarly, take frame 20}
\PYG{c}{\PYGZsh{} and smooth that}

\PYG{n}{ZZ} \PYG{o}{=} \PYG{n}{smoothn}\PYG{p}{(}\PYG{n}{z}\PYG{p}{,}\PYG{n}{s}\PYG{o}{=}\PYG{n}{s}\PYG{p}{,}\PYG{n}{smoothOrder}\PYG{o}{=}\PYG{l+m+mf}{2.}\PYG{p}{,}\PYG{n}{axis}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,}\PYG{n}{verbose}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}

\PYG{n}{Z} \PYG{o}{=} \PYG{n}{ZZ}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{9}\PYG{p}{,}\PYG{l+m+mi}{9}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{Z}\PYG{p}{[}\PYG{l+m+mi}{30}\PYG{p}{]}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{vmax}\PYG{o}{=}\PYG{l+m+mi}{6}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
tol 1.0 nit 0
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.colorbar.Colorbar instance at 0x23289dd0\PYGZgt{}
\end{Verbatim}

\includegraphics{Interpolation_78_2.png}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{46}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{8}\PYG{o}{+}\PYG{l+m+mf}{1.}
\PYG{k}{try}\PYG{p}{:}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{n}{Z}\PYG{p}{,}\PYG{n}{axis}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{min}\PYG{p}{(}\PYG{n}{Z}\PYG{p}{,}\PYG{n}{axis}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r\PYGZhy{}\PYGZhy{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{n}{Z}\PYG{p}{,}\PYG{n}{axis}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r\PYGZhy{}\PYGZhy{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{except}\PYG{p}{:}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{n}{Z}\PYG{p}{,}\PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{min}\PYG{p}{(}\PYG{n}{Z}\PYG{p}{,}\PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{.}\PYG{n}{min}\PYG{p}{(}\PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r\PYGZhy{}\PYGZhy{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{n}{Z}\PYG{p}{,}\PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r\PYGZhy{}\PYGZhy{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{LAI variation of Eire}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.text.Text at 0x232b2ed0\PYGZgt{}
\end{Verbatim}

\includegraphics{Interpolation_79_1.png}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} or doing this pixel by pixel ...}
\PYG{c}{\PYGZsh{} which is slower than using axis}

\PYG{n}{order} \PYG{o}{=} \PYG{l+m+mi}{2}

\PYG{c}{\PYGZsh{} pixels that have some data}
\PYG{n}{mask} \PYG{o}{=} \PYG{p}{(}\PYG{o}{\PYGZti{}}\PYG{n}{data}\PYG{o}{.}\PYG{n}{mask}\PYG{p}{)}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}

\PYG{n}{odata} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{46}\PYG{p}{,}\PYG{p}{)} \PYG{o}{+} \PYG{n}{mask}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{)}

\PYG{n}{rows}\PYG{p}{,}\PYG{n}{cols} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{where}\PYG{p}{(}\PYG{n}{mask}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{0}\PYG{p}{)}

\PYG{n}{len\PYGZus{}x} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{rows}\PYG{p}{)}
\PYG{n}{order} \PYG{o}{=} \PYG{l+m+mi}{2}
\PYG{n}{gamma} \PYG{o}{=} \PYG{l+m+mf}{5.}

\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{n}{len\PYGZus{}x}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{r}\PYG{p}{,}\PYG{n}{c} \PYG{o}{=} \PYG{n}{rows}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,}\PYG{n}{cols}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
    \PYG{c}{\PYGZsh{} progress bar}
    \PYG{k}{if} \PYG{n}{i}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{len\PYGZus{}x}\PYG{o}{/}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:}
        \PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{... }\PYG{l+s+si}{\PYGZpc{}4.2f}\PYG{l+s}{ percent}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{i}\PYG{o}{*}\PYG{l+m+mf}{100.}\PYG{o}{/}\PYG{n+nb}{float}\PYG{p}{(}\PYG{n}{len\PYGZus{}x}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{pixel}    \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{]}
    \PYG{n}{pixel\PYGZus{}sd} \PYG{o}{=} \PYG{n}{sd}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{]}

    \PYG{n}{zz} \PYG{o}{=} \PYG{n}{smoothn}\PYG{p}{(}\PYG{n}{pixel}\PYG{p}{,}\PYG{n}{s}\PYG{o}{=}\PYG{n}{gamma}\PYG{p}{,}\PYG{n}{sd}\PYG{o}{=}\PYG{n}{pixel\PYGZus{}sd}\PYG{p}{,}\PYG{n}{smoothOrder}\PYG{o}{=}\PYG{n}{order}\PYG{p}{,}\PYG{n}{TolZ}\PYG{o}{=}\PYG{l+m+mf}{0.05}\PYG{p}{)}
    \PYG{n}{odata}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{rows}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,}\PYG{n}{cols}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{]} \PYG{o}{=} \PYG{n}{zz}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{0.00} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{5.00} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{10.00} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{15.00} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{20.00} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{25.00} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{30.00} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{35.00} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{40.00} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{45.00} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{50.00} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{55.00} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{60.00} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{65.00} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{70.00} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{75.00} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{80.00} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{85.00} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{90.00} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{95.00} \PYG{n}{percent}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{pylab} \PYG{k+kn}{as} \PYG{n+nn}{plt}
\PYG{k+kn}{import} \PYG{n+nn}{os}

\PYG{n}{root} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/images/lai\PYGZus{}eire\PYGZus{}colourZ}\PYG{l+s}{\PYGZsq{}}

\PYG{k}{for} \PYG{n}{i}\PYG{p}{,}\PYG{n}{f} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{lai}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{filenames}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{fig} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{)}\PYG{p}{)}
    \PYG{c}{\PYGZsh{} get some info from filename}
    \PYG{n}{file\PYGZus{}id} \PYG{o}{=} \PYG{n}{f}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{.}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{p}{]}
    \PYG{k}{print} \PYG{n}{file\PYGZus{}id}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{Z}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{vmax}\PYG{o}{=}\PYG{l+m+mf}{6.}\PYG{p}{,}\PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mf}{0.0}\PYG{p}{)}
    \PYG{c}{\PYGZsh{} plot a jpg}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{n}{file\PYGZus{}id}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZus{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{.jpg}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{root}\PYG{p}{,}\PYG{n}{file\PYGZus{}id}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{n}{fig}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{2005001}
\PYG{l+m+mi}{2005009}
\PYG{l+m+mi}{2005017}
\PYG{l+m+mi}{2005025}
\PYG{l+m+mi}{2005033}
\PYG{l+m+mi}{2005041}
\PYG{l+m+mi}{2005049}
\PYG{l+m+mi}{2005057}
\PYG{l+m+mi}{2005065}
\PYG{l+m+mi}{2005073}
\PYG{l+m+mi}{2005081}
\PYG{l+m+mi}{2005089}
\PYG{l+m+mi}{2005097}
\PYG{l+m+mi}{2005105}
\PYG{l+m+mi}{2005113}
\PYG{l+m+mi}{2005121}
\PYG{l+m+mi}{2005129}
\PYG{l+m+mi}{2005137}
\PYG{l+m+mi}{2005145}
\PYG{l+m+mi}{2005153}
\PYG{l+m+mi}{2005161}
\PYG{l+m+mi}{2005169}
\PYG{l+m+mi}{2005177}
\PYG{l+m+mi}{2005185}
\PYG{l+m+mi}{2005193}
\PYG{l+m+mi}{2005201}
\PYG{l+m+mi}{2005209}
\PYG{l+m+mi}{2005217}
\PYG{l+m+mi}{2005225}
\PYG{l+m+mi}{2005233}
\PYG{l+m+mi}{2005241}
\PYG{l+m+mi}{2005249}
\PYG{l+m+mi}{2005257}
\PYG{l+m+mi}{2005265}
\PYG{l+m+mi}{2005273}
\PYG{l+m+mi}{2005281}
\PYG{l+m+mi}{2005289}
\PYG{l+m+mi}{2005297}
\PYG{l+m+mi}{2005305}
\PYG{l+m+mi}{2005313}
\PYG{l+m+mi}{2005321}
\PYG{l+m+mi}{2005329}
\PYG{l+m+mi}{2005337}
\PYG{l+m+mi}{2005345}
\PYG{l+m+mi}{2005353}
\PYG{l+m+mi}{2005361}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{cmd} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{convert \PYGZhy{}delay 100 \PYGZhy{}loop 0 \PYGZob{}0\PYGZcb{}\PYGZus{}*.jpg \PYGZob{}0\PYGZcb{}\PYGZus{}movie2.gif}\PYG{l+s}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{root}\PYG{p}{)}
\PYG{n}{os}\PYG{o}{.}\PYG{n}{system}\PYG{p}{(}\PYG{n}{cmd}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{0}
\end{Verbatim}
\begin{figure}[htbp]
\centering

\includegraphics{Chapter5_Interpolation/files/images/lai_eire_colourZ_movie2.gif}
\end{figure}


\subsection{5.3 Function fitting}
\label{Chapter5_Interpolation/Interpolation:function-fitting}
Sometimes, instead of applying some arbitrary smoothing function to
data, we want to extract particular infromation from the time series.

One way to approach this is to fit some function to the time series at
each location.

Let us suppose that we wish to characterise the phenology of vegetation
in Ireland.
\begin{figure}[htbp]
\centering
\end{figure}

One way we could do this would be to look in the lai data for the most
rapid changes.

Another would be to explicitly fit some mathematical function to the LAI
data that would would expect to descrive typical LAI trajectories.

One example of such a function is the double logistic. A logistic
function is:
\begin{gather}
\begin{split}\hat{y} = p_0 - p_1 \left( \frac{1}{1 + e^{p_2 (t - p_3)}} + \frac{1}{1 + e^{p_4 (t - p_5)}} -1\right)\end{split}\notag
\end{gather}
We can give a function for a double logistic:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{dbl\PYGZus{}logistic\PYGZus{}model} \PYG{p}{(} \PYG{n}{p}\PYG{p}{,} \PYG{n}{t} \PYG{p}{)}\PYG{p}{:}
        \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}A double logistic model, as in Sobrino and Juliean, or Zhang et al\PYGZdq{}\PYGZdq{}\PYGZdq{}}
        \PYG{k}{return} \PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{*} \PYG{p}{(} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{*}\PYG{p}{(}\PYG{n}{t}\PYG{o}{\PYGZhy{}}\PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYGZbs{}
                              \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{o}{*}\PYG{p}{(}\PYG{n}{t}\PYG{o}{\PYGZhy{}}\PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}  \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1} \PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{tile} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{h17v03}\PYG{l+s}{\PYGZsq{}}
\PYG{n}{year} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{2005}\PYG{l+s}{\PYGZsq{}}

\PYG{c}{\PYGZsh{} specify the file with the urls in}
\PYG{n}{ifile}\PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/modis\PYGZus{}lai\PYGZus{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZus{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{.txt}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{tile}\PYG{p}{,}\PYG{n}{year}\PYG{p}{)}

\PYG{n}{fp} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{ifile}\PYG{p}{)}
\PYG{n}{filelist} \PYG{o}{=} \PYG{p}{[}\PYG{n}{url}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{strip}\PYG{p}{(}\PYG{p}{)} \PYG{k}{for} \PYG{n}{url} \PYG{o+ow}{in} \PYG{n}{fp}\PYG{o}{.}\PYG{n}{readlines}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}
\PYG{n}{fp}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{n}{sys}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/python}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{k+kn}{from} \PYG{n+nn}{get\PYGZus{}lai} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{k}{try}\PYG{p}{:}
    \PYG{n}{data} \PYG{o}{=} \PYG{n}{lai}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
    \PYG{n}{sd} \PYG{o}{=} \PYG{n}{lai}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{LaiStdDev\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\PYG{k}{except}\PYG{p}{:}
    \PYG{n}{lai} \PYG{o}{=} \PYG{n}{read\PYGZus{}lai}\PYG{p}{(}\PYG{n}{filelist}\PYG{p}{,}\PYG{n}{country}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{IRELAND}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{data} \PYG{o}{=} \PYG{n}{lai}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
    \PYG{n}{sd} \PYG{o}{=} \PYG{n}{lai}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{LaiStdDev\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}

\PYG{n}{thresh} \PYG{o}{=} \PYG{l+m+mf}{0.25}
\PYG{n}{sd}\PYG{p}{[}\PYG{n}{sd}\PYG{o}{\PYGZlt{}}\PYG{n}{thresh}\PYG{p}{]} \PYG{o}{=} \PYG{n}{thresh}

\PYG{c}{\PYGZsh{} test pixel}
\PYG{n}{r} \PYG{o}{=} \PYG{l+m+mi}{472}
\PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{84}


\PYG{n}{y} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{]}
\PYG{n}{mask} \PYG{o}{=} \PYG{o}{\PYGZti{}}\PYG{n}{y}\PYG{o}{.}\PYG{n}{mask}
\PYG{n}{y} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{y}\PYG{p}{[}\PYG{n}{mask}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{x} \PYG{o}{=} \PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{46}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{8}\PYG{o}{+}\PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{[}\PYG{n}{mask}\PYG{p}{]}
\PYG{n}{unc} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{sd}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{]}\PYG{p}{[}\PYG{n}{mask}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

And see what this looks like:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} define x (time)}
\PYG{n}{x\PYGZus{}full} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{366}\PYG{p}{)}

\PYG{c}{\PYGZsh{} some default values for the parameters}
\PYG{n}{p} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)}

\PYG{c}{\PYGZsh{} some stats on y}
\PYG{n}{ysd} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{std}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}
\PYG{n}{ymean} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}

\PYG{c}{\PYGZsh{} some rough guesses at the parameters}

\PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n}{ymean} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{1.151}\PYG{o}{*}\PYG{n}{ysd}\PYG{p}{;}   \PYG{c}{\PYGZsh{} minimum  (1.151 is 75\PYGZpc{} CI)}
\PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{l+m+mf}{1.151}\PYG{o}{*}\PYG{n}{ysd}          \PYG{c}{\PYGZsh{} range}
\PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{0.19}                 \PYG{c}{\PYGZsh{} related to up slope}
\PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{120}                  \PYG{c}{\PYGZsh{} midpoint of up slope}
\PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{0.13}                 \PYG{c}{\PYGZsh{} related to down slope}
\PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{220}                  \PYG{c}{\PYGZsh{} midpoint of down slope}

\PYG{n}{y\PYGZus{}hat} \PYG{o}{=} \PYG{n}{dbl\PYGZus{}logistic\PYGZus{}model}\PYG{p}{(}\PYG{n}{p}\PYG{p}{,}\PYG{n}{x\PYGZus{}full}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{clf}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x\PYGZus{}full}\PYG{p}{,}\PYG{n}{y\PYGZus{}hat}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{*}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{errorbar}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{unc}\PYG{o}{*}\PYG{l+m+mf}{1.96}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}Container object of 3 artists\PYGZgt{}
\end{Verbatim}

\includegraphics{Interpolation_90_1.png}

We could manually `tweak' the parameters until we got a better `fit' to
the observations.

First though, let's define a measure of `fit':
\begin{gather}
\begin{split}Z_i = \frac{\hat{y}_i - y_i}{\sigma_i}\end{split}\notag
\end{gather}\begin{gather}
\begin{split}Z^2 = \sum_i{Z_i^2} =  \sum_i{\left( \frac{\hat{y}_i - y_i}{\sigma_i} \right)^2}\end{split}\notag
\end{gather}
and implement this as a mismatch function where we have data points:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{mismatch\PYGZus{}function}\PYG{p}{(}\PYG{n}{p}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{unc}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{y\PYGZus{}hat} \PYG{o}{=} \PYG{n}{dbl\PYGZus{}logistic\PYGZus{}model}\PYG{p}{(}\PYG{n}{p}\PYG{p}{,} \PYG{n}{x}\PYG{p}{)}
    \PYG{n}{diff} \PYG{o}{=} \PYG{p}{(}\PYG{n}{y\PYGZus{}hat} \PYG{o}{\PYGZhy{}} \PYG{n}{y}\PYG{p}{)}\PYG{o}{/}\PYG{n}{unc}
    \PYG{k}{return} \PYG{n}{diff}


\PYG{n}{Z} \PYG{o}{=} \PYG{n}{mismatch\PYGZus{}function}\PYG{p}{(}\PYG{n}{p}\PYG{p}{,}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{unc}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mf}{365.}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mf}{0.}\PYG{p}{]}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{k\PYGZhy{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlim}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{365}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{Z}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{*}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}


\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Z\PYGZca{}2 =}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{p}{(}\PYG{n}{Z}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Z}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{=} \PYG{l+m+mf}{113.325251358}
\end{Verbatim}

\includegraphics{Interpolation_92_1.png}

Now lets change p a bit:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n}{ymean} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{1.151}\PYG{o}{*}\PYG{n}{ysd}\PYG{p}{;}   \PYG{c}{\PYGZsh{} minimum  (1.151 is 75\PYGZpc{} CI)}
\PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{l+m+mf}{1.151}\PYG{o}{*}\PYG{n}{ysd}          \PYG{c}{\PYGZsh{} range}
\PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{0.19}                 \PYG{c}{\PYGZsh{} related to up slope}
\PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{140}                  \PYG{c}{\PYGZsh{} midpoint of up slope}
\PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{0.13}                 \PYG{c}{\PYGZsh{} related to down slope}
\PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{220}                  \PYG{c}{\PYGZsh{} midpoint of down slope}

\PYG{n}{Z} \PYG{o}{=} \PYG{n}{mismatch\PYGZus{}function}\PYG{p}{(}\PYG{n}{p}\PYG{p}{,}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{unc}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mf}{365.}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mf}{0.}\PYG{p}{]}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{k\PYGZhy{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlim}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{365}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{Z}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{*}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}


\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Z\PYGZca{}2 =}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{p}{(}\PYG{n}{Z}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Z}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{=} \PYG{l+m+mf}{105.478274642}
\end{Verbatim}

\includegraphics{Interpolation_94_1.png}

We have made the mismatch go down a little ...

Clearly it would be tedious (and impractical) to do a lot of such
tweaking, so we can use methods that seek the minimum of some function.

One such method is implemented in \code{scipy.optimize.leastsq}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{scipy} \PYG{k+kn}{import} \PYG{n}{optimize}

\PYG{c}{\PYGZsh{} initial estimate is in p}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{initial parameters:}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}\PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,}\PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{,}\PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}

\PYG{c}{\PYGZsh{} set some bounds for the parameters}
\PYG{n}{bound} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{(}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{l+m+mf}{10.}\PYG{p}{)}\PYG{p}{,}\PYG{p}{(}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{l+m+mf}{10.}\PYG{p}{)}\PYG{p}{,}\PYG{p}{(}\PYG{l+m+mf}{0.01}\PYG{p}{,}\PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{,}\PYG{p}{(}\PYG{l+m+mf}{50.}\PYG{p}{,}\PYG{l+m+mf}{300.}\PYG{p}{)}\PYG{p}{,}\PYG{p}{(}\PYG{l+m+mf}{0.01}\PYG{p}{,}\PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{,}\PYG{p}{(}\PYG{l+m+mf}{50.}\PYG{p}{,}\PYG{l+m+mf}{300.}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}


\PYG{c}{\PYGZsh{} test pixel}
\PYG{n}{r} \PYG{o}{=} \PYG{l+m+mi}{472}
\PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{84}


\PYG{n}{y} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{]}
\PYG{n}{mask} \PYG{o}{=} \PYG{o}{\PYGZti{}}\PYG{n}{y}\PYG{o}{.}\PYG{n}{mask}
\PYG{n}{y} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{y}\PYG{p}{[}\PYG{n}{mask}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{x} \PYG{o}{=} \PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{46}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{8}\PYG{o}{+}\PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{[}\PYG{n}{mask}\PYG{p}{]}
\PYG{n}{unc} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{sd}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{]}\PYG{p}{[}\PYG{n}{mask}\PYG{p}{]}\PYG{p}{)}

\PYG{c}{\PYGZsh{} define function to give Z\PYGZca{}2}

\PYG{k}{def} \PYG{n+nf}{sse}\PYG{p}{(}\PYG{n}{p}\PYG{p}{,}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{unc}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}Sum of squared error\PYGZsq{}\PYGZsq{}\PYGZsq{}}
    \PYG{c}{\PYGZsh{} penalise p[3] \PYGZgt{} p[5]}
    \PYG{n}{err} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{p}{(}\PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mf}{1e4}
    \PYG{k}{return} \PYG{p}{(}\PYG{n}{mismatch\PYGZus{}function}\PYG{p}{(}\PYG{n}{p}\PYG{p}{,}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{unc}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{p}{)}\PYG{o}{+}\PYG{n}{err}

\PYG{c}{\PYGZsh{} we pass the function:}
\PYG{c}{\PYGZsh{}}
\PYG{c}{\PYGZsh{} sse               : the name of the function we wrote to give}
\PYG{c}{\PYGZsh{}                     sum of squares of Z\PYGZus{}i}
\PYG{c}{\PYGZsh{} p                 : an initial estimate of the parameters}
\PYG{c}{\PYGZsh{} args=(x,y,unc)    : the other information (other than p) that}
\PYG{c}{\PYGZsh{}                     mismatch\PYGZus{}function needs}
\PYG{c}{\PYGZsh{} approx\PYGZus{}grad       : if we dont have a function for the gradien}
\PYG{c}{\PYGZsh{}                     we have to get the solver to approximate it}
\PYG{c}{\PYGZsh{}                     which takes time ... see if you can work out}
\PYG{c}{\PYGZsh{}                     d\PYGZus{}sse / dp and use that to speed this up!}

\PYG{n}{psolve} \PYG{o}{=} \PYG{n}{optimize}\PYG{o}{.}\PYG{n}{fmin\PYGZus{}l\PYGZus{}bfgs\PYGZus{}b}\PYG{p}{(}\PYG{n}{sse}\PYG{p}{,}\PYG{n}{p}\PYG{p}{,}\PYG{n}{approx\PYGZus{}grad}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{,}\PYG{n}{iprint}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYGZbs{}
                                \PYG{n}{args}\PYG{o}{=}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{unc}\PYG{p}{)}\PYG{p}{,}\PYG{n}{bounds}\PYG{o}{=}\PYG{n}{bound}\PYG{p}{)}

\PYG{k}{print} \PYG{n}{psolve}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{pp} \PYG{o}{=} \PYG{n}{psolve}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{*}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{errorbar}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{unc}\PYG{o}{*}\PYG{l+m+mf}{1.96}\PYG{p}{)}
\PYG{n}{y\PYGZus{}hat} \PYG{o}{=} \PYG{n}{dbl\PYGZus{}logistic\PYGZus{}model}\PYG{p}{(}\PYG{n}{pp}\PYG{p}{,}\PYG{n}{x\PYGZus{}full}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x\PYGZus{}full}\PYG{p}{,}\PYG{n}{y\PYGZus{}hat}\PYG{p}{)}

\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{solved parameters: }\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{pp}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{pp}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{n}{pp}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}\PYG{n}{pp}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,}\PYG{n}{pp}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{,}\PYG{n}{pp}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}

\PYG{c}{\PYGZsh{} if we define the phenology as the parameter p[3]}
\PYG{c}{\PYGZsh{} and the \PYGZsq{}length\PYGZsq{} of the growing season:}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{phenology}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{pp}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,}\PYG{n}{pp}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{n}{pp}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
initial parameters: 1.04703335612 1.62445180627 0.19 140.0 0.13 220.0
23.2882812239
solved parameters:  0.614031423522 2.92120123969 0.0357337165804 159.497584338 0.0381324783625 227.002721261
phenology 159.497584338 67.5051369225
\end{Verbatim}

\includegraphics{Interpolation_96_1.png}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} and run over each pixel ... this will take some time}

\PYG{c}{\PYGZsh{} pixels that have some data}
\PYG{n}{mask} \PYG{o}{=} \PYG{p}{(}\PYG{o}{\PYGZti{}}\PYG{n}{data}\PYG{o}{.}\PYG{n}{mask}\PYG{p}{)}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}

\PYG{n}{pdata} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{p}{)} \PYG{o}{+} \PYG{n}{mask}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{)}

\PYG{n}{rows}\PYG{p}{,}\PYG{n}{cols} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{where}\PYG{p}{(}\PYG{n}{mask}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{len\PYGZus{}x} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{rows}\PYG{p}{)}

\PYG{c}{\PYGZsh{} lets just do some random ones to start with}
\PYG{c}{\PYGZsh{}rows = rows[::10]}
\PYG{c}{\PYGZsh{}cols = cols[::10]}

\PYG{n}{len\PYGZus{}x} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{rows}\PYG{p}{)}


\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{n}{len\PYGZus{}x}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{r}\PYG{p}{,}\PYG{n}{c} \PYG{o}{=} \PYG{n}{rows}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,}\PYG{n}{cols}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
    \PYG{c}{\PYGZsh{} progress bar}
    \PYG{k}{if} \PYG{n}{i}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{len\PYGZus{}x}\PYG{o}{/}\PYG{l+m+mi}{40}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:}
        \PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{... }\PYG{l+s+si}{\PYGZpc{}4.2f}\PYG{l+s}{ percent}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{i}\PYG{o}{*}\PYG{l+m+mf}{100.}\PYG{o}{/}\PYG{n+nb}{float}\PYG{p}{(}\PYG{n}{len\PYGZus{}x}\PYG{p}{)}\PYG{p}{)}

    \PYG{n}{y} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{]}
    \PYG{n}{mask} \PYG{o}{=} \PYG{o}{\PYGZti{}}\PYG{n}{y}\PYG{o}{.}\PYG{n}{mask}
    \PYG{n}{y} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{y}\PYG{p}{[}\PYG{n}{mask}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{x} \PYG{o}{=} \PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{46}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{8}\PYG{o}{+}\PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{[}\PYG{n}{mask}\PYG{p}{]}
    \PYG{n}{unc} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{sd}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{]}\PYG{p}{[}\PYG{n}{mask}\PYG{p}{]}\PYG{p}{)}

    \PYG{c}{\PYGZsh{} need to get an initial estimate of the parameters}

    \PYG{c}{\PYGZsh{} some stats on y}
    \PYG{n}{ysd} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{std}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}
    \PYG{n}{ymean} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}

    \PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n}{ymean} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{1.151}\PYG{o}{*}\PYG{n}{ysd}\PYG{p}{;}   \PYG{c}{\PYGZsh{} minimum  (1.151 is 75\PYGZpc{} CI)}
    \PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{l+m+mf}{1.151}\PYG{o}{*}\PYG{n}{ysd}          \PYG{c}{\PYGZsh{} range}
    \PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{0.19}                 \PYG{c}{\PYGZsh{} related to up slope}
    \PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{140}                  \PYG{c}{\PYGZsh{} midpoint of up slope}
    \PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{0.13}                 \PYG{c}{\PYGZsh{} related to down slope}
    \PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{220}                  \PYG{c}{\PYGZsh{} midpoint of down slope}


    \PYG{c}{\PYGZsh{} set factr to quite large number (relative error in solution)}
    \PYG{c}{\PYGZsh{} as it\PYGZsq{}ll take too long otherwise}
    \PYG{n}{psolve} \PYG{o}{=} \PYG{n}{optimize}\PYG{o}{.}\PYG{n}{fmin\PYGZus{}l\PYGZus{}bfgs\PYGZus{}b}\PYG{p}{(}\PYG{n}{sse}\PYG{p}{,}\PYG{n}{p}\PYG{p}{,}\PYG{n}{approx\PYGZus{}grad}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{,}\PYG{n}{iprint}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYGZbs{}
                                \PYG{n}{args}\PYG{o}{=}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{unc}\PYG{p}{)}\PYG{p}{,}\PYG{n}{bounds}\PYG{o}{=}\PYG{n}{bound}\PYG{p}{,}\PYG{n}{factr}\PYG{o}{=}\PYG{l+m+mf}{1e12}\PYG{p}{)}

    \PYG{n}{pdata}\PYG{p}{[}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{rows}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,}\PYG{n}{cols}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{]} \PYG{o}{=} \PYG{n}{psolve}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
    \PYG{n}{pdata}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{rows}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,}\PYG{n}{cols}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{]} \PYG{o}{=} \PYG{n}{psolve}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{c}{\PYGZsh{} sse}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{0.00} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{2.50} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{5.00} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{7.50} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{10.00} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{12.50} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{15.00} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{17.50} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{19.99} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{22.49} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{24.99} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{27.49} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{29.99} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{32.49} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{34.99} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{37.49} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{39.99} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{42.49} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{44.99} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{47.49} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{49.99} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{52.49} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{54.99} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{57.49} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{59.98} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{62.48} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{64.98} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{67.48} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{69.98} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{72.48} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{74.98} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{77.48} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{79.98} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{82.48} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{84.98} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{87.48} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{89.98} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{92.48} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{94.98} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{97.47} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{99.97} \PYG{n}{percent}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{pdata}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mi}{137}\PYG{p}{,}\PYG{n}{vmax}\PYG{o}{=}\PYG{l+m+mi}{141}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{green up doy}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{pdata}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{n}{pdata}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mi}{74}\PYG{p}{,}\PYG{n}{vmax}\PYG{o}{=}\PYG{l+m+mi}{84}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{season length}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{pdata}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{n}{vmax}\PYG{o}{=}\PYG{l+m+mf}{6.}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{min LAI}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{pdata}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{+}\PYG{n}{pdata}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{n}{vmax}\PYG{o}{=}\PYG{l+m+mf}{6.}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{max LAI}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{pdata}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{vmax}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{500}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{RSSE}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.colorbar.Colorbar instance at 0x2b75e5deefc8\PYGZgt{}
\end{Verbatim}

\includegraphics{Interpolation_98_1.png}

\includegraphics{Interpolation_98_2.png}

\includegraphics{Interpolation_98_3.png}

\includegraphics{Interpolation_98_4.png}

\includegraphics{Interpolation_98_5.png}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} check a few pixels}

\PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{200}

\PYG{k}{for} \PYG{n}{r} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{l+m+mi}{200}\PYG{p}{,}\PYG{l+m+mi}{400}\PYG{p}{,}\PYG{l+m+mi}{25}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{y} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{]}
    \PYG{n}{mask} \PYG{o}{=} \PYG{o}{\PYGZti{}}\PYG{n}{y}\PYG{o}{.}\PYG{n}{mask}
    \PYG{n}{y} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{y}\PYG{p}{[}\PYG{n}{mask}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{x} \PYG{o}{=} \PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{46}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{8}\PYG{o}{+}\PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{[}\PYG{n}{mask}\PYG{p}{]}
    \PYG{n}{unc} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{sd}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{]}\PYG{p}{[}\PYG{n}{mask}\PYG{p}{]}\PYG{p}{)}

    \PYG{n}{x\PYGZus{}full} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{366}\PYG{p}{)}

    \PYG{c}{\PYGZsh{} some default values for the parameters}
    \PYG{n}{pp} \PYG{o}{=} \PYG{n}{pdata}\PYG{p}{[}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{]}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{ c }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{*}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{errorbar}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{unc}\PYG{o}{*}\PYG{l+m+mf}{1.96}\PYG{p}{)}
    \PYG{n}{y\PYGZus{}hat} \PYG{o}{=} \PYG{n}{dbl\PYGZus{}logistic\PYGZus{}model}\PYG{p}{(}\PYG{n}{pp}\PYG{p}{,}\PYG{n}{x\PYGZus{}full}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x\PYGZus{}full}\PYG{p}{,}\PYG{n}{y\PYGZus{}hat}\PYG{p}{)}

    \PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{solved parameters: }\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{pp}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{pp}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{n}{pp}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}\PYG{n}{pp}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,}\PYG{n}{pp}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{,}\PYG{n}{pp}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}

    \PYG{c}{\PYGZsh{} if we define the phenology as the parameter p[3]}
    \PYG{c}{\PYGZsh{} and the \PYGZsq{}length\PYGZsq{} of the growing season:}
    \PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{phenology}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{pp}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,}\PYG{n}{pp}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{n}{pp}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
solved parameters:  0.837899998448 2.82427082241 0.0164922480786 139.933827392 0.015218312802 219.620042827
phenology 139.933827392 79.6862154345
solved parameters:  1.25111026954 2.3270241822 0.0190331997407 137.746147061 0.0650489530419 220.049105733
phenology 137.746147061 82.3029586718
solved parameters:  1.24735745202 2.64641924245 0.01 139.923207754 0.0103960017819 220.21982824
phenology 139.923207754 80.2966204854
solved parameters:  0.932759824658 2.57001493023 0.0499114191497 141.274250409 1.0 220.241108243
phenology 141.274250409 78.9668578339
solved parameters:  3.3118926764 10.0 0.0227526645775 141.59060759 0.0129963184052 218.391152509
phenology 141.59060759 76.8005449187
solved parameters:  1.00690819411 2.5680266473 0.0244446244614 139.049623755 0.0196297496409 220.194411837
phenology 139.049623755 81.1447880828
solved parameters:  1.41787972842 0.735065812424 0.183737093991 139.730989265 0.0642603310649 219.975475755
phenology 139.730989265 80.2444864894
solved parameters:  1.03836639365 1.58477670269 0.0296244335923 139.895942883 0.0436631925744 220.03650496
phenology 139.895942883 80.1405620773
\end{Verbatim}

\includegraphics{Interpolation_99_1.png}

\includegraphics{Interpolation_99_2.png}

\includegraphics{Interpolation_99_3.png}

\includegraphics{Interpolation_99_4.png}

\includegraphics{Interpolation_99_5.png}

\includegraphics{Interpolation_99_6.png}

\includegraphics{Interpolation_99_7.png}

\includegraphics{Interpolation_99_8.png}


\chapter{ENVI}
\label{Chapter6_ENVI/envi:envi}\label{Chapter6_ENVI/envi::doc}
The purpose of this week's practical (Reading Week) is for you to become
familiar with using the software package ENVI.

You should do one oby following the
\href{http://www2.geog.ucl.ac.uk/~plewis/geog2021/classificationPractical/}{Classification}
practical.

There is no direct supervision for this session.

You are expected to get on with this yourselves.


\chapter{6a. Assessed Practical}
\label{Chapter6a_Practical/Practical::doc}\label{Chapter6a_Practical/Practical:a-assessed-practical}

\section{6.1 Introduction}
\label{Chapter6a_Practical/Practical:introduction}

\subsection{6.1.1 Site, Data and Task overview}
\label{Chapter6a_Practical/Practical:site-data-and-task-overview}
These notes describe the practical you must submit for assessment in
this course.

The practical comes in two parts: (1) data preparation; (2) modelling.

It is important that you complete both parts of this exercise, as you
will need to make use of the code and results in the work you submit for
assessment for this course.
\begin{itemize}
\item {} 
\textbf{Data Preparation}

The first task you must complete is to produce a dataset of the
proportion of HUC catchment 13010001 (Rio Grande headwaters in
Colorado, USA) that is covered by snow for \textbf{two consecutive years},
along with associated datasets on temperature (in C) and river
discharge at the Del Norte monitoring station. You \textbf{may not} use
data from the year 2005, as this is given to you in the illustrations
above.

The dataset you produce must have a value for the mean snow cover,
temperature and discharge in the catchment for every day over each
year.

Your write up \textbf{must} include fully labelled graph(s) of snow cover,
temperature and discharge for the catchment for each year (with units
as appropriate), along with some summary statistics (e.g. mean or
median, minimum, maximum, and the timing of these).

You \textbf{must} provide evidence of how you got these data (i.e. the
code and commands you ran to produce the data).

\item {} 
\textbf{Modelling}

You will have prepared two years of data above. Use one of these
years to calibrate the (snowmelt) hydrological model (described
below) and one year to test it.

The model parameter estimate \emph{must} be objective (i.e. you can't just
arbitrarily choose a set) and ideally optimal, and you \emph{must} state
the equation of the cost function you will try to minimise and
explain the approach used.

You \textbf{must} state the values of the model parameters that you have
estimated and show evidence for how you went about calculating them.
Ideally, you should also state the uncertainty in these parameter
estimates (not critical to pass this section though).

You \textbf{must} quantify the goodness of fit between your measured flow
data and that produced by your model, booth for the calibration
exercise and the validation.

\end{itemize}

You \textbf{must} work individually on this task. If you do not, it will be
treated as plagiarism. By reading these instructions for this exercise,
we assume that you are aware of the UCL rules on plagiarism. You can
find more information on this matter in your student handbook. If in
doubt about what might constitute plagiarism, ask one of the course
convenors.

What you are going to do is to build, calibrate and test a (snowmelt)
hydrological model, driven by observations in the Rio Grande Headwaters
in Colorado, USA.

\textbf{You will need to process two years of data (N.B. *not* 2005 as that is
given in the illustrations).}

The purpose of the model is to describe the streamflow at the Del Norte
measurement station, just on the edge of the catchment.

The average climate for Del Norte is:
\begin{figure}[htbp]
\centering

\includegraphics{Chapter6a_Practical/files/images/usco0103climatedelnorte.png}
\end{figure}

Further general information is available from various
\href{http://www.usclimatedata.com/climate.php?location=USCO0103}{websites},
including
\href{http://www4.ncdc.noaa.gov/cgi-win/wwcgi.dll?wwDI~StnSrch~StnID~10100138}{NOAA}.

You can visualise the site
\href{http://mesonet.agron.iastate.edu/sites/site.php?station=CO2184\&network=COCLIMATE}{here}.

First then, we should look at the streamflow data. These data are in the
file delnorte.dat for the years 2000 to
2010 inclusive. You can get further data from \href{http://waterdata.usgs.gov}{http://waterdata.usgs.gov}
if you wish.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} load a pre\PYGZhy{}cooked version of the data for 2005 (NB \PYGZhy{}\PYGZhy{} Dont use this year!!!}
\PYG{c}{\PYGZsh{} except perhaps for testing)}

\PYG{c}{\PYGZsh{} load the data from a pickle file}
\PYG{k+kn}{import} \PYG{n+nn}{pickle}
\PYG{n}{pkl\PYGZus{}file} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/data.pkl}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{rb}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{data} \PYG{o}{=} \PYG{n}{pickle}\PYG{o}{.}\PYG{n}{load}\PYG{p}{(}\PYG{n}{pkl\PYGZus{}file}\PYG{p}{)}
\PYG{n}{pkl\PYGZus{}file}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}

\PYG{c}{\PYGZsh{} set up plot}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlim}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{doy}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{doy}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{day of year 2005}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{c}{\PYGZsh{} plot data}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{doy}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{temp}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{label}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{temperature / C}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{doy}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{snowprop}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{*}\PYG{l+m+mi}{100}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{b}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{label}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{snow cover }\PYG{l+s}{\PYGZpc{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{doy}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{l+m+mi}{100}\PYG{o}{\PYGZhy{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{snowprop}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{*}\PYG{l+m+mi}{100}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{c}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{label}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{snow free cover }\PYG{l+s}{\PYGZpc{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{doy}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{flow}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{/}\PYG{l+m+mf}{100.}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{g}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{label}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{river flow / 100}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}


\PYG{n}{plt}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{n}{loc}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{best}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.legend.Legend at 0x1a2cae10\PYGZgt{}
\end{Verbatim}

\includegraphics{Practical_5_1.png}

we have plotted the streamflow (scaled) in green, the snow cover in
blue, and the non snow cover in cyan and the temperature in red. It
should be apparent that thge hydrology is snow melt dominated, and to
describe this (i.e. to build the simplest possible model) we can
probably just apply some time lag function to the snow cover.


\subsection{6.1.2 The Model}
\label{Chapter6a_Practical/Practical:the-model}
We will build a mass balance model, in terms of `snow water equivalent':

The basis of a model is going to be something of the form:
\begin{gather}
\begin{split}SWE = k * snowProportion\end{split}\notag
\end{gather}
where \(SWE\) is the `snow water equivalent', the amount of snow in
the entire snow pack in the catchment. \(snowProportion\) here then,
is the proportion of snow cover in the catchment. We lump together
density and volume terms into the coefficient \(k\).

\(SWE\) then is the `mass' (of water) that is available for melting
on a particular day. We can obtain \(snowProportion\) from satellite
data, so we only need the area / density term \(k\), which we can
suppose to be constant over time.

The simplest model of snowmelt is one where we assume that a proportion
of this \(SWE\) is released (melted) as a function of temperature.
In its simplest form, this is simply a temperature threshold:

\code{meltDays = np.where(temperature \textgreater{} tempThresh){[}0{]}}

On these melt days then, we add \code{k * snowProportion} of water into the
system. For the present, we will ignore direct precipitation. So:

\code{for d in meltDays:     water = K * snowProportion{[}d{]}}

Now we have a mechanism to release snow melt into the catchment, but
there will always be some delay in the water reaching the monitoring
station from far away regions, compared to nearby areas. The function
that describes this delay can be called a network response function. It
is often modelled as a Laplace function (an exponential). The idea is
that if we have a `flash' input to the catchment, this \href{http://www.google.co.uk/search?q=network+response+function\&ie=utf-8\&oe=utf-8\&aq=t\&rls=org.mozilla:en-US:official\&client=firefox-a\#sclient=psy-ab\&hl=en\&client=firefox-a\&hs=qgI\&rls=org.mozilla:en-US\%3Aofficial\&source=hp\&q=network+response+function+hydrology\&pbx=1\&oq=network+response+function+hydrology\&aq=f\&aqi=\&aql=\&gs\_sm=e\&gs\_upl=2213l4483l0l4547l10l9l0l0l0l0l226l961l6.2.1l9l0\&bav=on.2,or.r\_gc.r\_pw.r\_cp.,cf.osb\&fp=d48ede2c1f2a6462\&biw=1098\&bih=673}{network response
function}
will give us what we would measure as a hydrograph at the monitoring
station (or elsewhere).

We can parameterise this with a decay factor, p, so that if the amount
of water on day d is 1, the amount on day d+1 is p, on d+2, p\textasciicircum{}2 etc:

\code{n = np.arange(len(snowProportion)) - d m = p ** n m{[}np.where(n\textless{}0){]}=0}

so here, \code{m} is the decay function:
\begin{figure}[htbp]
\centering

\includegraphics{Chapter6a_Practical/files/images/laplace.png}
\end{figure}

for day 150. This model will transfer a large amount of water of the
peak day, then less and less as time goes by. So, a simple model then is
of the form:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{model\PYGZus{}accum}\PYG{p}{(}\PYG{n}{data}\PYG{p}{,}\PYG{n}{tempThresh}\PYG{p}{,}\PYG{n}{k}\PYG{p}{,}\PYG{n}{p}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{meltDays} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{where}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{temp}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{\PYGZgt{}} \PYG{n}{tempThresh}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
    \PYG{n}{accum} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{snowprop}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{*}\PYG{l+m+mf}{0.}
    \PYG{k}{for} \PYG{n}{d} \PYG{o+ow}{in} \PYG{n}{meltDays}\PYG{p}{:}
        \PYG{n}{water} \PYG{o}{=} \PYG{n}{k} \PYG{o}{*} \PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{snowprop}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{n}{d}\PYG{p}{]}
        \PYG{n}{n} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{snowprop}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{d}
        \PYG{n}{m} \PYG{o}{=} \PYG{n}{p} \PYG{o}{*}\PYG{o}{*} \PYG{n}{n}
        \PYG{n}{m}\PYG{p}{[}\PYG{n}{np}\PYG{o}{.}\PYG{n}{where}\PYG{p}{(}\PYG{n}{n}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{]}\PYG{o}{=}\PYG{l+m+mi}{0}
        \PYG{n}{accum} \PYG{o}{+}\PYG{o}{=} \PYG{n}{m} \PYG{o}{*} \PYG{n}{water}
    \PYG{k}{return} \PYG{n}{accum}


\PYG{n}{tempThresh} \PYG{o}{=} \PYG{l+m+mf}{8.5}
\PYG{n}{k} \PYG{o}{=} \PYG{l+m+mf}{2000.0}
\PYG{n}{p} \PYG{o}{=} \PYG{l+m+mf}{0.95}

\PYG{c}{\PYGZsh{} test it}
\PYG{n}{accum} \PYG{o}{=} \PYG{n}{model\PYGZus{}accum}\PYG{p}{(}\PYG{n}{data}\PYG{p}{,}\PYG{n}{tempThresh}\PYG{p}{,}\PYG{n}{k}\PYG{p}{,}\PYG{n}{p}\PYG{p}{)}
\end{Verbatim}

This is a very simple model. It has three parameters (\code{tempThresh},
\code{k}, \code{p}) and is driven only by temperature and snow cover data. And
yet, we see that even with a rough guess at what the parameters ought to
be, we can get a reasonable match with the observed flow data:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{doy}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{flow}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{k}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{label}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{measured}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{doy}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{accum}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{k\PYGZhy{}\PYGZhy{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{label}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{modelled}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{river flow / units??}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{day of year 2005}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{n}{loc}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{best}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.legend.Legend at 0x1c0b4ed0\PYGZgt{}
\end{Verbatim}

\includegraphics{Practical_11_1.png}


\section{6.2 Data Preparation}
\label{Chapter6a_Practical/Practical:data-preparation}

\subsection{6.2.1 Statement of the task}
\label{Chapter6a_Practical/Practical:statement-of-the-task}
The first task you must complete is to produce a dataset of the
proportion of HUC catchment 13010001 (Rio Grande headwaters) that is
covered by snow for \textbf{two years}, along with associated datasets on
temperature and river discharge at the Del Norte monitoring station.

The dataset you produce must have a value for the mean snow cover,
temperature and discharge in the catchment for every day over each year.

Your write up \textbf{must} include a fully labelled graph of snow cover,
temperature and discharge for the catchment for each year, along with
some summary statistics (e.g. mean or median, minimum, maximum, and the
timing of these).
\begin{figure}[htbp]
\centering

\includegraphics{Chapter6a_Practical/files/images/snow.png}
\end{figure}

You should aim to complete this task soon after Reading Week.


\subsection{6.2.2 Some Advice}
\label{Chapter6a_Practical/Practical:some-advice}
You would probably want to use a \textbf{daily} snow product for this task,
such as that available from MODIS, so make sure you know what that is
and explore the characteristics of the dataset.

You will notice from the figure above (the figure should give you some
clue as to a suitable data product) that there will be areas of each
image for which you have no information (described in the dataset QC).
You will need to decide what to do about `missing data'. For instance,
you might consider interpolating over missing values.

The simplest thing might be to produce a mean snow cover over what
samples are available (ignoring the missing values). But whilst that may
be sufficient to pass this section, it is far from ideal.

Whilst you only need to produce an average daily value for the
catchment, a better approach would be to try to estimate snow cover for
each pixel in the catchment (e.g. so you could do spatially explicit
modelling with such data). I stress that this is not strictly necessary,
but would be an interesting thing to do if you feel able.

However you decide to process the data, you must give a rationale for
why you have taken the approach you have done.

You will notice that if you use MODIS data, you have access to both data
from Terra (MOD10A) and Aqua (MYD10A), which potentially gives you two
samples per day. Think about how to take that into account. Again, the
simplest thing to do might be to just use one of these. That is likely
to be sufficient, but it would be much better to include both datasets.

You should be able to hunt around to find the temperature and discharge
data you want, but we take you through finding them in the advice below.


\subsection{6.2.3 Data Advice}
\label{Chapter6a_Practical/Practical:data-advice}

\subsubsection{6.2.3.1 MODIS snow cover data}
\label{Chapter6a_Practical/Practical:modis-snow-cover-data}
For MODIS data, you will need to work out which data product you want
and how to download it. To help you with this, we have included urls of
the MODIS Terra snow data product \code{MOD10A1} and Aqua product
\code{MYD10A1} in the files \code{files/data/robot\_snow.????.txt}:

\begin{Verbatim}[commandchars=\\\{\}]
!ls \PYGZhy{}l files/data/robot\PYGZus{}snow.????.txt
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis  9034752 Nov  6 09:12 files/data/robot\PYGZus{}snow.2000.txt
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis 10820568 Nov  6 09:12 files/data/robot\PYGZus{}snow.2001.txt
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis 16321938 Nov  6 09:12 files/data/robot\PYGZus{}snow.2002.txt
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis 22423068 Nov  6 09:12 files/data/robot\PYGZus{}snow.2003.txt
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis  7633374 Nov  6 09:12 files/data/robot\PYGZus{}snow.2004.txt
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis 18872448 Nov  6 09:12 files/data/robot\PYGZus{}snow.2005.txt
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis 11433078 Nov  6 09:12 files/data/robot\PYGZus{}snow.2006.txt
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis 22663686 Nov  6 09:12 files/data/robot\PYGZus{}snow.2007.txt
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis 22668990 Nov  6 09:12 files/data/robot\PYGZus{}snow.2008.txt
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis 22705317 Nov  6 09:12 files/data/robot\PYGZus{}snow.2009.txt
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis 22712370 Nov  6 09:13 files/data/robot\PYGZus{}snow.2010.txt
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis 17129166 Nov  6 09:13 files/data/robot\PYGZus{}snow.2011.txt
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis 22756824 Nov  6 09:13 files/data/robot\PYGZus{}snow.2012.txt
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis 18104898 Nov  6 09:13 files/data/robot\PYGZus{}snow.2013.txt
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
!head \PYGZhy{}10 \PYGZlt{} files/data/robot\PYGZus{}snow.2007.txt
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
ftp://n4ftl01u.ecs.nasa.gov/MOSA/MYD10A1.005/2007.01.01/MYD10A1.A2007001.h00v08.005.2008309053908.hdf
ftp://n4ftl01u.ecs.nasa.gov/MOSA/MYD10A1.005/2007.01.01/MYD10A1.A2007001.h00v09.005.2008309053510.hdf
ftp://n4ftl01u.ecs.nasa.gov/MOSA/MYD10A1.005/2007.01.01/MYD10A1.A2007001.h00v10.005.2008309053824.hdf
ftp://n4ftl01u.ecs.nasa.gov/MOSA/MYD10A1.005/2007.01.01/MYD10A1.A2007001.h01v08.005.2008309053759.hdf
ftp://n4ftl01u.ecs.nasa.gov/MOSA/MYD10A1.005/2007.01.01/MYD10A1.A2007001.h01v09.005.2008309053913.hdf
ftp://n4ftl01u.ecs.nasa.gov/MOSA/MYD10A1.005/2007.01.01/MYD10A1.A2007001.h01v10.005.2008309053817.hdf
ftp://n4ftl01u.ecs.nasa.gov/MOSA/MYD10A1.005/2007.01.01/MYD10A1.A2007001.h01v11.005.2008309053918.hdf
ftp://n4ftl01u.ecs.nasa.gov/MOSA/MYD10A1.005/2007.01.01/MYD10A1.A2007001.h02v06.005.2008309053503.hdf
ftp://n4ftl01u.ecs.nasa.gov/MOSA/MYD10A1.005/2007.01.01/MYD10A1.A2007001.h02v08.005.2008309053822.hdf
ftp://n4ftl01u.ecs.nasa.gov/MOSA/MYD10A1.005/2007.01.01/MYD10A1.A2007001.h02v09.005.2008309054221.hdf
\end{Verbatim}

We can use the usual tools to explore the MODIS hdf files:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{gdal}
\PYG{n}{target\PYGZus{}vector\PYGZus{}file} \PYG{o}{=} \PYG{n+nb}{file}
\PYG{n}{modis\PYGZus{}file} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MYD10A1.A2003026.h09v05.005.2008047035848.hdf}\PYG{l+s}{\PYGZsq{}}
\PYG{n}{g} \PYG{o}{=} \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{Open}\PYG{p}{(}\PYG{n}{modis\PYGZus{}file}\PYG{p}{)}
\PYG{n}{data\PYGZus{}layer} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MOD\PYGZus{}Grid\PYGZus{}Snow\PYGZus{}500m:Fractional\PYGZus{}Snow\PYGZus{}Cover}\PYG{l+s}{\PYGZsq{}}

\PYG{n}{subdatasets} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{GetSubDatasets}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{fname}\PYG{p}{,} \PYG{n}{name} \PYG{o+ow}{in} \PYG{n}{subdatasets}\PYG{p}{:}
    \PYG{k}{print} \PYG{n}{name}
    \PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{fname}

\PYG{n}{fname} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{:}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{modis\PYGZus{}file}\PYG{p}{,}\PYG{n}{data\PYGZus{}layer}\PYG{p}{)}
\PYG{n}{raster} \PYG{o}{=} \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{Open}\PYG{p}{(}\PYG{n}{fname}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
[2400x2400] Snow\PYGZus{}Cover\PYGZus{}Daily\PYGZus{}Tile MOD\PYGZus{}Grid\PYGZus{}Snow\PYGZus{}500m (8\PYGZhy{}bit unsigned integer)
    HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:\PYGZdq{}files/data/MYD10A1.A2003026.h09v05.005.2008047035848.hdf\PYGZdq{}:MOD\PYGZus{}Grid\PYGZus{}Snow\PYGZus{}500m:Snow\PYGZus{}Cover\PYGZus{}Daily\PYGZus{}Tile
[2400x2400] Snow\PYGZus{}Spatial\PYGZus{}QA MOD\PYGZus{}Grid\PYGZus{}Snow\PYGZus{}500m (8\PYGZhy{}bit unsigned integer)
    HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:\PYGZdq{}files/data/MYD10A1.A2003026.h09v05.005.2008047035848.hdf\PYGZdq{}:MOD\PYGZus{}Grid\PYGZus{}Snow\PYGZus{}500m:Snow\PYGZus{}Spatial\PYGZus{}QA
[2400x2400] Snow\PYGZus{}Albedo\PYGZus{}Daily\PYGZus{}Tile MOD\PYGZus{}Grid\PYGZus{}Snow\PYGZus{}500m (8\PYGZhy{}bit unsigned integer)
    HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:\PYGZdq{}files/data/MYD10A1.A2003026.h09v05.005.2008047035848.hdf\PYGZdq{}:MOD\PYGZus{}Grid\PYGZus{}Snow\PYGZus{}500m:Snow\PYGZus{}Albedo\PYGZus{}Daily\PYGZus{}Tile
[2400x2400] Fractional\PYGZus{}Snow\PYGZus{}Cover MOD\PYGZus{}Grid\PYGZus{}Snow\PYGZus{}500m (8\PYGZhy{}bit unsigned integer)
    HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:\PYGZdq{}files/data/MYD10A1.A2003026.h09v05.005.2008047035848.hdf\PYGZdq{}:MOD\PYGZus{}Grid\PYGZus{}Snow\PYGZus{}500m:Fractional\PYGZus{}Snow\PYGZus{}Cover
\end{Verbatim}


\subsubsection{6.2.3.2 Boundary Data}
\label{Chapter6a_Practical/Practical:boundary-data}
Boundary data, such as catchments, might typically come as \href{http://en.wikipedia.org/wiki/Shapefile}{ESRI
shapefiles} or may be in
other vector formats. There tends to be variable quality among different
databases, but a reliable source for catchment data the USA is the
\href{http://water.usgs.gov/GIS/huc.html}{USGS}. One set of catchments in
the tile we have is the Rio Grande headwaters, which we can
\href{http://water.usgs.gov/GIS/huc\_rdb.html}{see} has a HUC 8-digit code
of 13010001. The full dataset is easily found from the
\href{http://water.usgs.gov/GIS/dsdl/huc250k\_shp.zip}{USGS} or
locally. Literature and associated data
concerning this area can be found
\href{http://water.usgs.gov/lookup/getwatershed?13010001}{here}.
Associated \href{http://water.usgs.gov/lookup/getgislist?type=huc\&value=13010001}{GIS data are
here},
including the \href{http://water.usgs.gov/GIS/dsdl/ds573\_wbdhuc8.ZIP}{watershed boundary
data}.

Data more specific to our particular catchment of interest can be found
on the \href{http://txpub.usgs.gov/USACE/resources.aspx}{Rio Grande Data Project
pages}.

You should download the file
\href{http://txpub.usgs.gov/USACE/data/water\_resources/Hydrologic\_Units.zip}{Hydrologic\_Units.zip}
or get this locally. Obviously,
you will need to \code{unzip} this file to get at the shapefile
\code{{}`Hydrologic\_Units/HUC\_Polygons.shp} \textless{}files/data/Hydrologic\_Units/HUC\_Polygons.shp\textgreater{}{}`\_\_
within it.

You can explore the shape file with the following:

\begin{Verbatim}[commandchars=\\\{\}]
!ogrinfo files/data/Hydrologic\PYGZus{}Units/HUC\PYGZus{}Polygons.shp HUC\PYGZus{}Polygons \textbar{} head \PYGZhy{}89 \textbar{} tail \PYGZhy{}16
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
OGRFeature(HUC\PYGZus{}Polygons):2
  HUC (Integer) = 13010001
  REG\PYGZus{}NAME (String) = Rio Grande Region
  SUB\PYGZus{}NAME (String) = Rio Grande Headwaters
  ACC\PYGZus{}NAME (String) = Rio Grande Headwaters
  CAT\PYGZus{}NAME (String) = Rio Grande Headwaters. Colorado.
  HUC2 (Integer) = 13
  HUC4 (Integer) = 1301
  HUC6 (Integer) = 130100
  REG (Integer) = 13
  SUB (Integer) = 1301
  ACC (Integer) = 130100
  CAT (Integer) = 13010001
  CAT\PYGZus{}NUM (String) = 13010001
  Shape\PYGZus{}Leng (Real) = 313605.66409400001
  Shape\PYGZus{}Area (Real) = 3458016895.23000001907
\end{Verbatim}

This tells us that we want \textbf{HUC feature 2} (catchment 13010001).

We can produce a mask with \code{raster\_mask}, but in this case, we need to
use a function \code{raster\_mask2}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{n}{sys}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/python}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{k+kn}{from} \PYG{n+nn}{raster\PYGZus{}mask} \PYG{k+kn}{import} \PYG{o}{*}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{m} \PYG{o}{=} \PYG{n}{raster\PYGZus{}mask2}\PYG{p}{(}\PYG{n}{fname}\PYG{p}{,}\PYGZbs{}
                \PYG{n}{target\PYGZus{}vector\PYGZus{}file}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{files/data/Hydrologic\PYGZus{}Units/HUC\PYGZus{}Polygons.shp}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYGZbs{}
                \PYG{n}{attribute\PYGZus{}filter}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{m}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.colorbar.Colorbar instance at 0x2b6b7fcd6cb0\PYGZgt{}
\end{Verbatim}

\includegraphics{Practical_32_1.png}

The catchment is only a very small portion of the dataset, so you should
make sure that you perform masking when you read the dataset in and only
extract the area of data that you want.


\subsubsection{6.2.3.3 Discharge Data}
\label{Chapter6a_Practical/Practical:discharge-data}
The river discharge data are in the file
\code{{}`files/data/delnorte.dat} \textless{}files/data/delnorte.dat\textgreater{}{}`\_\_.

If you examine the file:

\begin{Verbatim}[commandchars=\\\{\}]
!head \PYGZhy{}35 \PYGZlt{} files/data/delnorte.dat
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} WARNING \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
\PYGZsh{} The data you have obtained from this automated U.S. Geological Survey database
\PYGZsh{} have not received Director\PYGZsq{}s approval and as such are provisional and subject to
\PYGZsh{} revision.  The data are released on the condition that neither the USGS nor the
\PYGZsh{} United States Government may be held liable for any damages resulting from its use.
\PYGZsh{} Additional info: http://waterdata.usgs.gov/nwis/help/?provisional
\PYGZsh{}
\PYGZsh{} File\PYGZhy{}format description:  http://waterdata.usgs.gov/nwis/?tab\PYGZus{}delimited\PYGZus{}format\PYGZus{}info
\PYGZsh{} Automated\PYGZhy{}retrieval info: http://waterdata.usgs.gov/nwis/?automated\PYGZus{}retrieval\PYGZus{}info
\PYGZsh{}
\PYGZsh{} Contact:   gs\PYGZhy{}w\PYGZus{}support\PYGZus{}nwisweb@usgs.gov
\PYGZsh{} retrieved: 2011\PYGZhy{}09\PYGZhy{}30 09:35:31 EDT       (caww02)
\PYGZsh{}
\PYGZsh{} Data for the following 1 site(s) are contained in this file
\PYGZsh{}    USGS 08220000 RIO GRANDE NEAR DEL NORTE, CO
\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
\PYGZsh{}
\PYGZsh{} Data provided for site 08220000
\PYGZsh{}    DD parameter statistic   Description
\PYGZsh{}    01   00060     00003     Discharge, cubic feet per second (Mean)
\PYGZsh{}
\PYGZsh{} Data\PYGZhy{}value qualification codes included in this output:
\PYGZsh{}     A  Approved for publication \PYGZhy{}\PYGZhy{} Processing and review completed.
\PYGZsh{}     e  Value has been estimated.
\PYGZsh{} agency\PYGZus{}cd site\PYGZus{}no datetime        01\PYGZus{}00060\PYGZus{}00003  01\PYGZus{}00060\PYGZus{}00003\PYGZus{}cd
\PYGZsh{} 5s        15s     20d     14n     10s
USGS        08220000        2000\PYGZhy{}01\PYGZhy{}01      190     A:e
USGS        08220000        2000\PYGZhy{}01\PYGZhy{}02      170     A:e
USGS        08220000        2000\PYGZhy{}01\PYGZhy{}03      160     A:e
USGS        08220000        2000\PYGZhy{}01\PYGZhy{}04      160     A:e
USGS        08220000        2000\PYGZhy{}01\PYGZhy{}05      170     A:e
USGS        08220000        2000\PYGZhy{}01\PYGZhy{}06      180     A:e
USGS        08220000        2000\PYGZhy{}01\PYGZhy{}07      170     A:e
USGS        08220000        2000\PYGZhy{}01\PYGZhy{}08      190     A:e
USGS        08220000        2000\PYGZhy{}01\PYGZhy{}09      190     A:e
\end{Verbatim}

you will see comment lines that start with \code{\#}, followed by data
lines.

The easiest way to read these data would be to use:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nb}{file} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/delnorte.dat}\PYG{l+s}{\PYGZsq{}}
\PYG{n}{data} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{loadtxt}\PYG{p}{(}\PYG{n+nb}{file}\PYG{p}{,}\PYG{n}{usecols}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,}\PYG{n}{unpack}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{,}\PYG{n}{dtype}\PYG{o}{=}\PYG{n+nb}{str}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} so you have the dates in}
\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{2000\PYGZhy{}01\PYGZhy{}01}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{2000\PYGZhy{}01\PYGZhy{}02}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{2000\PYGZhy{}01\PYGZhy{}03}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{2010\PYGZhy{}12\PYGZhy{}29}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}
       \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{2010\PYGZhy{}12\PYGZhy{}30}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{2010\PYGZhy{}12\PYGZhy{}31}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}
      \PYG{n}{dtype}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\textbar{}S10}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} and the stream flow in data[1]}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{astype}\PYG{p}{(}\PYG{n+nb}{float}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
[\PYGZlt{}matplotlib.lines.Line2D at 0x2b6b7c573950\PYGZgt{}]
\end{Verbatim}

\includegraphics{Practical_40_1.png}

You will need to convert the date field (i.e. the data in \code{data{[}0{]}})
into the day of year.

This is readily accomplished using \code{datetime}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{datetime}
\PYG{c}{\PYGZsh{} transform the first one}
\PYG{n}{ds} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZhy{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}\PYG{o}{.}\PYG{n}{astype}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{ds}
\PYG{n}{year}\PYG{p}{,}\PYG{n}{doy} \PYG{o}{=} \PYG{n}{datetime}\PYG{o}{.}\PYG{n}{datetime}\PYG{p}{(}\PYG{n}{ds}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{ds}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{n}{ds}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{strftime}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZpc{}}\PYG{l+s}{Y }\PYG{l+s}{\PYGZpc{}}\PYG{l+s}{j}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{year}\PYG{p}{,}\PYG{n}{doy}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
[2000    1    1]
2000 001
\end{Verbatim}


\subsubsection{6.2.3.4 Temperature data}
\label{Chapter6a_Practical/Practical:temperature-data}
We can directly access temperature data from
\href{http://ccc.atmos.colostate.edu/cgi-bin/dlydb.pl?yrbeg=2000\&yrend=2020\&station=52184+DEL+NORTE\&proc=2+-+List+Format+\%28see+docs\%29}{here}.

The format of \code{{}`delNorteT.dat} \textless{}files/data/delNorteT.dat\textgreater{}{}`\_\_ is given
here.

The first three fields are date fields (\code{YEAR}, \code{MONTH} and
\code{DAY}), followed by \code{TMAX}, \code{TMIN}, \code{PRCP}, \code{SNOW}, \code{SNDP}.

You should read in the temperature data for the days and years that you
want.

For temperature, you might take a \textbf{mean of TMAX and TMIN}.

\textbf{Note that these are in Fahrenheit. You should convert them to
Celcius.}

Note also that there are missing data (values \code{9998} and \code{9999}).
You will need to filter these and interpolate the data in some way. A
median might be a good approach, but any interpolation will suffice.

With that processing then, you should have a dataset, Temperature that
will look something like (in cyan, for the year 2005):
\begin{figure}[htbp]
\centering

\includegraphics{Chapter6a_Practical/files/images/temperature.png}
\end{figure}


\section{6.3 Coursework}
\label{Chapter6a_Practical/Practical:coursework}
You need to submit you coursework in the usual manner by the usual
submission date.

You \textbf{must} work individually on this task. If you do not, it will be
treated as plagiarism. By reading these instructions for this exercise,
we assume that you are aware of the UCL rules on plagiarism. You can
find more information on this matter in your student handbook. If in
doubt about what might constitute plagiarism, ask one of the course
convenors.


\subsection{6.3.1 Summary of coursework requirements}
\label{Chapter6a_Practical/Practical:summary-of-coursework-requirements}\begin{itemize}
\item {} 
\textbf{Data Preparation}

The first task you must complete is to produce a dataset of the
proportion of HUC catchment 13010001 (Rio Grande headwaters in
Colorado, USA) that is covered by snow for \textbf{two consecutive years},
along with associated datasets on temperature (in C) and river
discharge at the Del Norte monitoring station.

You \textbf{may not} use data from the year 2005, as this is given to you
in the illustrations above.

The dataset you produce must have a value for the mean snow cover,
temperature and discharge in the catchment for every day over each
year.

Your write up \textbf{must} include fully labelled graph(s) of snow cover,
temperature and discharge for the catchment for each year (with units
as appropriate), along with some summary statistics (e.g. mean or
median, minimum, maximum, and the timing of these).

You \textbf{must} provide evidence of how you got these data (i.e. the
code and commands you ran to produce the data).

\item {} 
\textbf{Modelling}

You will have prepared two years of data above. Use one of these
years to calibrate the (snowmelt) hydrological model (described
below) and one year to test it.

The model parameter estimate \emph{must} be objective (i.e. you can't just
arbitrarily choose a set) and ideally optimal, and you \emph{must} state
the equation of the cost function you will try to minimise and
explain the approach used.

You \textbf{must} state the values of the model parameters that you have
estimated and show evidence for how you went about calculating them.
Ideally, you should also state the uncertainty in these parameter
estimates (not critical to pass this section though).

You \textbf{must} quantify the goodness of fit between your measured flow
data and that produced by your model, booth for the calibration
exercise and the validation.

\end{itemize}


\subsection{6.3.2 Summary of Advice}
\label{Chapter6a_Practical/Practical:summary-of-advice}
The first task involves pulling datasets from different sources. No
individual part of that should be too difficult, but you must put this
together from the material we have done so far. It is more a question of
organisation then.

Perhaps think first about where you want to end up with on this (the
`output'). This might for example be a dictionary with keys \code{temp},
\code{doy}, \code{snow} and \code{flow}, where each of these would be an array
with 365 values (or 366 in a leap year).

Then consider the datasets you have: these are: (i) a stack of MODIS
data with daily observations; (ii) temperature data in a file; (iii)
flow data in a file.

It might be a little fiddly getting the data you want from the flow and
temperature data files, but its not very complicated. You will need to
consider flagging invalid observations and perhaps interpolating between
these.

Processing the MODIS data might take a little more thought, but it is
much the same process. Again, we read the datasets in, trying to make
this efficient on data size by only using the area of the vector data
mask as in a previous exercise. The data reading will be very similar to
reading the MODIS LAI product, but you need to work out and implement
what changes are necessary. As advised abovem you should use the
\code{raster\_mask2()} function for creating the spatial data masks. Again,
you will need to interpolate or perhaps smooth between observations, and
then process the snow cover proportions to get an average over the
catchment.

The second task revolves around using the model that we have developed
above in the function \code{model\_accum()}. You have been through previous
examples in Python where you attempt to estimate some model parameters
given an initial estimate of the parameters and some cost function to be
minimised. Solving the model calibration part of problem should follow
those same lines then. Testing (validation) should be easy enough. Don't
forget to include the estimated parameters (and other relevant
information, e.g. your initial estimate, uncertainties if available) in
your write up.

There is quite a lot of data presentation here, and you need to provide
\emph{evidence} that you have done the task. Make sure you use images (e.g.
of snow cover varying), graphs (e.g. modelled and predicted flow, etc.),
and tables (e.g. model parameter estimates) throughout, as appropriate.

If, for some reason, you are unable to complete the first part of the
practical, you should submit what you can for that first part, and
continue with calibrating the model using the 2005 dataset that we used
above. This would be far from ideal as you would not have completed the
required elements for either part in that case, but it would generall be
better than not submitting anything.


\subsection{6.3.3 Further advice}
\label{Chapter6a_Practical/Practical:further-advice}
There is plenty of scope here for going beyond the basic requirements,
if you get time and are interested (and/or want a higher mark!).

You will be given credit for all additional work included in the write
up, \textbf{once you have achieved the basic requirements}. So, there is no
point (i.e. you will not get credit for) going off on all sorts of
interesting lines of exploration here \emph{unless} you have first completed
the core task.


\subsection{6.3.4 Structure of the Report}
\label{Chapter6a_Practical/Practical:structure-of-the-report}
The required elements of the report are:

\begin{Verbatim}[commandchars=\\\{\}]
Introduction (5\PYGZpc{})
Data Preparation (45\PYGZpc{})
Modelling (45\PYGZpc{})
Discussion/Conclusions (5\PYGZpc{})
\end{Verbatim}

The figures in brackets indicate the percentage of marks that we will
award for each section of the report.


\subsubsection{Introduction (5\%)}
\label{Chapter6a_Practical/Practical:introduction-5}
This should be of around 2-3 pages.

It should introduce the purpose of the study, being at a base level, to
build and calibrate a snow/hydrological model in Python.

It should provide some background to building models of this sort (their
purpose/role) and include some review of the types of models that might
be built, with reference to the literature (journals).

A pass mark for this section will describe and explain the purpose of
the study and examine some of the context to such modelling, with
appropriate literature being cited. Higher or lower marks will depend on
the depth that this goes into and the clarity of expression.


\subsubsection{Data Preparation (45\%)}
\label{Chapter6a_Practical/Practical:data-preparation-45}
This should contain around 3-4 pages of text, other than codes, figures
and tables.

For a pass mark in this section, you must :
\begin{itemize}
\item {} 
introduce the study site, giving general site characteristics, with
appropriate figures.

\item {} 
provide an overview of the data used in the study (snow cover,
temperature, flow data) and produce visualisations of the data you
are using (images, graphs, tables as appropriate) alongside
appropriate summary statistics.

\item {} 
fully demonstrate how you got these data to this point of processing
-- i.e. submit appropriate Python codes and/or unix commands that
when run in the sequence you describe would produce the data you have
described.

\end{itemize}

The weighting here on the study site description is 5\% and on the rest,
40\%.

You can obtain higher marks here by going beyond the basics in your
approaches to the data or modelling. You still need to demonstrate that
you have done the core `pass' material.


\subsubsection{Modelling}
\label{Chapter6a_Practical/Practical:modelling}
This should contain around 3-4 pages of text, other than codes, figures
and tables.

For a pass mark in this section, you must :
\begin{itemize}
\item {} 
provide an overview of the model that is constructed here, explaining
the role of each parameter.

\item {} 
explain the way in which model calibration and validation is to be
undertaken.

\item {} 
provide an overview of results of the calibration and validation
along with relevant visualisations (images, graphs, tables as
appropriate).

\item {} 
fully demonstrate how you got these results -- i.e. submit
appropriate Python codes and/or unix commands that when run in the
sequence you describe would produce the results you have described.

\end{itemize}

The weighting here is 5\% for the model description and on the rest, 40\%.

For a mildly improved mark, you should examine and discuss the model
assumptions in the context of any modelling literature you looked at in
the Introduction. For a significantly improved mark, you could try
improving the model.


\subsubsection{Discussion and Conclusions}
\label{Chapter6a_Practical/Practical:discussion-and-conclusions}
This section should be around 2 pages. It should provide a discussion
and analysis of your results and you should draw appropriate conclusions
from these.

You can also use this section to critique the model/data/methods, and
suggest ways that you would improve things. If you do this, you must
give some indication of how that would be achieved. You will get no
credit for simply saying next time I would make the code more
efficient, for example.

Very good/excellent marks would normally require you to cite appropriate
literature.

A sufficient effort for a pass would make a reasonable effort at
discussing these results in the context of some literature and draw a
few (non trivial) conclusions from the study.


\subsection{6.3.5 Computer Code}
\label{Chapter6a_Practical/Practical:computer-code}

\subsubsection{General requirements}
\label{Chapter6a_Practical/Practical:general-requirements}
You will obviously need to submit computer codes as part of this
assessment. Some flexibility in the style of these codes is to be
expected. For example, some might write a class that encompasses the
functionality for all tasks. Some poeple might have multiple versions of
codes with different functionality. All of these, and other reasonable
variations are allowed.

All codes needed to demonstrate that you have performed the core tasks
are required to be included in the submission. You should include all
codes that you make use of in the main body of the text in the main
body. Any other codes that you want to refer to (e.g. something you
tried out as an enhancement and didnt quite get there) you can include
in appendices.

All codes should be well-commented. Part of the marks you get for code
will depend on the adequacy of the commenting.


\subsubsection{Degree of original work required and plagiarism}
\label{Chapter6a_Practical/Practical:degree-of-original-work-required-and-plagiarism}
If you use a piece of code verbatim that you have taken from the course
pages or any other source, \textbf{you must acknowledge this} in comments in
your text. \textbf{Not to do so is plagiarism}. Where you have taken some
part (e.g. a few lines) of someone elses code, \textbf{you should also
indicate this}. If some of your code is heavily based on code from
elsewhere, \textbf{you must also indicate that}.

Some examples. You may recognise this snippet of code from above.

The first example is guilty of strong plagiarism, it does not seek to
acknowledge the source of this code, even though it is just a direct
copy, pasted into a method called \code{model()}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{model}\PYG{p}{(}\PYG{n}{tempThresh}\PYG{o}{=}\PYG{l+m+mf}{9.0}\PYG{p}{,}\PYG{n}{K}\PYG{o}{=}\PYG{l+m+mf}{2000.0}\PYG{p}{,}\PYG{n}{p}\PYG{o}{=}\PYG{l+m+mf}{0.96}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}need to comment this further ...}

\PYG{l+s+sd}{    \PYGZsq{}\PYGZsq{}\PYGZsq{}}
    \PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}
    \PYG{n}{meltDays} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{where}\PYG{p}{(}\PYG{n}{temperature} \PYG{o}{\PYGZgt{}} \PYG{n}{tempThresh}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
    \PYG{n}{accum} \PYG{o}{=} \PYG{n}{snowProportion}\PYG{o}{*}\PYG{l+m+mf}{0.}
    \PYG{k}{for} \PYG{n}{d} \PYG{o+ow}{in} \PYG{n}{meltDays}\PYG{p}{:}
        \PYG{n}{water} \PYG{o}{=} \PYG{n}{K} \PYG{o}{*} \PYG{n}{snowProportion}\PYG{p}{[}\PYG{n}{d}\PYG{p}{]}
        \PYG{n}{n} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{snowProportion}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{d}
        \PYG{n}{m} \PYG{o}{=} \PYG{n}{p} \PYG{o}{*}\PYG{o}{*} \PYG{n}{n}
        \PYG{n}{m}\PYG{p}{[}\PYG{n}{np}\PYG{o}{.}\PYG{n}{where}\PYG{p}{(}\PYG{n}{n}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{]}\PYG{o}{=}\PYG{l+m+mi}{0}
        \PYG{n}{accum} \PYG{o}{+}\PYG{o}{=} \PYG{n}{m} \PYG{o}{*} \PYG{n}{water}
    \PYG{k}{return} \PYG{n}{accum}
\end{Verbatim}

This is \textbf{not} acceptable.

This should probably be something along the lines of:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{model}\PYG{p}{(}\PYG{n}{tempThresh}\PYG{o}{=}\PYG{l+m+mf}{9.0}\PYG{p}{,}\PYG{n}{K}\PYG{o}{=}\PYG{l+m+mf}{2000.0}\PYG{p}{,}\PYG{n}{p}\PYG{o}{=}\PYG{l+m+mf}{0.96}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}need to comment this further ...}

\PYG{l+s+sd}{    This code is taken directly from}
\PYG{l+s+sd}{    \PYGZdq{}Modelling delay in a hydrological network\PYGZdq{}}
\PYG{l+s+sd}{    by P. Lewis http://www2.geog.ucl.ac.uk/\PYGZti{}plewis/geogg122/DelNorte.html}
\PYG{l+s+sd}{    and wrapped into a method.}
\PYG{l+s+sd}{    \PYGZsq{}\PYGZsq{}\PYGZsq{}}
    \PYG{c}{\PYGZsh{} my code: make sure numpy is imported}
    \PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}

    \PYG{c}{\PYGZsh{} code below verbatim from Lewis}
    \PYG{n}{meltDays} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{where}\PYG{p}{(}\PYG{n}{temperature} \PYG{o}{\PYGZgt{}} \PYG{n}{tempThresh}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
    \PYG{n}{accum} \PYG{o}{=} \PYG{n}{snowProportion}\PYG{o}{*}\PYG{l+m+mf}{0.}
    \PYG{k}{for} \PYG{n}{d} \PYG{o+ow}{in} \PYG{n}{meltDays}\PYG{p}{:}
        \PYG{n}{water} \PYG{o}{=} \PYG{n}{K} \PYG{o}{*} \PYG{n}{snowProportion}\PYG{p}{[}\PYG{n}{d}\PYG{p}{]}
        \PYG{n}{n} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{snowProportion}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{d}
        \PYG{n}{m} \PYG{o}{=} \PYG{n}{p} \PYG{o}{*}\PYG{o}{*} \PYG{n}{n}
        \PYG{n}{m}\PYG{p}{[}\PYG{n}{np}\PYG{o}{.}\PYG{n}{where}\PYG{p}{(}\PYG{n}{n}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{]}\PYG{o}{=}\PYG{l+m+mi}{0}
        \PYG{n}{accum} \PYG{o}{+}\PYG{o}{=} \PYG{n}{m} \PYG{o}{*} \PYG{n}{water}
    \PYG{c}{\PYGZsh{} my code: return accumulator}
    \PYG{k}{return} \PYG{n}{accum}
\end{Verbatim}

Now, we acknowledge that this is in essence a direct copy of someone
elses code, and clearly state this. We do also show that we have added
some new lines to the code, and that we have wrapped this into a method.

In the next example, we have seen that the way m is generated is in fact
rather inefficient, and have re-structured the code. It is partially
developed from the original code, and acknowledges this:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{model}\PYG{p}{(}\PYG{n}{tempThresh}\PYG{o}{=}\PYG{l+m+mf}{9.0}\PYG{p}{,}\PYG{n}{K}\PYG{o}{=}\PYG{l+m+mf}{2000.0}\PYG{p}{,}\PYG{n}{p}\PYG{o}{=}\PYG{l+m+mf}{0.96}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}need to comment this further ...}

\PYG{l+s+sd}{    This code after the model developed in}
\PYG{l+s+sd}{    \PYGZdq{}Modelling delay in a hydrological network\PYGZdq{}}
\PYG{l+s+sd}{    by P. Lewis}
\PYG{l+s+sd}{    http://www2.geog.ucl.ac.uk/\PYGZti{}plewis/geogg122/DelNorte.html}

\PYG{l+s+sd}{    My modifications have been to make the filtering more efficient.}
\PYG{l+s+sd}{    \PYGZsq{}\PYGZsq{}\PYGZsq{}}
    \PYG{c}{\PYGZsh{} my code: make sure numpy is imported}
    \PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}

    \PYG{c}{\PYGZsh{} code below verbatim from Lewis unless otherwise indicated}
    \PYG{n}{meltDays} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{where}\PYG{p}{(}\PYG{n}{temperature} \PYG{o}{\PYGZgt{}} \PYG{n}{tempThresh}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
    \PYG{n}{accum} \PYG{o}{=} \PYG{n}{snowProportion}\PYG{o}{*}\PYG{l+m+mf}{0.}

    \PYG{c}{\PYGZsh{} my code: pull the filter block out of the loop}
    \PYG{n}{n} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{snowProportion}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{m} \PYG{o}{=} \PYG{n}{p} \PYG{o}{*}\PYG{o}{*} \PYG{n}{n}

    \PYG{k}{for} \PYG{n}{d} \PYG{o+ow}{in} \PYG{n}{meltDays}\PYG{p}{:}
        \PYG{n}{water} \PYG{o}{=} \PYG{n}{K} \PYG{o}{*} \PYG{n}{snowProportion}\PYG{p}{[}\PYG{n}{d}\PYG{p}{]}

        \PYG{c}{\PYGZsh{} my code: shift the filter on by one day}
        \PYG{c}{\PYGZsh{} ...do something clever to shift it on by one day}

        \PYG{n}{accum} \PYG{o}{+}\PYG{o}{=} \PYG{n}{m} \PYG{o}{*} \PYG{n}{water}
    \PYG{c}{\PYGZsh{} my code: return accumulator}
    \PYG{k}{return} \PYG{n}{accum}
\end{Verbatim}

This example makes it clear that significant modifications have been
made to the code structure (and probably to its efficiency) although the
basic model and looping comes from an existing piece of code. It clearly
highlights what the actual modifications have been. Note that this is
not a working example!!

Although you are supposed to do this piece of work on your own, there
might be some circumstances under which someone has significantly helped
you to develop the code (e.g. written the main part of it for you \&
youve just copied that with some minor modifications). You \textbf{must}
acknowledge in your code comments if this has happened. On the whole
though, this should not occur, as you \textbf{must} complete this work on
your own.

If you take a piece of code from somewhere else and all you do is change
the variable names and/or other cosmetic changes, you \textbf{must}
acknowledge the source of the original code (with a URL if available).

Plagiarism in coding is a tricky issue. One reason for that is that
often the best way to learn something like this is to find an example
that someone else has written and adapt that to your purposes. Equally,
if someone has written some tool/library to do what you want to do, it
would generally not be worthwhile for you to write your own but to
concentrate on using that to achieve something new. Even in general code
writing (i.e. when not submitting it as part of your assessment) you and
anyone else who ever has to read your code would find it of value to
make reference to where you found the material to base what you did on.
The key issue to bear in mind in this work, as it is submitted as your
own work is that, to avoid being accused of plagiarism and to allow a
fair assessment of what you have done, you must clearly acknowledge
which parts of it are your own, and the degree to which you could claim
them to be your own.

For example, based on ... is absolutely fine, and you would certainly be
given credit for what you have done. In many circumstances taken
verbatim from ... would also be fine (provided it is acknowledged) but
then you would be given credit for what you had done with the code that
you had taken from elsewhere (e.g. you find some elegant way of doing
the graphs that someone has written and you make use of it for
presenting your results).

The difference between what you submit here and the code you might write
if this were not a piece submitted for assessment is that you the vast
majority of the credit you will gain for the code will be based on the
degree to which you demonstrate that you can write code to achieve the
required tasks. There would obviously be some credit for taking codes
from the coursenotes and bolting them together into something that
achieves the overall aim: provided that worked, and you had commented it
adequately and acknowledge what the extent of your efforts had been, you
should be able to achieve a pass in that component of the work. If there
was no original input other than vbolting pieces of existing code
together though, you be unlikely to achieve more than a pass. If you get
less than a pass in another component of the coursework, that then puts
you in danger of an overall fail.

Provided you achieve the core tasks, the more original work that you
do/show (that is of good quality), the higher the mark you will get.
Once you have achieved the core tasks, even if you try something and
dont quite achieve it, is is probably worth including, as you may get
marks for what you have done (or that fact that it was a good or
interesting thing to try to do).


\subsubsection{Documentation}
\label{Chapter6a_Practical/Practical:documentation}
Note: All methods/functions and classes must be documented for the code
to be adequate. Generally, this will contain:
\begin{itemize}
\item {} 
some text on the purpose of the method (/function/class)

\item {} 
some text describing the inputs and outputs, including reference to
any relevant details such as datatype, shape etc where such things
are of relevance to understanding the code.

\item {} 
some text on keywords, e.g.:

\end{itemize}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{complex}\PYG{p}{(}\PYG{n}{real}\PYG{o}{=}\PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{n}{imag}\PYG{o}{=}\PYG{l+m+mf}{0.0}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Form a complex number.}

\PYG{l+s+sd}{    Keyword arguments:}
\PYG{l+s+sd}{    real \PYGZhy{}\PYGZhy{} the real part (default 0.0)}
\PYG{l+s+sd}{    imag \PYGZhy{}\PYGZhy{} the imaginary part (default 0.0)}

\PYG{l+s+sd}{    Example taken verbatim from:}
\PYG{l+s+sd}{    http://www.python.org/dev/peps/pep\PYGZhy{}0257/}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{k}{if} \PYG{n}{imag} \PYG{o}{==} \PYG{l+m+mf}{0.0} \PYG{o+ow}{and} \PYG{n}{real} \PYG{o}{==} \PYG{l+m+mf}{0.0}\PYG{p}{:} \PYG{k}{return} \PYG{n}{complex\PYGZus{}zero}
\end{Verbatim}

You should look at the \href{http://www.python.org/dev/peps/pep-0257/}{document on good docstring
conventions} when
considering how to document methods, classes etc.

To demonstrate your documentation, you \textbf{must} include the help text
generated by your code after you include the code. e.g.:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{print\PYGZus{}something}\PYG{p}{(}\PYG{n}{this}\PYG{p}{,}\PYG{n}{stderr}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}This does something.}

\PYG{l+s+sd}{    Keyword arguments:}
\PYG{l+s+sd}{    stderr \PYGZhy{}\PYGZhy{} set to True to print to stderr (default False)}
\PYG{l+s+sd}{    \PYGZsq{}\PYGZsq{}\PYGZsq{}}

    \PYG{k}{if} \PYG{n}{stderr}\PYG{p}{:}
        \PYG{c}{\PYGZsh{} import sys.stderr}
        \PYG{k+kn}{from} \PYG{n+nn}{sys} \PYG{k+kn}{import} \PYG{n}{stderr}

        \PYG{c}{\PYGZsh{} print to stderr channel, converting this to str}
        \PYG{k}{print} \PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{n}{stderr}\PYG{p}{,}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{this}\PYG{p}{)}

        \PYG{c}{\PYGZsh{} job done, return}
        \PYG{k}{return}

    \PYG{c}{\PYGZsh{} print to stdout, converting this to str}
    \PYG{k}{print} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{this}\PYG{p}{)}

    \PYG{k}{return}
\end{Verbatim}

Then the help text would be:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{help}\PYG{p}{(}\PYG{n}{print\PYGZus{}something}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
Help on function print\PYGZus{}something in module \PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}:

print\PYGZus{}something(this, stderr=False)
    This does something.

    Keyword arguments:
    stderr \PYGZhy{}\PYGZhy{} set to True to print to stderr (default False)
\end{Verbatim}

The above example represents a good level of commenting as the code
broadly adheres to the style suggestions and most of the major features
are covered. It is not quite very good/excellent as the description of
the purpose of the method (rather important) is trivial and it fails to
describe the input this in any way. An excellent piece would do all of
these things, and might well tell us about any dependencies (e.g.
requires sys if stderr set to True).

An inadequate example would be:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{print\PYGZus{}something}\PYG{p}{(}\PYG{n}{this}\PYG{p}{,}\PYG{n}{stderr}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}This prints something\PYGZsq{}\PYGZsq{}\PYGZsq{}}
    \PYG{k}{if} \PYG{n}{stderr}\PYG{p}{:}
        \PYG{k+kn}{from} \PYG{n+nn}{sys} \PYG{k+kn}{import} \PYG{n}{stderr}
        \PYG{k}{print} \PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{n}{stderr}\PYG{p}{,}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{this}\PYG{p}{)}
        \PYG{k}{return}
    \PYG{k}{print} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{this}\PYG{p}{)}
\end{Verbatim}

It is inadequate because it still only has a trivial description of the
purpose of the method, it tells us nothing about inputs/outputs and
there is no commenting inside the method.


\subsubsection{Word limit}
\label{Chapter6a_Practical/Practical:word-limit}
There is no word limit per se on the computer codes, though as with all
writing, you should try to be succint rather than overly verbose.


\subsubsection{Code style}
\label{Chapter6a_Practical/Practical:code-style}
A good to excellent piece of code would take into account issues raised
in the \href{http://www.python.org/dev/peps/pep-0008/}{style guide}. The
degree of excellence would depend on how well you take those points on
board.


\chapter{7.0 Fire/ENSO teleconnections}
\label{Chapter7_ENSO/ENSO::doc}\label{Chapter7_ENSO/ENSO:fire-enso-teleconnections}

\section{7.1 Introduction}
\label{Chapter7_ENSO/ENSO:introduction}
There is much public and scientific interest in monitoring and
predicting the activity of wildfires and such topics are \href{http://www.bbc.co.uk/news/science-environment-15691060}{often in the
media}.

Part of this interest stems from the role fire plays in issues such as
\href{http://www.eufirelab.org/toolbox2/library/upload/2086.pdf}{land cover change, deforestation and forest
degradation}
and \href{http://www.google.com/url?sa=t\&rct=j\&q=fire\%20carbon\%20emissions\&source=web\&cd=6\&ved=0CFEQFjAF\&url=http\%3A\%2F\%2Fwww.kcl.ac.uk\%2Fsspp\%2Fdepartments\%2Fgeography\%2Fpeople\%2Facademic\%2Fwooster\%2F30yongwoosteretal.pdf\&ei=4FPCTuvZE9Gg8gPZybyxBA\&usg=AFQjCNG81fTRoCcK1nhKnk3u0b8az24bGQ\&sig2=EjJYm2S-\_2gHu2vgt4ByvA\&cad=rja}{Carbon
emissions}
from the land surface to the atmosphere, but also of concern are human
health impacts. The impacts of fire should not however be considered as
wholy negative, as it plays a \href{http://www.fl-dof.com/publications/fires\_natural\_role.html\#firerole}{significant role in natural ecosystem
processes}.

For many regions of the Earth, there are large inter-annual variations
in the timing, frequency and severity of wildfires. Whilst anthropogenic
activity accounts for a \href{http://www.google.com/url?sa=t\&rct=j\&q=fire\%20frequency\%20july\%204th\&source=web\&cd=7\&ved=0CFIQFjAG\&url=http\%3A\%2F\%2Farctic.synergiesprairies.ca\%2Farctic\%2Findex.php\%2Farctic\%2Farticle\%2Fdownload\%2F2806\%2F2783\&ei=K1bCTqv1MYS28QOR9ekG\&usg=AFQjCNFKillAOZMXrT5xpFhckMKvqW50Vg\&sig2=r3J6454VcvI1xpC3Sf3RKw\&cad=rja}{large and probably increasing
proportion}
of fires started, this is not in itself \href{http://www.google.com/url?sa=t\&rct=j\&q=anthropogenic\%20fire\&source=web\&cd=2\&ved=0CCcQFjAB\&url=http\%3A\%2F\%2Fwww.as.ua.edu\%2Fant\%2Fbindon\%2Fant475\%2FPapers\%2FHamm.pdf\&ei=rFXCTu-PHsay8QPdy-2MBA\&usg=AFQjCNGUMrfnDTwRDBxFB-wioZokBt8EtA\&sig2=Zt1nfHoKktbka-pEZs6NGw\&cad=rja}{a new
phenomenon}.

Fires spread where: (i) there is an ignition source (lightning or man,
mostly); (ii) sufficient combustible fuel to maintain the fire. The
latter is strongly dependent on fuel loads and mositure content, as well
as meteorological conditions. Generally then, when conditions are drier
(and there is sufficient fuel and appropriate weather conditions), we
would expect fire spread to increase. If the number of ignitions
remained approximately constant, this would mean more fires. \href{http://www.nasa.gov/images/content/492949main\_Figure-2-Wildfires.jpg}{Many
models of fire
activity}
predict increases in fire frequency in the coming decades, although
there may well be \href{http://news.sciencemag.org/sciencenow/2009/04/10-02.html}{different behaviours in differet parts of the
world}.

\href{http://www.nasa.gov/images/content/492949main\_Figure-2-Wildfires.jpg}{\includegraphics{Chapter7_ENSO/files/images/492949main_Figure-2-Wildfires_s3.jpg}}

Satellite data has been able to provide us with increasingly useful
tools for monitoring wildfire activity, particularly since 2000 with the
MODIS instruments on the NASA Terra and Aqua (2002) satellites. A suite
of \href{http://modis-fire.umd.edu/index.html}{fire products} have been
generated from these data that have been used in a large number of
\href{http://modis-fire.umd.edu/Publications.html}{publications} and
\href{http://maps.geog.umd.edu/firms/\#}{practical/management projects}.

There is growing evidence of teleconnection links between fire
occurence and large scale climate patterns, such as
\href{http://www.esrl.noaa.gov/psd/enso/}{ENSO}.

\href{http://www.esrl.noaa.gov/psd/enso/mei/}{}

The proposed mechanisms are essentially that such climatic patterns are
linked to local water status and temperature and thus affect the ability
of fires to spread. For some regions of the Earth, empirical models
built from such considerations have quite reasonable predictive skill,
meaning that fire season severity might be predicted \href{http://www.sciencemag.org/content/334/6057/787.full}{some months ahead
of time}.


\section{7.2 A Practical Exercise}
\label{Chapter7_ENSO/ENSO:a-practical-exercise}

\subsection{7.2.1 In This Session}
\label{Chapter7_ENSO/ENSO:in-this-session}
In this session, you will be working in groups (of 3 or 4) to build a
computer code in python to explore links between fire activity and Sea
Surface Temperature anomalies.

This is a team exercise, but does not form part of your formal
assessment for this course. You should be able to complete the exercise
in the 3 hour session, if you work effectively as a team. Staff will be
on hand to provide pointers.

You should be able to complete the exercise using coding skills and
python modules that you have previously experience of, though we will
also provide some pointers to get you started.


\subsection{7.2.2 Statement of the problem}
\label{Chapter7_ENSO/ENSO:statement-of-the-problem}
Using monthly fire count data from MODIS Terra, develop and test a
predictive model for the number of fires per unit area per year driven
by Sea Surface Temperature anomaly data.


\subsection{7.2.3 Datasets}
\label{Chapter7_ENSO/ENSO:datasets}
We suggest that the datasets you use of this analysis, following Chen at
al. (2011), are:
\begin{itemize}
\item {} 
MODIS Terra fire counts (2001-2011) (MOD14CMH). The particular
dataset you will want from the file is SUBDATASET\_2 {[}360x720{]}
CloudCorrFirePix (16-bit integer).

\item {} 
Climate index data from NOAA

\end{itemize}

If you ever wish to take this study further, you can find various other
useful datasets such as these.


\subsubsection{Fire Data}
\label{Chapter7_ENSO/ENSO:fire-data}
The MOD14CMH \href{http://maps.geog.umd.edu/firms/CMG.htm}{CMG data} are
available from the \href{ftp://fire:burnt@fuoco.geog.umd.edu/modis/C5/cmg/monthly/hdf}{UMD ftp
server}
but the data you will need are also directly available from
/data/geospatial\_10/ucfajlg/MOD14CMH/. Note that, if you are on the UCL
system, you do not need to copy the data, just use them from where they
are.

If for any reason, you \emph{did} want to copy or update them, use the
following unix command:

\code{wget 'ftp://fire:burnt@fuoco.geog.umd.edu/modis/C5/cmg/monthly/hdf/*'}

The data are in files/data and are in HDF format, so
you should know how to read them into a numpy array in python.

\begin{Verbatim}[commandchars=\\\{\}]
!ls \PYGZhy{}l files/data/*hdf \textbar{} head \PYGZhy{}10
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis  961993 Nov  1  2007 files/data/MOD14CMH.200011.005.01.hdf
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis  923238 Nov  1  2007 files/data/MOD14CMH.200012.005.01.hdf
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis  953227 Mar 22  2008 files/data/MOD14CMH.200101.005.01.hdf
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis  951917 Apr 23  2008 files/data/MOD14CMH.200102.005.01.hdf
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis  959282 Apr 23  2008 files/data/MOD14CMH.200103.005.01.hdf
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis  943794 Apr 23  2008 files/data/MOD14CMH.200104.005.01.hdf
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis  988588 Apr 23  2008 files/data/MOD14CMH.200105.005.01.hdf
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis  898137 Mar 22  2008 files/data/MOD14CMH.200106.005.01.hdf
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis  962767 Mar 22  2008 files/data/MOD14CMH.200107.005.01.hdf
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis  982616 Nov  5  2007 files/data/MOD14CMH.200108.005.01.hdf
ls: write error: Broken pipe
\end{Verbatim}

If you are \textbf{really} stuck on reading the data, or just want to move on
to the next parts, you can use
\code{{}`files/python/reader.py} \textless{}files/python/reader.py\textgreater{}{}`\_\_ which will
create a masked array in \code{data}, and an array of years (\code{year}) and
months (\code{month}):

\begin{Verbatim}[commandchars=\\\{\}]
run files/python/reader
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{x} \PYG{o}{=} \PYG{n}{year} \PYG{o}{+} \PYG{n}{month}\PYG{o}{/}\PYG{l+m+mf}{12.}
\PYG{n}{y} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{data}\PYG{p}{,}\PYG{n}{axis}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{global fire count}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{time}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.text.Text at 0x2b4488089490\PYGZgt{}
\end{Verbatim}

\includegraphics{ENSO_13_1.png}

This dataset is at 0.5 degree resolution and we want to perform tha
analysis as 5 degrees.

We need to shrink the dataset by a factor of 10 then.

There are different ways to achive this, but one way would be to
reoganise the data:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{rdata} \PYG{o}{=} \PYG{p}{[}\PYG{n}{data}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{i}\PYG{p}{:}\PYG{p}{:}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{n}{j}\PYG{p}{:}\PYG{p}{:}\PYG{l+m+mi}{10}\PYG{p}{]} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{]}
\PYG{n}{rdata} \PYG{o}{=} \PYG{n}{ma}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{rdata}\PYG{p}{)}

\PYG{k}{print} \PYG{n}{rdata}\PYG{o}{.}\PYG{n}{shape}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{l+m+mi}{154}\PYG{p}{,} \PYG{l+m+mi}{36}\PYG{p}{,} \PYG{l+m+mi}{72}\PYG{p}{)}
\end{Verbatim}

So, we have made the dataset which as \code{(154, 360, 720)} into a shape
\code{(100, 154, 36, 72)}.

We can now get the total fire counts easily at 5 degrees by summing over
those 100 cells (axis=0):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{fdata} \PYG{o}{=} \PYG{n}{rdata}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{fdata}\PYG{o}{.}\PYG{n}{shape}

\PYG{n}{lf} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{log}\PYG{p}{(}\PYG{n}{fdata}\PYG{p}{)}
\PYG{n}{vmax} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{n}{lf}\PYG{p}{[}\PYG{n}{lf}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{lf}\PYG{p}{[}\PYG{l+m+mi}{8}\PYG{p}{]}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nearest}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{vmax}\PYG{o}{=}\PYG{n}{vmax}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{log fire count for }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{ month }\PYG{l+s+si}{\PYGZpc{}02d}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{year}\PYG{p}{[}\PYG{l+m+mi}{8}\PYG{p}{]}\PYG{p}{,}\PYG{n}{month}\PYG{p}{[}\PYG{l+m+mi}{8}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{l+m+mi}{154}\PYG{p}{,} \PYG{l+m+mi}{36}\PYG{p}{,} \PYG{l+m+mi}{72}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.text.Text at 0x1e19add0\PYGZgt{}
\end{Verbatim}

\includegraphics{ENSO_17_2.png}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} or even make a movie}
\PYG{n}{lf} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{log}\PYG{p}{(}\PYG{n}{fdata}\PYG{p}{)}
\PYG{n}{vmax} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{n}{lf}\PYG{p}{[}\PYG{n}{lf}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{root} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/images/}\PYG{l+s}{\PYGZsq{}}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{n}{lf}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{fig} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{log}\PYG{p}{(}\PYG{n}{fdata}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nearest}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{vmax}\PYG{o}{=}\PYG{n}{vmax}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{file\PYGZus{}id} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{ month }\PYG{l+s+si}{\PYGZpc{}02d}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{year}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,}\PYG{n}{month}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{log fire count for }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{n}{file\PYGZus{}id}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZus{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{.jpg}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{root}\PYG{p}{,}\PYG{n}{file\PYGZus{}id}\PYG{o}{.}\PYG{n}{replace}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZus{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{n}{fig}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZhy{}c:2: RuntimeWarning: divide by zero encountered in log
\PYGZhy{}c:2: RuntimeWarning: invalid value encountered in log
\PYGZhy{}c:8: RuntimeWarning: divide by zero encountered in log
\PYGZhy{}c:8: RuntimeWarning: invalid value encountered in log
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{cmd} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{convert \PYGZhy{}delay 100 \PYGZhy{}loop 0 \PYGZob{}0\PYGZcb{}\PYGZus{}*month*.jpg \PYGZob{}0\PYGZcb{}fire\PYGZus{}movie3.gif}\PYG{l+s}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{root}\PYG{p}{)}
\PYG{n}{os}\PYG{o}{.}\PYG{n}{system}\PYG{p}{(}\PYG{n}{cmd}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{0}
\end{Verbatim}
\begin{figure}[htbp]
\centering

\includegraphics{Chapter7_ENSO/files/images/fire_movie3.gif}
\end{figure}

The information we want is the peak fire count and to know which month
this occurred in.

To do this, we might reoder the data first:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{nlatlon} \PYG{o}{=} \PYG{n}{fdata}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{p}{]}
\PYG{n}{min\PYGZus{}year} \PYG{o}{=} \PYG{n}{year}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{max\PYGZus{}year} \PYG{o}{=} \PYG{n}{year}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{c}{\PYGZsh{} number of years}
\PYG{n}{nyears} \PYG{o}{=} \PYG{n}{max\PYGZus{}year} \PYG{o}{\PYGZhy{}} \PYG{n}{min\PYGZus{}year} \PYG{o}{+} \PYG{l+m+mi}{1}

\PYG{c}{\PYGZsh{} set up a big array}
\PYG{n}{f2data}  \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{,}\PYG{n}{nyears}\PYG{p}{)}\PYG{o}{+}\PYG{n}{nlatlon}\PYG{p}{)}
\PYG{n}{f2datam} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{,}\PYG{n}{nyears}\PYG{p}{)}\PYG{o}{+}\PYG{n}{nlatlon}\PYG{p}{)}\PYG{o}{.}\PYG{n}{astype}\PYG{p}{(}\PYG{n+nb}{bool}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{i}\PYG{p}{,}\PYG{p}{(}\PYG{n}{y}\PYG{p}{,}\PYG{n}{m}\PYG{p}{)} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n+nb}{zip}\PYG{p}{(}\PYG{n}{year}\PYG{o}{\PYGZhy{}}\PYG{n}{year}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{month}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{f2data}\PYG{p}{[}\PYG{n}{m}\PYG{p}{,}\PYG{n}{y}\PYG{p}{]} \PYG{o}{=} \PYG{n}{fdata}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
    \PYG{n}{f2datam}\PYG{p}{[}\PYG{n}{m}\PYG{p}{,}\PYG{n}{y}\PYG{p}{]} \PYG{o}{=} \PYG{p}{(}\PYG{n}{fdata}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{c}{\PYGZsh{} mask it}
\PYG{n}{f2data} \PYG{o}{=} \PYG{n}{ma}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{f2data}\PYG{p}{,}\PYG{n}{mask}\PYG{o}{=}\PYG{n}{f2datam}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{f2data}\PYG{o}{.}\PYG{n}{shape}

\PYG{c}{\PYGZsh{} test it}
\PYG{n}{m} \PYG{o}{=} \PYG{l+m+mi}{8}
\PYG{n}{y} \PYG{o}{=} \PYG{l+m+mi}{2005}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{log}\PYG{p}{(}\PYG{n}{f2data}\PYG{p}{[}\PYG{n}{m}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{y}\PYG{o}{\PYGZhy{}}\PYG{n}{year}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nearest}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{log fire count for }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{ month }\PYG{l+s+si}{\PYGZpc{}02d}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{y}\PYG{p}{,}\PYG{n}{m}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{14}\PYG{p}{,} \PYG{l+m+mi}{36}\PYG{p}{,} \PYG{l+m+mi}{72}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZhy{}c:22: RuntimeWarning: divide by zero encountered in log
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.text.Text at 0x2b4489c91ad0\PYGZgt{}
\end{Verbatim}

\includegraphics{ENSO_22_3.png}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} which month has the highest fire count}
\PYG{c}{\PYGZsh{} NB 0\PYGZhy{}based here but we use a masked array}

\PYG{c}{\PYGZsh{} total fire count summed over month (axis 0)}
\PYG{n}{fmask} \PYG{o}{=} \PYG{n}{f2data}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{0}

\PYG{c}{\PYGZsh{} which month (axis 0) has the max value?}
\PYG{n}{fire\PYGZus{}month} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{argmax}\PYG{p}{(}\PYG{n}{f2data}\PYG{p}{,}\PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}

\PYG{c}{\PYGZsh{} masked array of this}
\PYG{n}{fire\PYGZus{}month} \PYG{o}{=} \PYG{n}{ma}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{fire\PYGZus{}month}\PYG{p}{,}\PYG{n}{mask}\PYG{o}{=}\PYG{n}{fmask}\PYG{p}{)}

\PYG{n}{y} \PYG{o}{=} \PYG{l+m+mi}{2005}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{fire\PYGZus{}month}\PYG{p}{[}\PYG{n}{y}\PYG{o}{\PYGZhy{}}\PYG{n}{year}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nearest}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Peak fire month for }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}\PYG{p}{)}

\PYG{c}{\PYGZsh{} suppose this is the same for all years:}
\PYG{n}{av\PYGZus{}fire\PYGZus{}month} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{median}\PYG{p}{(}\PYG{n}{fire\PYGZus{}month}\PYG{p}{,}\PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{o}{.}\PYG{n}{astype}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{av\PYGZus{}fire\PYGZus{}month}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nearest}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Average peak fire month}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.text.Text at 0x134d27d0\PYGZgt{}
\end{Verbatim}

\includegraphics{ENSO_23_1.png}

\includegraphics{ENSO_23_2.png}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} and now get the fire count for that month}
\PYG{c}{\PYGZsh{} lets try this by hand first}

\PYG{n}{peak\PYGZus{}count} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros\PYGZus{}like}\PYG{p}{(}\PYG{n}{f2data}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{y} \PYG{o}{=} \PYG{l+m+mi}{2001}
\PYG{n}{m} \PYG{o}{=} \PYG{l+m+mi}{0}

\PYG{n}{fmask} \PYG{o}{=} \PYG{p}{(}\PYG{n}{av\PYGZus{}fire\PYGZus{}month} \PYG{o}{==} \PYG{n}{m}\PYG{p}{)}
\PYG{n}{peak\PYGZus{}count}\PYG{p}{[}\PYG{n}{y}\PYG{o}{\PYGZhy{}}\PYG{n}{year}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{[}\PYG{n}{fmask}\PYG{p}{]} \PYG{o}{=} \PYG{n}{f2data}\PYG{p}{[}\PYG{n}{m}\PYG{p}{,}\PYG{n}{y}\PYG{o}{\PYGZhy{}}\PYG{n}{year}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{[}\PYG{n}{fmask}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} and now extend it}
\PYG{n}{peak\PYGZus{}count} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros\PYGZus{}like}\PYG{p}{(}\PYG{n}{f2data}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{m} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{n}{f2data}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{fmask} \PYG{o}{=} \PYG{p}{(}\PYG{n}{av\PYGZus{}fire\PYGZus{}month} \PYG{o}{==} \PYG{n}{m}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{y} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{n}{f2data}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{peak\PYGZus{}count}\PYG{p}{[}\PYG{n}{y}\PYG{p}{]}\PYG{p}{[}\PYG{n}{fmask}\PYG{p}{]} \PYG{o}{=} \PYG{n}{f2data}\PYG{p}{[}\PYG{n}{m}\PYG{p}{,}\PYG{n}{y}\PYG{p}{]}\PYG{p}{[}\PYG{n}{fmask}\PYG{p}{]}


\PYG{c}{\PYGZsh{} test it}
\PYG{n}{y} \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{log}\PYG{p}{(}\PYG{n}{peak\PYGZus{}count}\PYG{p}{[}\PYG{n}{y}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nearest}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Log Peak count for year }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{min\PYGZus{}year}\PYG{o}{+}\PYG{n}{y}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.text.Text at 0x2b44901b2090\PYGZgt{}
\end{Verbatim}

\includegraphics{ENSO_25_1.png}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} In summary, we have developed the following datasets:}

\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{peak\PYGZus{}count}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{peak\PYGZus{}count}\PYG{o}{.}\PYG{n}{shape}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{av\PYGZus{}fire\PYGZus{}month}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{av\PYGZus{}fire\PYGZus{}month}\PYG{o}{.}\PYG{n}{shape}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{min\PYGZus{}year}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{min\PYGZus{}year}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
peak\PYGZus{}count (14, 36, 72)
av\PYGZus{}fire\PYGZus{}month (36, 72)
min\PYGZus{}year 2000
\end{Verbatim}


\subsubsection{Climate Data}
\label{Chapter7_ENSO/ENSO:climate-data}
The climate data you will want will be some form of Sea Surface
Temperature (SST) anomaly measure. There is a long list of such measures
on
\href{http://www.esrl.noaa.gov/psd/data/climateindices/list/}{http://www.esrl.noaa.gov/psd/data/climateindices/list}.

Examples would be
\href{http://www.esrl.noaa.gov/psd/data/correlation/amon.us.data}{AMO} or
\href{http://www.esrl.noaa.gov/psd/data/correlation/oni.data}{ONI}. Note
that some of these measures are smoothed and others not.

Suppose we had selected AMO and we want to read directly from the url:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{urllib2}

\PYG{n}{url} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{http://www.esrl.noaa.gov/psd/data/correlation/amon.us.data}\PYG{l+s}{\PYGZsq{}}

\PYG{n}{req} \PYG{o}{=} \PYG{n}{urllib2}\PYG{o}{.}\PYG{n}{Request} \PYG{p}{(} \PYG{n}{url} \PYG{p}{)}
\PYG{n}{raw\PYGZus{}data} \PYG{o}{=} \PYG{n}{urllib2}\PYG{o}{.}\PYG{n}{urlopen}\PYG{p}{(}\PYG{n}{req}\PYG{p}{)}\PYG{o}{.}\PYG{n}{readlines}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} we notice from inspection that}
\PYG{c}{\PYGZsh{} we want data from rows 1 to \PYGZhy{}4}
\PYG{n}{raw\PYGZus{}data}\PYG{p}{[}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{]}
\end{Verbatim}
\begin{alltt}
{[}'  1948         2013n',
 ` 1948   -0.006   -0.018    0.037   -0.061    0.005    0.064   -0.030   -0.013   -0.043    0.017    0.144    0.072n'{]}
\end{alltt}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{raw\PYGZus{}data}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{]}
\end{Verbatim}
\begin{alltt}
{[}' 2008    0.051    0.150    0.185    0.071    0.193    0.287    0.237    0.201    0.228    0.129    0.031    0.049n',
 ` 2009   -0.032   -0.137   -0.139   -0.103   -0.039    0.152    0.259    0.182    0.086    0.198    0.098    0.112n',
 ` 2010    0.068    0.201    0.313    0.457    0.486    0.476    0.482    0.559    0.481    0.357    0.269    0.240n',
 ` 2011    0.173    0.134    0.082    0.119    0.172    0.206    0.126    0.180    0.183    0.094   -0.045   -0.020n',
 ` 2012   -0.041    0.028    0.048    0.109    0.191    0.332    0.412    0.468    0.482    0.372    0.206    0.173n',
 ` 2013    0.155    0.144    0.186    0.168    0.132    0.078    0.218    0.226    0.290  -99.990  -99.990  -99.990n'{]}
\end{alltt}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{cdata} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{n}{r}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)} \PYG{k}{for} \PYG{n}{r} \PYG{o+ow}{in} \PYG{n}{raw\PYGZus{}data}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{astype}\PYG{p}{(}\PYG{n+nb}{float}\PYG{p}{)}

\PYG{n}{cmask} \PYG{o}{=} \PYG{p}{(}\PYG{n}{cdata} \PYG{o}{\PYGZlt{}} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{50} \PYG{p}{)}
\PYG{n}{cdata} \PYG{o}{=} \PYG{n}{ma}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{cdata}\PYG{p}{,}\PYG{n}{mask}\PYG{o}{=}\PYG{n}{cmask}\PYG{p}{)}\PYG{o}{.}\PYG{n}{T}
\PYG{n}{cyears} \PYG{o}{=} \PYG{n}{cdata}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{cdata} \PYG{o}{=} \PYG{n}{cdata}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{p}{]}

\PYG{c}{\PYGZsh{} now we have the climate data as a masked array}
\PYG{c}{\PYGZsh{} column 0 is years, column 1 is Jan etc.}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{cyears}\PYG{p}{,}\PYG{n}{cdata}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{year}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{January AMO}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{cdata}\PYG{o}{.}\PYG{n}{shape}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{66}\PYG{p}{)}
\end{Verbatim}

\includegraphics{ENSO_32_1.png}


\subsection{7.2.4 Code to perform correlation analysis}
\label{Chapter7_ENSO/ENSO:code-to-perform-correlation-analysis}
The idea here is, for a particular (or set of) SST anomaly measures,
work out which lag month gives the highest correlation coefficient
with fire count.

By lag month, we mean that e.g. if the peak fire month for a
particular pixel was September, which month prior to that has a set of
SST anomalies over the sample years that is most strongly correlated
with fire count.

So, if we were using a single SST anomaly measure (e.g. AMO or ONI) and
sample years 2001 to 2009 to build our model, then we would do a linear
regression of fire count for a particular pixel over these years against
e.g. AMO data for September (lag 0) then August (lag 1) then July (lag
2) etc. and see which produced the highest \(R^2\).

Before we get into that, let's look again at the data structure we have:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} climate data}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{cdata}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{cdata}\PYG{o}{.}\PYG{n}{shape}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{cyears}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{cyears}\PYG{o}{.}\PYG{n}{shape}

\PYG{c}{\PYGZsh{} From the fire data}

\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{peak\PYGZus{}count}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{peak\PYGZus{}count}\PYG{o}{.}\PYG{n}{shape}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{av\PYGZus{}fire\PYGZus{}month}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{av\PYGZus{}fire\PYGZus{}month}\PYG{o}{.}\PYG{n}{shape}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{min\PYGZus{}year}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{min\PYGZus{}year}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
cdata (12, 66)
cyears (66,)
peak\PYGZus{}count (14, 36, 72)
av\PYGZus{}fire\PYGZus{}month (36, 72)
min\PYGZus{}year 2000
\end{Verbatim}

So, if we want to select data for particular years:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} which years (inclusive)}
\PYG{n}{years} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{2001}\PYG{p}{,}\PYG{l+m+mi}{2010}\PYG{p}{]}

\PYG{n}{ypeak\PYGZus{}count} \PYG{o}{=} \PYG{n}{peak\PYGZus{}count}\PYG{p}{[}\PYG{n}{years}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{n}{min\PYGZus{}year}\PYG{p}{:}\PYG{n}{years}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{min\PYGZus{}year} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{ycdata}  \PYG{o}{=}  \PYG{n}{cdata}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{years}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{cyears}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{:}\PYG{n}{years}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{cyears}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{]}

\PYG{c}{\PYGZsh{} check the shape}
\PYG{k}{print} \PYG{n}{ycdata}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{,}\PYG{n}{ypeak\PYGZus{}count}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{,}\PYG{n}{av\PYGZus{}fire\PYGZus{}month}\PYG{o}{.}\PYG{n}{shape}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{36}\PYG{p}{,} \PYG{l+m+mi}{72}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mi}{36}\PYG{p}{,} \PYG{l+m+mi}{72}\PYG{p}{)}
\end{Verbatim}

We need to consider a little carefully the implementation of lag ...

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} we will need to access ycdata[month \PYGZhy{} n][year]}
\PYG{c}{\PYGZsh{} which is a bit fiddly as e.g. \PYGZhy{}3 will be interpreted as}
\PYG{c}{\PYGZsh{} October for that same year, rather than the previous year}
\PYG{n}{y} \PYG{o}{=} \PYG{l+m+mi}{2001} \PYG{o}{\PYGZhy{}} \PYG{n}{min\PYGZus{}year}
\PYG{n}{m} \PYG{o}{=} \PYG{l+m+mi}{2}
\PYG{n}{lag} \PYG{o}{=} \PYG{l+m+mi}{5}
\PYG{k}{print} \PYG{n}{m} \PYG{o}{\PYGZhy{}} \PYG{n}{lag}\PYG{p}{,}\PYG{n}{y}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZhy{}3 1
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} so one way to fix this is to decrease y by one}
\PYG{c}{\PYGZsh{} if m \PYGZhy{} lag is \PYGZhy{}ve}
\PYG{n}{Y} \PYG{o}{=} \PYG{n}{y} \PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{n}{m} \PYG{o}{\PYGZhy{}} \PYG{n}{lag} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{m}\PYG{o}{\PYGZhy{}}\PYG{n}{lag}\PYG{p}{,}\PYG{n}{Y}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZhy{}3 0
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{scipy.stats} \PYG{k+kn}{import} \PYG{n}{linregress}

\PYG{c}{\PYGZsh{} examine an example row col}
\PYG{c}{\PYGZsh{} for a given month over all years}

\PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{24}
\PYG{n}{r} \PYG{o}{=} \PYG{l+m+mi}{19}
\PYG{n}{m} \PYG{o}{=} \PYG{n}{av\PYGZus{}fire\PYGZus{}month}\PYG{p}{[}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{]}
\PYG{c}{\PYGZsh{} pull the data}
\PYG{n}{yyears} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{n}{years}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{n}{years}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}

\PYG{n}{R2} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{n}{linregress}\PYG{p}{(}\PYGZbs{}
            \PYG{n}{ycdata}\PYG{p}{[}\PYG{n}{m}\PYG{o}{\PYGZhy{}}\PYG{n}{n}\PYG{p}{,}\PYG{n}{yyears} \PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{n}{m} \PYG{o}{\PYGZhy{}} \PYG{n}{n} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,}\PYGZbs{}
            \PYG{n}{ypeak\PYGZus{}count}\PYG{p}{[}\PYG{n}{yyears} \PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{n}{m} \PYG{o}{\PYGZhy{}} \PYG{n}{n} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{]}\PYGZbs{}
        \PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{k}{for} \PYG{n}{n} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{n} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{argmax}\PYG{p}{(}\PYG{n}{R2}\PYG{p}{)}

\PYG{n}{x}  \PYG{o}{=} \PYG{n}{ycdata}\PYG{p}{[}\PYG{n}{m}\PYG{o}{\PYGZhy{}}\PYG{n}{n}\PYG{p}{,}\PYG{n}{yyears} \PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{n}{m} \PYG{o}{\PYGZhy{}} \PYG{n}{n} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{]}
\PYG{n}{y} \PYG{o}{=} \PYG{n}{ypeak\PYGZus{}count}\PYG{p}{[}\PYG{n}{yyears} \PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{n}{m} \PYG{o}{\PYGZhy{}} \PYG{n}{n} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{]}
\PYG{n}{slope}\PYG{p}{,}\PYG{n}{intercept}\PYG{p}{,}\PYG{n}{R}\PYG{p}{,}\PYG{n}{p}\PYG{p}{,}\PYG{n}{err} \PYG{o}{=} \PYG{n}{linregress}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{)}

\PYG{k}{print} \PYG{n}{slope}\PYG{p}{,}\PYG{n}{intercept}\PYG{p}{,}\PYG{n}{p}\PYG{p}{,}\PYG{n}{err}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{ycdata}\PYG{p}{[}\PYG{n}{m}\PYG{o}{\PYGZhy{}}\PYG{n}{n}\PYG{p}{]}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r+}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Climate Index}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Fire count}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{x}\PYG{o}{.}\PYG{n}{min}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{x}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,}\PYGZbs{}
         \PYG{p}{[}\PYG{n}{intercept}\PYG{o}{+}\PYG{n}{slope}\PYG{o}{*}\PYG{n}{x}\PYG{o}{.}\PYG{n}{min}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{intercept}\PYG{o}{+}\PYG{n}{slope}\PYG{o}{*}\PYG{n}{x}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{k\PYGZhy{}\PYGZhy{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Fire count at r }\PYG{l+s+si}{\PYGZpc{}03d}\PYG{l+s}{ c }\PYG{l+s+si}{\PYGZpc{}03d}\PYG{l+s}{: R\PYGZca{}2 = }\PYG{l+s+si}{\PYGZpc{}.3f}\PYG{l+s}{: lag }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{,}\PYG{n}{R2}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{p}{,}\PYG{n}{n}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
11175.1548059 2691.89246835 0.0207363379213 3889.85050593
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.text.Text at 0x166679d0\PYGZgt{}
\end{Verbatim}

\includegraphics{ENSO_41_2.png}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} looper}

\PYG{n}{data\PYGZus{}mask} \PYG{o}{=} \PYG{n}{ypeak\PYGZus{}count}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{100}

\PYG{n}{rs}\PYG{p}{,}\PYG{n}{cs} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{where}\PYG{p}{(}\PYG{n}{data\PYGZus{}mask}\PYG{p}{)}

\PYG{n}{results} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{intercept}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{slope}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{p}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{R}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{stderr}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{lag}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{0}\PYG{p}{\PYGZcb{}}
\PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n}{results}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{results}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros\PYGZus{}like}\PYG{p}{(}\PYG{n}{av\PYGZus{}fire\PYGZus{}month}\PYG{p}{)}\PYG{o}{.}\PYG{n}{astype}\PYG{p}{(}\PYG{n+nb}{float}\PYG{p}{)}
    \PYG{n}{results}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]} \PYG{o}{=} \PYG{n}{ma}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{results}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{,}\PYG{n}{mask}\PYG{o}{=}\PYG{o}{\PYGZti{}}\PYG{n}{data\PYGZus{}mask}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{r}\PYG{p}{,}\PYG{n}{c} \PYG{o+ow}{in} \PYG{n+nb}{zip}\PYG{p}{(}\PYG{n}{rs}\PYG{p}{,}\PYG{n}{cs}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{m} \PYG{o}{=} \PYG{n}{av\PYGZus{}fire\PYGZus{}month}\PYG{p}{[}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{]}
    \PYG{c}{\PYGZsh{} pull the data}
    \PYG{n}{yyears} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{n}{years}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{n}{years}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{n}{R2} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYGZbs{}
            \PYG{n}{linregress}\PYG{p}{(}\PYGZbs{}
                \PYG{n}{ycdata}\PYG{p}{[}\PYG{n}{m}\PYG{o}{\PYGZhy{}}\PYG{n}{n}\PYG{p}{,}\PYG{n}{yyears} \PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{n}{m} \PYG{o}{\PYGZhy{}} \PYG{n}{n} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,}\PYGZbs{}
                \PYG{n}{ypeak\PYGZus{}count}\PYG{p}{[}\PYG{n}{yyears} \PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{n}{m} \PYG{o}{\PYGZhy{}} \PYG{n}{n} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{]}\PYGZbs{}
            \PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{k}{for} \PYG{n}{n} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}

    \PYG{n}{n} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{argmax}\PYG{p}{(}\PYG{n}{R2}\PYG{p}{)}
    \PYG{n}{results}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{lag}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{]} \PYG{o}{=} \PYG{n}{n}
    \PYG{n}{x}  \PYG{o}{=} \PYG{n}{ycdata}\PYG{p}{[}\PYG{n}{m}\PYG{o}{\PYGZhy{}}\PYG{n}{n}\PYG{p}{,}\PYG{n}{yyears} \PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{n}{m} \PYG{o}{\PYGZhy{}} \PYG{n}{n} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{]}
    \PYG{n}{y} \PYG{o}{=} \PYG{n}{ypeak\PYGZus{}count}\PYG{p}{[}\PYG{n}{yyears} \PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{n}{m} \PYG{o}{\PYGZhy{}} \PYG{n}{n} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{]}
    \PYG{n}{results}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{slope}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{]}\PYG{p}{,}\PYG{n}{results}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{intercept}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{]}\PYG{p}{,}\PYGZbs{}
    \PYG{n}{results}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{R}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{]}\PYG{p}{,}\PYG{n}{results}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{p}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{]}\PYG{p}{,}\PYGZbs{}
    \PYG{n}{results}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{stderr}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{]} \PYG{o}{=} \PYG{n}{linregress}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{results}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{R}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nearest}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{R}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{results}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{p}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nearest}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{p}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}


\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{results}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{slope}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nearest}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{slope}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}


\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{results}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{lag}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nearest}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{lag}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.text.Text at 0x6d69890\PYGZgt{}
\end{Verbatim}

\includegraphics{ENSO_43_1.png}

\includegraphics{ENSO_43_2.png}

\includegraphics{ENSO_43_3.png}

\includegraphics{ENSO_43_4.png}

which we can now predict:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} prediction year}
\PYG{n}{pyear} \PYG{o}{=} \PYG{l+m+mi}{2012}

\PYG{c}{\PYGZsh{} which month?}
\PYG{n}{M} \PYG{o}{=} \PYG{n}{av\PYGZus{}fire\PYGZus{}month} \PYG{o}{\PYGZhy{}} \PYG{n}{results}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{lag}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{Y} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros\PYGZus{}like}\PYG{p}{(}\PYG{n}{M}\PYG{p}{)} \PYG{o}{+} \PYG{n}{pyear}
\PYG{n}{Y}\PYG{p}{[}\PYG{n}{M}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{l+m+mi}{1}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} lets look at that ...}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{Y}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nearest}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.image.AxesImage at 0x7d6ab90\PYGZgt{}
\end{Verbatim}

\includegraphics{ENSO_46_1.png}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} climate data}
\PYG{n}{scdata} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros\PYGZus{}like}\PYG{p}{(}\PYG{n}{Y}\PYG{p}{)}\PYG{o}{.}\PYG{n}{astype}\PYG{p}{(}\PYG{n+nb}{float}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{y} \PYG{o+ow}{in} \PYG{p}{[}\PYG{n}{pyear}\PYG{p}{,}\PYG{n}{pyear}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{:}
    \PYG{k}{for} \PYG{n}{m} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{scdata}\PYG{p}{[}\PYG{p}{(}\PYG{n}{Y} \PYG{o}{==} \PYG{n}{y}\PYG{p}{)} \PYG{o}{\PYGZam{}} \PYG{p}{(}\PYG{n}{M} \PYG{o}{==} \PYG{n}{m}\PYG{p}{)}\PYG{p}{]} \PYG{o}{=} \PYG{n}{cdata}\PYG{p}{[}\PYG{n}{m}\PYG{p}{,}\PYG{n}{y}\PYG{o}{\PYGZhy{}}\PYG{n}{cyears}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{scdata}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nearest}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.image.AxesImage at 0x7d5a590\PYGZgt{}
\end{Verbatim}

\includegraphics{ENSO_47_1.png}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} now predict}

\PYG{n}{fc\PYGZus{}predict} \PYG{o}{=} \PYG{n}{results}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{intercept}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{+} \PYG{n}{results}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{slope}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{*} \PYG{n}{scdata}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{fc\PYGZus{}predict}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nearest}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{vmax}\PYG{o}{=}\PYG{l+m+mi}{10000}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{predicted peak fire count for }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{n}{pyear}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{peak\PYGZus{}count}\PYG{p}{[}\PYG{n}{pyear}\PYG{o}{\PYGZhy{}}\PYG{n}{min\PYGZus{}year}\PYG{p}{]}\PYG{p}{,}\PYGZbs{}
           \PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nearest}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{vmax}\PYG{o}{=}\PYG{l+m+mi}{10000}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{actual peak fire count for }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{n}{pyear}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.text.Text at 0x83ec750\PYGZgt{}
\end{Verbatim}

\includegraphics{ENSO_48_1.png}

\includegraphics{ENSO_48_2.png}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{=} \PYG{n}{peak\PYGZus{}count}\PYG{p}{[}\PYG{n}{pyear}\PYG{o}{\PYGZhy{}}\PYG{n}{min\PYGZus{}year}\PYG{p}{]}\PYG{o}{.}\PYG{n}{flatten}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{y} \PYG{o}{=} \PYG{n}{fc\PYGZus{}predict}\PYG{o}{.}\PYG{n}{flatten}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{slope}\PYG{p}{,}\PYG{n}{intercept}\PYG{p}{,}\PYG{n}{R}\PYG{p}{,}\PYG{n}{p}\PYG{p}{,}\PYG{n}{err} \PYG{o}{=} \PYG{n}{linregress}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{+}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{measured fire count}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{predicted fire count}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{cc} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{n}{x}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{cc}\PYG{p}{,}\PYG{n}{cc}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{k\PYGZhy{}\PYGZhy{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{cc}\PYG{p}{,}\PYG{n}{slope}\PYG{o}{*}\PYG{n}{cc}\PYG{o}{+}\PYG{n}{intercept}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{k\PYGZhy{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{fire count predictions}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{slope}\PYG{p}{,}\PYG{n}{intercept}\PYG{p}{,}\PYG{n}{R}\PYG{p}{,}\PYG{n}{p}\PYG{p}{,}\PYG{n}{err}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}class \PYGZsq{}numpy.ma.core.MaskedArray\PYGZsq{}\PYGZgt{}
0.802827703736 \PYGZhy{}6.97449131978 0.880785138861 0.0 0.00848080897451
\end{Verbatim}

\includegraphics{ENSO_49_1.png}


\chapter{Recollision Probability Theory}
\label{Chapter8_ptheory/Ptheory::doc}\label{Chapter8_ptheory/Ptheory:recollision-probability-theory}
A useful source of information quantifying vegetation amount is the Leaf
Area Index (LAI). To interpret LAI from satellite data, we build models
of radiative transfer.

One of the simplest such models that we can use at optical wavelengths
uses what is known as `p theory' or `recollision probability theory'
(Lewis and Disney, 2007; Huang et al., 2007).

\textbf{The task today is to use p-theory to estimate LAI over some
agricultural fields.}

References
\begin{itemize}
\item {} 
P. Lewis and M. Disney (2007) Spectral invariants and scattering
across multiple scales from within-leaf to canopy, \href{http://www2.geog.ucl.ac.uk/~mdisney/papers/lewis\_disney\_prospect.pdf}{Remote Sensing of
Environment 109,
196-206.}

\item {} 
D. Huang, Y. Knyazikhin, R.E. Dickinson, M. Rautiainen, P. Stenberg,
M. Disney, P. Lewis, A. Cescatti, Y. Tian, W. Verhoef, and R.B.
Myneni (2007), Canopy spectral invariants for remote sensing and
model applications, \href{http://www2.geog.ucl.ac.uk/~plewis/Huang\_Spectral\_Revised.pdf}{Remote Sensing of Environment, 106,
106-122}

\item {} 
Knyazikhin Y, Schull MA, Stenberg P, Mottus M, Rautiainen M, Yang Y,
Marshak A, Latorre Carmona P, Kaufmann RK, Lewis P, Disney MI,
Vanderbilt V, Davis AB, Baret F, Jacquemoud S, Lyapustin A, Myneni
RB. (2013) Hyperspectral remote sensing of foliar nitrogen content.
Proc Natl Acad Sci USA,
\href{http://cybele.bu.edu/download/manuscripts/knyazikhin-pnas-hypspec.pdf}{10.1073/pnas.1210196109}.

\end{itemize}


\chapter{Data}
\label{Chapter8_ptheory/Ptheory:data}
The dataset you have available is an airborne hyperspectral image
(HYMAP) dataset for which you have a 512x512 pixel subscene taken in 125
wavebands with a spatial resolution of 4m. The data were obtained on 17
June 2000 over Barton Bendish Farms, Norfolk during the BNSC/NERC SHAC
campaign.

The data are available as a compressed \emph{flat binary} file in the
directory \code{{}`files/data} \textless{}files/data\textgreater{}{}`\_\_.

First, uncompress the dataset:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{} or try zcat if gzcat isnt there
!gzcat files/data/bbHYMAP.dat.gz \PYGZgt{} files/data/bbHYMAP.dat
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
!ls \PYGZhy{}l files/data/bbHYMAP.dat
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{}r\PYGZhy{}\PYGZhy{}  1 plewis  staff  131072000 26 Nov 17:31 files/data/bbHYMAP.dat
\end{Verbatim}

The file is 131072000 bytes in 32 bit floating point format:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nbands =}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{131072000}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mi}{512}\PYG{o}{*}\PYG{l+m+mi}{512}\PYG{o}{*}\PYG{l+m+mi}{4}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{nbands} \PYG{o}{=} \PYG{l+m+mi}{125}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} we wuill use memmap to read the data in}
\PYG{k+kn}{from} \PYG{n+nn}{numpy} \PYG{k+kn}{import} \PYG{n}{memmap}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{hymap} \PYG{o}{=} \PYG{n}{memmap}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/bbHYMAP.dat}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{dtype}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{float32}\PYG{p}{,}\PYG{n}{mode}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{shape}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{125}\PYG{p}{,}\PYG{l+m+mi}{512}\PYG{p}{,}\PYG{l+m+mi}{512}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{hymap}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nearest}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.image.AxesImage at 0x10598edd0\PYGZgt{}
\end{Verbatim}

\includegraphics{Ptheory_10_1.png}

The wavelengths associated with each band are stored in
\code{{}`files/data/wavebands.dat} \textless{}files/data/wavebands.dat\textgreater{}{}`\_\_.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{mean} \PYG{o}{=} \PYG{n}{hymap}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{n}{axis}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{wavelength} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{loadtxt}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/wavebands.dat}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{wavelength}\PYG{p}{,}\PYG{n}{mean}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
[\PYGZlt{}matplotlib.lines.Line2D at 0x10f089790\PYGZgt{}]
\end{Verbatim}

\includegraphics{Ptheory_12_1.png}


\chapter{Theory}
\label{Chapter8_ptheory/Ptheory:theory}
The simplest form of model in p-theory assumes that the photon
recollision probability is constant with wavelength and scattering
order. Under this assumption, the total scattering from the canopy,
\(W\) is:
\begin{gather}
\begin{split}W = i_0 \frac{(1 - p) \omega}{1 - p \omega}\end{split}\notag
\end{gather}
where \(i_0\) is the canopy interception probability, \(\omega\)
is the leaf-level scattering (the leaf single scattering albedo) and
\(p\) is the recollision probability: the probability that a photon,
having intercepted a canopy element, will recollide with another element
rather than escape the canopy.

We can develop from this a model of the canopy \emph{reflectance}
\(\rho\) (i.e. that portion scattered upwards, perhaps in a
particular direction):
\begin{gather}
\begin{split}\rho = \frac{a \omega}{1 - p \omega}\end{split}\notag
\end{gather}
For a closed canopy, or one with only little soil influence, this will
describe the spectral reflectance for some given leaf single scattering
albedo spectrum and given \(p\).

If we know \(\omega\) then, and have a measurement of \(\rho\),
we can estimate \(p\). From \(p\), we can estimate LAI according
to Lewis and Disney (2007) by:
\begin{gather}
\begin{split}p = 0.88 \left( 1 - exp(- 0.7 LAI^{0.75}) \right)\end{split}\notag
\end{gather}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{LAI} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{12}\PYG{p}{,}\PYG{l+m+mf}{0.01}\PYG{p}{)}
\PYG{n}{p} \PYG{o}{=} \PYG{l+m+mf}{0.88}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.7} \PYG{o}{*} \PYG{n}{LAI}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mf}{0.75}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{LAI}\PYG{p}{,}\PYG{n}{p}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{LAI}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{p}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.text.Text at 0x10f12f0d0\PYGZgt{}
\end{Verbatim}

\includegraphics{Ptheory_15_1.png}

There are several ways we could estimate \(p\). An interesting
feature exploited by Knyazikhin et al. (2013) follows from:
\begin{gather}
\begin{split}\frac{\rho}{\omega} = \frac{a}{1 - p \omega}\end{split}\notag
\end{gather}
so
\begin{gather}
\begin{split}\frac{\rho}{\omega}  = a + p \rho\end{split}\notag
\end{gather}
So that if we plot \(\frac{\rho}{\omega}\) as a function of
\(\rho\), this theory predicts we should see a straight line.

An example leaf single scattering albedo is given in
\code{{}`files/data/ssalbedo.dat} \textless{}files/data/ssalbedo.dat\textgreater{}{}`\_\_:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{ssalbedo} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{loadtxt}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/ssalbedo.dat}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{T}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{ssalbedo}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{ssalbedo}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{wavelength / nm}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{single scattering albedo}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlim}\PYG{p}{(}\PYG{n}{ssalbedo}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{ssalbedo}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{l+m+mf}{400.0}\PYG{p}{,} \PYG{l+m+mf}{2400.0}\PYG{p}{)}
\end{Verbatim}

\includegraphics{Ptheory_17_1.png}

which is sampled every 1 nm from 400 to 2400 nm.

We will clearly need to resample this to the same wavebands as the
hyperspectral data:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{scipy.interpolate} \PYG{k+kn}{import} \PYG{n}{interp1d}
\PYG{k+kn}{from} \PYG{n+nn}{scipy.stats} \PYG{k+kn}{import} \PYG{n}{linregress}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{f} \PYG{o}{=} \PYG{n}{interp1d}\PYG{p}{(}\PYG{n}{ssalbedo}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{ssalbedo}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{omega} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{n}{wavelength}\PYG{p}{[}\PYG{n}{wavelength}\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{l+m+mi}{2400}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

The theory becomes more complicated when multiple absorbing constituents
are involved, so we select here only wavelengths between 710 and 790 nm
(on the `red edge'), where the main absorbing constituent is
chlorophyll.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} wavelength}
\PYG{n}{W} \PYG{o}{=} \PYG{p}{(}\PYG{n}{wavelength} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{710}\PYG{p}{)} \PYG{o}{\PYGZam{}} \PYG{p}{(}\PYG{n}{wavelength} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{790}\PYG{p}{)}

\PYG{n}{wave} \PYG{o}{=} \PYG{n}{wavelength}\PYG{p}{[}\PYG{n}{W}\PYG{p}{]}
\PYG{c}{\PYGZsh{} single scattering albedo}
\PYG{n}{omega} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{n}{wavelength}\PYG{p}{[}\PYG{n}{W}\PYG{p}{]}\PYG{p}{)}
\PYG{c}{\PYGZsh{} reflectance}
\PYG{n}{rho} \PYG{o}{=} \PYG{n}{hymap}\PYG{p}{[}\PYG{n}{W}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} lets see if its a straight line!}
\PYG{n}{mean} \PYG{o}{=} \PYG{n}{rho}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{n}{axis}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{mean}\PYG{p}{,}\PYG{n}{mean}\PYG{o}{/}\PYG{n}{omega}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{+}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{c}{\PYGZsh{} linear fit}
\PYG{n}{slope}\PYG{p}{,} \PYG{n}{intercept}\PYG{p}{,} \PYG{n}{r\PYGZus{}value}\PYG{p}{,} \PYG{n}{p\PYGZus{}value}\PYG{p}{,} \PYG{n}{std\PYGZus{}err} \PYG{o}{=} \PYG{n}{linregress}\PYG{p}{(}\PYG{n}{mean}\PYG{p}{,}\PYG{n}{mean}\PYG{o}{/}\PYG{n}{omega}\PYG{p}{)}
\PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{n}{mean}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{mean}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{x}\PYG{o}{*}\PYG{n}{slope}\PYG{o}{+}\PYG{n}{intercept}\PYG{p}{)}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{slope}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{slope}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{intercept}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{intercept}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
slope 0.710882123721 intercept 0.125383329915
\end{Verbatim}

\includegraphics{Ptheory_23_1.png}

So, here, \(p\) is 0.71088

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{}p = 0.88*(1 \PYGZhy{} np.exp(\PYGZhy{}0.7 * LAI**0.75))}
\PYG{n}{LAI} \PYG{o}{=} \PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{log}\PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}} \PYG{n}{slope}\PYG{o}{/}\PYG{l+m+mf}{0.88}\PYG{p}{)}\PYG{o}{/}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.7}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mf}{4.}\PYG{o}{/}\PYG{l+m+mf}{3.}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{LAI}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{3.13529156174}
\end{Verbatim}

Following Knyazikhin et al. (2013) we can calculate the \code{DASF}
(Directional Area Scattering Function) from:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{DASF} \PYG{o}{=} \PYG{n}{intercept}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}} \PYG{n}{slope}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{DASF}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{0.43367546666}
\end{Verbatim}

and from that, \(W\):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{W} \PYG{o}{=} \PYG{n}{mean}\PYG{o}{/}\PYG{n}{DASF}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{wave}\PYG{p}{,}\PYG{n}{W}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{wave}\PYG{p}{,}\PYG{n}{omega}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
[\PYGZlt{}matplotlib.lines.Line2D at 0x11b5d1410\PYGZgt{}]
\end{Verbatim}

\includegraphics{Ptheory_29_1.png}

which in turn can give access to leaf biochemistry.


\chapter{The Task}
\label{Chapter8_ptheory/Ptheory:the-task}
The output of this exercise should be a spatial dataset of LAI.

The processing for this task is quite straightforward, and you \emph{should}
be able to develop a neat algorithm given the information above.

You should work in teams for this exercise as in previous weeks, and
assign tasks for people to complete after you have discussed an overall
algorithm and defined any interfaces you will need.

If you finish the task quickly, you could explore the impact of the the
leaf single scattering albedo assumed, and/or examine the impact of
widening the wavelength range used here.

This section of the notes is intended for follow-up after the class and
future reference. We will not go through this in detail in the teaching
sessions.

This material and the exercises are more advanced than in the main
notes. You are not \emph{required} to do these, but may like to do so if you
want to stretch yourself.


\chapter{A2.1 Binary Operators}
\label{Chapter2_Python_intro/advanced:a2-1-binary-operators}\label{Chapter2_Python_intro/advanced::doc}

\section{A2.1.1 Basic Logic}
\label{Chapter2_Python_intro/advanced:a2-1-1-basic-logic}
Quite often (data masks in data products, being the most typical
example), you will need to deal with binary numbers and binary
operations, so we will introduce the concepts you need here.

We came across \emph{logical} or \emph{Boolean} operations in the main session
(with the data type \code{bool}). In logic, something can be \code{True} or
\code{False}, and operations such as
\code{{}`not} \textless{}\href{http://en.wikipedia.org/wiki/Logical\_NOT}{http://en.wikipedia.org/wiki/Logical\_NOT}\textgreater{}{}`\_\_,
\code{{}`and} \textless{}\href{http://en.wikipedia.org/wiki/Logical\_AND}{http://en.wikipedia.org/wiki/Logical\_AND}\textgreater{}{}`\_\_ and
\code{{}`or} \textless{}\href{http://en.wikipedia.org/wiki/Logical\_OR}{http://en.wikipedia.org/wiki/Logical\_OR}\textgreater{}{}`\_\_ have quite obvious
meanings. More generally in logic (and electronics) we may come across
other logical operators such as
\code{{}`nand} \textless{}\href{http://en.wikipedia.org/wiki/Logical\_NAND}{http://en.wikipedia.org/wiki/Logical\_NAND}\textgreater{}{}`\_\_ (\code{not and})
and \code{{}`nor} \textless{}\href{http://en.wikipedia.org/wiki/Logical\_NOR}{http://en.wikipedia.org/wiki/Logical\_NOR}\textgreater{}{}`\_\_ (\code{not or})
and \code{{}`xor} \textless{}\href{http://en.wikipedia.org/wiki/Logical\_XOR}{http://en.wikipedia.org/wiki/Logical\_XOR}\textgreater{}{}`\_\_ (exclusive
\code{or}: \emph{either but not both}), but these are not defined in Python
(they can of course be \emph{derived} though).

You should first make sure that you understand the results of the
\code{and}, \code{or} and \code{not} \code{bool} operators:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{False and False =}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n+nb+bp}{False} \PYG{o+ow}{and} \PYG{n+nb+bp}{False}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{False and True  =}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n+nb+bp}{False} \PYG{o+ow}{and} \PYG{n+nb+bp}{True}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{True  and False =}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n+nb+bp}{True} \PYG{o+ow}{and} \PYG{n+nb+bp}{False}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{True  and True  =}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n+nb+bp}{True} \PYG{o+ow}{and} \PYG{n+nb+bp}{True}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nb+bp}{False} \PYG{o+ow}{and} \PYG{n+nb+bp}{False} \PYG{o}{=} \PYG{n+nb+bp}{False}
\PYG{n+nb+bp}{False} \PYG{o+ow}{and} \PYG{n+nb+bp}{True}  \PYG{o}{=} \PYG{n+nb+bp}{False}
\PYG{n+nb+bp}{True}  \PYG{o+ow}{and} \PYG{n+nb+bp}{False} \PYG{o}{=} \PYG{n+nb+bp}{False}
\PYG{n+nb+bp}{True}  \PYG{o+ow}{and} \PYG{n+nb+bp}{True}  \PYG{o}{=} \PYG{n+nb+bp}{True}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{False or False =}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n+nb+bp}{False} \PYG{o+ow}{or} \PYG{n+nb+bp}{False}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{False or True  =}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n+nb+bp}{False} \PYG{o+ow}{or} \PYG{n+nb+bp}{True}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{True  or False =}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n+nb+bp}{True} \PYG{o+ow}{or} \PYG{n+nb+bp}{False}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{True  or True  =}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n+nb+bp}{True} \PYG{o+ow}{or} \PYG{n+nb+bp}{True}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nb+bp}{False} \PYG{o+ow}{or} \PYG{n+nb+bp}{False} \PYG{o}{=} \PYG{n+nb+bp}{False}
\PYG{n+nb+bp}{False} \PYG{o+ow}{or} \PYG{n+nb+bp}{True}  \PYG{o}{=} \PYG{n+nb+bp}{True}
\PYG{n+nb+bp}{True}  \PYG{o+ow}{or} \PYG{n+nb+bp}{False} \PYG{o}{=} \PYG{n+nb+bp}{True}
\PYG{n+nb+bp}{True}  \PYG{o+ow}{or} \PYG{n+nb+bp}{True}  \PYG{o}{=} \PYG{n+nb+bp}{True}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{not False =}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{o+ow}{not} \PYG{n+nb+bp}{False}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{not True  =}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{o+ow}{not} \PYG{n+nb+bp}{True}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{o+ow}{not} \PYG{n+nb+bp}{False} \PYG{o}{=} \PYG{n+nb+bp}{True}
\PYG{o+ow}{not} \PYG{n+nb+bp}{True}  \PYG{o}{=} \PYG{n+nb+bp}{False}
\end{Verbatim}


\section{Exercise A2.1}
\label{Chapter2_Python_intro/advanced:exercise-a2-1}
As an exercise for this, you could see if you can simulate the logical
combinations \code{xor}, \code{nor} and \code{nand}, e.g.:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} nand test:}
\PYG{c}{\PYGZsh{}see http://en.wikipedia.org/wiki/Logical\PYGZus{}NAND}
\PYG{c}{\PYGZsh{} (A nand B) is not (A and B)}

\PYG{n}{ABList} \PYG{o}{=} \PYG{p}{[}\PYG{p}{(}\PYG{n+nb+bp}{False}\PYG{p}{,}\PYG{n+nb+bp}{False}\PYG{p}{)}\PYG{p}{,}\PYG{p}{(}\PYG{n+nb+bp}{False}\PYG{p}{,}\PYG{n+nb+bp}{True}\PYG{p}{)}\PYG{p}{,}\PYG{p}{(}\PYG{n+nb+bp}{True}\PYG{p}{,}\PYG{n+nb+bp}{False}\PYG{p}{)}\PYG{p}{,}\PYG{p}{(}\PYG{n+nb+bp}{True}\PYG{p}{,}\PYG{n+nb+bp}{True}\PYG{p}{)}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{A}\PYG{p}{,}\PYG{n}{B} \PYG{o+ow}{in} \PYG{n}{ABList}\PYG{p}{:}
  \PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{ nand }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{  =}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}\PYG{p}{,}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{B}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}\PYG{o+ow}{not} \PYG{p}{(}\PYG{n}{A} \PYG{o+ow}{and} \PYG{n}{B}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
False nand False  = True
False nand True  = True
True nand False  = True
True nand True  = False
\end{Verbatim}


\section{A2.1.2 Binary}
\label{Chapter2_Python_intro/advanced:a2-1-2-binary}

\section{Endianness}
\label{Chapter2_Python_intro/advanced:endianness}
It is of value to have some understanding of binary operations and
representation(s):
\begin{itemize}
\item {} 
you will come across these in encoded data products (such as the QA
information in MODIS and other satellite products) as it is a more
efficient way of enconding multiple sets of logical information

\item {} 
this is the form in which the computer ultimately stores and
processes information, so it is useful to have some appreciation of
that

\item {} 
you will sometimes need to consider how large a number representation
is (e.g. byte or short integer or long integer) as this can impact
computer memory and storage requirements

\item {} 
you may come across different binary representations for different
datasets

\end{itemize}

There are two main number representations used in computing, which
depend on the interpretation of the
\href{http://en.wikipedia.org/wiki/Most\_significant\_bit}{MSB}, Most
Significant Bit or `high bit order' (or Byte) and
\href{http://en.wikipedia.org/wiki/Least\_significant\_bit}{LSB}, Least
Significant Bit or `low bit order' (or Byte).

Which system is used is sometimes refered to as
\href{http://en.wikipedia.org/wiki/Endianness}{`endianness'} so we may
refer to a `big-endian' or `little-endian' representation. In a
big-endian representation, the left-most byte represents the highest
number. In a little-endian system, this is the lowest number.

It is probably easiest to understand this with decimal numbers:

So, in a big-endian decimal representation:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{152}
\end{Verbatim}

represents one hundred and fifty two
(\code{(1 x 10\textasciicircum{}2) + (5 x 10\textasciicircum{}1) + (2 x 10\textasciicircum{}0)})

In a little-endian system, this is interpreted the other way around, so
\code{152} is \code{(2 x 10\textasciicircum{}2) + (5 x 10\textasciicircum{}1) + (1 x 10\textasciicircum{}0)}, so is actually two
hundred and fifty one.

The term comes from Jonathan Swift's \href{http://www.gutenberg.org/files/829/829-h/829-h.htm}{Gulliver's
travels}, if you
are interested, refering to the which end of an egg the people of
Lilliput and Blefuscu believe you should open:

\code{"(The people of Lilliput and Blefuscu have) been engaged in a most obstinate war for six-and-thirty moons past.  It began upon the following occasion.  It is allowed on all hands, that the primitive way of breaking eggs, before we eat them, was upon the larger end; but his present majestys grandfather, while he was a boy, going to eat an egg, and breaking it according to the ancient practice, happened to cut one of his fingers.  Whereupon the emperor his father published an edict, commanding all his subjects, upon great penalties, to break the smaller end of their eggs.  The people so highly resented this law, that our histories tell us, there have been six rebellions raised on that account; wherein one emperor lost his life, and another his crown.  These civil commotions were constantly fomented by the monarchs of Blefuscu; and when they were quelled, the exiles always fled for refuge to that empire.  It is computed that eleven thousand persons have at several times suffered death, rather than submit to break their eggs at the smaller end.  Many hundred large volumes have been published upon this controversy: but the books of the Big-endians have been long forbidden, and the whole party rendered incapable by law of holding employments."}

Endianness then (like which end of an egg you should break), is
ultimately arbitrary, but we must still have conventions so that
information on one computer system can be interpreted by another.

At present, probably most computers you use will be little-endian (the
`Intel convention' as it has come to be known), but you may also come
across data stored in big-endian (so-called `Motorola convention')
format.

Endianness is mainly implemented at the byte level, so if you are
considering a signle byte, which `end you open the egg' has no
consequence.

For longer number representations though (e.g. a 2-byte or 4-byte
integer) it can have significant consequences, and you need to be aware
of the endianness of data that you might try to be reading. Many file
formats will explicitly store the endinaness that data were written in,
so a correct interpretation will be handled by low level reading
routines. But, if you get binary data that are of more than one byte
that look rather odd when you display them, one possible reason is that
you have assumed a different endinaness to what the data were written
in.


\section{Binary numbers}
\label{Chapter2_Python_intro/advanced:binary-numbers}
When we are working with \emph{binary} numbers \emph{for a single bit}, we
represent \code{False} by \code{0} and \code{True} by \code{1}.

In Python, these representations can essentially be used interchangably
with logical operators, (but we use the function \code{bool()} to convert
to a boolean representation)

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{n+nb+bp}{True} \PYG{o+ow}{or} \PYG{n+nb+bp}{False}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nb+bp}{True}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{l+m+mi}{1} \PYG{o+ow}{or} \PYG{l+m+mi}{0}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{1}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{n+nb}{bool}\PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o+ow}{or} \PYG{l+m+mi}{0}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nb+bp}{True}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{whatTheySay} \PYG{o}{=} \PYG{n+nb+bp}{True}

\PYG{k}{if} \PYG{n}{whatTheySay}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{it}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{s true what they say ...}\PYG{l+s}{\PYGZdq{}}
\PYG{k}{else}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{it}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{s not true what they say ...}\PYG{l+s}{\PYGZdq{}}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
it\PYGZsq{}s true what they say ...
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{whatTheySay} \PYG{o}{=} \PYG{l+m+mi}{1}

\PYG{k}{if} \PYG{n}{whatTheySay}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{it}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{s true what they say ...}\PYG{l+s}{\PYGZdq{}}
\PYG{k}{else}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{it}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{s not true what they say ...}\PYG{l+s}{\PYGZdq{}}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
it\PYGZsq{}s true what they say ...
\end{Verbatim}

A binary representation of a number is a representation in \href{http://en.wikipedia.org/wiki/Binary\_number}{base
2}, where we may use
multiple \href{http://en.wikipedia.org/wiki/Bit}{bits} to represent
numbers.

Some number representations (such as \href{http://en.wikipedia.org/wiki/IEEE\_floating\_point}{floating
point}) are stored
in a more complicated manner, but \href{http://www.asciitable.com/}{ASCII
codes} for string representation and
integers are in a more straightforward binary format.

So, e.g. the (integer) \textbf{decimal} number 3 is \code{11} in binary (base
2):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{3} \PYG{o}{==} \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{+} \PYGZbs{}
     \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{0}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nb+bp}{True}
\end{Verbatim}

We can use the Python function \code{bin()} to get this more directly:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{n+nb}{bin}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{0}\PYG{n}{b11}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{l+m+mi}{0}\PYG{n}{b11}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{3}
\end{Verbatim}

Similarly, the decimal number \code{101} is \code{1100101} in binary:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{101} \PYG{o}{==}  \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{6}\PYG{p}{)} \PYG{o}{+} \PYGZbs{}
        \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYGZbs{}
        \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYGZbs{}
        \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{o}{+} \PYGZbs{}
        \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+} \PYGZbs{}
        \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{+} \PYGZbs{}
        \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{0}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nb+bp}{True}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{n+nb}{bin}\PYG{p}{(}\PYG{l+m+mi}{101}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{0}\PYG{n}{b1100101}
\end{Verbatim}


\section{Exercise A2.2}
\label{Chapter2_Python_intro/advanced:exercise-a2-2}\begin{enumerate}
\item {} 
Work out what the following decimal numbers are in binary:

\begin{DUlineblock}{0em}
\item[] 7
\item[] 493
\item[] 127
\item[] 255
\item[] 1024
\end{DUlineblock}

\end{enumerate}

and check your result using the approach we took to confirming \code{101}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{101} \PYG{o}{==}  \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{6}\PYG{p}{)} \PYG{o}{+} \PYGZbs{}
        \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYGZbs{}
        \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYGZbs{}
        \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{o}{+} \PYGZbs{}
        \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+} \PYGZbs{}
        \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{+} \PYGZbs{}
        \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{0}\PYG{p}{)}
\end{Verbatim}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
How many bits are needed to represent each of these numbers?

\item {} 
What is the largest number you could represent in: (i) a 32 bit
representation; (b) a 64 bit representation?

\item {} 
Recalling that there are 8 bits in a
\href{http://en.wikipedia.org/wiki/Byte}{byte}, what is the largest
number you could represent in: (a) a single byte; (b) two bytes?

\end{enumerate}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+sd}{    Explorations in binary!}

\PYG{l+s+sd}{    We can represent:}

\PYG{l+s+sd}{    binary numbers, e.g.    0b010101}
\PYG{l+s+sd}{    octal numbers, e.g.     0o755}
\PYG{l+s+sd}{    hexadecimal, e.g.       0x2A2FF}

\PYG{l+s+sd}{    but if we print these,}
\PYG{l+s+sd}{    by default they are printed as the decimal equivalents.}

\PYG{l+s+sd}{    We can convert to binary, octal or hex string with}
\PYG{l+s+sd}{    bin(), oct(), hex()}
\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{n}{b111101101}
\PYG{k}{print} \PYG{n+nb}{bin}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{is}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{x}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{in decimal}\PYG{l+s}{\PYGZsq{}}
\PYG{k}{print} \PYG{n+nb}{bin}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{is}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n+nb}{oct}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{in octal}\PYG{l+s}{\PYGZsq{}}
\PYG{k}{print} \PYG{n+nb}{bin}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{is}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n+nb}{hex}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{in hexadecimal}\PYG{l+s}{\PYGZsq{}}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{0}\PYG{n}{b111101101} \PYG{o+ow}{is} \PYG{l+m+mi}{493} \PYG{o+ow}{in} \PYG{n}{decimal}
\PYG{l+m+mi}{0}\PYG{n}{b111101101} \PYG{o+ow}{is} \PYG{l+m+mo}{0755} \PYG{o+ow}{in} \PYG{n}{octal}
\PYG{l+m+mi}{0}\PYG{n}{b111101101} \PYG{o+ow}{is} \PYG{l+m+mh}{0x1ed} \PYG{o+ow}{in} \PYG{n}{hexadecimal}
\end{Verbatim}


\section{A2.1.2 Bitwise Operators}
\label{Chapter2_Python_intro/advanced:a2-1-2-bitwise-operators}
In Python (and most other computer languages) you have access to bitwise
operators. As you might expect, these are operators that are executed on
individual bits in a binary representation of a number.

The bitwise operators available in Python are:
\begin{itemize}
\item {} 
\code{\&} bitwise and

\item {} 
\code{\textbar{}} bitwise or

\item {} 
\code{\textasciicircum{}} bitwise \code{xor} (exclusive or)

\item {} 
\code{\textasciitilde{}} bitwise ones complement

\item {} 
\code{\textless{}\textless{}} bitwise left shift

\item {} 
\code{\textgreater{}\textgreater{}} bitwise right shift

\end{itemize}

The \code{\&} operator simply performs a logical \code{and} operation on two
sets of binary representations, so:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{1} \PYG{o}{\PYGZam{}} \PYG{l+m+mi}{0} \PYG{o}{==} \PYG{l+m+mi}{0}
\end{Verbatim}

is the same as a logical \code{True and False} operation that we saw above
.

The \code{\textbar{}} operator simply performs a logical \code{or} operation on two
sets of binary representations, so:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{1} \PYG{o}{\textbar{}} \PYG{l+m+mi}{0} \PYG{o}{==} \PYG{l+m+mi}{1}
\end{Verbatim}

is the same as a logical \code{True or False} operation that we saw above.

Similarly,

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{1} \PYG{o}{\PYGZca{}} \PYG{l+m+mi}{0} \PYG{o}{==} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{1} \PYG{o}{\PYGZca{}} \PYG{l+m+mi}{1} \PYG{o}{==} \PYG{l+m+mi}{0}
\end{Verbatim}

and

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZti{}}\PYG{l+m+mi}{1} \PYG{o}{==} \PYG{l+m+mi}{0}
\PYG{o}{\PYGZti{}}\PYG{l+m+mi}{0} \PYG{o}{==} \PYG{l+m+mi}{1}
\end{Verbatim}

These same rules apply then to all bit fields:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZti{}}\PYG{l+m+mi}{1010} \PYG{o}{==} \PYG{l+m+mo}{0101}
\end{Verbatim}

etc.

The shift operators are interesting:

left shift by 1, for example is equivalent to multiplying by 2, and
right shift by 1 a division by 2.

They are also very useful in sorting out `bit masks' for data products.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+sd}{    Bitwise operators:}
\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}

\PYG{n}{A} \PYG{o}{=} \PYG{l+m+mi}{521}
\PYG{n}{B} \PYG{o}{=} \PYG{l+m+mi}{523}
\PYG{c}{\PYGZsh{} print as binary:}
\PYG{k}{print} \PYG{n}{A}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{A:}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n+nb}{bin}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{B}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{B:}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n+nb}{bin}\PYG{p}{(}\PYG{n}{B}\PYG{p}{)}

\PYG{c}{\PYGZsh{} some operations}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{A \textbar{} B:}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n+nb}{bin}\PYG{p}{(}\PYG{n}{A}\PYG{o}{\textbar{}}\PYG{n}{B}\PYG{p}{)}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{A}\PYG{o}{\textbar{}}\PYG{n}{B}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{A \PYGZca{} B:}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n+nb}{bin}\PYG{p}{(}\PYG{n}{A}\PYG{o}{\PYGZca{}}\PYG{n}{B}\PYG{p}{)}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{A}\PYG{o}{\PYGZca{}}\PYG{n}{B}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{A \PYGZam{} B:}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n+nb}{bin}\PYG{p}{(}\PYG{n}{A}\PYG{o}{\PYGZam{}}\PYG{n}{B}\PYG{p}{)}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{A}\PYG{o}{\PYGZam{}}\PYG{n}{B}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
521         A:      0b1000001001
523         B:      0b1000001011
    A \textbar{} B:  0b1000001011    523
    A \PYGZca{} B:  0b10            2
    A \PYGZam{} B:  0b1000001001    521
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+sd}{    Bitwise shift operators:}
\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}

\PYG{n}{A} \PYG{o}{=} \PYG{l+m+mi}{531}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{A:}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n+nb}{bin}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{A}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{A\PYGZgt{}\PYGZgt{}1:}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n+nb}{bin}\PYG{p}{(}\PYG{n}{A}\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{A}\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{l+m+mi}{1}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{A\PYGZgt{}\PYGZgt{}1:}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n+nb}{bin}\PYG{p}{(}\PYG{n}{A}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{A}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{l+m+mi}{1}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{A\PYGZgt{}\PYGZgt{}3:}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n+nb}{bin}\PYG{p}{(}\PYG{n}{A}\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{A}\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{l+m+mi}{3}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{A\PYGZgt{}\PYGZgt{}3:}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n+nb}{bin}\PYG{p}{(}\PYG{n}{A}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{A}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{l+m+mi}{3}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
A:      0b1000010011    531
A\PYGZgt{}\PYGZgt{}1:   0b100001001     265
A\PYGZgt{}\PYGZgt{}1:   0b10000100110   1062
A\PYGZgt{}\PYGZgt{}3:   0b1000010       66
A\PYGZgt{}\PYGZgt{}3:   0b1000010011000         4248
\end{Verbatim}

As an example of data masking, consider the QA mask in the \href{https://lpdaac.usgs.gov/products/modis\_products\_table/leaf\_area\_index\_fraction\_of\_photosynthetically\_active\_radiation/8\_day\_l4\_global\_1km/mod15a2}{MODIS Leaf
Area Index
(LAI)}
product:

Bit number

Parameter Name

Bit combination

Interpretation

0

MODLAND\_QC bits

0

Good quality (main algorithm with or without saturation)

1

Other Quality (back-up algorithm or fill values)

1

Sensor

0

Terra

1

Aqua

2

DeadDetector

0

Detectors apparently fine for up to 50\% of channels

1

Dead detectors caused \textgreater{}50\% adjacent detector retrieval

3-4

CloudState

00

Significant clouds NOT present (clear)

01

Significant clouds WERE present

10

Mixed cloud present on pixel

11

Cloud state not defined (assumed clear)

5-7

CF\_QC

000

Main (RT) method used (best result possible (no saturation))

001

Main (RT) method used with saturation. (usable)

010

Main (RT) method failed due to bad geometry (empirical algorithm used)

010

Main (RT) method failed due to problems other than geometry (empirical
algorithm used)

010

Pixel not produced at all.

So, the MODIS LAI QA information is contained in one byte (8 bits),
which encodes data about five different categories of QA information.

When using such data, we need to make choices about what quality of data
we are willing to accept.

How can we use our understanding of bitwise operations to pull out these
datasets?

First, we can try to pull out the different categories.

One way to do this is using a set of `bit masks' for each of the bit
fields we want to cover.

If then perform a bitwise and operation with these, only relevant bits
will `show' through.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} an example QA value: fill all fields}
\PYG{n}{qa} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{n}{b11111111}

\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{qa}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{qa}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{binary qa}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n+nb}{bin}\PYG{p}{(}\PYG{n}{qa}\PYG{p}{)}

\PYG{c}{\PYGZsh{} set up masks for the different parameters}
\PYG{n}{mask1} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{n}{b00000001}    \PYG{c}{\PYGZsh{} bit 0}
\PYG{n}{mask2} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{n}{b00000010}    \PYG{c}{\PYGZsh{} bit 1}
\PYG{n}{mask3} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{n}{b00000100}    \PYG{c}{\PYGZsh{} bit 2}
\PYG{n}{mask4} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{n}{b00011000}    \PYG{c}{\PYGZsh{} bit 3\PYGZhy{}4}
\PYG{n}{mask5} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{n}{b11100000}    \PYG{c}{\PYGZsh{} bit 5\PYGZhy{}7}

\PYG{n}{qa1} \PYG{o}{=} \PYG{n}{qa} \PYG{o}{\PYGZam{}} \PYG{n}{mask1}
\PYG{n}{qa2} \PYG{o}{=} \PYG{n}{qa} \PYG{o}{\PYGZam{}} \PYG{n}{mask2}
\PYG{n}{qa3} \PYG{o}{=} \PYG{n}{qa} \PYG{o}{\PYGZam{}} \PYG{n}{mask3}
\PYG{n}{qa4} \PYG{o}{=} \PYG{n}{qa} \PYG{o}{\PYGZam{}} \PYG{n}{mask4}
\PYG{n}{qa5} \PYG{o}{=} \PYG{n}{qa} \PYG{o}{\PYGZam{}} \PYG{n}{mask5}

\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{qa1}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n+nb}{bin}\PYG{p}{(}\PYG{n}{qa1}\PYG{p}{)}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{qa2}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n+nb}{bin}\PYG{p}{(}\PYG{n}{qa2}\PYG{p}{)}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{qa3}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n+nb}{bin}\PYG{p}{(}\PYG{n}{qa3}\PYG{p}{)}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{qa4}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n+nb}{bin}\PYG{p}{(}\PYG{n}{qa4}\PYG{p}{)}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{qa5}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n+nb}{bin}\PYG{p}{(}\PYG{n}{qa5}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
qa 255
binary qa 0b11111111
qa1 0b1
qa2 0b10
qa3 0b100
qa4 0b11000
qa5 0b11100000
\end{Verbatim}

We gave an example qa value with \code{1} in all bit fields, and can see
that this information has been passed through above, but we still need
to remove the trailing zeros to the right of the bit field.

We can easily do this with a right shift operator:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{qa1} \PYG{o}{=} \PYG{p}{(}\PYG{n}{qa} \PYG{o}{\PYGZam{}} \PYG{l+m+mi}{0}\PYG{n}{b00000001}\PYG{p}{)} \PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{l+m+mi}{0}    \PYG{c}{\PYGZsh{} bit 0}
\PYG{n}{qa2} \PYG{o}{=} \PYG{p}{(}\PYG{n}{qa} \PYG{o}{\PYGZam{}} \PYG{l+m+mi}{0}\PYG{n}{b00000010}\PYG{p}{)} \PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{l+m+mi}{1}    \PYG{c}{\PYGZsh{} bit 1}
\PYG{n}{qa3} \PYG{o}{=} \PYG{p}{(}\PYG{n}{qa} \PYG{o}{\PYGZam{}} \PYG{l+m+mi}{0}\PYG{n}{b00000100}\PYG{p}{)} \PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{l+m+mi}{2}    \PYG{c}{\PYGZsh{} bit 2}
\PYG{n}{qa4} \PYG{o}{=} \PYG{p}{(}\PYG{n}{qa} \PYG{o}{\PYGZam{}} \PYG{l+m+mi}{0}\PYG{n}{b00011000}\PYG{p}{)} \PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{l+m+mi}{3}    \PYG{c}{\PYGZsh{} bit 3\PYGZhy{}4}
\PYG{n}{qa5} \PYG{o}{=} \PYG{p}{(}\PYG{n}{qa} \PYG{o}{\PYGZam{}} \PYG{l+m+mi}{0}\PYG{n}{b11100000}\PYG{p}{)} \PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{l+m+mi}{5}    \PYG{c}{\PYGZsh{} bit 5\PYGZhy{}7}

\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{qa1}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n+nb}{bin}\PYG{p}{(}\PYG{n}{qa1}\PYG{p}{)}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{qa2}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n+nb}{bin}\PYG{p}{(}\PYG{n}{qa2}\PYG{p}{)}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{qa3}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n+nb}{bin}\PYG{p}{(}\PYG{n}{qa3}\PYG{p}{)}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{qa4}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n+nb}{bin}\PYG{p}{(}\PYG{n}{qa4}\PYG{p}{)}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{qa5}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n+nb}{bin}\PYG{p}{(}\PYG{n}{qa5}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
qa1 0b1
qa2 0b1
qa3 0b1
qa4 0b11
qa5 0b111
\end{Verbatim}

And now we see that we have \emph{just} the information we required.

There are many ways to achieve the same result in filtering such QA
masks, but it is quite easy to make a mistake in doing so, so the
\emph{clearest} way to do this is generally as above:
\begin{itemize}
\item {} 
develop a bit mask with \code{1} in the required fields
\begin{itemize}
\item {} 
e.g. \code{mask4 = 0b00011000    \# bit 3-4}

\item {} 
e.g. \code{mask1 = 0b00000001    \# bit 0}

\end{itemize}

\item {} 
do a bitwise and (\code{\&}) between the data and the bit mask

\item {} 
and right shift the result by the `starting' bit
\begin{itemize}
\item {} 
e.g. \code{(qa \& 0b00011000) \textgreater{}\textgreater{} 3    \# bit 3-4}

\end{itemize}

\end{itemize}

It is always a good idea to test the application of such masks by
setting \code{1} in all fields, as you can easily see if you get the result
you should be expecting.


\section{Exercise A2.3}
\label{Chapter2_Python_intro/advanced:exercise-a2-3}
Develop some code to repeat the QA bit masking done above, but make the
code generate the bit masks itself from knowledge of the first and last
of the bit fields you require (assuming they are sequential).

If possible, do this in a function.

Demonstrate its operation with several example bit masks.


\chapter{A2.2 Exception handling}
\label{Chapter2_Python_intro/advanced:a2-2-exception-handling}
In Python, the mechanism for trapping errors (i.e. when something goes
wrong in running a block of code) is:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{try}\PYG{p}{:}
    \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{k}{except}\PYG{p}{:}
    \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\end{Verbatim}

e.g.:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{k}{print} \PYG{n}{a}\PYG{o}{/}\PYG{n}{b}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
ZeroDivisionError                         Traceback (most recent call last)

\PYGZlt{}ipython\PYGZhy{}input\PYGZhy{}20\PYGZhy{}e0a9b2305aea\PYGZgt{} in \PYGZlt{}module\PYGZgt{}()
      1 a = 1
      2 b = 0
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} 3 print a/b


ZeroDivisionError: integer division or modulo by zero
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{0}

\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+sd}{    What do we want to happen if we try to divide by zero?}
\PYG{l+s+sd}{    In this case, we decide we want to set the result to zero}
\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{k}{try}\PYG{p}{:}
    \PYG{k}{print} \PYG{n}{a}\PYG{o}{/}\PYG{n}{b}
\PYG{k}{except} \PYG{n+ne}{ZeroDivisionError}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+m+mi}{0}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{0}
\end{Verbatim}

Note the indentation in the code. This is what defines the heirarchy of
conditional statements in Python (rather than some explicit `start' and
`end' statements, as in some other languages).

We can trap \emph{explicit} types of error, e.g.:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mf}{100.}
\PYG{k}{del} \PYG{n}{x}

\PYG{k}{try}\PYG{p}{:}
    \PYG{k}{print} \PYG{n}{x}
\PYG{k}{except} \PYG{n+ne}{NameError}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{name }\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{x}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{ is not defined}\PYG{l+s}{\PYGZdq{}}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
name \PYGZsq{}x\PYGZsq{} is not defined
\end{Verbatim}

or we can be non-specific and trap all errors in a code block:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{try}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{2}\PYG{l+s}{\PYGZsq{}} \PYG{o}{+} \PYG{l+m+mi}{2}     \PYG{c}{\PYGZsh{} adding a string to integer doesn\PYGZsq{}t make sense}
\PYG{k}{except}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{you made an error}\PYG{l+s}{\PYGZsq{}}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
you made an error
\end{Verbatim}

You can trap multiple forms of error:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{sys}

\PYG{n}{filename} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/progress.dat}\PYG{l+s}{\PYGZsq{}}

\PYG{k}{try}\PYG{p}{:}
    \PYG{n}{f} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{)}
    \PYG{n}{s} \PYG{o}{=} \PYG{n}{f}\PYG{o}{.}\PYG{n}{readlines}\PYG{p}{(}\PYG{p}{)}
    \PYG{k}{print} \PYG{n}{s}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
    \PYG{k}{print} \PYG{n}{s}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{/}\PYG{l+m+mi}{10}
\PYG{k}{except} \PYG{n+ne}{IOError} \PYG{k}{as} \PYG{n}{e}\PYG{p}{:}
    \PYG{c}{\PYGZsh{} trap a specific IOError}
    \PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{I/O error reading from }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{)}
\PYG{k}{except}\PYG{p}{:}
    \PYG{c}{\PYGZsh{} trap any further errors}
    \PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Error in processing data from file }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZpc{}}\PYG{n}{filename}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
AS I walkd through the wilderness of this world,

Error in processing data from file files/data/progress.dat
\end{Verbatim}

If you want to know more on this subject, you can follow this up with a
more detailed
\href{http://docs.python.org/2/tutorial/errors.html}{tutorial}.


\chapter{A2.3 More complex splitting examples}
\label{Chapter2_Python_intro/advanced:a2-3-more-complex-splitting-examples}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} We can use separators other than whitespace with split:}

\PYG{n}{data} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{1964,1220}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{1974,2470}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{1984,2706}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{1994,4812}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{2004,2707}\PYG{l+s}{\PYGZdq{}}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{data.split(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s}{n}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{):}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{data}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{c}{\PYGZsh{} note \PYGZsq{}\PYGZbs{}\PYGZbs{}n\PYGZsq{} in here as \PYGZsq{}\PYGZbs{}n\PYGZsq{} would have printed a newline}
\PYG{c}{\PYGZsh{} \PYGZbs{} is an escape character (as in unix)}
\end{Verbatim}
\begin{alltt}
data.split(`n'):
    {[}`1964,1220', `1974,2470', `1984,2706', `1994,4812', `2004,2707'{]}
\end{alltt}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} using a generator expressions}

\PYG{n}{fdata1} \PYG{o}{=} \PYG{p}{(}\PYG{n}{i}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{data}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}

\PYG{k}{print} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{fdata1}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{1964,1220}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{1974,2470}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{1984,2706}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{1994,4812}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{2004,2707}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} two listcomps to split first}
\PYG{c}{\PYGZsh{} on \PYGZbs{}n and then each of these on comma}

\PYG{n}{fdata1} \PYG{o}{=} \PYG{p}{[}\PYG{n}{i}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{data}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{]}

\PYG{n}{fdata2} \PYG{o}{=} \PYG{p}{[}\PYG{n}{j}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)} \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n}{fdata1}\PYG{p}{]}

\PYG{k}{print} \PYG{n}{fdata2}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{1964}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{1220}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{1974}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{2470}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{1984}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{2706}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{1994}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{4812}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{2004}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{2707}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{fdata1} \PYG{o}{=} \PYG{p}{[}\PYG{n}{i}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{data}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{]}
\PYG{n}{fdata2} \PYG{o}{=} \PYG{p}{[}\PYG{n}{j}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)} \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n}{fdata1}\PYG{p}{]}
\PYG{n}{fdata} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{l}\PYG{p}{)} \PYG{k}{for} \PYG{n}{l} \PYG{o+ow}{in} \PYG{n}{k}\PYG{p}{]} \PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n}{fdata2}\PYG{p}{]}

\PYG{k}{print} \PYG{n}{fdata}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1964}\PYG{p}{,} \PYG{l+m+mi}{1220}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1974}\PYG{p}{,} \PYG{l+m+mi}{2470}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1984}\PYG{p}{,} \PYG{l+m+mi}{2706}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1994}\PYG{p}{,} \PYG{l+m+mi}{4812}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2004}\PYG{p}{,} \PYG{l+m+mi}{2707}\PYG{p}{]}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} or all at once, which works}
\PYG{c}{\PYGZsh{} but now the meaning of code is too obscure}
\PYG{c}{\PYGZsh{} so this is poor style}

\PYG{n}{fdata} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{l}\PYG{p}{)} \PYG{k}{for} \PYG{n}{l} \PYG{o+ow}{in} \PYG{n}{k}\PYG{p}{]} \PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{p}{[}\PYG{n}{j}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)} \PYGZbs{}
            \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{p}{[}\PYG{n}{i}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{data}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{]}\PYG{p}{]}\PYG{p}{]}

\PYG{k}{print} \PYG{n}{fdata}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1964}\PYG{p}{,} \PYG{l+m+mi}{1220}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1974}\PYG{p}{,} \PYG{l+m+mi}{2470}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1984}\PYG{p}{,} \PYG{l+m+mi}{2706}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1994}\PYG{p}{,} \PYG{l+m+mi}{4812}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2004}\PYG{p}{,} \PYG{l+m+mi}{2707}\PYG{p}{]}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} It might be comprehensible if laid out better}

\PYG{n}{fdata} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{l}\PYG{p}{)} \PYGZbs{}
            \PYG{k}{for} \PYG{n}{l} \PYG{o+ow}{in} \PYG{n}{k}\PYG{p}{]} \PYGZbs{}
                \PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{p}{[}\PYG{n}{j}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)} \PYGZbs{}
                    \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{p}{[}\PYG{n}{i}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)} \PYGZbs{}
                        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{data}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{]}\PYG{p}{]}\PYG{p}{]}

\PYG{c}{\PYGZsh{} even so you might find this confusing}
\PYG{c}{\PYGZsh{} and prefer to do it is smaller chunks}

\PYG{k}{print} \PYG{n}{fdata}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1964}\PYG{p}{,} \PYG{l+m+mi}{1220}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1974}\PYG{p}{,} \PYG{l+m+mi}{2470}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1984}\PYG{p}{,} \PYG{l+m+mi}{2706}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1994}\PYG{p}{,} \PYG{l+m+mi}{4812}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2004}\PYG{p}{,} \PYG{l+m+mi}{2707}\PYG{p}{]}\PYG{p}{]}
\end{Verbatim}


\chapter{A2.4 String formatting}
\label{Chapter2_Python_intro/advanced:a2-4-string-formatting}
You can control spaces, and precision e.g.:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+si}{\PYGZpc{}20s}\PYG{l+s}{ }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{hello}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{world}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+si}{\PYGZpc{}\PYGZhy{}20s}\PYG{l+s}{ }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{hello}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{world}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
               hello world
hello                world
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{pi} \PYG{o}{=} \PYG{l+m+mf}{3.1415926536}
\PYG{k}{for} \PYG{n}{format} \PYG{o+ow}{in} \PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+si}{\PYGZpc{}3.2f}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+si}{\PYGZpc{}3.20f}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+si}{\PYGZpc{}9.5f}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+si}{\PYGZpc{}020.3f}\PYG{l+s}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{:}
    \PYG{k}{print} \PYG{n}{format}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{:}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{format}\PYG{o}{\PYGZpc{}}\PYG{n}{pi}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZpc{}3.2f
    : 3.14
\PYGZpc{}3.20f
    : 3.14159265360000006240
\PYGZpc{}9.5f
    :   3.14159
\PYGZpc{}020.3f
    : 0000000000000003.142
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{pi} \PYG{o}{=} \PYG{l+m+mf}{3.1415926536}
\PYG{k}{for} \PYG{n}{format} \PYG{o+ow}{in} \PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+si}{\PYGZpc{}3.2e}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+si}{\PYGZpc{}3.20e}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+si}{\PYGZpc{}9.5e}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+si}{\PYGZpc{}020.3e}\PYG{l+s}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{:}
    \PYG{k}{print} \PYG{n}{format}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{:}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{format}\PYG{o}{\PYGZpc{}}\PYG{n}{pi}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZpc{}3.2e
    : 3.14e+00
\PYGZpc{}3.20e
    : 3.14159265360000006240e+00
\PYGZpc{}9.5e
    : 3.14159e+00
\PYGZpc{}020.3e
    : 000000000003.142e+00
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{100}
\PYG{k}{for} \PYG{n}{format} \PYG{o+ow}{in} \PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+si}{\PYGZpc{}i}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+si}{\PYGZpc{}3i}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+si}{\PYGZpc{}5i}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+si}{\PYGZpc{}08i}\PYG{l+s}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{:}
    \PYG{k}{print} \PYG{n}{format}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{:}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{format}\PYG{o}{\PYGZpc{}}\PYG{n}{i}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZpc{}i
    : 100
\PYGZpc{}3i
    : 100
\PYGZpc{}5i
    :   100
\PYGZpc{}08i
    : 00000100
\end{Verbatim}

There are other (and in some ways more elegant) ways to \href{http://docs.python.org/2/library/string.html}{format strings
in Python}. e.g:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Hey \PYGZob{}1\PYGZcb{}, Hello \PYGZob{}0\PYGZcb{}}\PYG{l+s}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{world}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{you}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZob{}0\PYGZcb{}\PYGZob{}1\PYGZcb{}\PYGZob{}0\PYGZcb{}}\PYG{l+s}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{abra}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{cad}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{c}{\PYGZsh{} date formatting is a particular example}
\PYG{k+kn}{from} \PYG{n+nn}{datetime} \PYG{k+kn}{import} \PYG{n}{datetime}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s}{At the third stroke, it will be}
\PYG{l+s}{\PYGZob{}:}\PYG{l+s}{\PYGZpc{}}\PYG{l+s}{Y\PYGZhy{}}\PYG{l+s}{\PYGZpc{}}\PYG{l+s}{m\PYGZhy{}}\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{ }\PYG{l+s}{\PYGZpc{}}\PYG{l+s}{H:}\PYG{l+s}{\PYGZpc{}}\PYG{l+s}{M:}\PYG{l+s}{\PYGZpc{}}\PYG{l+s}{S\PYGZcb{}}
\PYG{l+s}{Beep}
\PYG{l+s}{Beep}
\PYG{l+s}{Beep}
\PYG{l+s}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{datetime}\PYG{o}{.}\PYG{n}{now}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{beep}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
Hey you, Hello world
abracadabra

At the third stroke, it will be
2014\PYGZhy{}09\PYGZhy{}30 11:11:37
Beep
Beep
Beep
\end{Verbatim}

There are also additional formatting codes, including:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} character}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{char: }\PYG{l+s+si}{\PYGZpc{}c}\PYG{l+s}{ }\PYG{l+s+si}{\PYGZpc{}c}\PYG{l+s}{ }\PYG{l+s+si}{\PYGZpc{}c}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{,}\PYG{l+m+mi}{101}\PYG{p}{,}\PYG{l+m+mi}{102}\PYG{p}{)}

\PYG{c}{\PYGZsh{} octal}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{octal: }\PYG{l+s+si}{\PYGZpc{}o}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{n}{o755}\PYG{p}{)}

\PYG{c}{\PYGZsh{} hex}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{hex: }\PYG{l+s+si}{\PYGZpc{}X}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{l+m+mh}{0xFFF}\PYG{p}{)}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{hex: }\PYG{l+s+si}{\PYGZpc{}x}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{l+m+mh}{0xFFF}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
char: d e f
octal: 755
hex: FFF
hex: fff
\end{Verbatim}


\chapter{A2.5 File Separator: portability}
\label{Chapter2_Python_intro/advanced:a2-5-file-separator-portability}
We noted earlier that in parsing a filename, you might want to split it
by the file separator:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} example, with directory names}

\PYG{c}{\PYGZsh{} glob unix style pattern matching for files and directories}
\PYG{k+kn}{import} \PYG{n+nn}{glob}

\PYG{c}{\PYGZsh{} returns a list (or [] if empty)}
\PYG{c}{\PYGZsh{} to match the pattern given}
\PYG{n}{file\PYGZus{}list} \PYG{o}{=} \PYG{n}{glob}\PYG{o}{.}\PYG{n}{glob}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{files/data/*.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{file\PYGZus{}list:}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{file\PYGZus{}list}

\PYG{c}{\PYGZsh{} e.g. the first string in the list}
\PYG{n}{this\PYGZus{}file} \PYG{o}{=} \PYG{n}{file\PYGZus{}list}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}

\PYG{c}{\PYGZsh{} split the filename on the field \PYGZsq{}/\PYGZsq{}}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{this\PYGZus{}file.split(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{):}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{this\PYGZus{}file}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{c}{\PYGZsh{} so the filename is just the last element in this list}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{this\PYGZus{}file.split(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{)[\PYGZhy{}1]:}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{this\PYGZus{}file}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
file\PYGZus{}list:
    [\PYGZsq{}files/data/HadSEEP\PYGZus{}monthly\PYGZus{}qc.txt\PYGZsq{}, \PYGZsq{}files/data/heathrowdata.txt\PYGZsq{}, \PYGZsq{}files/data/modis\PYGZus{}files.txt\PYGZsq{}, \PYGZsq{}files/data/modis\PYGZus{}files2a.txt\PYGZsq{}, \PYGZsq{}files/data/modis\PYGZus{}files2b.txt\PYGZsq{}, \PYGZsq{}files/data/some\PYGZus{}modis\PYGZus{}files.txt\PYGZsq{}]

this\PYGZus{}file.split(\PYGZsq{}/\PYGZsq{}):
    [\PYGZsq{}files\PYGZsq{}, \PYGZsq{}data\PYGZsq{}, \PYGZsq{}HadSEEP\PYGZus{}monthly\PYGZus{}qc.txt\PYGZsq{}]

this\PYGZus{}file.split(\PYGZsq{}/\PYGZsq{})[\PYGZhy{}1]:
    HadSEEP\PYGZus{}monthly\PYGZus{}qc.txt
\end{Verbatim}

That's fine if you are on a unix system, but on a windows system, the
file separator is the other way around, so this code is not portable.

To make aspects of your code like this portable, we can use features
from Python that will tend to be in the module \code{os}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{os} \PYG{k+kn}{import} \PYG{n}{sep} \PYG{c}{\PYGZsh{} import the string sep from the module os}

\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{On this system, the file separator is}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{sep}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
On this system, the file separator is /
\end{Verbatim}

So, better code than the above is:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} example, with directory names}

\PYG{c}{\PYGZsh{} glob unix style pattern matching for files and directories}
\PYG{k+kn}{import} \PYG{n+nn}{glob}
\PYG{k+kn}{from} \PYG{n+nn}{os} \PYG{k+kn}{import} \PYG{n}{sep}

\PYG{c}{\PYGZsh{} returns a list (or [] if empty)}
\PYG{c}{\PYGZsh{} to match the pattern given}
\PYG{n}{file\PYGZus{}list} \PYG{o}{=} \PYG{n}{glob}\PYG{o}{.}\PYG{n}{glob}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{files\PYGZob{}0\PYGZcb{}data\PYGZob{}0\PYGZcb{}*.txt}\PYG{l+s}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{sep}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{file\PYGZus{}list:}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{file\PYGZus{}list}

\PYG{c}{\PYGZsh{} e.g. the first string in the list}
\PYG{n}{this\PYGZus{}file} \PYG{o}{=} \PYG{n}{file\PYGZus{}list}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}

\PYG{c}{\PYGZsh{} split the filename on the field \PYGZsq{}/\PYGZsq{} or \PYGZsq{}\PYGZbs{}\PYGZsq{} (sep)}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{this\PYGZus{}file.split(\PYGZob{}0\PYGZcb{}):}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{sep}\PYG{p}{)}\PYG{p}{,}\PYGZbs{}
                            \PYG{n}{this\PYGZus{}file}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{n}{sep}\PYG{p}{)}

\PYG{c}{\PYGZsh{} so the filename is just the last element in this list}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{this\PYGZus{}file.split(\PYGZob{}0\PYGZcb{})[\PYGZhy{}1]:}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{sep}\PYG{p}{)}\PYG{p}{,}\PYGZbs{}
                            \PYG{n}{this\PYGZus{}file}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{n}{sep}\PYG{p}{)}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
file\PYGZus{}list:
    [\PYGZsq{}files/data/HadSEEP\PYGZus{}monthly\PYGZus{}qc.txt\PYGZsq{}, \PYGZsq{}files/data/heathrowdata.txt\PYGZsq{}, \PYGZsq{}files/data/modis\PYGZus{}files.txt\PYGZsq{}, \PYGZsq{}files/data/modis\PYGZus{}files2a.txt\PYGZsq{}, \PYGZsq{}files/data/modis\PYGZus{}files2b.txt\PYGZsq{}, \PYGZsq{}files/data/some\PYGZus{}modis\PYGZus{}files.txt\PYGZsq{}]

this\PYGZus{}file.split(/):
    [\PYGZsq{}files\PYGZsq{}, \PYGZsq{}data\PYGZsq{}, \PYGZsq{}HadSEEP\PYGZus{}monthly\PYGZus{}qc.txt\PYGZsq{}]

this\PYGZus{}file.split(/)[\PYGZhy{}1]:
    HadSEEP\PYGZus{}monthly\PYGZus{}qc.txt
\end{Verbatim}

There will always be a compromise between portability and readability of
the code, so try to make sure that any portability modifications you
make don't obscure the meaniong of the code.


\chapter{A2.7 Installing your own packages}
\label{Chapter2_Python_intro/advanced:a2-7-installing-your-own-packages}
Most of what you will want (especially to begin with) will be contained
in your current Python distribution.

Sometimes though, you might need to install some new module.

Generally, the easiest way to do this is to use \code{easy\_install}.

We will use this to install a package \code{pyephem} into your user area:

at a unix prompt, type:

\code{easy\_install -{-}user pyephem}

If all goes well, the text that comes up at the terminal should tell you
that this has installed (e.g. in
\code{/home/plewis/.local/lib/python2.7/site-packages/pyephem-3.7.5.1-py2.7-linux-x86\_64.egg}).

We can test to see if we can load this package:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{ephem}
\end{Verbatim}

and then do some interesting things with it.

The following piece of code might seem a little complicated right now,
but it just uses

We will need to \code{import} some other things from a few other packages
as well:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{ephem} \PYG{k+kn}{import} \PYG{n}{Sun}\PYG{p}{,} \PYG{n}{Observer}
\PYG{k+kn}{from} \PYG{n+nn}{math} \PYG{k+kn}{import} \PYG{n}{pi}
\PYG{k+kn}{from} \PYG{n+nn}{datetime} \PYG{k+kn}{import} \PYG{n}{date}\PYG{p}{,}\PYG{n}{datetime}\PYG{p}{,}\PYG{n}{time}

\PYG{c}{\PYGZsh{} radians to degrees}
\PYG{n}{rtod} \PYG{o}{=} \PYG{l+m+mf}{180.}\PYG{o}{/}\PYG{n}{pi}

\PYG{c}{\PYGZsh{} observer information in pyephem}
\PYG{n}{obs} \PYG{o}{=} \PYG{n}{Observer}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{today} \PYG{o}{=} \PYG{n}{date}\PYG{o}{.}\PYG{n}{today}\PYG{p}{(}\PYG{p}{)}
\PYG{c}{\PYGZsh{} or datetime.date(2013, 3, 12)}

\PYG{c}{\PYGZsh{} put in lat / lon for UCL}
\PYG{c}{\PYGZsh{} https://www.google.co.uk/search?q=ucl+longitude+latitude}
\PYG{n}{obs}\PYG{o}{.}\PYG{n}{lat}  \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{51.5248}\PYG{l+s}{\PYGZsq{}}
\PYG{n}{obs}\PYG{o}{.}\PYG{n}{long} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZhy{}0.1336}\PYG{l+s}{\PYGZsq{}}

\PYG{k}{for} \PYG{n}{hour} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{24}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{for} \PYG{n}{minute} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{60}\PYG{p}{,}\PYG{l+m+mi}{30}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{t} \PYG{o}{=} \PYG{n}{time}\PYG{p}{(}\PYG{n}{hour}\PYG{p}{,} \PYG{n}{minute}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{n}{obs}\PYG{o}{.}\PYG{n}{date} \PYG{o}{=} \PYG{n}{datetime}\PYG{o}{.}\PYG{n}{combine}\PYG{p}{(}\PYG{n}{today}\PYG{p}{,} \PYG{n}{t}\PYG{p}{)}
        \PYG{n}{sun} \PYG{o}{=} \PYG{n}{Sun}\PYG{p}{(}\PYG{n}{obs}\PYG{p}{)}
        \PYG{n}{zenith\PYGZus{}elevation} \PYG{o}{=} \PYG{n+nb}{float}\PYG{p}{(}\PYG{n}{sun}\PYG{o}{.}\PYG{n}{alt}\PYG{p}{)}\PYG{o}{*}\PYG{n}{rtod} \PYG{c}{\PYGZsh{} degrees}

        \PYG{k}{print} \PYG{n}{obs}\PYG{o}{.}\PYG{n}{date}\PYG{p}{,}\PYG{n}{zenith\PYGZus{}elevation}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
2014/9/30 00:00:00 \PYGZhy{}41.1227180114
2014/9/30 00:30:00 \PYGZhy{}40.4796625312
2014/9/30 00:59:59 \PYGZhy{}39.0649015428
2014/9/30 01:30:00 \PYGZhy{}36.9463783528
2014/9/30 02:00:00 \PYGZhy{}34.2136162508
2014/9/30 02:30:00 \PYGZhy{}30.9643006022
2014/9/30 03:00:00 \PYGZhy{}27.2941667536
2014/9/30 03:30:00 \PYGZhy{}23.2912319377
2014/9/30 03:59:59 \PYGZhy{}19.0337171884
2014/9/30 04:30:00 \PYGZhy{}14.5903017653
2014/9/30 05:00:00 \PYGZhy{}10.0216590927
2014/9/30 05:30:00 \PYGZhy{}5.01932715546
2014/9/30 06:00:00 \PYGZhy{}0.134849371939
2014/9/30 06:30:00 4.09286322097
2014/9/30 06:59:59 8.55453445901
2014/9/30 07:30:00 12.938958392
2014/9/30 08:00:00 17.1514399965
2014/9/30 08:30:00 21.1181133381
2014/9/30 09:00:00 24.7672136192
2014/9/30 09:30:00 28.020436136
2014/9/30 09:59:59 30.7949255712
2014/9/30 10:30:00 33.0070257679
2014/9/30 11:00:00 34.579161145
2014/9/30 11:30:00 35.4491052641
2014/9/30 12:00:00 35.5794764999
2014/9/30 12:30:00 34.9643838142
2014/9/30 12:59:59 33.6305127561
2014/9/30 13:30:00 31.6322282163
2014/9/30 14:00:00 29.0427156717
2014/9/30 14:30:00 25.9443096378
2014/9/30 15:00:00 22.4206252902
2014/9/30 15:30:00 18.5516782953
2014/9/30 15:59:59 14.4111578562
2014/9/30 16:30:00 10.0714597095
2014/9/30 17:00:00 5.61372180666
2014/9/30 17:30:00 1.2203105187
2014/9/30 18:00:00 \PYGZhy{}2.38322183516
2014/9/30 18:30:00 \PYGZhy{}8.47981048194
2014/9/30 18:59:59 \PYGZhy{}13.0951972617
2014/9/30 19:30:00 \PYGZhy{}17.6077341991
2014/9/30 20:00:00 \PYGZhy{}21.9594218892
2014/9/30 20:30:00 \PYGZhy{}26.0849005441
2014/9/30 21:00:00 \PYGZhy{}29.9096032812
2014/9/30 21:30:00 \PYGZhy{}33.3488186792
2014/9/30 21:59:59 \PYGZhy{}36.3086640806
2014/9/30 22:30:00 \PYGZhy{}38.6902793272
2014/9/30 23:00:00 \PYGZhy{}40.3983491291
2014/9/30 23:30:00 \PYGZhy{}41.3537969714
\end{Verbatim}

Let's write this out to a file now:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{ephem} \PYG{k+kn}{import} \PYG{n}{Sun}\PYG{p}{,} \PYG{n}{Observer}
\PYG{k+kn}{from} \PYG{n+nn}{math} \PYG{k+kn}{import} \PYG{n}{pi}
\PYG{k+kn}{from} \PYG{n+nn}{datetime} \PYG{k+kn}{import} \PYG{n}{date}\PYG{p}{,}\PYG{n}{datetime}\PYG{p}{,}\PYG{n}{time}

\PYG{n}{filename} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/elevation.dat}\PYG{l+s}{\PYGZsq{}}
\PYG{k}{try}\PYG{p}{:}
    \PYG{n}{fp} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{w}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{except}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Failed to open file }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{ for writing}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZpc{}}\PYG{n}{filename}

\PYG{c}{\PYGZsh{} radians to degrees}
\PYG{n}{rtod} \PYG{o}{=} \PYG{l+m+mf}{180.}\PYG{o}{/}\PYG{n}{pi}

\PYG{c}{\PYGZsh{} observer information in pyephem}
\PYG{n}{obs} \PYG{o}{=} \PYG{n}{Observer}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{today} \PYG{o}{=} \PYG{n}{date}\PYG{o}{.}\PYG{n}{today}\PYG{p}{(}\PYG{p}{)}
\PYG{c}{\PYGZsh{} or datetime.date(2013, 3, 12)}

\PYG{c}{\PYGZsh{} put in lat / lon for UCL}
\PYG{c}{\PYGZsh{} https://www.google.co.uk/search?q=ucl+longitude+latitude}
\PYG{n}{obs}\PYG{o}{.}\PYG{n}{lat}  \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{51.5248}\PYG{l+s}{\PYGZsq{}}
\PYG{n}{obs}\PYG{o}{.}\PYG{n}{long} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZhy{}0.1336}\PYG{l+s}{\PYGZsq{}}

\PYG{k}{for} \PYG{n}{hour} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{24}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{for} \PYG{n}{minute} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{60}\PYG{p}{,}\PYG{l+m+mi}{30}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{t} \PYG{o}{=} \PYG{n}{time}\PYG{p}{(}\PYG{n}{hour}\PYG{p}{,} \PYG{n}{minute}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{n}{obs}\PYG{o}{.}\PYG{n}{date} \PYG{o}{=} \PYG{n}{datetime}\PYG{o}{.}\PYG{n}{combine}\PYG{p}{(}\PYG{n}{today}\PYG{p}{,} \PYG{n}{t}\PYG{p}{)}
        \PYG{n}{sun} \PYG{o}{=} \PYG{n}{Sun}\PYG{p}{(}\PYG{n}{obs}\PYG{p}{)}
        \PYG{n}{elevation} \PYG{o}{=} \PYG{n+nb}{float}\PYG{p}{(}\PYG{n}{sun}\PYG{o}{.}\PYG{n}{alt}\PYG{p}{)}\PYG{o}{*}\PYG{n}{rtod} \PYG{c}{\PYGZsh{} degrees}
        \PYG{n}{fp}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{ }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{obs}\PYG{o}{.}\PYG{n}{date}\PYG{p}{,}\PYG{n}{elevation}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{fp}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} just for interest, let\PYGZsq{}s plot this:}

\PYG{k+kn}{import} \PYG{n+nn}{pylab} \PYG{k+kn}{as} \PYG{n+nn}{plt}

\PYG{n}{filename} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/elevation.dat}\PYG{l+s}{\PYGZsq{}}
\PYG{n}{fp} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{r}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}

\PYG{n}{hours} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{zeniths} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}

\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{fp}\PYG{o}{.}\PYG{n}{readlines}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{data} \PYG{o}{=} \PYG{n}{i}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{time} \PYG{o}{=} \PYG{p}{[}\PYG{n+nb}{float}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{:}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{]}
    \PYG{n}{hour} \PYG{o}{=} \PYG{n}{time}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{+} \PYG{n}{time}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{/}\PYG{l+m+mf}{60.} \PYG{o}{+} \PYG{n}{time}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mf}{60.}\PYG{o}{*}\PYG{l+m+mi}{60}\PYG{p}{)}
    \PYG{n}{zenith} \PYG{o}{=} \PYG{l+m+mf}{90.} \PYG{o}{\PYGZhy{}} \PYG{n+nb}{float}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
    \PYG{k}{if} \PYG{n}{zenith} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mf}{90.}\PYG{p}{:}
        \PYG{n}{hours}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{hour}\PYG{p}{)}
        \PYG{n}{zeniths}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{zenith}\PYG{p}{)}
\PYG{n}{fp}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}

\PYG{c}{\PYGZsh{} plotting}
\PYG{n}{fig} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{14}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{hours}\PYG{p}{,}\PYG{n}{zeniths}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{hour}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{solar zenith / degrees}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.text.Text at 0x106574710\PYGZgt{}
\end{Verbatim}

\includegraphics{advanced_88_1.png}


\chapter{A2.8 Reading Files from a URL}
\label{Chapter2_Python_intro/advanced:a2-8-reading-files-from-a-url}
In the main exercises, you have been advised to download a file and read
it using the normal file \code{open} commands.

If a file is available as a
\href{http://en.wikipedia.org/wiki/Uniform\_resource\_locator}{URL}, you can
conveniently use the \code{urllib2} module in Python to access the file
directly.

So, in the case of the precipitation data in an earlier exercise, we
could hhave directly read the data with:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{urllib2}

\PYG{c}{\PYGZsh{}as files}
\PYG{n}{url} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{http://www.metoffice.gov.uk/hadobs/hadukp/data/monthly/HadSEEP\PYGZus{}monthly\PYGZus{}qc.txt}\PYG{l+s}{\PYGZdq{}}

\PYG{n}{req} \PYG{o}{=} \PYG{n}{urllib2}\PYG{o}{.}\PYG{n}{Request} \PYG{p}{(} \PYG{n}{url} \PYG{p}{)}
\PYG{n}{raw\PYGZus{}data} \PYG{o}{=} \PYG{n}{urllib2}\PYG{o}{.}\PYG{n}{urlopen}\PYG{p}{(}\PYG{n}{req}\PYG{p}{)}\PYG{o}{.}\PYG{n}{readlines}\PYG{p}{(}\PYG{p}{)}

\PYG{k}{print} \PYG{n}{raw\PYGZus{}data}\PYG{p}{[}\PYG{p}{:}\PYG{l+m+mi}{6}\PYG{p}{]}
\end{Verbatim}
\begin{alltt}
{[}'Monthly Southeast England precipitation (mm). Daily automated values used after 1996.n', `Wigley \& Jones (J.Climatol.,1987), Gregory et al. (Int.J.Clim.,1991)n', `Jones \& Conway (Int.J.Climatol.,1997), Alexander \& Jones (ASL,2001). Values may change after QC.n', `YEAR   JAN   FEB   MAR   APR   MAY   JUN   JUL   AUG   SEP   OCT   NOV   DEC   ANNn', ` 1873  87.1  50.4  52.9  19.9  41.1  63.6  53.2  56.4  62.0  86.0  59.4  15.7  647.7n', ` 1874  46.8  44.9  15.8  48.4  24.1  49.9  28.3  43.6  79.4  96.1  63.9  52.3  593.5n'{]}
\end{alltt}


\chapter{A2.9 Advanced dictionaries}
\label{Chapter2_Python_intro/advanced:a2-9-advanced-dictionaries}
They are particularly useful when you want to build clear data
structures, e.g. in loading a dataset such as
\code{{}`files/data/HadSEEP\_monthly\_qc.txt} \textless{}files/data/HadSEEP\_monthly\_qc.txt\textgreater{}{}`\_\_.

First, let's read the data from this file into the lists \code{label} and
\code{rdata}, where \code{rdata{[}0{]}} will be the first column in the file,
\code{rdata{[}1{]}} the second column etc.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{fp} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/HadSEEP\PYGZus{}monthly\PYGZus{}qc.txt}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{sdata} \PYG{o}{=} \PYG{n}{fp}\PYG{o}{.}\PYG{n}{readlines}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{fp}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{labels} \PYG{o}{=} \PYG{n}{sdata}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{data} \PYG{o}{=} \PYG{p}{[}\PYG{n}{i}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{sdata}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{:}\PYG{p}{]}\PYG{p}{]}
\PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{rdata} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{n+nb}{float}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{)} \PYGZbs{}
         \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}\PYG{p}{)}\PYG{p}{]}\PYGZbs{}
         \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{]}

\PYG{k}{print} \PYG{n}{rdata}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{l+m+mf}{1873.0}\PYG{p}{,} \PYG{l+m+mf}{1874.0}\PYG{p}{,} \PYG{l+m+mf}{1875.0}\PYG{p}{,} \PYG{l+m+mf}{1876.0}\PYG{p}{,} \PYG{l+m+mf}{1877.0}\PYG{p}{,} \PYG{l+m+mf}{1878.0}\PYG{p}{,} \PYG{l+m+mf}{1879.0}\PYG{p}{,} \PYG{l+m+mf}{1880.0}\PYG{p}{,} \PYG{l+m+mf}{1881.0}\PYG{p}{,} \PYG{l+m+mf}{1882.0}\PYG{p}{,} \PYG{l+m+mf}{1883.0}\PYG{p}{,} \PYG{l+m+mf}{1884.0}\PYG{p}{,} \PYG{l+m+mf}{1885.0}\PYG{p}{,} \PYG{l+m+mf}{1886.0}\PYG{p}{,} \PYG{l+m+mf}{1887.0}\PYG{p}{,} \PYG{l+m+mf}{1888.0}\PYG{p}{,} \PYG{l+m+mf}{1889.0}\PYG{p}{,} \PYG{l+m+mf}{1890.0}\PYG{p}{,} \PYG{l+m+mf}{1891.0}\PYG{p}{,} \PYG{l+m+mf}{1892.0}\PYG{p}{,} \PYG{l+m+mf}{1893.0}\PYG{p}{,} \PYG{l+m+mf}{1894.0}\PYG{p}{,} \PYG{l+m+mf}{1895.0}\PYG{p}{,} \PYG{l+m+mf}{1896.0}\PYG{p}{,} \PYG{l+m+mf}{1897.0}\PYG{p}{,} \PYG{l+m+mf}{1898.0}\PYG{p}{,} \PYG{l+m+mf}{1899.0}\PYG{p}{,} \PYG{l+m+mf}{1900.0}\PYG{p}{,} \PYG{l+m+mf}{1901.0}\PYG{p}{,} \PYG{l+m+mf}{1902.0}\PYG{p}{,} \PYG{l+m+mf}{1903.0}\PYG{p}{,} \PYG{l+m+mf}{1904.0}\PYG{p}{,} \PYG{l+m+mf}{1905.0}\PYG{p}{,} \PYG{l+m+mf}{1906.0}\PYG{p}{,} \PYG{l+m+mf}{1907.0}\PYG{p}{,} \PYG{l+m+mf}{1908.0}\PYG{p}{,} \PYG{l+m+mf}{1909.0}\PYG{p}{,} \PYG{l+m+mf}{1910.0}\PYG{p}{,} \PYG{l+m+mf}{1911.0}\PYG{p}{,} \PYG{l+m+mf}{1912.0}\PYG{p}{,} \PYG{l+m+mf}{1913.0}\PYG{p}{,} \PYG{l+m+mf}{1914.0}\PYG{p}{,} \PYG{l+m+mf}{1915.0}\PYG{p}{,} \PYG{l+m+mf}{1916.0}\PYG{p}{,} \PYG{l+m+mf}{1917.0}\PYG{p}{,} \PYG{l+m+mf}{1918.0}\PYG{p}{,} \PYG{l+m+mf}{1919.0}\PYG{p}{,} \PYG{l+m+mf}{1920.0}\PYG{p}{,} \PYG{l+m+mf}{1921.0}\PYG{p}{,} \PYG{l+m+mf}{1922.0}\PYG{p}{,} \PYG{l+m+mf}{1923.0}\PYG{p}{,} \PYG{l+m+mf}{1924.0}\PYG{p}{,} \PYG{l+m+mf}{1925.0}\PYG{p}{,} \PYG{l+m+mf}{1926.0}\PYG{p}{,} \PYG{l+m+mf}{1927.0}\PYG{p}{,} \PYG{l+m+mf}{1928.0}\PYG{p}{,} \PYG{l+m+mf}{1929.0}\PYG{p}{,} \PYG{l+m+mf}{1930.0}\PYG{p}{,} \PYG{l+m+mf}{1931.0}\PYG{p}{,} \PYG{l+m+mf}{1932.0}\PYG{p}{,} \PYG{l+m+mf}{1933.0}\PYG{p}{,} \PYG{l+m+mf}{1934.0}\PYG{p}{,} \PYG{l+m+mf}{1935.0}\PYG{p}{,} \PYG{l+m+mf}{1936.0}\PYG{p}{,} \PYG{l+m+mf}{1937.0}\PYG{p}{,} \PYG{l+m+mf}{1938.0}\PYG{p}{,} \PYG{l+m+mf}{1939.0}\PYG{p}{,} \PYG{l+m+mf}{1940.0}\PYG{p}{,} \PYG{l+m+mf}{1941.0}\PYG{p}{,} \PYG{l+m+mf}{1942.0}\PYG{p}{,} \PYG{l+m+mf}{1943.0}\PYG{p}{,} \PYG{l+m+mf}{1944.0}\PYG{p}{,} \PYG{l+m+mf}{1945.0}\PYG{p}{,} \PYG{l+m+mf}{1946.0}\PYG{p}{,} \PYG{l+m+mf}{1947.0}\PYG{p}{,} \PYG{l+m+mf}{1948.0}\PYG{p}{,} \PYG{l+m+mf}{1949.0}\PYG{p}{,} \PYG{l+m+mf}{1950.0}\PYG{p}{,} \PYG{l+m+mf}{1951.0}\PYG{p}{,} \PYG{l+m+mf}{1952.0}\PYG{p}{,} \PYG{l+m+mf}{1953.0}\PYG{p}{,} \PYG{l+m+mf}{1954.0}\PYG{p}{,} \PYG{l+m+mf}{1955.0}\PYG{p}{,} \PYG{l+m+mf}{1956.0}\PYG{p}{,} \PYG{l+m+mf}{1957.0}\PYG{p}{,} \PYG{l+m+mf}{1958.0}\PYG{p}{,} \PYG{l+m+mf}{1959.0}\PYG{p}{,} \PYG{l+m+mf}{1960.0}\PYG{p}{,} \PYG{l+m+mf}{1961.0}\PYG{p}{,} \PYG{l+m+mf}{1962.0}\PYG{p}{,} \PYG{l+m+mf}{1963.0}\PYG{p}{,} \PYG{l+m+mf}{1964.0}\PYG{p}{,} \PYG{l+m+mf}{1965.0}\PYG{p}{,} \PYG{l+m+mf}{1966.0}\PYG{p}{,} \PYG{l+m+mf}{1967.0}\PYG{p}{,} \PYG{l+m+mf}{1968.0}\PYG{p}{,} \PYG{l+m+mf}{1969.0}\PYG{p}{,} \PYG{l+m+mf}{1970.0}\PYG{p}{,} \PYG{l+m+mf}{1971.0}\PYG{p}{,} \PYG{l+m+mf}{1972.0}\PYG{p}{,} \PYG{l+m+mf}{1973.0}\PYG{p}{,} \PYG{l+m+mf}{1974.0}\PYG{p}{,} \PYG{l+m+mf}{1975.0}\PYG{p}{,} \PYG{l+m+mf}{1976.0}\PYG{p}{,} \PYG{l+m+mf}{1977.0}\PYG{p}{,} \PYG{l+m+mf}{1978.0}\PYG{p}{,} \PYG{l+m+mf}{1979.0}\PYG{p}{,} \PYG{l+m+mf}{1980.0}\PYG{p}{,} \PYG{l+m+mf}{1981.0}\PYG{p}{,} \PYG{l+m+mf}{1982.0}\PYG{p}{,} \PYG{l+m+mf}{1983.0}\PYG{p}{,} \PYG{l+m+mf}{1984.0}\PYG{p}{,} \PYG{l+m+mf}{1985.0}\PYG{p}{,} \PYG{l+m+mf}{1986.0}\PYG{p}{,} \PYG{l+m+mf}{1987.0}\PYG{p}{,} \PYG{l+m+mf}{1988.0}\PYG{p}{,} \PYG{l+m+mf}{1989.0}\PYG{p}{,} \PYG{l+m+mf}{1990.0}\PYG{p}{,} \PYG{l+m+mf}{1991.0}\PYG{p}{,} \PYG{l+m+mf}{1992.0}\PYG{p}{,} \PYG{l+m+mf}{1993.0}\PYG{p}{,} \PYG{l+m+mf}{1994.0}\PYG{p}{,} \PYG{l+m+mf}{1995.0}\PYG{p}{,} \PYG{l+m+mf}{1996.0}\PYG{p}{,} \PYG{l+m+mf}{1997.0}\PYG{p}{,} \PYG{l+m+mf}{1998.0}\PYG{p}{,} \PYG{l+m+mf}{1999.0}\PYG{p}{,} \PYG{l+m+mf}{2000.0}\PYG{p}{,} \PYG{l+m+mf}{2001.0}\PYG{p}{,} \PYG{l+m+mf}{2002.0}\PYG{p}{,} \PYG{l+m+mf}{2003.0}\PYG{p}{,} \PYG{l+m+mf}{2004.0}\PYG{p}{,} \PYG{l+m+mf}{2005.0}\PYG{p}{,} \PYG{l+m+mf}{2006.0}\PYG{p}{,} \PYG{l+m+mf}{2007.0}\PYG{p}{,} \PYG{l+m+mf}{2008.0}\PYG{p}{,} \PYG{l+m+mf}{2009.0}\PYG{p}{,} \PYG{l+m+mf}{2010.0}\PYG{p}{,} \PYG{l+m+mf}{2011.0}\PYG{p}{,} \PYG{l+m+mf}{2012.0}\PYG{p}{,} \PYG{l+m+mf}{2013.0}\PYG{p}{]}
\end{Verbatim}

We can of course just remember that the first column is `year', the
second column data for `JAN' etc., but we would have a much better
organised dataset if we put it in a dictionary.

One way to do this would be:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} set up a}
\PYG{n}{dataset} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{k}{for} \PYG{n}{i}\PYG{p}{,}\PYG{n}{k} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{labels}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{dataset}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]} \PYG{o}{=} \PYG{n}{rdata}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
\end{Verbatim}

and we could now refer to the `year' data as:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{n}{dataset}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{YEAR}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{l+m+mf}{1873.0}\PYG{p}{,} \PYG{l+m+mf}{1874.0}\PYG{p}{,} \PYG{l+m+mf}{1875.0}\PYG{p}{,} \PYG{l+m+mf}{1876.0}\PYG{p}{,} \PYG{l+m+mf}{1877.0}\PYG{p}{,} \PYG{l+m+mf}{1878.0}\PYG{p}{,} \PYG{l+m+mf}{1879.0}\PYG{p}{,} \PYG{l+m+mf}{1880.0}\PYG{p}{,} \PYG{l+m+mf}{1881.0}\PYG{p}{,} \PYG{l+m+mf}{1882.0}\PYG{p}{,} \PYG{l+m+mf}{1883.0}\PYG{p}{,} \PYG{l+m+mf}{1884.0}\PYG{p}{,} \PYG{l+m+mf}{1885.0}\PYG{p}{,} \PYG{l+m+mf}{1886.0}\PYG{p}{,} \PYG{l+m+mf}{1887.0}\PYG{p}{,} \PYG{l+m+mf}{1888.0}\PYG{p}{,} \PYG{l+m+mf}{1889.0}\PYG{p}{,} \PYG{l+m+mf}{1890.0}\PYG{p}{,} \PYG{l+m+mf}{1891.0}\PYG{p}{,} \PYG{l+m+mf}{1892.0}\PYG{p}{,} \PYG{l+m+mf}{1893.0}\PYG{p}{,} \PYG{l+m+mf}{1894.0}\PYG{p}{,} \PYG{l+m+mf}{1895.0}\PYG{p}{,} \PYG{l+m+mf}{1896.0}\PYG{p}{,} \PYG{l+m+mf}{1897.0}\PYG{p}{,} \PYG{l+m+mf}{1898.0}\PYG{p}{,} \PYG{l+m+mf}{1899.0}\PYG{p}{,} \PYG{l+m+mf}{1900.0}\PYG{p}{,} \PYG{l+m+mf}{1901.0}\PYG{p}{,} \PYG{l+m+mf}{1902.0}\PYG{p}{,} \PYG{l+m+mf}{1903.0}\PYG{p}{,} \PYG{l+m+mf}{1904.0}\PYG{p}{,} \PYG{l+m+mf}{1905.0}\PYG{p}{,} \PYG{l+m+mf}{1906.0}\PYG{p}{,} \PYG{l+m+mf}{1907.0}\PYG{p}{,} \PYG{l+m+mf}{1908.0}\PYG{p}{,} \PYG{l+m+mf}{1909.0}\PYG{p}{,} \PYG{l+m+mf}{1910.0}\PYG{p}{,} \PYG{l+m+mf}{1911.0}\PYG{p}{,} \PYG{l+m+mf}{1912.0}\PYG{p}{,} \PYG{l+m+mf}{1913.0}\PYG{p}{,} \PYG{l+m+mf}{1914.0}\PYG{p}{,} \PYG{l+m+mf}{1915.0}\PYG{p}{,} \PYG{l+m+mf}{1916.0}\PYG{p}{,} \PYG{l+m+mf}{1917.0}\PYG{p}{,} \PYG{l+m+mf}{1918.0}\PYG{p}{,} \PYG{l+m+mf}{1919.0}\PYG{p}{,} \PYG{l+m+mf}{1920.0}\PYG{p}{,} \PYG{l+m+mf}{1921.0}\PYG{p}{,} \PYG{l+m+mf}{1922.0}\PYG{p}{,} \PYG{l+m+mf}{1923.0}\PYG{p}{,} \PYG{l+m+mf}{1924.0}\PYG{p}{,} \PYG{l+m+mf}{1925.0}\PYG{p}{,} \PYG{l+m+mf}{1926.0}\PYG{p}{,} \PYG{l+m+mf}{1927.0}\PYG{p}{,} \PYG{l+m+mf}{1928.0}\PYG{p}{,} \PYG{l+m+mf}{1929.0}\PYG{p}{,} \PYG{l+m+mf}{1930.0}\PYG{p}{,} \PYG{l+m+mf}{1931.0}\PYG{p}{,} \PYG{l+m+mf}{1932.0}\PYG{p}{,} \PYG{l+m+mf}{1933.0}\PYG{p}{,} \PYG{l+m+mf}{1934.0}\PYG{p}{,} \PYG{l+m+mf}{1935.0}\PYG{p}{,} \PYG{l+m+mf}{1936.0}\PYG{p}{,} \PYG{l+m+mf}{1937.0}\PYG{p}{,} \PYG{l+m+mf}{1938.0}\PYG{p}{,} \PYG{l+m+mf}{1939.0}\PYG{p}{,} \PYG{l+m+mf}{1940.0}\PYG{p}{,} \PYG{l+m+mf}{1941.0}\PYG{p}{,} \PYG{l+m+mf}{1942.0}\PYG{p}{,} \PYG{l+m+mf}{1943.0}\PYG{p}{,} \PYG{l+m+mf}{1944.0}\PYG{p}{,} \PYG{l+m+mf}{1945.0}\PYG{p}{,} \PYG{l+m+mf}{1946.0}\PYG{p}{,} \PYG{l+m+mf}{1947.0}\PYG{p}{,} \PYG{l+m+mf}{1948.0}\PYG{p}{,} \PYG{l+m+mf}{1949.0}\PYG{p}{,} \PYG{l+m+mf}{1950.0}\PYG{p}{,} \PYG{l+m+mf}{1951.0}\PYG{p}{,} \PYG{l+m+mf}{1952.0}\PYG{p}{,} \PYG{l+m+mf}{1953.0}\PYG{p}{,} \PYG{l+m+mf}{1954.0}\PYG{p}{,} \PYG{l+m+mf}{1955.0}\PYG{p}{,} \PYG{l+m+mf}{1956.0}\PYG{p}{,} \PYG{l+m+mf}{1957.0}\PYG{p}{,} \PYG{l+m+mf}{1958.0}\PYG{p}{,} \PYG{l+m+mf}{1959.0}\PYG{p}{,} \PYG{l+m+mf}{1960.0}\PYG{p}{,} \PYG{l+m+mf}{1961.0}\PYG{p}{,} \PYG{l+m+mf}{1962.0}\PYG{p}{,} \PYG{l+m+mf}{1963.0}\PYG{p}{,} \PYG{l+m+mf}{1964.0}\PYG{p}{,} \PYG{l+m+mf}{1965.0}\PYG{p}{,} \PYG{l+m+mf}{1966.0}\PYG{p}{,} \PYG{l+m+mf}{1967.0}\PYG{p}{,} \PYG{l+m+mf}{1968.0}\PYG{p}{,} \PYG{l+m+mf}{1969.0}\PYG{p}{,} \PYG{l+m+mf}{1970.0}\PYG{p}{,} \PYG{l+m+mf}{1971.0}\PYG{p}{,} \PYG{l+m+mf}{1972.0}\PYG{p}{,} \PYG{l+m+mf}{1973.0}\PYG{p}{,} \PYG{l+m+mf}{1974.0}\PYG{p}{,} \PYG{l+m+mf}{1975.0}\PYG{p}{,} \PYG{l+m+mf}{1976.0}\PYG{p}{,} \PYG{l+m+mf}{1977.0}\PYG{p}{,} \PYG{l+m+mf}{1978.0}\PYG{p}{,} \PYG{l+m+mf}{1979.0}\PYG{p}{,} \PYG{l+m+mf}{1980.0}\PYG{p}{,} \PYG{l+m+mf}{1981.0}\PYG{p}{,} \PYG{l+m+mf}{1982.0}\PYG{p}{,} \PYG{l+m+mf}{1983.0}\PYG{p}{,} \PYG{l+m+mf}{1984.0}\PYG{p}{,} \PYG{l+m+mf}{1985.0}\PYG{p}{,} \PYG{l+m+mf}{1986.0}\PYG{p}{,} \PYG{l+m+mf}{1987.0}\PYG{p}{,} \PYG{l+m+mf}{1988.0}\PYG{p}{,} \PYG{l+m+mf}{1989.0}\PYG{p}{,} \PYG{l+m+mf}{1990.0}\PYG{p}{,} \PYG{l+m+mf}{1991.0}\PYG{p}{,} \PYG{l+m+mf}{1992.0}\PYG{p}{,} \PYG{l+m+mf}{1993.0}\PYG{p}{,} \PYG{l+m+mf}{1994.0}\PYG{p}{,} \PYG{l+m+mf}{1995.0}\PYG{p}{,} \PYG{l+m+mf}{1996.0}\PYG{p}{,} \PYG{l+m+mf}{1997.0}\PYG{p}{,} \PYG{l+m+mf}{1998.0}\PYG{p}{,} \PYG{l+m+mf}{1999.0}\PYG{p}{,} \PYG{l+m+mf}{2000.0}\PYG{p}{,} \PYG{l+m+mf}{2001.0}\PYG{p}{,} \PYG{l+m+mf}{2002.0}\PYG{p}{,} \PYG{l+m+mf}{2003.0}\PYG{p}{,} \PYG{l+m+mf}{2004.0}\PYG{p}{,} \PYG{l+m+mf}{2005.0}\PYG{p}{,} \PYG{l+m+mf}{2006.0}\PYG{p}{,} \PYG{l+m+mf}{2007.0}\PYG{p}{,} \PYG{l+m+mf}{2008.0}\PYG{p}{,} \PYG{l+m+mf}{2009.0}\PYG{p}{,} \PYG{l+m+mf}{2010.0}\PYG{p}{,} \PYG{l+m+mf}{2011.0}\PYG{p}{,} \PYG{l+m+mf}{2012.0}\PYG{p}{,} \PYG{l+m+mf}{2013.0}\PYG{p}{]}
\end{Verbatim}

A simper and more Pythonic way is to use \code{zip}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{dataset} \PYG{o}{=} \PYG{n+nb}{dict}\PYG{p}{(}\PYG{n+nb}{zip}\PYG{p}{(}\PYG{n}{labels}\PYG{p}{,}\PYG{n}{rdata}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{n}{dataset}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{YEAR}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{l+m+mf}{1873.0}\PYG{p}{,} \PYG{l+m+mf}{1874.0}\PYG{p}{,} \PYG{l+m+mf}{1875.0}\PYG{p}{,} \PYG{l+m+mf}{1876.0}\PYG{p}{,} \PYG{l+m+mf}{1877.0}\PYG{p}{,} \PYG{l+m+mf}{1878.0}\PYG{p}{,} \PYG{l+m+mf}{1879.0}\PYG{p}{,} \PYG{l+m+mf}{1880.0}\PYG{p}{,} \PYG{l+m+mf}{1881.0}\PYG{p}{,} \PYG{l+m+mf}{1882.0}\PYG{p}{,} \PYG{l+m+mf}{1883.0}\PYG{p}{,} \PYG{l+m+mf}{1884.0}\PYG{p}{,} \PYG{l+m+mf}{1885.0}\PYG{p}{,} \PYG{l+m+mf}{1886.0}\PYG{p}{,} \PYG{l+m+mf}{1887.0}\PYG{p}{,} \PYG{l+m+mf}{1888.0}\PYG{p}{,} \PYG{l+m+mf}{1889.0}\PYG{p}{,} \PYG{l+m+mf}{1890.0}\PYG{p}{,} \PYG{l+m+mf}{1891.0}\PYG{p}{,} \PYG{l+m+mf}{1892.0}\PYG{p}{,} \PYG{l+m+mf}{1893.0}\PYG{p}{,} \PYG{l+m+mf}{1894.0}\PYG{p}{,} \PYG{l+m+mf}{1895.0}\PYG{p}{,} \PYG{l+m+mf}{1896.0}\PYG{p}{,} \PYG{l+m+mf}{1897.0}\PYG{p}{,} \PYG{l+m+mf}{1898.0}\PYG{p}{,} \PYG{l+m+mf}{1899.0}\PYG{p}{,} \PYG{l+m+mf}{1900.0}\PYG{p}{,} \PYG{l+m+mf}{1901.0}\PYG{p}{,} \PYG{l+m+mf}{1902.0}\PYG{p}{,} \PYG{l+m+mf}{1903.0}\PYG{p}{,} \PYG{l+m+mf}{1904.0}\PYG{p}{,} \PYG{l+m+mf}{1905.0}\PYG{p}{,} \PYG{l+m+mf}{1906.0}\PYG{p}{,} \PYG{l+m+mf}{1907.0}\PYG{p}{,} \PYG{l+m+mf}{1908.0}\PYG{p}{,} \PYG{l+m+mf}{1909.0}\PYG{p}{,} \PYG{l+m+mf}{1910.0}\PYG{p}{,} \PYG{l+m+mf}{1911.0}\PYG{p}{,} \PYG{l+m+mf}{1912.0}\PYG{p}{,} \PYG{l+m+mf}{1913.0}\PYG{p}{,} \PYG{l+m+mf}{1914.0}\PYG{p}{,} \PYG{l+m+mf}{1915.0}\PYG{p}{,} \PYG{l+m+mf}{1916.0}\PYG{p}{,} \PYG{l+m+mf}{1917.0}\PYG{p}{,} \PYG{l+m+mf}{1918.0}\PYG{p}{,} \PYG{l+m+mf}{1919.0}\PYG{p}{,} \PYG{l+m+mf}{1920.0}\PYG{p}{,} \PYG{l+m+mf}{1921.0}\PYG{p}{,} \PYG{l+m+mf}{1922.0}\PYG{p}{,} \PYG{l+m+mf}{1923.0}\PYG{p}{,} \PYG{l+m+mf}{1924.0}\PYG{p}{,} \PYG{l+m+mf}{1925.0}\PYG{p}{,} \PYG{l+m+mf}{1926.0}\PYG{p}{,} \PYG{l+m+mf}{1927.0}\PYG{p}{,} \PYG{l+m+mf}{1928.0}\PYG{p}{,} \PYG{l+m+mf}{1929.0}\PYG{p}{,} \PYG{l+m+mf}{1930.0}\PYG{p}{,} \PYG{l+m+mf}{1931.0}\PYG{p}{,} \PYG{l+m+mf}{1932.0}\PYG{p}{,} \PYG{l+m+mf}{1933.0}\PYG{p}{,} \PYG{l+m+mf}{1934.0}\PYG{p}{,} \PYG{l+m+mf}{1935.0}\PYG{p}{,} \PYG{l+m+mf}{1936.0}\PYG{p}{,} \PYG{l+m+mf}{1937.0}\PYG{p}{,} \PYG{l+m+mf}{1938.0}\PYG{p}{,} \PYG{l+m+mf}{1939.0}\PYG{p}{,} \PYG{l+m+mf}{1940.0}\PYG{p}{,} \PYG{l+m+mf}{1941.0}\PYG{p}{,} \PYG{l+m+mf}{1942.0}\PYG{p}{,} \PYG{l+m+mf}{1943.0}\PYG{p}{,} \PYG{l+m+mf}{1944.0}\PYG{p}{,} \PYG{l+m+mf}{1945.0}\PYG{p}{,} \PYG{l+m+mf}{1946.0}\PYG{p}{,} \PYG{l+m+mf}{1947.0}\PYG{p}{,} \PYG{l+m+mf}{1948.0}\PYG{p}{,} \PYG{l+m+mf}{1949.0}\PYG{p}{,} \PYG{l+m+mf}{1950.0}\PYG{p}{,} \PYG{l+m+mf}{1951.0}\PYG{p}{,} \PYG{l+m+mf}{1952.0}\PYG{p}{,} \PYG{l+m+mf}{1953.0}\PYG{p}{,} \PYG{l+m+mf}{1954.0}\PYG{p}{,} \PYG{l+m+mf}{1955.0}\PYG{p}{,} \PYG{l+m+mf}{1956.0}\PYG{p}{,} \PYG{l+m+mf}{1957.0}\PYG{p}{,} \PYG{l+m+mf}{1958.0}\PYG{p}{,} \PYG{l+m+mf}{1959.0}\PYG{p}{,} \PYG{l+m+mf}{1960.0}\PYG{p}{,} \PYG{l+m+mf}{1961.0}\PYG{p}{,} \PYG{l+m+mf}{1962.0}\PYG{p}{,} \PYG{l+m+mf}{1963.0}\PYG{p}{,} \PYG{l+m+mf}{1964.0}\PYG{p}{,} \PYG{l+m+mf}{1965.0}\PYG{p}{,} \PYG{l+m+mf}{1966.0}\PYG{p}{,} \PYG{l+m+mf}{1967.0}\PYG{p}{,} \PYG{l+m+mf}{1968.0}\PYG{p}{,} \PYG{l+m+mf}{1969.0}\PYG{p}{,} \PYG{l+m+mf}{1970.0}\PYG{p}{,} \PYG{l+m+mf}{1971.0}\PYG{p}{,} \PYG{l+m+mf}{1972.0}\PYG{p}{,} \PYG{l+m+mf}{1973.0}\PYG{p}{,} \PYG{l+m+mf}{1974.0}\PYG{p}{,} \PYG{l+m+mf}{1975.0}\PYG{p}{,} \PYG{l+m+mf}{1976.0}\PYG{p}{,} \PYG{l+m+mf}{1977.0}\PYG{p}{,} \PYG{l+m+mf}{1978.0}\PYG{p}{,} \PYG{l+m+mf}{1979.0}\PYG{p}{,} \PYG{l+m+mf}{1980.0}\PYG{p}{,} \PYG{l+m+mf}{1981.0}\PYG{p}{,} \PYG{l+m+mf}{1982.0}\PYG{p}{,} \PYG{l+m+mf}{1983.0}\PYG{p}{,} \PYG{l+m+mf}{1984.0}\PYG{p}{,} \PYG{l+m+mf}{1985.0}\PYG{p}{,} \PYG{l+m+mf}{1986.0}\PYG{p}{,} \PYG{l+m+mf}{1987.0}\PYG{p}{,} \PYG{l+m+mf}{1988.0}\PYG{p}{,} \PYG{l+m+mf}{1989.0}\PYG{p}{,} \PYG{l+m+mf}{1990.0}\PYG{p}{,} \PYG{l+m+mf}{1991.0}\PYG{p}{,} \PYG{l+m+mf}{1992.0}\PYG{p}{,} \PYG{l+m+mf}{1993.0}\PYG{p}{,} \PYG{l+m+mf}{1994.0}\PYG{p}{,} \PYG{l+m+mf}{1995.0}\PYG{p}{,} \PYG{l+m+mf}{1996.0}\PYG{p}{,} \PYG{l+m+mf}{1997.0}\PYG{p}{,} \PYG{l+m+mf}{1998.0}\PYG{p}{,} \PYG{l+m+mf}{1999.0}\PYG{p}{,} \PYG{l+m+mf}{2000.0}\PYG{p}{,} \PYG{l+m+mf}{2001.0}\PYG{p}{,} \PYG{l+m+mf}{2002.0}\PYG{p}{,} \PYG{l+m+mf}{2003.0}\PYG{p}{,} \PYG{l+m+mf}{2004.0}\PYG{p}{,} \PYG{l+m+mf}{2005.0}\PYG{p}{,} \PYG{l+m+mf}{2006.0}\PYG{p}{,} \PYG{l+m+mf}{2007.0}\PYG{p}{,} \PYG{l+m+mf}{2008.0}\PYG{p}{,} \PYG{l+m+mf}{2009.0}\PYG{p}{,} \PYG{l+m+mf}{2010.0}\PYG{p}{,} \PYG{l+m+mf}{2011.0}\PYG{p}{,} \PYG{l+m+mf}{2012.0}\PYG{p}{,} \PYG{l+m+mf}{2013.0}\PYG{p}{]}
\end{Verbatim}

So, e.g. plotting data sets would be clear using the dictionary:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{pylab} \PYG{k+kn}{as} \PYG{n+nn}{plt}

\PYG{k}{for} \PYG{n}{i}\PYG{p}{,}\PYG{n}{JFM} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{JAN}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{FEB}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MAR}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{APR}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MAY}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{JUN}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYGZbs{}
              \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{JUL}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{AUG}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{SEP}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{OCT}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{NOV}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{DEC}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{14}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Year}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Precip. (mm)}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{month} \PYG{o+ow}{in} \PYG{n}{JFM}\PYG{p}{:}
        \PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylim}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{250}\PYG{p}{)}
        \PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlim}\PYG{p}{(}\PYG{n}{dataset}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{YEAR}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{dataset}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{YEAR}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{JFM}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{dataset}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{YEAR}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{dataset}\PYG{p}{[}\PYG{n}{month}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{14}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Year}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Precip. (mm)}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{ANN}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylim}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1100}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlim}\PYG{p}{(}\PYG{n}{dataset}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{YEAR}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{dataset}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{YEAR}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{dataset}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{YEAR}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{dataset}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{ANN}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
[\PYGZlt{}matplotlib.lines.Line2D at 0x107593850\PYGZgt{}]
\end{Verbatim}

\includegraphics{advanced_103_1.png}

\includegraphics{advanced_103_2.png}

\includegraphics{advanced_103_3.png}

\includegraphics{advanced_103_4.png}

\includegraphics{advanced_103_5.png}


\chapter{Excercise}
\label{Chapter2_Python_intro/advanced:excercise}
In this example, we want to read all data from the Heathrow Met data
file \code{files/data/heathrowdata.txt} and plot each data field.

In doing this, we want to store the data in a dictionary, as this is a
convenient way of access the different data fields.

At the heart of this example is the statement

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nb}{dict}\PYG{p}{(}\PYG{n+nb}{zip}\PYG{p}{(}\PYG{n}{labels}\PYG{p}{,}\PYG{n}{rdata}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

This is a very useful combination in Python as it allows us to generate
a dictionary with the keys specified by \code{labels} and the values
\code{rdata}.

A few things that make this a bit more complicated are:
\begin{enumerate}
\item {} 
When we read the data line by line from the file, we have it stored
as data{[}line{]}{[}sample{]}, i.e. each data{[}line{]} is the data for that
line. When we want to load it into the dictionary, we want the data
the other way around. This is a bit tricky with lists, and we have to
use the following, which is a general statement, so you can use it
for similar rotations, but its a bit dense.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{rdata} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{n}{data}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}\PYG{p}{)}\PYG{p}{]} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{]}
\end{Verbatim}

\item {} 
When parsing the file, we have to deal with some awkward aspects,
such as the presence of \code{\#} symbols here and there and the fact
that \code{'-{-}-'} is used to indicate no data. Here, we replace these
awkward fields with more convenient numerical values (that won't
break the conversion to \code{float}), or get rid of them as appropriate
(using \code{replace()} on the strings).

\item {} 
When we come to plot the data, we have to confront the fact that we
used \code{-999} to indicate no data, and have to filter these values
out before plotting. This is easy enough to do in a listcomp for the
\code{y} values by using a conditional statement:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{y} \PYG{o}{=} \PYG{p}{[}\PYG{n}{i} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{items}\PYG{p}{[}\PYG{n}{label}\PYG{p}{]} \PYG{k}{if} \PYG{n}{i} \PYG{o}{!=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{999}\PYG{p}{]}
\end{Verbatim}

But for the x values, we have to filter these based on a test with
the \code{y} values ... and so we use a more complex statement:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{=} \PYG{p}{[}\PYG{n}{time}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{k}{for} \PYG{n}{j}\PYG{p}{,}\PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{items}\PYG{p}{[}\PYG{n}{label}\PYG{p}{]}\PYG{p}{)} \PYG{k}{if} \PYG{n}{i} \PYG{o}{!=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{999}\PYG{p}{]}
\end{Verbatim}

\item {} 
Finally, lists are not very convenient for numerical operations on
the lists ... we can't simply add {[}0.1,0.2{]} to {[}3.0,4.0{]} to get
{[}3.1,4.2{]}, because \code{+} is a concatenation operator for lists.
Instead, we have to loop over all of the items in the lists:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{time} \PYG{o}{=} \PYG{p}{[}\PYG{n}{items}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{year}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{+} \PYG{n}{items}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{month}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{/}\PYG{l+m+mf}{12.} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{items}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{year}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{]}
\end{Verbatim}

We will see next time that there are more convenient modules for
doing this sort of thing, but it's of value to know how you can do it
if you only have lists.

\end{enumerate}

One final comment is that we have made extensive use of listcomps here,
which make the code more compact but may be more difficult for people
just starting coding to follow.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} Read files/data/heathrowdata.txt as above into data as float}
\PYG{c}{\PYGZsh{} doing some clever things to deal with file markers}
\PYG{c}{\PYGZsh{} i.e. where it says \PYGZsh{}  Provisional or \PYGZsh{} we will not worry about}
\PYG{c}{\PYGZsh{} that for the moment}
\PYG{c}{\PYGZsh{} where it has fillers, \PYGZhy{}\PYGZhy{}\PYGZhy{}, replace by \PYGZhy{}999}

\PYG{n}{fp} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/heathrowdata.txt}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ldata} \PYG{o}{=} \PYG{p}{[}\PYG{n}{i}\PYG{o}{.}\PYG{n}{replace}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZhy{}\PYGZhy{}\PYGZhy{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZhy{}999}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{replace}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZsh{}  Provisional}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{replace}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZsh{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)} \PYGZbs{}
                     \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{fp}\PYG{o}{.}\PYG{n}{readlines}\PYG{p}{(}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{7}\PYG{p}{:}\PYG{p}{]}\PYG{p}{]}
\PYG{n}{data} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{n+nb}{float}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)} \PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n}{j}\PYG{p}{]} \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n}{ldata}\PYG{p}{]}
\PYG{n}{fp}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}

\PYG{c}{\PYGZsh{} The reading by line is a bit inconvenient, so rotate the}
\PYG{c}{\PYGZsh{} dataset}
\PYG{n}{rdata} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{n}{data}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}\PYG{p}{)}\PYG{p}{]} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{]}

\PYG{c}{\PYGZsh{} set some labels for each column}
\PYG{n}{labels} \PYG{o}{=} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{year}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{month}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{tmax (degC)}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{tmin (degC)}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYGZbs{}
          \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{air frost (days)}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{rain (mm)}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{sun (hours)}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}

\PYG{c}{\PYGZsh{} generate a dictionary with the labels as keys}
\PYG{n}{items} \PYG{o}{=} \PYG{n+nb}{dict}\PYG{p}{(}\PYG{n+nb}{zip}\PYG{p}{(}\PYG{n}{labels}\PYG{p}{,}\PYG{n}{rdata}\PYG{p}{)}\PYG{p}{)}

\PYG{k+kn}{import} \PYG{n+nn}{pylab} \PYG{k+kn}{as} \PYG{n+nn}{plt}
\PYG{c}{\PYGZsh{} its quite difficult to add arrays}
\PYG{c}{\PYGZsh{} so we have to loop over each item}
\PYG{n}{time} \PYG{o}{=} \PYG{p}{[}\PYG{n}{items}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{year}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{+} \PYG{n}{items}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{month}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{/}\PYG{l+m+mf}{12.} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{items}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{year}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{]}

\PYG{k}{for} \PYG{n}{i}\PYG{p}{,}\PYG{n}{label} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{labels}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{:}\PYG{p}{]}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{14}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{year}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{n}{label}\PYG{p}{)}
    \PYG{c}{\PYGZsh{} filter out the \PYGZhy{}999 values}
    \PYG{n}{x} \PYG{o}{=} \PYG{p}{[}\PYG{n}{time}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{k}{for} \PYG{n}{j}\PYG{p}{,}\PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{items}\PYG{p}{[}\PYG{n}{label}\PYG{p}{]}\PYG{p}{)} \PYG{k}{if} \PYG{n}{i} \PYG{o}{!=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{999}\PYG{p}{]}
    \PYG{n}{y} \PYG{o}{=} \PYG{p}{[}\PYG{n}{i} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{items}\PYG{p}{[}\PYG{n}{label}\PYG{p}{]} \PYG{k}{if} \PYG{n}{i} \PYG{o}{!=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{999}\PYG{p}{]}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{)}
\end{Verbatim}

\includegraphics{advanced_106_0.png}

\includegraphics{advanced_106_1.png}

\includegraphics{advanced_106_2.png}

\includegraphics{advanced_106_3.png}

\includegraphics{advanced_106_4.png}


\chapter{AE2. Advanced Exercises}
\label{Chapter2_Python_intro/advanced_answers:ae2-advanced-exercises}\label{Chapter2_Python_intro/advanced_answers::doc}\begin{itemize}
\item {} 
{\hyperref[Chapter2_Python_intro/advanced_answers:Exercise_A2.1]{Exercise A2.1}}

\item {} 
{\hyperref[Chapter2_Python_intro/advanced_answers:Exercise_A2.2]{Exercise A2.2}}

\item {} 
{\hyperref[Chapter2_Python_intro/advanced_answers:Exercise_A2.3]{Exercise A2.3}}

\end{itemize}

Remember that these exercises are more advanced. You are not \emph{required}
to do these, but may like to do so if you want to stretch yourself.


\section{Exercise A2.1}
\label{Chapter2_Python_intro/advanced_answers:exercise-a2-1}
As an exercise for this, you could see if you can simulate the logical
combinations \code{xor}, \code{nor} and \code{nand}, e.g.:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} nand test:}
\PYG{c}{\PYGZsh{} see http://en.wikipedia.org/wiki/Logical\PYGZus{}NAND}
\PYG{c}{\PYGZsh{} (A nand B) is not (A and B)}

\PYG{n}{ABList} \PYG{o}{=} \PYG{p}{[}\PYG{p}{(}\PYG{n+nb+bp}{False}\PYG{p}{,}\PYG{n+nb+bp}{False}\PYG{p}{)}\PYG{p}{,}\PYG{p}{(}\PYG{n+nb+bp}{False}\PYG{p}{,}\PYG{n+nb+bp}{True}\PYG{p}{)}\PYG{p}{,}\PYG{p}{(}\PYG{n+nb+bp}{True}\PYG{p}{,}\PYG{n+nb+bp}{False}\PYG{p}{)}\PYG{p}{,}\PYG{p}{(}\PYG{n+nb+bp}{True}\PYG{p}{,}\PYG{n+nb+bp}{True}\PYG{p}{)}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{A}\PYG{p}{,}\PYG{n}{B} \PYG{o+ow}{in} \PYG{n}{ABList}\PYG{p}{:}
  \PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{ nand }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{  =}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}\PYG{p}{,}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{B}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}\PYG{o+ow}{not} \PYG{p}{(}\PYG{n}{A} \PYG{o+ow}{and} \PYG{n}{B}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
False nand False  = True
False nand True  = True
True nand False  = True
True nand True  = False
\end{Verbatim}


\section{Answer}
\label{Chapter2_Python_intro/advanced_answers:answer}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{} Exercise 2.1 Scientific Computing}

\PYG{l+s+sd}{    Thu  3 Oct 2013 10:46:58 BST}

\PYG{l+s+sd}{    P. Lewis : p.lewis@ucl.ac.uk}

\PYG{l+s+sd}{    nand test}

\PYG{l+s+sd}{    see http://en.wikipedia.org/wiki/Logical\PYGZus{}NAND}

\PYG{l+s+sd}{    (A nand B) is not (A and B)}

\PYG{l+s+sd}{    It is a modification of the code in Exercise A2.1}
\PYG{l+s+sd}{    of Scientific Computing (https://github.com/profLewis/geogg122)}

\PYG{l+s+sd}{    Edits made from original:}
\PYG{l+s+sd}{        \PYGZhy{} neatened output format}
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}

\PYG{c}{\PYGZsh{} set up a list of tuples to loop over}
\PYG{n}{ABList} \PYG{o}{=} \PYG{p}{[}\PYG{p}{(}\PYG{n+nb+bp}{False}\PYG{p}{,}\PYG{n+nb+bp}{False}\PYG{p}{)}\PYG{p}{,}\PYG{p}{(}\PYG{n+nb+bp}{False}\PYG{p}{,}\PYG{n+nb+bp}{True}\PYG{p}{)}\PYG{p}{,}\PYG{p}{(}\PYG{n+nb+bp}{True}\PYG{p}{,}\PYG{n+nb+bp}{False}\PYG{p}{)}\PYG{p}{,}\PYG{p}{(}\PYG{n+nb+bp}{True}\PYG{p}{,}\PYG{n+nb+bp}{True}\PYG{p}{)}\PYG{p}{]}

\PYG{c}{\PYGZsh{} loop over tuples and print A xor B}
\PYG{c}{\PYGZsh{} with tabs (\PYGZbs{}t) for neater output}
\PYG{k}{for} \PYG{n}{A}\PYG{p}{,}\PYG{n}{B} \PYG{o+ow}{in} \PYG{n}{ABList}\PYG{p}{:}
  \PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{nand}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{=}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}\PYG{p}{,}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{B}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}\PYG{o+ow}{not} \PYG{p}{(}\PYG{n}{A} \PYG{o+ow}{and} \PYG{n}{B}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
False       nand    False   = True
False       nand    True    = True
True        nand    False   = True
True        nand    True    = False
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{} Exercise 2.1 Scientific Computing}

\PYG{l+s+sd}{    Thu  3 Oct 2013 10:46:58 BST}

\PYG{l+s+sd}{    P. Lewis : p.lewis@ucl.ac.uk}

\PYG{l+s+sd}{    nor test}

\PYG{l+s+sd}{    see http://en.wikipedia.org/wiki/Logical\PYGZus{}NOR}

\PYG{l+s+sd}{    (A nor B) is not (A or B)}

\PYG{l+s+sd}{    It is a modification of the code in Exercise A2.1}
\PYG{l+s+sd}{    of Scientific Computing (https://github.com/profLewis/geogg122)}

\PYG{l+s+sd}{    Edits made from original:}
\PYG{l+s+sd}{        \PYGZhy{} neatened output format}
\PYG{l+s+sd}{        \PYGZhy{} modified from nand to nor}
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}

\PYG{c}{\PYGZsh{} set up a list of tuples to loop over}
\PYG{n}{ABList} \PYG{o}{=} \PYG{p}{[}\PYG{p}{(}\PYG{n+nb+bp}{False}\PYG{p}{,}\PYG{n+nb+bp}{False}\PYG{p}{)}\PYG{p}{,}\PYG{p}{(}\PYG{n+nb+bp}{False}\PYG{p}{,}\PYG{n+nb+bp}{True}\PYG{p}{)}\PYG{p}{,}\PYG{p}{(}\PYG{n+nb+bp}{True}\PYG{p}{,}\PYG{n+nb+bp}{False}\PYG{p}{)}\PYG{p}{,}\PYG{p}{(}\PYG{n+nb+bp}{True}\PYG{p}{,}\PYG{n+nb+bp}{True}\PYG{p}{)}\PYG{p}{]}

\PYG{c}{\PYGZsh{} loop over tuples and print A xor B}
\PYG{c}{\PYGZsh{} with tabs (\PYGZbs{}t) for neater output}
\PYG{k}{for} \PYG{n}{A}\PYG{p}{,}\PYG{n}{B} \PYG{o+ow}{in} \PYG{n}{ABList}\PYG{p}{:}
  \PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{nor}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{=}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}\PYG{p}{,}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{B}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}\PYG{o+ow}{not} \PYG{p}{(}\PYG{n}{A} \PYG{o+ow}{or} \PYG{n}{B}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
False       nor     False   = True
False       nor     True    = False
True        nor     False   = False
True        nor     True    = False
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{} Exercise 2.1 Scientific Computing}

\PYG{l+s+sd}{    Thu  3 Oct 2013 10:46:58 BST}

\PYG{l+s+sd}{    P. Lewis : p.lewis@ucl.ac.uk}

\PYG{l+s+sd}{    xor test}

\PYG{l+s+sd}{    see http://en.wikipedia.org/wiki/Logical\PYGZus{}XOR}

\PYG{l+s+sd}{    (A xor B) is (A or B) and not (A and B)}

\PYG{l+s+sd}{    It is a modification of the code in Exercise A2.1}
\PYG{l+s+sd}{    of Scientific Computing (https://github.com/profLewis/geogg122)}

\PYG{l+s+sd}{    Edits made from original:}
\PYG{l+s+sd}{        \PYGZhy{} neatened output format}
\PYG{l+s+sd}{        \PYGZhy{} modified from nand to xor}
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}

\PYG{c}{\PYGZsh{} set up a list of tuples to loop over}
\PYG{n}{ABList} \PYG{o}{=} \PYG{p}{[}\PYG{p}{(}\PYG{n+nb+bp}{False}\PYG{p}{,}\PYG{n+nb+bp}{False}\PYG{p}{)}\PYG{p}{,}\PYG{p}{(}\PYG{n+nb+bp}{False}\PYG{p}{,}\PYG{n+nb+bp}{True}\PYG{p}{)}\PYG{p}{,}\PYG{p}{(}\PYG{n+nb+bp}{True}\PYG{p}{,}\PYG{n+nb+bp}{False}\PYG{p}{)}\PYG{p}{,}\PYG{p}{(}\PYG{n+nb+bp}{True}\PYG{p}{,}\PYG{n+nb+bp}{True}\PYG{p}{)}\PYG{p}{]}

\PYG{c}{\PYGZsh{} loop over tuples and print A xor B}
\PYG{c}{\PYGZsh{} with tabs (\PYGZbs{}t) for neater output}
\PYG{k}{for} \PYG{n}{A}\PYG{p}{,}\PYG{n}{B} \PYG{o+ow}{in} \PYG{n}{ABList}\PYG{p}{:}
  \PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{xor}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{=}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}\PYG{p}{,}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{B}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}\PYG{p}{(}\PYG{n}{A} \PYG{o+ow}{or} \PYG{n}{B}\PYG{p}{)} \PYG{o+ow}{and} \PYG{o+ow}{not} \PYG{p}{(}\PYG{n}{A} \PYG{o+ow}{and} \PYG{n}{B}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
False       xor     False   = False
False       xor     True    = True
True        xor     False   = True
True        xor     True    = False
\end{Verbatim}


\section{Exercise A2.2}
\label{Chapter2_Python_intro/advanced_answers:exercise-a2-2}\begin{enumerate}
\item {} 
Work out what the following decimal numbers are in binary:

\begin{DUlineblock}{0em}
\item[] 7
\item[] 493
\item[] 127
\item[] 255
\item[] 1024
\end{DUlineblock}

\end{enumerate}

and check your result using the approach we took to confirming \code{101}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{101} \PYG{o}{==}  \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{6}\PYG{p}{)} \PYG{o}{+} \PYGZbs{}
        \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYGZbs{}
        \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYGZbs{}
        \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{o}{+} \PYGZbs{}
        \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+} \PYGZbs{}
        \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{+} \PYGZbs{}
        \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{0}\PYG{p}{)}
\end{Verbatim}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
How many bits are needed to represent each of these numbers?

\item {} 
What is the largest number you could represent in: (i) a 32 bit
representation; (b) a 64 bit representation?

\item {} 
Recalling that there are 8 bits in a
\href{http://en.wikipedia.org/wiki/Byte}{byte}, what is the largest
number you could represent in: (a) a single byte; (b) two bytes?

\end{enumerate}


\section{Answer}
\label{Chapter2_Python_intro/advanced_answers:id1}
\textbf{a. Work out what the following decimal numbers are in binary:}

\begin{DUlineblock}{0em}
\item[] 7
\item[] 493
\item[] 127
\item[] 255
\item[] 1024
\end{DUlineblock}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{n} \PYG{o+ow}{in} \PYG{p}{(}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{493}\PYG{p}{,}\PYG{l+m+mi}{127}\PYG{p}{,}\PYG{l+m+mi}{255}\PYG{p}{,}\PYG{l+m+mi}{1024}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{print} \PYG{n}{n}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{in binary is}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n+nb}{bin}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{7}   \PYG{o+ow}{in} \PYG{n}{binary} \PYG{o+ow}{is} \PYG{l+m+mi}{0}\PYG{n}{b111}
\PYG{l+m+mi}{493}         \PYG{o+ow}{in} \PYG{n}{binary} \PYG{o+ow}{is} \PYG{l+m+mi}{0}\PYG{n}{b111101101}
\PYG{l+m+mi}{127}         \PYG{o+ow}{in} \PYG{n}{binary} \PYG{o+ow}{is} \PYG{l+m+mi}{0}\PYG{n}{b1111111}
\PYG{l+m+mi}{255}         \PYG{o+ow}{in} \PYG{n}{binary} \PYG{o+ow}{is} \PYG{l+m+mi}{0}\PYG{n}{b11111111}
\PYG{l+m+mi}{1024}        \PYG{o+ow}{in} \PYG{n}{binary} \PYG{o+ow}{is} \PYG{l+m+mi}{0}\PYG{n}{b10000000000}
\end{Verbatim}

\textbf{check your result using the approach we took to confirming {}`{}`101{}`{}`:}

Long-hand way:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{7}   \PYG{o}{==}  \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+} \PYGZbs{}
        \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{+} \PYGZbs{}
        \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{0}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nb+bp}{True}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{493} \PYG{o}{==}  \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{8}\PYG{p}{)} \PYG{o}{+} \PYGZbs{}
        \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{7}\PYG{p}{)} \PYG{o}{+} \PYGZbs{}
        \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{6}\PYG{p}{)} \PYG{o}{+} \PYGZbs{}
        \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYGZbs{}
        \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYGZbs{}
        \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{o}{+} \PYGZbs{}
        \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+} \PYGZbs{}
        \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{+} \PYGZbs{}
        \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{0}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nb+bp}{True}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{127} \PYG{o}{==}  \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{6}\PYG{p}{)} \PYG{o}{+} \PYGZbs{}
        \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYGZbs{}
        \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYGZbs{}
        \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{o}{+} \PYGZbs{}
        \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+} \PYGZbs{}
        \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{+} \PYGZbs{}
        \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{0}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nb+bp}{True}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{255} \PYG{o}{==}  \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{7}\PYG{p}{)} \PYG{o}{+} \PYGZbs{}
        \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{6}\PYG{p}{)} \PYG{o}{+} \PYGZbs{}
        \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYGZbs{}
        \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYGZbs{}
        \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{o}{+} \PYGZbs{}
        \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+} \PYGZbs{}
        \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{+} \PYGZbs{}
        \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{0}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nb+bp}{True}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{1024} \PYG{o}{==} \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{o}{+} \PYGZbs{}
        \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{9}\PYG{p}{)} \PYG{o}{+} \PYGZbs{}
        \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{8}\PYG{p}{)} \PYG{o}{+} \PYGZbs{}
        \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{7}\PYG{p}{)} \PYG{o}{+} \PYGZbs{}
        \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{6}\PYG{p}{)} \PYG{o}{+} \PYGZbs{}
        \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYGZbs{}
        \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYGZbs{}
        \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{o}{+} \PYGZbs{}
        \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+} \PYGZbs{}
        \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{+} \PYGZbs{}
        \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{0}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nb+bp}{True}
\end{Verbatim}

More automatic/advanced way (but more complicated coding):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} loop over numbers}
\PYG{k}{for} \PYG{n}{n} \PYG{o+ow}{in} \PYG{p}{(}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{493}\PYG{p}{,}\PYG{l+m+mi}{127}\PYG{p}{,}\PYG{l+m+mi}{255}\PYG{p}{,}\PYG{l+m+mi}{1024}\PYG{p}{)}\PYG{p}{:}

    \PYG{c}{\PYGZsh{} convert decimal to binary}
    \PYG{c}{\PYGZsh{} then convert to string and ignore 0b at start}
    \PYG{n}{binstr} \PYG{o}{=} \PYG{n+nb}{bin}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{:}\PYG{p}{]}

    \PYG{c}{\PYGZsh{} initialise sum as accumulator}
    \PYG{n+nb}{sum} \PYG{o}{=} \PYG{l+m+mi}{0}

    \PYG{c}{\PYGZsh{} how many bits in this case?}
    \PYG{n}{nBits} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{binstr}\PYG{p}{)}
    \PYG{k}{print} \PYG{n}{n}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{in binary is}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{binstr}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{: }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{ bits}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZpc{}}\PYG{n}{nBits}

    \PYG{c}{\PYGZsh{} loop over each bit}
    \PYG{k}{for} \PYG{n}{c} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{n}{nBits}\PYG{p}{)}\PYG{p}{:}

        \PYG{c}{\PYGZsh{} extract the bit and exponent}
        \PYG{n}{bit} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{binstr}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{n}{c}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{exp} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{n}{c}
        \PYG{n+nb}{sum} \PYG{o}{+}\PYG{o}{=} \PYG{n}{exp} \PYG{o}{*} \PYG{n}{bit}
        \PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{ }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{ x 2\PYGZca{}}\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{ = }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{ x }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{ }\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{bit}\PYG{p}{,}\PYG{n}{c}\PYG{p}{,}\PYG{n}{bit}\PYG{p}{,}\PYG{n}{exp}\PYG{p}{,}\PYG{n+nb}{sum}\PYG{p}{)}

    \PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{ == }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{?}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{n}\PYG{p}{,}\PYG{n+nb}{sum}\PYG{p}{)}\PYG{p}{,}\PYG{n}{n} \PYG{o}{==} \PYG{n+nb}{sum}
    \PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{====================================}\PYG{l+s}{\PYGZdq{}}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
7   in binary is 111 : 3 bits
     1 x 2\PYGZca{}0 = 1 x 1        1
     1 x 2\PYGZca{}1 = 1 x 2        3
     1 x 2\PYGZca{}2 = 1 x 4        7
7 == 7? True
====================================
493         in binary is 111101101 : 9 bits
     1 x 2\PYGZca{}0 = 1 x 1        1
     0 x 2\PYGZca{}1 = 0 x 2        1
     1 x 2\PYGZca{}2 = 1 x 4        5
     1 x 2\PYGZca{}3 = 1 x 8        13
     0 x 2\PYGZca{}4 = 0 x 16       13
     1 x 2\PYGZca{}5 = 1 x 32       45
     1 x 2\PYGZca{}6 = 1 x 64       109
     1 x 2\PYGZca{}7 = 1 x 128      237
     1 x 2\PYGZca{}8 = 1 x 256      493
493 == 493? True
====================================
127         in binary is 1111111 : 7 bits
     1 x 2\PYGZca{}0 = 1 x 1        1
     1 x 2\PYGZca{}1 = 1 x 2        3
     1 x 2\PYGZca{}2 = 1 x 4        7
     1 x 2\PYGZca{}3 = 1 x 8        15
     1 x 2\PYGZca{}4 = 1 x 16       31
     1 x 2\PYGZca{}5 = 1 x 32       63
     1 x 2\PYGZca{}6 = 1 x 64       127
127 == 127? True
====================================
255         in binary is 11111111 : 8 bits
     1 x 2\PYGZca{}0 = 1 x 1        1
     1 x 2\PYGZca{}1 = 1 x 2        3
     1 x 2\PYGZca{}2 = 1 x 4        7
     1 x 2\PYGZca{}3 = 1 x 8        15
     1 x 2\PYGZca{}4 = 1 x 16       31
     1 x 2\PYGZca{}5 = 1 x 32       63
     1 x 2\PYGZca{}6 = 1 x 64       127
     1 x 2\PYGZca{}7 = 1 x 128      255
255 == 255? True
====================================
1024        in binary is 10000000000 : 11 bits
     0 x 2\PYGZca{}0 = 0 x 1        0
     0 x 2\PYGZca{}1 = 0 x 2        0
     0 x 2\PYGZca{}2 = 0 x 4        0
     0 x 2\PYGZca{}3 = 0 x 8        0
     0 x 2\PYGZca{}4 = 0 x 16       0
     0 x 2\PYGZca{}5 = 0 x 32       0
     0 x 2\PYGZca{}6 = 0 x 64       0
     0 x 2\PYGZca{}7 = 0 x 128      0
     0 x 2\PYGZca{}8 = 0 x 256      0
     0 x 2\PYGZca{}9 = 0 x 512      0
     1 x 2\PYGZca{}10 = 1 x 1024    1024
1024 == 1024? True
====================================
\end{Verbatim}

If you enjoyed this part of the exercise ;-) , you could repeat this
part of it, but using base 8 (octal) and or base 16 (hexadecimal), which
you will often come across in computing. We might use octal e.g. in unix
file permissions, or hexadecimal more widely in memory addresses
(because it would be too long a number in binary!).

e.g.:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{n} \PYG{o}{=} \PYG{l+m+mi}{493}
\PYG{c}{\PYGZsh{} N.B, no 0b or 0x part on the string for octal, just a}
\PYG{c}{\PYGZsh{} leading 0}
\PYG{n}{octstr} \PYG{o}{=} \PYG{n+nb}{oct}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{p}{]}
\PYG{n+nb}{sum} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{c}{\PYGZsh{} how many octets in this case? (assuming thats the right word)}
\PYG{n}{nOct} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{octstr}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{n}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{in octal is}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{octstr}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{: }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{ octets}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZpc{}}\PYG{n}{nOct}

\PYG{c}{\PYGZsh{} loop over each octets}
\PYG{k}{for} \PYG{n}{c} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{n}{nOct}\PYG{p}{)}\PYG{p}{:}
    \PYG{c}{\PYGZsh{} extract the octet and exponent}
    \PYG{n}{octet} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{octstr}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{n}{c}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{exp} \PYG{o}{=} \PYG{l+m+mi}{8}\PYG{o}{*}\PYG{o}{*}\PYG{n}{c}
    \PYG{n+nb}{sum} \PYG{o}{+}\PYG{o}{=} \PYG{n}{exp} \PYG{o}{*} \PYG{n}{octet}
    \PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{ }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{ x 8\PYGZca{}}\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{ = }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{ x }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{ }\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{octet}\PYG{p}{,}\PYG{n}{c}\PYG{p}{,}\PYG{n}{octet}\PYG{p}{,}\PYG{n}{exp}\PYG{p}{,}\PYG{n+nb}{sum}\PYG{p}{)}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{ == }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{?}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{n}\PYG{p}{,}\PYG{n+nb}{sum}\PYG{p}{)}\PYG{p}{,}\PYG{n}{n} \PYG{o}{==} \PYG{n+nb}{sum}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{====================================}\PYG{l+s}{\PYGZdq{}}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
493         in octal is 755 : 3 octets
     5 x 8\PYGZca{}0 = 5 x 1        5
     5 x 8\PYGZca{}1 = 5 x 8        45
     7 x 8\PYGZca{}2 = 7 x 64       493
493 == 493? True
====================================
\end{Verbatim}

\textbf{b. How many bits are needed to represent each of these numbers?}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} bin() converts to binary, but really its a string}
\PYG{c}{\PYGZsh{} the first 2 characters of which are \PYGZsq{}0b\PYGZsq{}}
\PYG{c}{\PYGZsh{} so find the length of the string other than the first two}
\PYG{c}{\PYGZsh{} characters}

\PYG{k}{for} \PYG{n}{n} \PYG{o+ow}{in} \PYG{p}{(}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{493}\PYG{p}{,}\PYG{l+m+mi}{127}\PYG{p}{,}\PYG{l+m+mi}{255}\PYG{p}{,}\PYG{l+m+mi}{1024}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{binstr} \PYG{o}{=} \PYG{n+nb}{bin}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{:}\PYG{p}{]}
    \PYG{k}{print} \PYG{n}{binstr}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{binstr}\PYG{p}{)}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{bits}\PYG{l+s}{\PYGZsq{}}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
111 3 bits
111101101 9 bits
1111111 7 bits
11111111 8 bits
10000000000 11 bits
\end{Verbatim}

\textbf{c. What is the largest number you could represent in: (i) a 32 bit
representation; (b) a 64 bit representation?}

In an \emph{unsigned} integer representation, the largest number would be one
with \code{1} in all bit fields.

We \emph{could} add this up, but it's faster to notice that this is one less
than two to the power of the number of bits, e.g. the largest number
with 8 bits is \code{2\textasciicircum{}8 - 1}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{the largest (unsigned) integer with 8 bits (1 byte) is}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{8} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
the largest (unsigned) integer with 8 bits (1 byte) is 255
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{the largest (unsigned) integer with 32 bits is}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{32} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{the largest (unsigned) integer with 64 bits is}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{64} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
the largest (unsigned) integer with 32 bits is 4294967295
the largest (unsigned) integer with 64 bits is 18446744073709551615
\end{Verbatim}

Sometimes, a \emph{signed} integer representation is used, in which case the
leftmost bit (usually) of the bit field is used to represent the \emph{sign}
(\code{0} meaning \code{+ve} and \code{1} meaning \code{-ve}), so e.g.:

\begin{DUlineblock}{0em}
\item[] \code{011} would be +7 in decimal but
\item[] \code{111} would be -7 in decimal
\end{DUlineblock}

This means that there is one fewer bit to represent the magnitude of the
number, so e.g. with 8 bits (one byte) you have one bit for the sign,
and 7 bits for magnitude:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{the largest  (signed) integer with 8 bits (1 byte) is}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{the smallest (signed) integer with 8 bits (1 byte) is}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{+}\PYG{l+m+mi}{1}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
the largest  (signed) integer with 8 bits (1 byte) is 127
the smallest (signed) integer with 8 bits (1 byte) is \PYGZhy{}127
\end{Verbatim}

Interestingly, in a signed integer representation, there are two numbers
that represent zero:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mo}{000}
\PYG{l+m+mi}{100}
\end{Verbatim}

which effectively mean \code{+0} and \code{-0}. In that sense, the signed
representation is a little wasteful (but you only lose one number!).

{\color{red}\bfseries{}**}d. Recalling that there are 8 bits in a
\href{http://en.wikipedia.org/wiki/Byte}{byte}, what is the largest number
you could represent in: (a) a single byte; (b) two bytes? **

So, one byte is 8 bits.

As we saw above, for an unsigned representation this can have integers
from \code{0} to \code{255}.

For a signed representation this can have integers from \code{-127} to
\code{+127}.

Two bytes is 16 bits, so:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{the largest (unsigned) integer with 16 bits (2 bytes) is}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{16} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{the largest   (signed) integer with 16 bits (2 bytes) is}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{16}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{the smallest  (signed) integer with 16 bits (2 bytes) is}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{16}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{+}\PYG{l+m+mi}{1}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
the largest (unsigned) integer with 16 bits (2 bytes) is 65535
the largest   (signed) integer with 16 bits (2 bytes) is 32767
the smallest  (signed) integer with 16 bits (2 bytes) is \PYGZhy{}32767
\end{Verbatim}


\section{Exercise A2.3}
\label{Chapter2_Python_intro/advanced_answers:exercise-a2-3}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{qa} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{n}{b11111111}

\PYG{n}{qa1} \PYG{o}{=} \PYG{p}{(}\PYG{n}{qa} \PYG{o}{\PYGZam{}} \PYG{l+m+mi}{0}\PYG{n}{b00000001}\PYG{p}{)} \PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{l+m+mi}{0}    \PYG{c}{\PYGZsh{} bit 0}
\PYG{n}{qa2} \PYG{o}{=} \PYG{p}{(}\PYG{n}{qa} \PYG{o}{\PYGZam{}} \PYG{l+m+mi}{0}\PYG{n}{b00000010}\PYG{p}{)} \PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{l+m+mi}{1}    \PYG{c}{\PYGZsh{} bit 1}
\PYG{n}{qa3} \PYG{o}{=} \PYG{p}{(}\PYG{n}{qa} \PYG{o}{\PYGZam{}} \PYG{l+m+mi}{0}\PYG{n}{b00000100}\PYG{p}{)} \PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{l+m+mi}{2}    \PYG{c}{\PYGZsh{} bit 2}
\PYG{n}{qa4} \PYG{o}{=} \PYG{p}{(}\PYG{n}{qa} \PYG{o}{\PYGZam{}} \PYG{l+m+mi}{0}\PYG{n}{b00011000}\PYG{p}{)} \PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{l+m+mi}{3}    \PYG{c}{\PYGZsh{} bit 3\PYGZhy{}4}
\PYG{n}{qa5} \PYG{o}{=} \PYG{p}{(}\PYG{n}{qa} \PYG{o}{\PYGZam{}} \PYG{l+m+mi}{0}\PYG{n}{b11100000}\PYG{p}{)} \PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{l+m+mi}{5}    \PYG{c}{\PYGZsh{} bit 5\PYGZhy{}7}

\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{qa1}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n+nb}{bin}\PYG{p}{(}\PYG{n}{qa1}\PYG{p}{)}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{qa2}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n+nb}{bin}\PYG{p}{(}\PYG{n}{qa2}\PYG{p}{)}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{qa3}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n+nb}{bin}\PYG{p}{(}\PYG{n}{qa3}\PYG{p}{)}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{qa4}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n+nb}{bin}\PYG{p}{(}\PYG{n}{qa4}\PYG{p}{)}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{qa5}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n+nb}{bin}\PYG{p}{(}\PYG{n}{qa5}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
qa1 0b1
qa2 0b1
qa3 0b1
qa4 0b11
qa5 0b111
\end{Verbatim}

Develop some code to repeat the QA bit masking done above, but make the
code generate the bit masks itself from knowledge of the first and last
of the bit fields you require (assuming they are sequential).

If possible, do this in a function.

Demonstrate its operation with several example bit masks.


\section{Answer}
\label{Chapter2_Python_intro/advanced_answers:id4}
One way to this elegantly is to use the left shift to generate the bit
masks.

e.g. to put a \code{1} in bit 2:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{mask2} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{n}{b1} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{l+m+mi}{2}
\PYG{k}{print} \PYG{n+nb}{bin}\PYG{p}{(}\PYG{n}{mask2}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{0}\PYG{n}{b100}
\end{Verbatim}

or to fill fields 3-4:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{mask3} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{n}{b11} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{l+m+mi}{3}
\PYG{k}{print} \PYG{n+nb}{bin}\PYG{p}{(}\PYG{n}{mask3}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{0}\PYG{n}{b11000}
\end{Verbatim}

An easier way though is to right shift the qa and perform a bitwise and
with the mask:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{qa} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{n}{b00011000}
\PYG{n}{mask3} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{n}{b11}
\PYG{k}{print} \PYG{n+nb}{bin}\PYG{p}{(}\PYG{p}{(}\PYG{n}{qa} \PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{l+m+mi}{3}\PYG{p}{)} \PYG{o}{\PYGZam{}} \PYG{n}{mask3}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{0}\PYG{n}{b11}
\end{Verbatim}

We need to consider how to pass the information through to this
operation.

One way would be to use a \code{dict} with the \code{key} as the starting
value of the bit field and the \code{value} as the end:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{fields} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{:}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{:}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{:}\PYG{l+m+mi}{7}\PYG{p}{\PYGZcb{}}
\end{Verbatim}

We access these as:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{start}\PYG{p}{,}\PYG{n}{finish} \PYG{o+ow}{in} \PYG{n}{fields}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{print} \PYG{n}{start}\PYG{p}{,}\PYG{n}{finish}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
0 0
1 1
2 2
3 4
5 7
\end{Verbatim}

Then form an integer which is \code{2\textasciicircum{}n -1}, where \code{n} is the (inclusive)
length from \code{start} to \code{finish}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} a test qa with only required bits}
\PYG{n}{qa} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{n}{b00011000}
\PYG{n}{start} \PYG{o}{=} \PYG{l+m+mi}{3}
\PYG{n}{finish} \PYG{o}{=} \PYG{l+m+mi}{4}

\PYG{k}{print} \PYG{n+nb}{bin}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{p}{(}\PYG{n}{finish}\PYG{o}{\PYGZhy{}}\PYG{n}{start}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{0}\PYG{n}{b11}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} qa with all bits filled}
\PYG{n}{qa} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{n}{b11111111}

\PYG{k}{for} \PYG{n}{start}\PYG{p}{,}\PYG{n}{finish} \PYG{o+ow}{in} \PYG{n}{fields}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{mask} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{p}{(}\PYG{n}{finish}\PYG{o}{\PYGZhy{}}\PYG{n}{start}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}
    \PYG{k}{print} \PYG{n}{start}\PYG{p}{,}\PYG{n}{finish}\PYG{p}{,}\PYG{n+nb}{bin}\PYG{p}{(}\PYG{n}{mask}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
0 0 0b1
1 1 0b1
2 2 0b1
3 4 0b11
5 7 0b111
\end{Verbatim}

so now we right shift the \code{qa} by \code{start} and perform a bitwise and
(\code{\&}) with the mask:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{start} \PYG{o}{=} \PYG{l+m+mi}{3}
\PYG{n}{finish} \PYG{o}{=} \PYG{l+m+mi}{4}
\PYG{n}{qa} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{n}{b00011000}

\PYG{n}{mask} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{p}{(}\PYG{n}{finish}\PYG{o}{\PYGZhy{}}\PYG{n}{start}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{maskedQA} \PYG{o}{=} \PYG{p}{(}\PYG{n}{qa} \PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{n}{start}\PYG{p}{)} \PYG{o}{\PYGZam{}} \PYG{n}{mask}
\PYG{k}{print} \PYG{n+nb}{bin}\PYG{p}{(}\PYG{n}{maskedQA}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{0}\PYG{n}{b11}
\end{Verbatim}

Now we can combine all of these ideas:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{fields} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{:}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{:}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{:}\PYG{l+m+mi}{7}\PYG{p}{\PYGZcb{}}

\PYG{c}{\PYGZsh{} qa with all bits filled}
\PYG{n}{qa} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{n}{b11111111}

\PYG{k}{for} \PYG{n}{start}\PYG{p}{,}\PYG{n}{finish} \PYG{o+ow}{in} \PYG{n}{fields}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{mask}     \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{p}{(}\PYG{n}{finish}\PYG{o}{\PYGZhy{}}\PYG{n}{start}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{n}{maskedQA} \PYG{o}{=} \PYG{p}{(}\PYG{n}{qa} \PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{n}{start}\PYG{p}{)} \PYG{o}{\PYGZam{}} \PYG{n}{mask}
    \PYG{k}{print} \PYG{n}{start}\PYG{p}{,}\PYG{n}{finish}\PYG{p}{,}\PYG{n+nb}{bin}\PYG{p}{(}\PYG{n}{maskedQA}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
0 0 0b1
1 1 0b1
2 2 0b1
3 4 0b11
5 7 0b111
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Exercise 2.1 Scientific Computing}

\PYG{l+s+sd}{    Thu  3 Oct 2013 10:46:58 BST}

\PYG{l+s+sd}{    P. Lewis : p.lewis@ucl.ac.uk}

\PYG{l+s+sd}{    bit mask test}

\PYG{l+s+sd}{    Original code}

\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{k}{def} \PYG{n+nf}{maskedQA}\PYG{p}{(}\PYG{n}{qa}\PYG{p}{,} \PYG{n}{fields} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{:}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{:}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{:}\PYG{l+m+mi}{7}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Return a dictionary of masked QA bit fields}

\PYG{l+s+sd}{    Inputs:}
\PYG{l+s+sd}{    qa \PYGZhy{}\PYGZhy{} QA to be masked}

\PYG{l+s+sd}{    Keyword arguments:}
\PYG{l+s+sd}{    fields \PYGZhy{}\PYGZhy{} bit field dictionary (default \PYGZob{}0:0, 1:1, 2:2, 3:4, 5:7\PYGZcb{})}
\PYG{l+s+sd}{              Here, the key is the start bit of a mask and the value}
\PYG{l+s+sd}{              the end bit (inclusive).}

\PYG{l+s+sd}{    Returns:}
\PYG{l+s+sd}{    Masked QA in dictionary with same keys as fields}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}

    \PYG{n}{maskedQAs} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}

    \PYG{k}{for} \PYG{n}{start}\PYG{p}{,}\PYG{n}{finish} \PYG{o+ow}{in} \PYG{n}{fields}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{mask}     \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{p}{(}\PYG{n}{finish}\PYG{o}{\PYGZhy{}}\PYG{n}{start}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}
        \PYG{n}{maskedQAs}\PYG{p}{[}\PYG{n}{start}\PYG{p}{]} \PYG{o}{=} \PYG{p}{(}\PYG{n}{qa} \PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{n}{start}\PYG{p}{)} \PYG{o}{\PYGZam{}} \PYG{n}{mask}

    \PYG{k}{return} \PYG{n}{maskedQAs}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{help}\PYG{p}{(}\PYG{n}{maskedQA}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
Help on function maskedQA in module \PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}:

maskedQA(qa, fields=\PYGZob{}0: 0, 1: 1, 2: 2, 3: 4, 5: 7\PYGZcb{})
    Return a dictionary of masked QA bit fields

    Inputs:
    qa \PYGZhy{}\PYGZhy{} QA to be masked

    Keyword arguments:
    fields \PYGZhy{}\PYGZhy{} bit field dictionary (default \PYGZob{}0:0, 1:1, 2:2, 3:4, 5:7\PYGZcb{})
              Here, the key is the start bit of a mask and the value
              the end bit (inclusive).

    Returns:
    Masked QA in dictionary with same keys as fields
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} testing}

\PYG{n}{qaDict} \PYG{o}{=} \PYG{n}{maskedQA}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{n}{b11111111}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n}{qaDict}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{print} \PYG{n}{k}\PYG{p}{,}\PYG{n}{qaDict}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{,}\PYG{n+nb}{bin}\PYG{p}{(}\PYG{n}{qaDict}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
0 1 0b1
1 1 0b1
2 1 0b1
3 3 0b11
5 7 0b111
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{qaDict} \PYG{o}{=} \PYG{n}{maskedQA}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{n}{b01010101}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n}{qaDict}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{print} \PYG{n}{k}\PYG{p}{,}\PYG{n}{qaDict}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{,}\PYG{n+nb}{bin}\PYG{p}{(}\PYG{n}{qaDict}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
0 1 0b1
1 0 0b0
2 1 0b1
3 2 0b10
5 2 0b10
\end{Verbatim}


\chapter{E2. Exercises}
\label{Chapter2_Python_intro/main_answers:e2-exercises}\label{Chapter2_Python_intro/main_answers::doc}
This notebook contains answers and notes for the following exercises:
\begin{itemize}
\item {} 
{\hyperref[Chapter2_Python_intro/main_answers:Exercise_2.1]{Exercise 2.1}}
\begin{itemize}
\item {} 
{\hyperref[Chapter2_Python_intro/main_answers:Answer-2.1]{Answer 2.1}}

\end{itemize}

\item {} 
{\hyperref[Chapter2_Python_intro/main_answers:Exercise_2.2]{Exercise 2.2}}
\begin{itemize}
\item {} 
{\hyperref[Chapter2_Python_intro/main_answers:Answer-2.2]{Answer 2.2}}

\end{itemize}

\item {} 
{\hyperref[Chapter2_Python_intro/main_answers:Exercise_2.3]{Exercise 2.3}}
\begin{itemize}
\item {} 
{\hyperref[Chapter2_Python_intro/main_answers:Answer-2.3]{Answer 2.3}}

\end{itemize}

\item {} 
{\hyperref[Chapter2_Python_intro/main_answers:Exercise_2.4]{Exercise 2.4}}
\begin{itemize}
\item {} 
{\hyperref[Chapter2_Python_intro/main_answers:Answer-2.4]{Answer 2.4}}

\end{itemize}

\item {} 
{\hyperref[Chapter2_Python_intro/main_answers:Exercise_2.5]{Exercise 2.5}}
\begin{itemize}
\item {} 
{\hyperref[Chapter2_Python_intro/main_answers:Answer-2.5]{Answer 2.5}}

\end{itemize}

\item {} 
{\hyperref[Chapter2_Python_intro/main_answers:Exercise_2.6]{Exercise 2.6}}
\begin{itemize}
\item {} 
{\hyperref[Chapter2_Python_intro/main_answers:Answer-2.6]{Answer 2.6}}

\end{itemize}

\item {} 
{\hyperref[Chapter2_Python_intro/main_answers:Exercise_2.7]{Exercise 2.7}}
\begin{itemize}
\item {} 
{\hyperref[Chapter2_Python_intro/main_answers:Answer-2.7]{Answer 2.7}}

\end{itemize}

\end{itemize}


\section{Exercise 2.1}
\label{Chapter2_Python_intro/main_answers:exercise-2-1}
You were given some code:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{}!/usr/bin/env python}



\PYG{c}{\PYGZsh{} hunger threshold in hours}
\PYG{n}{hungerThreshold} \PYG{o}{=} \PYG{l+m+mf}{3.0}
\PYG{c}{\PYGZsh{} sleep threshold in hours}
\PYG{n}{sleepThreshold} \PYG{o}{=} \PYG{l+m+mf}{8.0}

\PYG{c}{\PYGZsh{} time since fed, in hours}
\PYG{n}{timeSinceFed} \PYG{o}{=} \PYG{l+m+mf}{4.0}
\PYG{c}{\PYGZsh{} time since sleep, in hours}
\PYG{n}{timeSinceSleep} \PYG{o}{=} \PYG{l+m+mf}{3.0}

\PYG{c}{\PYGZsh{} Note use of \PYGZbs{} as line continuation here}
\PYG{c}{\PYGZsh{} It is poor style to have code lines \PYGZgt{} 79 characters}
\PYG{c}{\PYGZsh{}}
\PYG{c}{\PYGZsh{} see http://www.python.org/dev/peps/pep\PYGZhy{}0008/\PYGZsh{}maximum\PYGZhy{}line\PYGZhy{}length}
\PYG{c}{\PYGZsh{}}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Tired and hungry?}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{p}{(}\PYG{n}{timeSinceSleep} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{sleepThreshold}\PYG{p}{)} \PYG{o+ow}{and} \PYGZbs{}
                            \PYG{p}{(}\PYG{n}{timeSinceFed} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{hungerThreshold}\PYG{p}{)}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Just tired?}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{p}{(}\PYG{n}{timeSinceSleep} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{sleepThreshold}\PYG{p}{)} \PYG{o+ow}{and} \PYGZbs{}
                            \PYG{p}{(}\PYG{o+ow}{not} \PYG{p}{(}\PYG{n}{timeSinceFed} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{hungerThreshold}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Just hungry?}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{p}{(}\PYG{o+ow}{not} \PYG{p}{(}\PYG{n}{timeSinceSleep} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{sleepThreshold}\PYG{p}{)}\PYG{p}{)} \PYG{o+ow}{and} \PYGZbs{}
                            \PYG{p}{(}\PYG{n}{timeSinceFed} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{hungerThreshold}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
Tired and hungry? False
Just tired? False
Just hungry? True
\end{Verbatim}

The code above works fine, but the large blocks of logical tests are not
very clear or readable, and contain repeated items.

Modify this block of code to be clearer by assigning the individual
logical tests to variables,

e.g.

\code{tired = timeSinceSleep \textgreater{}= sleepThreshold}


\section{Answer 2.1}
\label{Chapter2_Python_intro/main_answers:answer-2-1}
This is quite easily made clearer, and is also improved by making sure
you comment what you are doing.

It is normally a good idea to put some information on what the purpose
of the code is etc.

It is also a good idea if you get into the practice of describing what
changes you have made to the code from the original version that this is
based on, to give full attribution. We will see that this is important
with regard to plagiarism in coursework submission.

Hasve a look at the \href{http://www.python.org/dev/peps/pep-0008/\#code-lay-out}{Python
styleguide}
for ideas on what makes good clear code.

You wouldn't have been expected to do \emph{all} of these things (the code
below is mainly to give you some ideas for what to do next time!), but
hopefully you will have at least set the variables:

\begin{DUlineblock}{0em}
\item[] \code{tired  = (timeSinceSleep \textgreater{}= sleepThreshold)}
\item[] \code{hungry = (timeSinceFed \textgreater{}= hungerThreshold)}
\end{DUlineblock}

and used them in the code for greater clarity.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{} Exercise 2.1 Scientific Computing}

\PYG{l+s+sd}{    Thu  3 Oct 2013 10:46:58 BST}

\PYG{l+s+sd}{    P. Lewis : p.lewis@ucl.ac.uk}

\PYG{l+s+sd}{    This code prints information on whether}
\PYG{l+s+sd}{    I am tired and/or hungry.}

\PYG{l+s+sd}{    It is controlled by the variables:}
\PYG{l+s+sd}{        timeSinceFed}
\PYG{l+s+sd}{        timeSinceSleep}

\PYG{l+s+sd}{    which are checked against hunger and}
\PYG{l+s+sd}{    sleep thresholds:}
\PYG{l+s+sd}{        hungerThreshold}
\PYG{l+s+sd}{        sleepThreshold}

\PYG{l+s+sd}{    All times given as float, in hours}


\PYG{l+s+sd}{    It is a modification of the code in Exercise 2.1}
\PYG{l+s+sd}{    of Scientific Computing (https://github.com/profLewis/geogg122)}

\PYG{l+s+sd}{    Edits made from original:}
\PYG{l+s+sd}{        \PYGZhy{} added detailed comment strings}
\PYG{l+s+sd}{        \PYGZhy{} neatened up the comments}
\PYG{l+s+sd}{        \PYGZhy{} made code easier to read by setting variables}
\PYG{l+s+sd}{          tired and hungry.}
\PYG{l+s+sd}{        \PYGZhy{} added a new result for \PYGZsq{}tired or hungry\PYGZsq{}}
\PYG{l+s+sd}{        \PYGZhy{} added tabs (\PYGZbs{}t) to the print statements to get}
\PYG{l+s+sd}{          neater output formatting.}

\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}

\PYG{c}{\PYGZsh{} Thresholds}
\PYG{n}{hungerThreshold} \PYG{o}{=} \PYG{l+m+mf}{3.0}    \PYG{c}{\PYGZsh{} hunger threshold in hours}
\PYG{n}{sleepThreshold}  \PYG{o}{=} \PYG{l+m+mf}{8.0}    \PYG{c}{\PYGZsh{} sleep threshold in hours}

\PYG{c}{\PYGZsh{} Control variables}
\PYG{n}{timeSinceFed}   \PYG{o}{=} \PYG{l+m+mf}{4.0}     \PYG{c}{\PYGZsh{} time since fed, in hour}
\PYG{n}{timeSinceSleep} \PYG{o}{=} \PYG{l+m+mf}{3.0}     \PYG{c}{\PYGZsh{} time since sleep, in hours}

\PYG{c}{\PYGZsh{} logical tests for tired and hungry}
\PYG{n}{tired}  \PYG{o}{=} \PYG{p}{(}\PYG{n}{timeSinceSleep} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{sleepThreshold}\PYG{p}{)}
\PYG{n}{hungry} \PYG{o}{=} \PYG{p}{(}\PYG{n}{timeSinceFed} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{hungerThreshold}\PYG{p}{)}

\PYG{c}{\PYGZsh{} print results}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Tired and hungry?}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}  \PYG{n}{tired} \PYG{o+ow}{and} \PYG{n}{hungry}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Tired or hungry?}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{tired} \PYG{o+ow}{or} \PYG{n}{hungry}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Just tired?}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}      \PYG{n}{tired} \PYG{o+ow}{and} \PYG{o+ow}{not} \PYG{n}{hungry}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Just hungry?}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}     \PYG{n}{hungry} \PYG{o+ow}{and} \PYG{o+ow}{not} \PYG{n}{tired}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
Tired and hungry?   False
Tired or hungry?            True
Just tired?         False
Just hungry?                True
\end{Verbatim}


\section{Exercise 2.2}
\label{Chapter2_Python_intro/main_answers:exercise-2-2}

\subsection{A.}
\label{Chapter2_Python_intro/main_answers:a}
A small piece of Python code that will set the variable \code{today} to be
a string with the day of the week today is:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} This imports a module that we can use to access dates}
\PYG{k+kn}{from} \PYG{n+nn}{datetime} \PYG{k+kn}{import} \PYG{n}{datetime}

\PYG{c}{\PYGZsh{} set up a list of days of the week, starting Monday}
\PYG{c}{\PYGZsh{} Note the line continuation here with \PYGZbs{}}
\PYG{n}{week} \PYG{o}{=} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Monday}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Tuesday}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Wednesday}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Thursday}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYGZbs{}
        \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Friday}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Saturday}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Sunday}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}

\PYG{c}{\PYGZsh{} This part gives the day of the week}
\PYG{c}{\PYGZsh{} as an integer, 0 \PYGZhy{}\PYGZgt{} Monday, 1 \PYGZhy{}\PYGZgt{} Tuesday etc.}
\PYG{n}{day\PYGZus{}number} \PYG{o}{=} \PYG{n}{datetime}\PYG{o}{.}\PYG{n}{now}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{weekday}\PYG{p}{(}\PYG{p}{)}

\PYG{c}{\PYGZsh{} print item day\PYGZus{}number in the list week}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{today is}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{week}\PYG{p}{[}\PYG{n}{day\PYGZus{}number}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{today} \PYG{o+ow}{is} \PYG{n}{Tuesday}
\end{Verbatim}

Based on the example below, \textbf{set up a diary for youself for the week to
print out what you should be doing today, using the conditional
structure {}`{}`if .. elif ... else{}`{}`.}


\section{Answer 2.2}
\label{Chapter2_Python_intro/main_answers:answer-2-2}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+sd}{    Exercise 2.2A Scientific Computing}

\PYG{l+s+sd}{    Mon  7 Oct 2013 10:43:38 BST}

\PYG{l+s+sd}{    P. Lewis : p.lewis@ucl.ac.uk}

\PYG{l+s+sd}{    This code prints a diary for today.}

\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}

\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}The following code block is taken verbatim from}
\PYG{l+s+sd}{   The Scientific Computing notes}
\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{c}{\PYGZsh{} This imports a module that we can use to access dates}
\PYG{k+kn}{from} \PYG{n+nn}{datetime} \PYG{k+kn}{import} \PYG{n}{datetime}

\PYG{c}{\PYGZsh{} set up a list of days of the week, starting Monday}
\PYG{c}{\PYGZsh{} Note the line continuation here with \PYGZbs{}}
\PYG{n}{week} \PYG{o}{=} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Monday}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Tuesday}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Wednesday}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Thursday}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYGZbs{}
        \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Friday}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Saturday}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Sunday}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}

\PYG{c}{\PYGZsh{} This part gives the day of the week}
\PYG{c}{\PYGZsh{} as an integer, 0 \PYGZhy{}\PYGZgt{} Monday, 1 \PYGZhy{}\PYGZgt{} Tuesday etc.}
\PYG{n}{day\PYGZus{}number} \PYG{o}{=} \PYG{n}{datetime}\PYG{o}{.}\PYG{n}{now}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{weekday}\PYG{p}{(}\PYG{p}{)}

\PYG{c}{\PYGZsh{} print item day\PYGZus{}number in the list week}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Today is}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{week}\PYG{p}{[}\PYG{n}{day\PYGZus{}number}\PYG{p}{]}

\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}New code: my own work}
\PYG{l+s+sd}{   Following the example in the question for E2.2A}
\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}

\PYG{k}{if} \PYG{n}{day\PYGZus{}number} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:}   \PYG{c}{\PYGZsh{} Monday}
    \PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Spend the day learning Python}\PYG{l+s}{\PYGZsq{}}
\PYG{k}{elif} \PYG{n}{day\PYGZus{}number} \PYG{o}{==} \PYG{l+m+mi}{1}\PYG{p}{:} \PYG{c}{\PYGZsh{} Tuesday}
    \PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Spend the day learning Python}\PYG{l+s}{\PYGZsq{}}
\PYG{k}{elif} \PYG{n}{day\PYGZus{}number} \PYG{o}{==} \PYG{l+m+mi}{2}\PYG{p}{:} \PYG{c}{\PYGZsh{} Wednesday}
    \PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Go to Python class}\PYG{l+s}{\PYGZsq{}}
\PYG{k}{elif} \PYG{n}{day\PYGZus{}number} \PYG{o}{==} \PYG{l+m+mi}{3}\PYG{p}{:} \PYG{c}{\PYGZsh{} Thursday}
    \PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Spend the day learning Python}\PYG{l+s}{\PYGZsq{}}
\PYG{k}{elif} \PYG{n}{day\PYGZus{}number} \PYG{o}{==} \PYG{l+m+mi}{4}\PYG{p}{:} \PYG{c}{\PYGZsh{} Friday}
    \PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Spend the day learning Python}\PYG{l+s}{\PYGZsq{}}
\PYG{k}{elif} \PYG{n}{day\PYGZus{}number} \PYG{o}{==} \PYG{l+m+mi}{5}\PYG{p}{:} \PYG{c}{\PYGZsh{} Saturday}
    \PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Spend the day learning Python}\PYG{l+s}{\PYGZsq{}}
\PYG{k}{elif} \PYG{n}{day\PYGZus{}number} \PYG{o}{==} \PYG{l+m+mi}{6}\PYG{p}{:} \PYG{c}{\PYGZsh{} Sunday}
    \PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Spend the day learning Python}\PYG{l+s}{\PYGZsq{}}
\PYG{k}{else}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{get some sleep}\PYG{l+s}{\PYGZdq{}}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
Today is Tuesday
Spend the day learning Python
\end{Verbatim}

You should see from this that this is a rather awkward way to set up
something of this nature, and it is prone to error in typing (you could
easily miss a day out or type something else wrong).


\subsection{B.}
\label{Chapter2_Python_intro/main_answers:b}
You could set up the basic calendar for the week in a list, with the
first entry representing Monday, the second Tuesday etc.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{my\PYGZus{}diary} \PYG{o}{=} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Spend the day practicing Python}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYGZbs{}
            \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Spend the day practicing Python}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYGZbs{}
            \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Do some reading in the library at UCL}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYGZbs{}
            \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Remember to wake up early to get to the Python class at UCL}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYGZbs{}
            \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Spend the day practicing Python}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYGZbs{}
            \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Remember to wake up early to go to classes at Imperial College}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYGZbs{}
            \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Work at Python exercises from home}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYGZbs{}
            \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Work at Python exercises from home}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\end{Verbatim}

Using a list of this sort, \textbf{print the diary entry for today *without*
using conditional statements.}

Criticise the code you develop and make suggestions for improvement.


\subsubsection{Answer}
\label{Chapter2_Python_intro/main_answers:answer}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+sd}{    Exercise 2.2B Scientific Computing}

\PYG{l+s+sd}{    Mon  7 Oct 2013 10:43:38 BST}

\PYG{l+s+sd}{    P. Lewis : p.lewis@ucl.ac.uk}

\PYG{l+s+sd}{    This code prints a diary for today.}

\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}

\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}The following code block is taken verbatim from}
\PYG{l+s+sd}{   The Scientific Computing notes}
\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{c}{\PYGZsh{} This imports a module that we can use to access dates}
\PYG{k+kn}{from} \PYG{n+nn}{datetime} \PYG{k+kn}{import} \PYG{n}{datetime}

\PYG{c}{\PYGZsh{} set up a list of days of the week, starting Monday}
\PYG{c}{\PYGZsh{} Note the line continuation here with \PYGZbs{}}
\PYG{n}{week} \PYG{o}{=} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Monday}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Tuesday}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Wednesday}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Thursday}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYGZbs{}
        \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Friday}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Saturday}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Sunday}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}

\PYG{c}{\PYGZsh{} This part gives the day of the week}
\PYG{c}{\PYGZsh{} as an integer, 0 \PYGZhy{}\PYGZgt{} Monday, 1 \PYGZhy{}\PYGZgt{} Tuesday etc.}
\PYG{n}{day\PYGZus{}number} \PYG{o}{=} \PYG{n}{datetime}\PYG{o}{.}\PYG{n}{now}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{weekday}\PYG{p}{(}\PYG{p}{)}

\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}New code: my own work}
\PYG{l+s+sd}{   Following the example in the question for E2.2B}
\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}

\PYG{n}{my\PYGZus{}diary} \PYG{o}{=} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{spend the day doing Python}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYGZbs{}
            \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{do some reading in the library at UCL}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYGZbs{}
            \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{remember to wake up early to get to the Python class at UCL}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYGZbs{}
            \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{spend the day doing Python}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYGZbs{}
            \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{remember to wake up early to go to classes at Imperial College}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYGZbs{}
            \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{work at Python exercises from home}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYGZbs{}
            \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{work at Python exercises from home}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}


\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Today is}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{week}\PYG{p}{[}\PYG{n}{day\PYGZus{}number}\PYG{p}{]}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{so}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{my\PYGZus{}diary}\PYG{p}{[}\PYG{n}{day\PYGZus{}number}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
Today is Tuesday so do some reading in the library at UCL
\end{Verbatim}

This is a bit better, but it's still too easy to get the entries in the
list wrong, or get confused that Monday is day 0, so we would typically
use a dictionary (\code{dict}) for something of this nature.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+sd}{    Exercise 2.2B Scientific Computing}

\PYG{l+s+sd}{    Mon  7 Oct 2013 10:43:38 BST}

\PYG{l+s+sd}{    P. Lewis : p.lewis@ucl.ac.uk}

\PYG{l+s+sd}{    This code prints a diary for today.}

\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}

\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}The following code block is taken verbatim from}
\PYG{l+s+sd}{   The Scientific Computing notes}
\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{c}{\PYGZsh{} This imports a module that we can use to access dates}
\PYG{k+kn}{from} \PYG{n+nn}{datetime} \PYG{k+kn}{import} \PYG{n}{datetime}

\PYG{c}{\PYGZsh{} This part gives the day of the week}
\PYG{c}{\PYGZsh{} as an integer, 0 \PYGZhy{}\PYGZgt{} Monday, 1 \PYGZhy{}\PYGZgt{} Tuesday etc.}
\PYG{n}{day\PYGZus{}number} \PYG{o}{=} \PYG{n}{datetime}\PYG{o}{.}\PYG{n}{now}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{weekday}\PYG{p}{(}\PYG{p}{)}

\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}New code: my own work}
\PYG{l+s+sd}{   Following the example in the question for E2.2B}
\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}

\PYG{n}{week} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{0}\PYG{p}{:} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Monday}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYGZbs{}
        \PYG{l+m+mi}{1}\PYG{p}{:} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Tuesday}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYGZbs{}
        \PYG{l+m+mi}{2}\PYG{p}{:} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Wednesday}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYGZbs{}
        \PYG{l+m+mi}{3}\PYG{p}{:} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Thursday}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYGZbs{}
        \PYG{l+m+mi}{4}\PYG{p}{:} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Friday}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYGZbs{}
        \PYG{l+m+mi}{5}\PYG{p}{:} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Saturday}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYGZbs{}
        \PYG{l+m+mi}{6}\PYG{p}{:} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Sunday}\PYG{l+s}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}


\PYG{n}{my\PYGZus{}diary} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Monday}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}    \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{spend the day doing Python}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYGZbs{}
            \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Tuesday}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}   \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{do some reading in the library at UCL}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYGZbs{}
            \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Wednesday}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{remember to wake up early to get to the Python class at UCL}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYGZbs{}
            \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Thursday}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}  \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{spend the day doing Python}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYGZbs{}
            \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Friday}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}    \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{remember to wake up early to go to classes at Imperial College}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYGZbs{}
            \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Saturday}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}  \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{work at Python exercises from home}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYGZbs{}
            \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Sunday}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}    \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{work at Python exercises from home}\PYG{l+s}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}

\PYG{n}{today} \PYG{o}{=} \PYG{n}{week}\PYG{p}{[}\PYG{n}{day\PYGZus{}number}\PYG{p}{]}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Today is}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{today}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{so}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{my\PYGZus{}diary}\PYG{p}{[}\PYG{n}{today}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
Today is Tuesday so do some reading in the library at UCL
\end{Verbatim}


\section{Exercise 2.3}
\label{Chapter2_Python_intro/main_answers:exercise-2-3}
The data below are fields of:

\begin{DUlineblock}{0em}
\item[] 0 year
\item[] 1 month
\item[] 2 tmax (degC)
\item[] 3 tmin (degC)
\item[] 4 air frost (days)
\item[] 5 rain (mm)
\item[] 6 sun (hours)
\end{DUlineblock}

for Lowestoft in the UK for the year 2012, taken from \href{http://www.metoffice.gov.uk/climate/uk/stationdata/lowestoftdata.txt}{Met Office
data}.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{data} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}\PYG{l+s}{   2012   1    8.7    3.1      5   33.1   53.9}
\PYG{l+s}{   2012   2    7.1    1.6     13   13.8   86.6}
\PYG{l+s}{   2012   3   11.3    3.7      2   64.2  141.3}
\PYG{l+s}{   2012   4   10.9    4.3      3  108.9  151.1}
\PYG{l+s}{   2012   5   15.1    8.6      0   46.6  171.3}
\PYG{l+s}{   2012   6   17.9   10.9      0   74.4  189.0}
\PYG{l+s}{   2012   7   20.3   12.8      0   93.6  206.9}
\PYG{l+s}{   2012   8   22.0   14.0      0   59.6  217.3}
\PYG{l+s}{   2012   9   18.9    9.5      0   38.8  200.8}
\PYG{l+s}{   2012  10   13.6    7.9      0   92.7   94.7}
\PYG{l+s}{   2012  11   10.5    4.4      2   62.1   79.6}
\PYG{l+s}{   2012  12    7.9    2.4      8   95.6   41.9  }\PYG{l+s}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}

\PYG{k}{print} \PYG{n}{data}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
2012   1    8.7    3.1      5   33.1   53.9
2012   2    7.1    1.6     13   13.8   86.6
2012   3   11.3    3.7      2   64.2  141.3
2012   4   10.9    4.3      3  108.9  151.1
2012   5   15.1    8.6      0   46.6  171.3
2012   6   17.9   10.9      0   74.4  189.0
2012   7   20.3   12.8      0   93.6  206.9
2012   8   22.0   14.0      0   59.6  217.3
2012   9   18.9    9.5      0   38.8  200.8
2012  10   13.6    7.9      0   92.7   94.7
2012  11   10.5    4.4      2   62.1   79.6
2012  12    7.9    2.4      8   95.6   41.9
\end{Verbatim}

You can use the Python package \code{pylab} to simply plot data on a graph:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} import the pylab module}
\PYG{k+kn}{import} \PYG{n+nn}{pylab} \PYG{k+kn}{as} \PYG{n+nn}{plt}

\PYG{c}{\PYGZsh{} some e.g. x and y data}
\PYG{n}{x} \PYG{o}{=} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}
\PYG{n}{y} \PYG{o}{=} \PYG{p}{[}\PYG{n}{i}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mf}{0.5} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{x}\PYG{p}{]}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{x}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{y}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Plot of sqrt(x)}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.text.Text at 0x106501890\PYGZgt{}
\end{Verbatim}

\includegraphics{main_answers_29_1.png}

\textbf{Produce a plot of the number of sunshine hours for Lowestoft for the
year 2012} using the data given above.

Hint: the data have newline chcracters \code{\textbackslash{}n} at the end of each line of
data, and are separated by white space withion each line.


\section{Answer 2.3}
\label{Chapter2_Python_intro/main_answers:answer-2-3}
First, we need to split the string \code{data} by newline (\code{\textbackslash{}n}) to give
a list of lines:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{ldata} \PYG{o}{=} \PYG{n}{data}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{k}{print} \PYG{n}{ldata}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{   2012   1    8.7    3.1      5   33.1   53.9}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{   2012   2    7.1    1.6     13   13.8   86.6}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{   2012   3   11.3    3.7      2   64.2  141.3}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{   2012   4   10.9    4.3      3  108.9  151.1}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{   2012   5   15.1    8.6      0   46.6  171.3}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{   2012   6   17.9   10.9      0   74.4  189.0}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{   2012   7   20.3   12.8      0   93.6  206.9}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{   2012   8   22.0   14.0      0   59.6  217.3}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{   2012   9   18.9    9.5      0   38.8  200.8}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{   2012  10   13.6    7.9      0   92.7   94.7}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{   2012  11   10.5    4.4      2   62.1   79.6  }\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{   2012  12    7.9    2.4      8   95.6   41.9  }\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\end{Verbatim}

Next, we need to loop over each line and split by whitespace.

This will involve something like:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} example using first line}
\PYG{n}{this\PYGZus{}line} \PYG{o}{=} \PYG{n}{ldata}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{items} \PYG{o}{=} \PYG{n}{this\PYGZus{}line}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{items}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{2012}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{1}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{8.7}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{3.1}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{5}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{33.1}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{53.9}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{ldata} \PYG{o}{=} \PYG{n}{data}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{c}{\PYGZsh{} set empty lists to put the data in}
\PYG{n}{x} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{y} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}

\PYG{k}{for} \PYG{n}{this\PYGZus{}line} \PYG{o+ow}{in} \PYG{n}{ldata}\PYG{p}{:}
    \PYG{n}{items} \PYG{o}{=} \PYG{n}{this\PYGZus{}line}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)}
    \PYG{c}{\PYGZsh{} convert from string to float}
    \PYG{n}{x}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb}{float}\PYG{p}{(}\PYG{n}{items}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)} \PYG{c}{\PYGZsh{} the month}
    \PYG{n}{y}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb}{float}\PYG{p}{(}\PYG{n}{items}\PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)} \PYG{c}{\PYGZsh{} sunshine hrs}

\PYG{k}{print} \PYG{n}{x}
\PYG{k}{print} \PYG{n}{y}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{l+m+mf}{1.0}\PYG{p}{,} \PYG{l+m+mf}{2.0}\PYG{p}{,} \PYG{l+m+mf}{3.0}\PYG{p}{,} \PYG{l+m+mf}{4.0}\PYG{p}{,} \PYG{l+m+mf}{5.0}\PYG{p}{,} \PYG{l+m+mf}{6.0}\PYG{p}{,} \PYG{l+m+mf}{7.0}\PYG{p}{,} \PYG{l+m+mf}{8.0}\PYG{p}{,} \PYG{l+m+mf}{9.0}\PYG{p}{,} \PYG{l+m+mf}{10.0}\PYG{p}{,} \PYG{l+m+mf}{11.0}\PYG{p}{,} \PYG{l+m+mf}{12.0}\PYG{p}{]}
\PYG{p}{[}\PYG{l+m+mf}{53.9}\PYG{p}{,} \PYG{l+m+mf}{86.6}\PYG{p}{,} \PYG{l+m+mf}{141.3}\PYG{p}{,} \PYG{l+m+mf}{151.1}\PYG{p}{,} \PYG{l+m+mf}{171.3}\PYG{p}{,} \PYG{l+m+mf}{189.0}\PYG{p}{,} \PYG{l+m+mf}{206.9}\PYG{p}{,} \PYG{l+m+mf}{217.3}\PYG{p}{,} \PYG{l+m+mf}{200.8}\PYG{p}{,} \PYG{l+m+mf}{94.7}\PYG{p}{,} \PYG{l+m+mf}{79.6}\PYG{p}{,} \PYG{l+m+mf}{41.9}\PYG{p}{]}
\end{Verbatim}

Now we just need to plot it:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} import the pylab module}
\PYG{k+kn}{import} \PYG{n+nn}{pylab} \PYG{k+kn}{as} \PYG{n+nn}{plt}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{month of 2012}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Sunshine hours}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Sunshine hours for Lowestoft, UK, 2012}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.text.Text at 0x106499550\PYGZgt{}
\end{Verbatim}

\includegraphics{main_answers_38_1.png}

We could make it a bit more compact and general, but if you do, make
sure it is still easily readable.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{pylab} \PYG{k+kn}{as} \PYG{n+nn}{plt}

\PYG{n}{items} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{n+nb}{float}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)} \PYGZbs{}
            \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{j}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]} \PYGZbs{}
                \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n}{data}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{]}

\PYG{c}{\PYGZsh{} get specific columns from items}
\PYG{n}{x} \PYG{o}{=} \PYG{p}{[}\PYG{n}{i}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{items}\PYG{p}{]}
\PYG{n}{y} \PYG{o}{=} \PYG{p}{[}\PYG{n}{i}\PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{]} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{items}\PYG{p}{]}

\PYG{c}{\PYGZsh{} bigger graph if we want}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{14}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{month of 2012}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Sunshine hours}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Sunshine hours for Lowestoft, UK, 2012}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.text.Text at 0x106787510\PYGZgt{}
\end{Verbatim}

\includegraphics{main_answers_40_1.png}

You \emph{might think} that labelling with the month name would be nicer.

Thats quite a bit more complicated, but we'll put it in here anyway for
future reference:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{pylab} \PYG{k+kn}{as} \PYG{n+nn}{plt}

\PYG{n}{items} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{n+nb}{float}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)} \PYGZbs{}
            \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{j}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]} \PYGZbs{}
                \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n}{data}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{]}

\PYG{c}{\PYGZsh{} get specific columns from items}
\PYG{n}{x} \PYG{o}{=} \PYG{p}{[}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{i}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{items}\PYG{p}{]}
\PYG{n}{y} \PYG{o}{=} \PYG{p}{[}\PYG{n}{i}\PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{]} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{items}\PYG{p}{]}

\PYG{n}{months} \PYG{o}{=} \PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Jan}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Feb}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Mar}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Apr}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYGZbs{}
    \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{May}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Jun}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Jul}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Aug}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Sep}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Oct}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Nov}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Dec}\PYG{l+s}{\PYGZdq{}} \PYG{p}{]}

\PYG{c}{\PYGZsh{} need access to ax to mess with xticks}
\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{14}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{)}

\PYG{c}{\PYGZsh{} lots of hassle to do this sort of thing ...}
\PYG{c}{\PYGZsh{} but it is possible}
\PYG{c}{\PYGZsh{}}
\PYG{c}{\PYGZsh{} first set the limits to be the}
\PYG{c}{\PYGZsh{} same as x}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlim}\PYG{p}{(}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{x}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{c}{\PYGZsh{} then set the xticks to the values of x}
\PYG{c}{\PYGZsh{} to make sure there are 12 of them}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xticks}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
\PYG{c}{\PYGZsh{} then replace these by the months}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xticklabels}\PYG{p}{(}\PYG{n}{months}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{month of 2012}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Sunshine hours}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Sunshine hours for Lowestoft, UK, 2012}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.text.Text at 0x106855110\PYGZgt{}
\end{Verbatim}

\includegraphics{main_answers_42_1.png}


\section{Exercise 2.4}
\label{Chapter2_Python_intro/main_answers:exercise-2-4}
The text file
files/data/modis\_files.txt contains a
listing of hdf format files that are in the directory
\code{/data/geospatial\_19/ucfajlg/fire/Angola/MOD09} on the UCL Geography
system. The contents of the file looks like (first 10 lines):

\begin{Verbatim}[commandchars=\\\{\}]
!head \PYGZhy{}10 \PYGZlt{} files/data/modis\PYGZus{}files.txt
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
/data/geospatial\PYGZus{}19/ucfajlg/fire/Angola/MOD09/MOD09GA.A2004001.h19v10.005.2008109063923.hdf
/data/geospatial\PYGZus{}19/ucfajlg/fire/Angola/MOD09/MOD09GA.A2004002.h19v10.005.2008108084250.hdf
/data/geospatial\PYGZus{}19/ucfajlg/fire/Angola/MOD09/MOD09GA.A2004003.h19v10.005.2008108054126.hdf
/data/geospatial\PYGZus{}19/ucfajlg/fire/Angola/MOD09/MOD09GA.A2004004.h19v10.005.2008108112322.hdf
/data/geospatial\PYGZus{}19/ucfajlg/fire/Angola/MOD09/MOD09GA.A2004005.h19v10.005.2008108173219.hdf
/data/geospatial\PYGZus{}19/ucfajlg/fire/Angola/MOD09/MOD09GA.A2004006.h19v10.005.2008108214033.hdf
/data/geospatial\PYGZus{}19/ucfajlg/fire/Angola/MOD09/MOD09GA.A2004007.h19v10.005.2008109081257.hdf
/data/geospatial\PYGZus{}19/ucfajlg/fire/Angola/MOD09/MOD09GA.A2004008.h19v10.005.2008109111447.hdf
/data/geospatial\PYGZus{}19/ucfajlg/fire/Angola/MOD09/MOD09GA.A2004009.h19v10.005.2008109211421.hdf
/data/geospatial\PYGZus{}19/ucfajlg/fire/Angola/MOD09/MOD09GA.A2004010.h19v10.005.2008110031925.hdf
\end{Verbatim}

Your task is to create a new file \code{files/data/some\_modis\_files.txt}
that contains \emph{only} the file names for the month of August.

You will notice that the file names have a field in them such as
\code{A2004006}. This is the one you will need to concentrate on, as it
specifies the year (\code{2004} here) and the day of year (\code{doy}),
(\code{006} in this example).

There are various ways to find the day of year for a particular month /
year, e,g, look on a
\href{http://www.soils.wisc.edu/cgi-bin/asig/doyCal.rb}{website}.


\section{Answer 2.4}
\label{Chapter2_Python_intro/main_answers:answer-2-4}
First then, find out which day of year range you want.

August 2004 was doy 214 to 244 inclusive, so in python:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{214}\PYG{p}{,}\PYG{l+m+mi}{245}\PYG{p}{)}
\end{Verbatim}

We should know how to read data from files from the material above.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} ls /data/geospatial\PYGZus{}19/ucfajlg/fire/Angola/MOD09/*.hdf \PYGZgt{} /tmp/modis\PYGZus{}files.txt}
\PYG{n}{fp} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/modis\PYGZus{}files.txt}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n}{fp}\PYG{o}{.}\PYG{n}{readlines}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{print} \PYG{n}{line}
    \PYG{k}{break}   \PYG{c}{\PYGZsh{} break in here just so it doesnt print too much}
            \PYG{c}{\PYGZsh{} dont put that in your code !!!}
\PYG{n}{fp}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
/data/geospatial\PYGZus{}19/ucfajlg/fire/Angola/MOD09/MOD09GA.A2004001.h19v10.005.2008109063923.hdf
\end{Verbatim}

we have the filename e.g.

\code{/data/geospatial\_19/ucfajlg/fire/Angola/MOD09/MOD09GA.A2004001.h19v10.005.2008109063923.hdf}

in the variable \code{line}.

Now we want to split this to find the filename, which will be the last
element (-1):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} split the string on \PYGZsq{}/\PYGZsq{}, the file separator}
\PYG{n}{aline} \PYG{o}{=} \PYG{n}{line}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{aline}
\end{Verbatim}
\begin{alltt}
{[}'`, `data', `geospatial\_19', `ucfajlg', `fire', `Angola', `MOD09', `MOD09GA.A2004001.h19v10.005.2008109063923.hdfn'{]}
\end{alltt}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} and all we want is the last item:}

\PYG{n}{fname} \PYG{o}{=} \PYG{n}{line}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{k}{print} \PYG{n}{fname}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
MOD09GA.A2004001.h19v10.005.2008109063923.hdf
\end{Verbatim}

Now we need to split this up, with \code{.} (dot) as the separator, and get
the second item:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{fname} \PYG{o}{=} \PYG{n}{line}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{fbits} \PYG{o}{=} \PYG{n}{fname}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{.}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{fbits}

\PYG{n}{datebit} \PYG{o}{=} \PYG{n}{fbits}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{k}{print} \PYG{n}{datebit}
\end{Verbatim}
\begin{alltt}
{[}'MOD09GA', `A2004001', `h19v10', `005', `2008109063923', `hdfn'{]}
A2004001
\end{alltt}

The day of year is the last 3 elements of this string:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{doy} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{datebit}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{:}\PYG{p}{]}\PYG{p}{)}

\PYG{k}{print} \PYG{n}{doy}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{1}
\end{Verbatim}

And check to see if doy is in the required range:

Putting this together:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{date\PYGZus{}range} \PYG{o}{=} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{214}\PYG{p}{,}\PYG{l+m+mi}{245}\PYG{p}{)}

\PYG{c}{\PYGZsh{} ls /data/geospatial\PYGZus{}19/ucfajlg/fire/Angola/MOD09/*.hdf \PYGZgt{} /tmp/modis\PYGZus{}files.txt}
\PYG{n}{fp} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/modis\PYGZus{}files.txt}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n}{fp}\PYG{o}{.}\PYG{n}{readlines}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{fname} \PYG{o}{=} \PYG{n}{line}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
    \PYG{n}{fbits} \PYG{o}{=} \PYG{n}{fname}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{.}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{datebit} \PYG{o}{=} \PYG{n}{fbits}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
    \PYG{n}{doy} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{datebit}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{:}\PYG{p}{]}\PYG{p}{)}
    \PYG{k}{if} \PYG{n}{doy} \PYG{o+ow}{in} \PYG{n}{date\PYGZus{}range}\PYG{p}{:}
        \PYG{k}{print} \PYG{n}{line}
        \PYG{k}{break}
\PYG{n}{fp}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
/data/geospatial\PYGZus{}19/ucfajlg/fire/Angola/MOD09/MOD09GA.A2004214.h19v10.005.2010052095834.hdf
\end{Verbatim}

Now put in the part that writes it to a file:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{ifile} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/modis\PYGZus{}files.txt}\PYG{l+s}{\PYGZsq{}}
\PYG{n}{ofile} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/some\PYGZus{}modis\PYGZus{}files.txt}\PYG{l+s}{\PYGZsq{}}

\PYG{n}{ifp} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{ifile}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ofp} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{ofile}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{w}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n}{ifp}\PYG{o}{.}\PYG{n}{readlines}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{fname} \PYG{o}{=} \PYG{n}{line}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
    \PYG{n}{fbits} \PYG{o}{=} \PYG{n}{fname}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{.}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{datebit} \PYG{o}{=} \PYG{n}{fbits}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
    \PYG{n}{doy} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{datebit}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{:}\PYG{p}{]}\PYG{p}{)}
    \PYG{k}{if} \PYG{n}{doy} \PYG{o+ow}{in} \PYG{n}{date\PYGZus{}range}\PYG{p}{:}
        \PYG{n}{ofp}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n}{line}\PYG{p}{)}
\PYG{n}{ifp}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{ofp}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} or in a more compressed form}

\PYG{n}{ifile} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/modis\PYGZus{}files.txt}\PYG{l+s}{\PYGZsq{}}
\PYG{n}{ofile} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/some\PYGZus{}modis\PYGZus{}files.txt}\PYG{l+s}{\PYGZsq{}}

\PYG{n}{ifp} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{ifile}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ofp} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{ofile}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{w}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n}{ifp}\PYG{o}{.}\PYG{n}{readlines}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{doy} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{line}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{.}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{:}\PYG{p}{]}\PYG{p}{)}
    \PYG{k}{if} \PYG{n}{doy} \PYG{o+ow}{in} \PYG{n}{date\PYGZus{}range}\PYG{p}{:}
        \PYG{n}{ofp}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n}{line}\PYG{p}{)}
\PYG{n}{ifp}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{ofp}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

check from unix:

\begin{Verbatim}[commandchars=\\\{\}]
!head \PYGZhy{}1 \PYGZlt{} files/data/some\PYGZus{}modis\PYGZus{}files.txt
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
/data/geospatial\PYGZus{}19/ucfajlg/fire/Angola/MOD09/MOD09GA.A2004214.h19v10.005.2010052095834.hdf
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
!tail \PYGZhy{}1 \PYGZlt{} files/data/some\PYGZus{}modis\PYGZus{}files.txt
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
/data/geospatial\PYGZus{}19/ucfajlg/fire/Angola/MOD09/MOD09GA.A2004244.h19v10.005.2008256095130.hdf
\end{Verbatim}


\section{Exercise 2.5}
\label{Chapter2_Python_intro/main_answers:exercise-2-5}
We want to calculate the \textbf{maximum} monthly precipitation for regions
of the UK for all years in the 20th Century.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} specify filename}
\PYG{n}{filename} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/HadSEEP\PYGZus{}monthly\PYGZus{}qc.txt}\PYG{l+s}{\PYGZsq{}}

\PYG{c}{\PYGZsh{} read the data, chop off first 4 lines}
\PYG{c}{\PYGZsh{} and store in required\PYGZus{}data}
\PYG{n}{fp} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{raw\PYGZus{}data} \PYG{o}{=} \PYG{n}{fp}\PYG{o}{.}\PYG{n}{readlines}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{fp}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{required\PYGZus{}data} \PYG{o}{=} \PYG{n}{raw\PYGZus{}data}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{:}\PYG{p}{]}

\PYG{c}{\PYGZsh{} set up list to store data in}
\PYG{n}{data} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}


\PYG{c}{\PYGZsh{} loop over each line}
\PYG{k}{for} \PYG{n}{line\PYGZus{}data} \PYG{o+ow}{in} \PYG{n}{required\PYGZus{}data}\PYG{p}{:}
    \PYG{c}{\PYGZsh{} split on white space}
    \PYG{n}{year\PYGZus{}data} \PYG{o}{=} \PYG{n}{line\PYGZus{}data}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)}

    \PYG{c}{\PYGZsh{} convert data to float}
    \PYG{k}{for} \PYG{n}{column}\PYG{p}{,}\PYG{n}{this\PYGZus{}element} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{year\PYGZus{}data}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{year\PYGZus{}data}\PYG{p}{[}\PYG{n}{column}\PYG{p}{]} \PYG{o}{=} \PYG{n+nb}{float}\PYG{p}{(}\PYG{n}{this\PYGZus{}element}\PYG{p}{)}
    \PYG{n}{data}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{year\PYGZus{}data}\PYG{p}{)}


\PYG{c}{\PYGZsh{} select years}
\PYG{n}{c20\PYGZus{}data} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n}{data}\PYG{p}{:}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{line}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{1900}\PYG{p}{)} \PYG{o+ow}{and} \PYG{p}{(}\PYG{n}{line}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{2000}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{c20\PYGZus{}data}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{line}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Aside: show which month that was}
\PYG{n}{month\PYGZus{}names} \PYG{o}{=} \PYG{p}{[} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Jan}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Feb}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Mar}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Apr}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYGZbs{}
    \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{May}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Jun}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Jul}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Aug}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Sep}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Oct}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Nov}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Dec}\PYG{l+s}{\PYGZdq{}} \PYG{p}{]}

\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{In South East England}\PYG{l+s}{\PYGZdq{}}
\PYG{k}{for} \PYG{n}{row} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{100}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{year} \PYG{o}{=} \PYG{l+m+mi}{1900} \PYG{o}{+} \PYG{n}{row}
    \PYG{n}{max\PYGZus{}precip} \PYG{o}{=} \PYG{n+nb}{max}\PYG{p}{(}\PYG{n}{c20\PYGZus{}data}\PYG{p}{[}\PYG{n}{row}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{month} \PYG{o}{=} \PYG{n}{c20\PYGZus{}data}\PYG{p}{[}\PYG{n}{row}\PYG{p}{]}\PYG{o}{.}\PYG{n}{index}\PYG{p}{(}\PYG{n}{max\PYGZus{}precip}\PYG{p}{)}

    \PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{In the year}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{year}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{the rainiest month was}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{month\PYGZus{}names}\PYG{p}{[}\PYG{n}{month}\PYG{p}{]}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{with}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{max\PYGZus{}precip}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{mm}\PYG{l+s}{\PYGZdq{}}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
In South East England
In the year 1900 the rainiest month was Feb with 125.9 mm
In the year 1901 the rainiest month was Dec with 98.7 mm
In the year 1902 the rainiest month was Aug with 97.2 mm
In the year 1903 the rainiest month was Oct with 188.4 mm
In the year 1904 the rainiest month was Jan with 96.0 mm
In the year 1905 the rainiest month was Jun with 104.5 mm
In the year 1906 the rainiest month was Jan with 127.3 mm
In the year 1907 the rainiest month was Oct with 129.5 mm
In the year 1908 the rainiest month was Aug with 83.8 mm
In the year 1909 the rainiest month was Oct with 143.9 mm
In the year 1910 the rainiest month was Dec with 119.4 mm
In the year 1911 the rainiest month was Dec with 153.6 mm
In the year 1912 the rainiest month was Aug with 151.6 mm
In the year 1913 the rainiest month was Oct with 106.5 mm
In the year 1914 the rainiest month was Dec with 190.2 mm
In the year 1915 the rainiest month was Dec with 163.9 mm
In the year 1916 the rainiest month was Mar with 110.7 mm
In the year 1917 the rainiest month was Aug with 135.1 mm
In the year 1918 the rainiest month was Sep with 151.1 mm
In the year 1919 the rainiest month was Dec with 121.4 mm
In the year 1920 the rainiest month was Jul with 116.9 mm
In the year 1921 the rainiest month was Jan with 70.8 mm
In the year 1922 the rainiest month was Jul with 92.2 mm
In the year 1923 the rainiest month was Oct with 142.5 mm
In the year 1924 the rainiest month was Oct with 110.2 mm
In the year 1925 the rainiest month was Jul with 98.1 mm
In the year 1926 the rainiest month was Nov with 143.8 mm
In the year 1927 the rainiest month was Sep with 138.5 mm
In the year 1928 the rainiest month was Oct with 137.0 mm
In the year 1929 the rainiest month was Nov with 175.6 mm
In the year 1930 the rainiest month was Nov with 121.0 mm
In the year 1931 the rainiest month was Aug with 101.3 mm
In the year 1932 the rainiest month was Oct with 146.4 mm
In the year 1933 the rainiest month was Mar with 74.1 mm
In the year 1934 the rainiest month was Dec with 176.3 mm
In the year 1935 the rainiest month was Nov with 148.2 mm
In the year 1936 the rainiest month was Jan with 112.8 mm
In the year 1937 the rainiest month was Jan with 124.9 mm
In the year 1938 the rainiest month was Nov with 93.6 mm
In the year 1939 the rainiest month was Oct with 154.0 mm
In the year 1940 the rainiest month was Nov with 203.0 mm
In the year 1941 the rainiest month was Aug with 117.3 mm
In the year 1942 the rainiest month was Oct with 94.3 mm
In the year 1943 the rainiest month was Jan with 130.2 mm
In the year 1944 the rainiest month was Nov with 117.0 mm
In the year 1945 the rainiest month was Jul with 103.8 mm
In the year 1946 the rainiest month was Nov with 126.7 mm
In the year 1947 the rainiest month was Mar with 150.7 mm
In the year 1948 the rainiest month was Jan with 125.3 mm
In the year 1949 the rainiest month was Oct with 189.3 mm
In the year 1950 the rainiest month was Nov with 137.9 mm
In the year 1951 the rainiest month was Nov with 161.9 mm
In the year 1952 the rainiest month was Nov with 99.9 mm
In the year 1953 the rainiest month was Jul with 87.5 mm
In the year 1954 the rainiest month was Nov with 131.0 mm
In the year 1955 the rainiest month was May with 110.5 mm
In the year 1956 the rainiest month was Jan with 113.7 mm
In the year 1957 the rainiest month was Feb with 97.7 mm
In the year 1958 the rainiest month was Sep with 107.4 mm
In the year 1959 the rainiest month was Dec with 143.4 mm
In the year 1960 the rainiest month was Oct with 167.0 mm
In the year 1961 the rainiest month was Dec with 102.0 mm
In the year 1962 the rainiest month was Sep with 94.0 mm
In the year 1963 the rainiest month was Nov with 141.0 mm
In the year 1964 the rainiest month was Mar with 97.7 mm
In the year 1965 the rainiest month was Dec with 126.9 mm
In the year 1966 the rainiest month was Oct with 129.1 mm
In the year 1967 the rainiest month was Oct with 126.6 mm
In the year 1968 the rainiest month was Sep with 135.5 mm
In the year 1969 the rainiest month was Nov with 108.4 mm
In the year 1970 the rainiest month was Nov with 186.4 mm
In the year 1971 the rainiest month was Jun with 134.4 mm
In the year 1972 the rainiest month was Dec with 94.0 mm
In the year 1973 the rainiest month was May with 76.6 mm
In the year 1974 the rainiest month was Sep with 164.7 mm
In the year 1975 the rainiest month was Sep with 122.8 mm
In the year 1976 the rainiest month was Oct with 141.5 mm
In the year 1977 the rainiest month was Aug with 132.8 mm
In the year 1978 the rainiest month was Dec with 144.9 mm
In the year 1979 the rainiest month was Dec with 122.6 mm
In the year 1980 the rainiest month was Oct with 110.1 mm
In the year 1981 the rainiest month was Mar with 131.2 mm
In the year 1982 the rainiest month was Oct with 143.0 mm
In the year 1983 the rainiest month was May with 98.5 mm
In the year 1984 the rainiest month was Jan with 112.4 mm
In the year 1985 the rainiest month was Dec with 103.7 mm
In the year 1986 the rainiest month was Jan with 110.1 mm
In the year 1987 the rainiest month was Oct with 198.7 mm
In the year 1988 the rainiest month was Jan with 143.8 mm
In the year 1989 the rainiest month was Dec with 143.8 mm
In the year 1990 the rainiest month was Feb with 122.3 mm
In the year 1991 the rainiest month was Jun with 102.0 mm
In the year 1992 the rainiest month was Nov with 132.8 mm
In the year 1993 the rainiest month was Dec with 133.9 mm
In the year 1994 the rainiest month was Jan with 115.6 mm
In the year 1995 the rainiest month was Jan with 143.1 mm
In the year 1996 the rainiest month was Nov with 122.6 mm
In the year 1997 the rainiest month was Jun with 100.6 mm
In the year 1998 the rainiest month was Oct with 128.1 mm
In the year 1999 the rainiest month was Dec with 109.5 mm
\end{Verbatim}

That is quite an achievement, given the limited amount of programming
you know so far.

If you go through this though, you will (should) see that it is really
not very efficient.

For example:

\begin{Verbatim}[commandchars=\\\{\}]
we read all the data in and then filter out the years we want (what if the dataset were huge?)
we loop over the 100 years multiple times
we store intermediate results
\end{Verbatim}

For this exercise, you should look through the code we developed and try
to make it more efficient.

Efficiency should not override clarity and understanding though, so make
sure you can understand what is going on at each stage.


\section{Answer 2.5}
\label{Chapter2_Python_intro/main_answers:answer-2-5}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} specify filename}
\PYG{n}{filename} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/HadSEEP\PYGZus{}monthly\PYGZus{}qc.txt}\PYG{l+s}{\PYGZsq{}}

\PYG{n}{fp} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{c}{\PYGZsh{} years range}
\PYG{n}{years} \PYG{o}{=} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1900}\PYG{p}{,}\PYG{l+m+mi}{2000}\PYG{p}{)}

\PYG{c}{\PYGZsh{} set up list to store data in}
\PYG{n}{c20\PYGZus{}data} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}

\PYG{c}{\PYGZsh{} loop over each line}
\PYG{k}{for} \PYG{n}{line\PYGZus{}data} \PYG{o+ow}{in} \PYG{n}{fp}\PYG{o}{.}\PYG{n}{readlines}\PYG{p}{(}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{:}\PYG{p}{]}\PYG{p}{:}
    \PYG{c}{\PYGZsh{} split on white space}
    \PYG{c}{\PYGZsh{} convert data to float}
    \PYG{n}{year\PYGZus{}data} \PYG{o}{=} \PYG{p}{[}\PYG{n+nb}{float}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{line\PYGZus{}data}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}

    \PYG{k}{if} \PYG{n}{year\PYGZus{}data}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o+ow}{in} \PYG{n}{years}\PYG{p}{:}
        \PYG{n}{c20\PYGZus{}data}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{year\PYGZus{}data}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Aside: show which month that was}
\PYG{n}{month\PYGZus{}names} \PYG{o}{=} \PYG{p}{[} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Jan}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Feb}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Mar}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Apr}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYGZbs{}
    \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{May}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Jun}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Jul}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Aug}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Sep}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Oct}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Nov}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Dec}\PYG{l+s}{\PYGZdq{}} \PYG{p}{]}

\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{In South East England}\PYG{l+s}{\PYGZdq{}}
\PYG{k}{for} \PYG{n}{row}\PYG{p}{,}\PYG{n}{year} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{years}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{max\PYGZus{}precip} \PYG{o}{=} \PYG{n+nb}{max}\PYG{p}{(}\PYG{n}{c20\PYGZus{}data}\PYG{p}{[}\PYG{n}{row}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{month} \PYG{o}{=} \PYG{n}{c20\PYGZus{}data}\PYG{p}{[}\PYG{n}{row}\PYG{p}{]}\PYG{o}{.}\PYG{n}{index}\PYG{p}{(}\PYG{n}{max\PYGZus{}precip}\PYG{p}{)}

    \PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{In the year}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{year}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{the rainiest month was}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{month\PYGZus{}names}\PYG{p}{[}\PYG{n}{month}\PYG{p}{]}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{with}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{max\PYGZus{}precip}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{mm}\PYG{l+s}{\PYGZdq{}}

\PYG{n}{fp}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
In South East England
In the year 1900 the rainiest month was Jan with 1900.0 mm
In the year 1901 the rainiest month was Jan with 1901.0 mm
In the year 1902 the rainiest month was Jan with 1902.0 mm
In the year 1903 the rainiest month was Jan with 1903.0 mm
In the year 1904 the rainiest month was Jan with 1904.0 mm
In the year 1905 the rainiest month was Jan with 1905.0 mm
In the year 1906 the rainiest month was Jan with 1906.0 mm
In the year 1907 the rainiest month was Jan with 1907.0 mm
In the year 1908 the rainiest month was Jan with 1908.0 mm
In the year 1909 the rainiest month was Jan with 1909.0 mm
In the year 1910 the rainiest month was Jan with 1910.0 mm
In the year 1911 the rainiest month was Jan with 1911.0 mm
In the year 1912 the rainiest month was Jan with 1912.0 mm
In the year 1913 the rainiest month was Jan with 1913.0 mm
In the year 1914 the rainiest month was Jan with 1914.0 mm
In the year 1915 the rainiest month was Jan with 1915.0 mm
In the year 1916 the rainiest month was Jan with 1916.0 mm
In the year 1917 the rainiest month was Jan with 1917.0 mm
In the year 1918 the rainiest month was Jan with 1918.0 mm
In the year 1919 the rainiest month was Jan with 1919.0 mm
In the year 1920 the rainiest month was Jan with 1920.0 mm
In the year 1921 the rainiest month was Jan with 1921.0 mm
In the year 1922 the rainiest month was Jan with 1922.0 mm
In the year 1923 the rainiest month was Jan with 1923.0 mm
In the year 1924 the rainiest month was Jan with 1924.0 mm
In the year 1925 the rainiest month was Jan with 1925.0 mm
In the year 1926 the rainiest month was Jan with 1926.0 mm
In the year 1927 the rainiest month was Jan with 1927.0 mm
In the year 1928 the rainiest month was Jan with 1928.0 mm
In the year 1929 the rainiest month was Jan with 1929.0 mm
In the year 1930 the rainiest month was Jan with 1930.0 mm
In the year 1931 the rainiest month was Jan with 1931.0 mm
In the year 1932 the rainiest month was Jan with 1932.0 mm
In the year 1933 the rainiest month was Jan with 1933.0 mm
In the year 1934 the rainiest month was Jan with 1934.0 mm
In the year 1935 the rainiest month was Jan with 1935.0 mm
In the year 1936 the rainiest month was Jan with 1936.0 mm
In the year 1937 the rainiest month was Jan with 1937.0 mm
In the year 1938 the rainiest month was Jan with 1938.0 mm
In the year 1939 the rainiest month was Jan with 1939.0 mm
In the year 1940 the rainiest month was Jan with 1940.0 mm
In the year 1941 the rainiest month was Jan with 1941.0 mm
In the year 1942 the rainiest month was Jan with 1942.0 mm
In the year 1943 the rainiest month was Jan with 1943.0 mm
In the year 1944 the rainiest month was Jan with 1944.0 mm
In the year 1945 the rainiest month was Jan with 1945.0 mm
In the year 1946 the rainiest month was Jan with 1946.0 mm
In the year 1947 the rainiest month was Jan with 1947.0 mm
In the year 1948 the rainiest month was Jan with 1948.0 mm
In the year 1949 the rainiest month was Jan with 1949.0 mm
In the year 1950 the rainiest month was Jan with 1950.0 mm
In the year 1951 the rainiest month was Jan with 1951.0 mm
In the year 1952 the rainiest month was Jan with 1952.0 mm
In the year 1953 the rainiest month was Jan with 1953.0 mm
In the year 1954 the rainiest month was Jan with 1954.0 mm
In the year 1955 the rainiest month was Jan with 1955.0 mm
In the year 1956 the rainiest month was Jan with 1956.0 mm
In the year 1957 the rainiest month was Jan with 1957.0 mm
In the year 1958 the rainiest month was Jan with 1958.0 mm
In the year 1959 the rainiest month was Jan with 1959.0 mm
In the year 1960 the rainiest month was Jan with 1960.0 mm
In the year 1961 the rainiest month was Jan with 1961.0 mm
In the year 1962 the rainiest month was Jan with 1962.0 mm
In the year 1963 the rainiest month was Jan with 1963.0 mm
In the year 1964 the rainiest month was Jan with 1964.0 mm
In the year 1965 the rainiest month was Jan with 1965.0 mm
In the year 1966 the rainiest month was Jan with 1966.0 mm
In the year 1967 the rainiest month was Jan with 1967.0 mm
In the year 1968 the rainiest month was Jan with 1968.0 mm
In the year 1969 the rainiest month was Jan with 1969.0 mm
In the year 1970 the rainiest month was Jan with 1970.0 mm
In the year 1971 the rainiest month was Jan with 1971.0 mm
In the year 1972 the rainiest month was Jan with 1972.0 mm
In the year 1973 the rainiest month was Jan with 1973.0 mm
In the year 1974 the rainiest month was Jan with 1974.0 mm
In the year 1975 the rainiest month was Jan with 1975.0 mm
In the year 1976 the rainiest month was Jan with 1976.0 mm
In the year 1977 the rainiest month was Jan with 1977.0 mm
In the year 1978 the rainiest month was Jan with 1978.0 mm
In the year 1979 the rainiest month was Jan with 1979.0 mm
In the year 1980 the rainiest month was Jan with 1980.0 mm
In the year 1981 the rainiest month was Jan with 1981.0 mm
In the year 1982 the rainiest month was Jan with 1982.0 mm
In the year 1983 the rainiest month was Jan with 1983.0 mm
In the year 1984 the rainiest month was Jan with 1984.0 mm
In the year 1985 the rainiest month was Jan with 1985.0 mm
In the year 1986 the rainiest month was Jan with 1986.0 mm
In the year 1987 the rainiest month was Jan with 1987.0 mm
In the year 1988 the rainiest month was Jan with 1988.0 mm
In the year 1989 the rainiest month was Jan with 1989.0 mm
In the year 1990 the rainiest month was Jan with 1990.0 mm
In the year 1991 the rainiest month was Jan with 1991.0 mm
In the year 1992 the rainiest month was Jan with 1992.0 mm
In the year 1993 the rainiest month was Jan with 1993.0 mm
In the year 1994 the rainiest month was Jan with 1994.0 mm
In the year 1995 the rainiest month was Jan with 1995.0 mm
In the year 1996 the rainiest month was Jan with 1996.0 mm
In the year 1997 the rainiest month was Jan with 1997.0 mm
In the year 1998 the rainiest month was Jan with 1998.0 mm
In the year 1999 the rainiest month was Jan with 1999.0 mm
\end{Verbatim}


\section{Exercise 2.6}
\label{Chapter2_Python_intro/main_answers:exercise-2-6}
We want to calculate the long-term average temperature (tmax degC) using
observational data at one or more meteorological stations. Such data are
\href{http://www.carbonbrief.org/profiles/global-temperatures/}{relevant to understanding climate and its
dynamics}.

We choose the period 1960 to 1990 (30 years average to even out natural
variability).

We can obtain monthly average data for a number of UK stations from the
\href{http://www.metoffice.gov.uk/climate/uk/stationdata}{UK Met. Office}.

Not all station records are complete enough for this calculation, so we
select, for example
\href{http://www.metoffice.gov.uk/climate/uk/stationdata/heathrowdata.txt}{Heathrow}.

Just with the Python skills you have learned so far, you should be able
to solve a problem of this nature.


\section{Answer 2.6}
\label{Chapter2_Python_intro/main_answers:answer-2-6}
Before diving into this though, you need to think through \textbf{what steps}
you need to go through to achieve your aim?

At a `high' level, this could be:
\begin{enumerate}
\item {} 
Get hold of the data

\item {} 
Read the data into the computer program

\item {} 
Select which years you want

\item {} 
Average the data for each month over all selected years

\item {} 
Print the results

\end{enumerate}

So now we need to think about how to implement these steps.

For the first step, there are many ways you could do this.

\begin{Verbatim}[commandchars=\\\{\}]
!wget \PYGZhy{}O files/data/heathrowdata.txt http://www.metoffice.gov.uk/climate/uk/stationdata/heathrowdata.txt
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZhy{}\PYGZhy{}2014\PYGZhy{}09\PYGZhy{}30 11:13:08\PYGZhy{}\PYGZhy{}  http://www.metoffice.gov.uk/climate/uk/stationdata/heathrowdata.txt
Resolving www.metoffice.gov.uk... 213.120.162.233, 213.120.162.211
Connecting to www.metoffice.gov.uk\textbar{}213.120.162.233\textbar{}:80... connected.
HTTP request sent, awaiting response... 301 Moved Permanently
Location: http://www.metoffice.gov.uk/pub/data/weather/uk/climate/stationdata/heathrowdata.txt [following]
\PYGZhy{}\PYGZhy{}2014\PYGZhy{}09\PYGZhy{}30 11:13:08\PYGZhy{}\PYGZhy{}  http://www.metoffice.gov.uk/pub/data/weather/uk/climate/stationdata/heathrowdata.txt
Reusing existing connection to www.metoffice.gov.uk:80.
HTTP request sent, awaiting response... 200 OK
Length: 41280 (40K) [text/plain]
Saving to: files/data/heathrowdata.txt

100\PYGZpc{}[======================================\PYGZgt{}] 41,280      \PYGZhy{}\PYGZhy{}.\PYGZhy{}K/s   in 0s

2014\PYGZhy{}09\PYGZhy{}30 11:13:09 (206 MB/s) \PYGZhy{} files/data/heathrowdata.txt saved [41280/41280]
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{ifile} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/heathrowdata.txt}\PYG{l+s}{\PYGZsq{}}
\PYG{n}{fp} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{ifile}\PYG{p}{)}
\PYG{n}{raw\PYGZus{}data} \PYG{o}{=} \PYG{n}{fp}\PYG{o}{.}\PYG{n}{readlines}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{fp}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{raw\PYGZus{}data} \PYG{o}{=} \PYG{n}{raw\PYGZus{}data}\PYG{p}{[}\PYG{l+m+mi}{7}\PYG{p}{:}\PYG{p}{]} \PYG{c}{\PYGZsh{} Skip headers}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} set up the problem}
\PYG{n}{start\PYGZus{}year} \PYG{o}{=} \PYG{l+m+mi}{1960}
\PYG{n}{end\PYGZus{}year} \PYG{o}{=} \PYG{l+m+mi}{1990}

\PYG{n}{tmax} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}

\PYG{k}{for} \PYG{n}{l} \PYG{o+ow}{in} \PYG{n}{raw\PYGZus{}data}\PYG{p}{:}
    \PYG{n}{s} \PYG{o}{=} \PYG{n}{l}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{year} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(} \PYG{n}{s}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{p}{)}
    \PYG{k}{if} \PYG{n}{year} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{start\PYGZus{}year} \PYG{o+ow}{and} \PYG{n}{year} \PYG{o}{\PYGZlt{}} \PYG{n}{end\PYGZus{}year}\PYG{p}{:}
        \PYG{n}{month} \PYG{o}{=} \PYG{n+nb}{int} \PYG{p}{(} \PYG{n}{s}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{p}{)}
        \PYG{k}{if} \PYG{n}{month} \PYG{o}{==} \PYG{l+m+mi}{1}\PYG{p}{:}
            \PYG{n}{tmax}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{tmax}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb}{float} \PYG{p}{(} \PYG{n}{s}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{p}{)}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{l} \PYG{o+ow}{in} \PYG{n}{tmax}\PYG{p}{:}
    \PYG{k}{print} \PYG{n}{l}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{l+m+mf}{6.9}\PYG{p}{,} \PYG{l+m+mf}{7.9}\PYG{p}{,} \PYG{l+m+mf}{10.2}\PYG{p}{,} \PYG{l+m+mf}{14.3}\PYG{p}{,} \PYG{l+m+mf}{18.4}\PYG{p}{,} \PYG{l+m+mf}{22.1}\PYG{p}{,} \PYG{l+m+mf}{20.1}\PYG{p}{,} \PYG{l+m+mf}{20.3}\PYG{p}{,} \PYG{l+m+mf}{18.5}\PYG{p}{,} \PYG{l+m+mf}{14.2}\PYG{p}{,} \PYG{l+m+mf}{11.2}\PYG{p}{,} \PYG{l+m+mf}{6.9}\PYG{p}{]}
\PYG{p}{[}\PYG{l+m+mf}{6.9}\PYG{p}{,} \PYG{l+m+mf}{10.3}\PYG{p}{,} \PYG{l+m+mf}{13.9}\PYG{p}{,} \PYG{l+m+mf}{15.0}\PYG{p}{,} \PYG{l+m+mf}{16.8}\PYG{p}{,} \PYG{l+m+mf}{21.7}\PYG{p}{,} \PYG{l+m+mf}{22.1}\PYG{p}{,} \PYG{l+m+mf}{21.7}\PYG{p}{,} \PYG{l+m+mf}{20.9}\PYG{p}{,} \PYG{l+m+mf}{15.6}\PYG{p}{,} \PYG{l+m+mf}{9.9}\PYG{p}{,} \PYG{l+m+mf}{6.8}\PYG{p}{]}
\PYG{p}{[}\PYG{l+m+mf}{7.9}\PYG{p}{,} \PYG{l+m+mf}{7.6}\PYG{p}{,} \PYG{l+m+mf}{7.4}\PYG{p}{,} \PYG{l+m+mf}{12.7}\PYG{p}{,} \PYG{l+m+mf}{15.0}\PYG{p}{,} \PYG{l+m+mf}{20.4}\PYG{p}{,} \PYG{l+m+mf}{20.6}\PYG{p}{,} \PYG{l+m+mf}{20.0}\PYG{p}{,} \PYG{l+m+mf}{17.8}\PYG{p}{,} \PYG{l+m+mf}{15.7}\PYG{p}{,} \PYG{l+m+mf}{9.1}\PYG{p}{,} \PYG{l+m+mf}{5.0}\PYG{p}{]}
\PYG{p}{[}\PYG{l+m+mf}{0.8}\PYG{p}{,} \PYG{l+m+mf}{2.8}\PYG{p}{,} \PYG{l+m+mf}{10.7}\PYG{p}{,} \PYG{l+m+mf}{13.6}\PYG{p}{,} \PYG{l+m+mf}{16.0}\PYG{p}{,} \PYG{l+m+mf}{20.8}\PYG{p}{,} \PYG{l+m+mf}{21.1}\PYG{p}{,} \PYG{l+m+mf}{19.8}\PYG{p}{,} \PYG{l+m+mf}{18.0}\PYG{p}{,} \PYG{l+m+mf}{14.8}\PYG{p}{,} \PYG{l+m+mf}{11.8}\PYG{p}{,} \PYG{l+m+mf}{5.4}\PYG{p}{]}
\PYG{p}{[}\PYG{l+m+mf}{5.8}\PYG{p}{,} \PYG{l+m+mf}{7.6}\PYG{p}{,} \PYG{l+m+mf}{7.6}\PYG{p}{,} \PYG{l+m+mf}{12.8}\PYG{p}{,} \PYG{l+m+mf}{19.6}\PYG{p}{,} \PYG{l+m+mf}{19.3}\PYG{p}{,} \PYG{l+m+mf}{22.8}\PYG{p}{,} \PYG{l+m+mf}{22.3}\PYG{p}{,} \PYG{l+m+mf}{21.1}\PYG{p}{,} \PYG{l+m+mf}{13.7}\PYG{p}{,} \PYG{l+m+mf}{11.2}\PYG{p}{,} \PYG{l+m+mf}{7.1}\PYG{p}{]}
\PYG{p}{[}\PYG{l+m+mf}{6.6}\PYG{p}{,} \PYG{l+m+mf}{5.9}\PYG{p}{,} \PYG{l+m+mf}{10.5}\PYG{p}{,} \PYG{l+m+mf}{13.4}\PYG{p}{,} \PYG{l+m+mf}{16.8}\PYG{p}{,} \PYG{l+m+mf}{19.7}\PYG{p}{,} \PYG{l+m+mf}{19.3}\PYG{p}{,} \PYG{l+m+mf}{20.8}\PYG{p}{,} \PYG{l+m+mf}{17.4}\PYG{p}{,} \PYG{l+m+mf}{16.2}\PYG{p}{,} \PYG{l+m+mf}{8.4}\PYG{p}{,} \PYG{l+m+mf}{8.4}\PYG{p}{]}
\PYG{p}{[}\PYG{l+m+mf}{5.3}\PYG{p}{,} \PYG{l+m+mf}{9.3}\PYG{p}{,} \PYG{l+m+mf}{10.9}\PYG{p}{,} \PYG{l+m+mf}{12.2}\PYG{p}{,} \PYG{l+m+mf}{17.0}\PYG{p}{,} \PYG{l+m+mf}{21.8}\PYG{p}{,} \PYG{l+m+mf}{20.1}\PYG{p}{,} \PYG{l+m+mf}{20.6}\PYG{p}{,} \PYG{l+m+mf}{19.6}\PYG{p}{,} \PYG{l+m+mf}{14.7}\PYG{p}{,} \PYG{l+m+mf}{8.8}\PYG{p}{,} \PYG{l+m+mf}{9.3}\PYG{p}{]}
\PYG{p}{[}\PYG{l+m+mf}{7.3}\PYG{p}{,} \PYG{l+m+mf}{9.3}\PYG{p}{,} \PYG{l+m+mf}{11.6}\PYG{p}{,} \PYG{l+m+mf}{12.5}\PYG{p}{,} \PYG{l+m+mf}{15.6}\PYG{p}{,} \PYG{l+m+mf}{20.1}\PYG{p}{,} \PYG{l+m+mf}{23.5}\PYG{p}{,} \PYG{l+m+mf}{21.5}\PYG{p}{,} \PYG{l+m+mf}{18.5}\PYG{p}{,} \PYG{l+m+mf}{15.0}\PYG{p}{,} \PYG{l+m+mf}{9.7}\PYG{p}{,} \PYG{l+m+mf}{7.2}\PYG{p}{]}
\PYG{p}{[}\PYG{l+m+mf}{7.2}\PYG{p}{,} \PYG{l+m+mf}{5.7}\PYG{p}{,} \PYG{l+m+mf}{11.1}\PYG{p}{,} \PYG{l+m+mf}{13.7}\PYG{p}{,} \PYG{l+m+mf}{15.4}\PYG{p}{,} \PYG{l+m+mf}{20.6}\PYG{p}{,} \PYG{l+m+mf}{20.7}\PYG{p}{,} \PYG{l+m+mf}{20.2}\PYG{p}{,} \PYG{l+m+mf}{18.8}\PYG{p}{,} \PYG{l+m+mf}{16.5}\PYG{p}{,} \PYG{l+m+mf}{9.5}\PYG{p}{,} \PYG{l+m+mf}{5.4}\PYG{p}{]}
\PYG{p}{[}\PYG{l+m+mf}{8.9}\PYG{p}{,} \PYG{l+m+mf}{4.9}\PYG{p}{,} \PYG{l+m+mf}{8.0}\PYG{p}{,} \PYG{l+m+mf}{13.6}\PYG{p}{,} \PYG{l+m+mf}{17.1}\PYG{p}{,} \PYG{l+m+mf}{20.6}\PYG{p}{,} \PYG{l+m+mf}{23.9}\PYG{p}{,} \PYG{l+m+mf}{21.8}\PYG{p}{,} \PYG{l+m+mf}{19.6}\PYG{p}{,} \PYG{l+m+mf}{18.2}\PYG{p}{,} \PYG{l+m+mf}{9.6}\PYG{p}{,} \PYG{l+m+mf}{6.1}\PYG{p}{]}
\PYG{p}{[}\PYG{l+m+mf}{7.1}\PYG{p}{,} \PYG{l+m+mf}{7.2}\PYG{p}{,} \PYG{l+m+mf}{8.1}\PYG{p}{,} \PYG{l+m+mf}{11.4}\PYG{p}{,} \PYG{l+m+mf}{19.2}\PYG{p}{,} \PYG{l+m+mf}{23.6}\PYG{p}{,} \PYG{l+m+mf}{21.3}\PYG{p}{,} \PYG{l+m+mf}{22.3}\PYG{p}{,} \PYG{l+m+mf}{20.3}\PYG{p}{,} \PYG{l+m+mf}{15.7}\PYG{p}{,} \PYG{l+m+mf}{11.9}\PYG{p}{,} \PYG{l+m+mf}{7.0}\PYG{p}{]}
\PYG{p}{[}\PYG{l+m+mf}{7.8}\PYG{p}{,} \PYG{l+m+mf}{8.6}\PYG{p}{,} \PYG{l+m+mf}{9.1}\PYG{p}{,} \PYG{l+m+mf}{12.2}\PYG{p}{,} \PYG{l+m+mf}{18.1}\PYG{p}{,} \PYG{l+m+mf}{17.8}\PYG{p}{,} \PYG{l+m+mf}{24.1}\PYG{p}{,} \PYG{l+m+mf}{21.3}\PYG{p}{,} \PYG{l+m+mf}{20.7}\PYG{p}{,} \PYG{l+m+mf}{17.2}\PYG{p}{,} \PYG{l+m+mf}{10.4}\PYG{p}{,} \PYG{l+m+mf}{9.3}\PYG{p}{]}
\PYG{p}{[}\PYG{l+m+mf}{6.9}\PYG{p}{,} \PYG{l+m+mf}{7.9}\PYG{p}{,} \PYG{l+m+mf}{12.4}\PYG{p}{,} \PYG{l+m+mf}{12.9}\PYG{p}{,} \PYG{l+m+mf}{16.0}\PYG{p}{,} \PYG{l+m+mf}{17.5}\PYG{p}{,} \PYG{l+m+mf}{22.3}\PYG{p}{,} \PYG{l+m+mf}{21.8}\PYG{p}{,} \PYG{l+m+mf}{17.3}\PYG{p}{,} \PYG{l+m+mf}{15.6}\PYG{p}{,} \PYG{l+m+mf}{9.9}\PYG{p}{,} \PYG{l+m+mf}{9.4}\PYG{p}{]}
\PYG{p}{[}\PYG{l+m+mf}{7.3}\PYG{p}{,} \PYG{l+m+mf}{8.1}\PYG{p}{,} \PYG{l+m+mf}{11.5}\PYG{p}{,} \PYG{l+m+mf}{12.5}\PYG{p}{,} \PYG{l+m+mf}{16.9}\PYG{p}{,} \PYG{l+m+mf}{21.9}\PYG{p}{,} \PYG{l+m+mf}{21.4}\PYG{p}{,} \PYG{l+m+mf}{23.7}\PYG{p}{,} \PYG{l+m+mf}{20.7}\PYG{p}{,} \PYG{l+m+mf}{13.9}\PYG{p}{,} \PYG{l+m+mf}{10.3}\PYG{p}{,} \PYG{l+m+mf}{8.6}\PYG{p}{]}
\PYG{p}{[}\PYG{l+m+mf}{9.6}\PYG{p}{,} \PYG{l+m+mf}{9.2}\PYG{p}{,} \PYG{l+m+mf}{10.3}\PYG{p}{,} \PYG{l+m+mf}{14.0}\PYG{p}{,} \PYG{l+m+mf}{17.0}\PYG{p}{,} \PYG{l+m+mf}{20.1}\PYG{p}{,} \PYG{l+m+mf}{20.9}\PYG{p}{,} \PYG{l+m+mf}{21.5}\PYG{p}{,} \PYG{l+m+mf}{17.5}\PYG{p}{,} \PYG{l+m+mf}{11.0}\PYG{p}{,} \PYG{l+m+mf}{10.6}\PYG{p}{,} \PYG{l+m+mf}{11.0}\PYG{p}{]}
\PYG{p}{[}\PYG{l+m+mf}{10.3}\PYG{p}{,} \PYG{l+m+mf}{9.3}\PYG{p}{,} \PYG{l+m+mf}{8.4}\PYG{p}{,} \PYG{l+m+mf}{13.3}\PYG{p}{,} \PYG{l+m+mf}{15.1}\PYG{p}{,} \PYG{l+m+mf}{21.8}\PYG{p}{,} \PYG{l+m+mf}{24.1}\PYG{p}{,} \PYG{l+m+mf}{25.9}\PYG{p}{,} \PYG{l+m+mf}{19.5}\PYG{p}{,} \PYG{l+m+mf}{14.4}\PYG{p}{,} \PYG{l+m+mf}{10.1}\PYG{p}{,} \PYG{l+m+mf}{7.6}\PYG{p}{]}
\PYG{p}{[}\PYG{l+m+mf}{8.8}\PYG{p}{,} \PYG{l+m+mf}{7.8}\PYG{p}{,} \PYG{l+m+mf}{9.5}\PYG{p}{,} \PYG{l+m+mf}{13.7}\PYG{p}{,} \PYG{l+m+mf}{19.3}\PYG{p}{,} \PYG{l+m+mf}{25.5}\PYG{p}{,} \PYG{l+m+mf}{26.6}\PYG{p}{,} \PYG{l+m+mf}{25.1}\PYG{p}{,} \PYG{l+m+mf}{19.0}\PYG{p}{,} \PYG{l+m+mf}{14.9}\PYG{p}{,} \PYG{l+m+mf}{9.9}\PYG{p}{,} \PYG{l+m+mf}{5.6}\PYG{p}{]}
\PYG{p}{[}\PYG{l+m+mf}{6.1}\PYG{p}{,} \PYG{l+m+mf}{9.6}\PYG{p}{,} \PYG{l+m+mf}{11.2}\PYG{p}{,} \PYG{l+m+mf}{12.2}\PYG{p}{,} \PYG{l+m+mf}{16.4}\PYG{p}{,} \PYG{l+m+mf}{17.4}\PYG{p}{,} \PYG{l+m+mf}{22.4}\PYG{p}{,} \PYG{l+m+mf}{20.3}\PYG{p}{,} \PYG{l+m+mf}{18.0}\PYG{p}{,} \PYG{l+m+mf}{16.3}\PYG{p}{,} \PYG{l+m+mf}{10.4}\PYG{p}{,} \PYG{l+m+mf}{9.2}\PYG{p}{]}
\PYG{p}{[}\PYG{l+m+mf}{6.7}\PYG{p}{,} \PYG{l+m+mf}{6.2}\PYG{p}{,} \PYG{l+m+mf}{11.3}\PYG{p}{,} \PYG{l+m+mf}{10.7}\PYG{p}{,} \PYG{l+m+mf}{17.2}\PYG{p}{,} \PYG{l+m+mf}{19.7}\PYG{p}{,} \PYG{l+m+mf}{20.5}\PYG{p}{,} \PYG{l+m+mf}{20.7}\PYG{p}{,} \PYG{l+m+mf}{20.1}\PYG{p}{,} \PYG{l+m+mf}{17.1}\PYG{p}{,} \PYG{l+m+mf}{12.6}\PYG{p}{,} \PYG{l+m+mf}{7.8}\PYG{p}{]}
\PYG{p}{[}\PYG{l+m+mf}{3.8}\PYG{p}{,} \PYG{l+m+mf}{4.5}\PYG{p}{,} \PYG{l+m+mf}{9.2}\PYG{p}{,} \PYG{l+m+mf}{12.7}\PYG{p}{,} \PYG{l+m+mf}{15.9}\PYG{p}{,} \PYG{l+m+mf}{19.0}\PYG{p}{,} \PYG{l+m+mf}{22.5}\PYG{p}{,} \PYG{l+m+mf}{21.0}\PYG{p}{,} \PYG{l+m+mf}{19.6}\PYG{p}{,} \PYG{l+m+mf}{16.4}\PYG{p}{,} \PYG{l+m+mf}{10.8}\PYG{p}{,} \PYG{l+m+mf}{9.2}\PYG{p}{]}
\PYG{p}{[}\PYG{l+m+mf}{6.0}\PYG{p}{,} \PYG{l+m+mf}{9.9}\PYG{p}{,} \PYG{l+m+mf}{9.0}\PYG{p}{,} \PYG{l+m+mf}{14.0}\PYG{p}{,} \PYG{l+m+mf}{17.3}\PYG{p}{,} \PYG{l+m+mf}{19.8}\PYG{p}{,} \PYG{l+m+mf}{19.7}\PYG{p}{,} \PYG{l+m+mf}{21.9}\PYG{p}{,} \PYG{l+m+mf}{20.1}\PYG{p}{,} \PYG{l+m+mf}{14.0}\PYG{p}{,} \PYG{l+m+mf}{9.3}\PYG{p}{,} \PYG{l+m+mf}{8.9}\PYG{p}{]}
\PYG{p}{[}\PYG{l+m+mf}{8.1}\PYG{p}{,} \PYG{l+m+mf}{7.1}\PYG{p}{,} \PYG{l+m+mf}{11.8}\PYG{p}{,} \PYG{l+m+mf}{12.9}\PYG{p}{,} \PYG{l+m+mf}{16.1}\PYG{p}{,} \PYG{l+m+mf}{18.5}\PYG{p}{,} \PYG{l+m+mf}{22.0}\PYG{p}{,} \PYG{l+m+mf}{22.8}\PYG{p}{,} \PYG{l+m+mf}{20.3}\PYG{p}{,} \PYG{l+m+mf}{12.9}\PYG{p}{,} \PYG{l+m+mf}{11.5}\PYG{p}{,} \PYG{l+m+mf}{4.4}\PYG{p}{]}
\PYG{p}{[}\PYG{l+m+mf}{6.9}\PYG{p}{,} \PYG{l+m+mf}{8.4}\PYG{p}{,} \PYG{l+m+mf}{11.1}\PYG{p}{,} \PYG{l+m+mf}{14.3}\PYG{p}{,} \PYG{l+m+mf}{18.0}\PYG{p}{,} \PYG{l+m+mf}{21.5}\PYG{p}{,} \PYG{l+m+mf}{22.7}\PYG{p}{,} \PYG{l+m+mf}{22.2}\PYG{p}{,} \PYG{l+m+mf}{20.8}\PYG{p}{,} \PYG{l+m+mf}{14.1}\PYG{p}{,} \PYG{l+m+mf}{11.4}\PYG{p}{,} \PYG{l+m+mf}{8.2}\PYG{p}{]}
\PYG{p}{[}\PYG{l+m+mf}{10.0}\PYG{p}{,} \PYG{l+m+mf}{5.5}\PYG{p}{,} \PYG{l+m+mf}{10.8}\PYG{p}{,} \PYG{l+m+mf}{12.4}\PYG{p}{,} \PYG{l+m+mf}{15.6}\PYG{p}{,} \PYG{l+m+mf}{20.8}\PYG{p}{,} \PYG{l+m+mf}{27.6}\PYG{p}{,} \PYG{l+m+mf}{24.5}\PYG{p}{,} \PYG{l+m+mf}{19.3}\PYG{p}{,} \PYG{l+m+mf}{15.1}\PYG{p}{,} \PYG{l+m+mf}{11.3}\PYG{p}{,} \PYG{l+m+mf}{9.2}\PYG{p}{]}
\PYG{p}{[}\PYG{l+m+mf}{8.0}\PYG{p}{,} \PYG{l+m+mf}{7.4}\PYG{p}{,} \PYG{l+m+mf}{8.9}\PYG{p}{,} \PYG{l+m+mf}{14.6}\PYG{p}{,} \PYG{l+m+mf}{14.9}\PYG{p}{,} \PYG{l+m+mf}{21.3}\PYG{p}{,} \PYG{l+m+mf}{24.2}\PYG{p}{,} \PYG{l+m+mf}{24.4}\PYG{p}{,} \PYG{l+m+mf}{18.6}\PYG{p}{,} \PYG{l+m+mf}{15.8}\PYG{p}{,} \PYG{l+m+mf}{12.2}\PYG{p}{,} \PYG{l+m+mf}{8.7}\PYG{p}{]}
\PYG{p}{[}\PYG{l+m+mf}{4.1}\PYG{p}{,} \PYG{l+m+mf}{6.3}\PYG{p}{,} \PYG{l+m+mf}{9.4}\PYG{p}{,} \PYG{l+m+mf}{14.0}\PYG{p}{,} \PYG{l+m+mf}{16.4}\PYG{p}{,} \PYG{l+m+mf}{18.5}\PYG{p}{,} \PYG{l+m+mf}{22.9}\PYG{p}{,} \PYG{l+m+mf}{20.3}\PYG{p}{,} \PYG{l+m+mf}{20.6}\PYG{p}{,} \PYG{l+m+mf}{16.1}\PYG{p}{,} \PYG{l+m+mf}{8.1}\PYG{p}{,} \PYG{l+m+mf}{10.0}\PYG{p}{]}
\PYG{p}{[}\PYG{l+m+mf}{7.2}\PYG{p}{,} \PYG{l+m+mf}{1.7}\PYG{p}{,} \PYG{l+m+mf}{10.1}\PYG{p}{,} \PYG{l+m+mf}{10.9}\PYG{p}{,} \PYG{l+m+mf}{16.3}\PYG{p}{,} \PYG{l+m+mf}{21.8}\PYG{p}{,} \PYG{l+m+mf}{22.6}\PYG{p}{,} \PYG{l+m+mf}{20.0}\PYG{p}{,} \PYG{l+m+mf}{17.4}\PYG{p}{,} \PYG{l+m+mf}{16.4}\PYG{p}{,} \PYG{l+m+mf}{12.1}\PYG{p}{,} \PYG{l+m+mf}{9.7}\PYG{p}{]}
\PYG{p}{[}\PYG{l+m+mf}{3.6}\PYG{p}{,} \PYG{l+m+mf}{7.7}\PYG{p}{,} \PYG{l+m+mf}{8.5}\PYG{p}{,} \PYG{l+m+mf}{15.8}\PYG{p}{,} \PYG{l+m+mf}{16.3}\PYG{p}{,} \PYG{l+m+mf}{18.6}\PYG{p}{,} \PYG{l+m+mf}{21.8}\PYG{p}{,} \PYG{l+m+mf}{21.8}\PYG{p}{,} \PYG{l+m+mf}{19.3}\PYG{p}{,} \PYG{l+m+mf}{15.0}\PYG{p}{,} \PYG{l+m+mf}{9.8}\PYG{p}{,} \PYG{l+m+mf}{8.9}\PYG{p}{]}
\PYG{p}{[}\PYG{l+m+mf}{8.8}\PYG{p}{,} \PYG{l+m+mf}{8.7}\PYG{p}{,} \PYG{l+m+mf}{10.7}\PYG{p}{,} \PYG{l+m+mf}{13.5}\PYG{p}{,} \PYG{l+m+mf}{18.0}\PYG{p}{,} \PYG{l+m+mf}{19.7}\PYG{p}{,} \PYG{l+m+mf}{20.0}\PYG{p}{,} \PYG{l+m+mf}{21.8}\PYG{p}{,} \PYG{l+m+mf}{18.8}\PYG{p}{,} \PYG{l+m+mf}{15.5}\PYG{p}{,} \PYG{l+m+mf}{9.9}\PYG{p}{,} \PYG{l+m+mf}{10.4}\PYG{p}{]}
\PYG{p}{[}\PYG{l+m+mf}{9.5}\PYG{p}{,} \PYG{l+m+mf}{10.2}\PYG{p}{,} \PYG{l+m+mf}{12.9}\PYG{p}{,} \PYG{l+m+mf}{11.5}\PYG{p}{,} \PYG{l+m+mf}{21.0}\PYG{p}{,} \PYG{l+m+mf}{22.1}\PYG{p}{,} \PYG{l+m+mf}{25.8}\PYG{p}{,} \PYG{l+m+mf}{24.2}\PYG{p}{,} \PYG{l+m+mf}{20.7}\PYG{p}{,} \PYG{l+m+mf}{17.1}\PYG{p}{,} \PYG{l+m+mf}{10.9}\PYG{p}{,} \PYG{l+m+mf}{9.4}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{monthly\PYGZus{}avg} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{n\PYGZus{}years} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{tmax}\PYG{p}{)}


\PYG{k}{for} \PYG{n}{month} \PYG{o+ow}{in} \PYG{n+nb}{xrange} \PYG{p}{(} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{tmax}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)} \PYG{p}{)}\PYG{p}{:}
    \PYG{n}{temp} \PYG{o}{=} \PYG{l+m+mf}{0.}
    \PYG{k}{for} \PYG{n}{year} \PYG{o+ow}{in} \PYG{n+nb}{xrange} \PYG{p}{(}\PYG{n}{n\PYGZus{}years}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{temp} \PYG{o}{+}\PYG{o}{=} \PYG{n}{tmax}\PYG{p}{[}\PYG{n}{year}\PYG{p}{]}\PYG{p}{[}\PYG{n}{month}\PYG{p}{]}
    \PYG{n}{monthly\PYGZus{}avg}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{temp}\PYG{o}{/}\PYG{n}{n\PYGZus{}years}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{T results for}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{n\PYGZus{}years}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{years:}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{start\PYGZus{}year}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{to}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{end\PYGZus{}year}

\PYG{n}{month\PYGZus{}names} \PYG{o}{=} \PYG{p}{[} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Jan}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Feb}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Mar}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Apr}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYGZbs{}
    \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{May}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Jun}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Jul}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Aug}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Sep}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Oct}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Nov}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Dec}\PYG{l+s}{\PYGZdq{}} \PYG{p}{]}

\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{Month}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{TmaxAvg}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}
\PYG{k}{for} \PYG{n}{i}\PYG{p}{,} \PYG{n}{mname} \PYG{o+ow}{in} \PYG{n+nb}{enumerate} \PYG{p}{(} \PYG{n}{month\PYGZus{}names} \PYG{p}{)}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{mname}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{monthly\PYGZus{}avg}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
T results for 30 years: 1960 to 1990

    Month   TmaxAvg

    Jan     7.00666666667
    Feb     7.42
    Mar     10.2033333333
    Apr     13.11
    May     16.9566666667
    Jun     20.4666666667
    Jul     22.32
    Aug     21.8833333333
    Sep     19.2933333333
    Oct     15.3033333333
    Nov     10.42
    Dec     8.00333333333
\end{Verbatim}


\section{Exercise 2.7}
\label{Chapter2_Python_intro/main_answers:exercise-2-7}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} 1. Read the configuration file}
\PYG{c}{\PYGZsh{} into the dict modis}
\PYG{k+kn}{import} \PYG{n+nn}{ConfigParser}

\PYG{n}{config} \PYG{o}{=} \PYG{n}{ConfigParser}\PYG{o}{.}\PYG{n}{ConfigParser}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{config}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/modis.cfg}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{c}{\PYGZsh{} we can convert this to a normal dictionary}
\PYG{n}{modis} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n}{config}\PYG{o}{.}\PYG{n}{sections}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{modis}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]} \PYG{o}{=} \PYG{n+nb}{dict}\PYG{p}{(}\PYG{n}{config}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}\PYG{p}{)}

\PYG{c}{\PYGZsh{} 2. Now, loop over config sections}
\PYG{c}{\PYGZsh{} and get the sub\PYGZhy{}dictionary which we call sub\PYGZus{}dict}

\PYG{c}{\PYGZsh{} 3. set up anb empty list to contain the}
\PYG{c}{\PYGZsh{} files we want to process}
\PYG{n}{wanted\PYGZus{}files} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}

\PYG{k}{for} \PYG{n}{k}\PYG{p}{,}\PYG{n}{v} \PYG{o+ow}{in} \PYG{n}{modis}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}

    \PYG{n}{sub\PYGZus{}dict} \PYG{o}{=} \PYG{n}{v}

    \PYG{c}{\PYGZsh{} 3a. Read the file list}
    \PYG{n}{fp} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{sub\PYGZus{}dict}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{file\PYGZus{}list}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{file\PYGZus{}data} \PYG{o}{=} \PYG{n}{fp}\PYG{o}{.}\PYG{n}{readlines}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{fp}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}

    \PYG{c}{\PYGZsh{} 3b. find the doy range}
    \PYG{n}{doy\PYGZus{}range} \PYG{o}{=} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{sub\PYGZus{}dict}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{doy\PYGZus{}start}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYGZbs{}
                          \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{sub\PYGZus{}dict}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{doy\PYGZus{}end}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}

    \PYG{c}{\PYGZsh{} 3c. loop over each file read from}
    \PYG{c}{\PYGZsh{}     sub\PYGZus{}dict[\PYGZsq{}file\PYGZus{}list\PYGZsq{}]}
    \PYG{k}{for} \PYG{n}{count} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{file\PYGZus{}data}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{c}{\PYGZsh{} 3d. extract doy from the file name}
        \PYG{n}{this\PYGZus{}file} \PYG{o}{=} \PYG{n}{file\PYGZus{}data}\PYG{p}{[}\PYG{n}{count}\PYG{p}{]}

        \PYG{n}{doy} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{this\PYGZus{}file}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{.}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{:}\PYG{p}{]}\PYG{p}{)}

        \PYG{c}{\PYGZsh{} 3e. see if doy is in the range we want?}
        \PYG{k}{if} \PYG{n}{doy} \PYG{o+ow}{in} \PYG{n}{doy\PYGZus{}range}\PYG{p}{:}

            \PYG{c}{\PYGZsh{} 3f. put the directory on the fornt}
            \PYG{n}{full\PYGZus{}name} \PYG{o}{=} \PYG{n}{sub\PYGZus{}dict}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{dir}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{+} \PYGZbs{}
                        \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/}\PYG{l+s}{\PYGZsq{}} \PYG{o}{+} \PYG{n}{this\PYGZus{}file}
            \PYG{n}{wanted\PYGZus{}files}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{full\PYGZus{}name}\PYG{p}{)}

\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{I found }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{ files to process}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZpc{}}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{wanted\PYGZus{}files}\PYG{p}{)}

\PYG{c}{\PYGZsh{} I won\PYGZsq{}t print the whole list as its too long}
\PYG{c}{\PYGZsh{} just the first 10}
\PYG{k}{for} \PYG{n}{f} \PYG{o+ow}{in} \PYG{n}{wanted\PYGZus{}files}\PYG{p}{[}\PYG{p}{:}\PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{:}
    \PYG{k}{print} \PYG{n}{f}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
I found 62 files to process
/data/geospatial\PYGZus{}19/ucfajlg/fire/Angola/MYD09/MYD09GA.A2004214.h19v10.005.2007299212915.hdf

/data/geospatial\PYGZus{}19/ucfajlg/fire/Angola/MYD09/MYD09GA.A2004215.h19v10.005.2007300042347.hdf

/data/geospatial\PYGZus{}19/ucfajlg/fire/Angola/MYD09/MYD09GA.A2004216.h19v10.005.2007300091257.hdf

/data/geospatial\PYGZus{}19/ucfajlg/fire/Angola/MYD09/MYD09GA.A2004217.h19v10.005.2007300153436.hdf

/data/geospatial\PYGZus{}19/ucfajlg/fire/Angola/MYD09/MYD09GA.A2004218.h19v10.005.2007300215826.hdf

/data/geospatial\PYGZus{}19/ucfajlg/fire/Angola/MYD09/MYD09GA.A2004219.h19v10.005.2007302194509.hdf

/data/geospatial\PYGZus{}19/ucfajlg/fire/Angola/MYD09/MYD09GA.A2004220.h19v10.005.2007302093547.hdf

/data/geospatial\PYGZus{}19/ucfajlg/fire/Angola/MYD09/MYD09GA.A2004221.h19v10.005.2007302222054.hdf

/data/geospatial\PYGZus{}19/ucfajlg/fire/Angola/MYD09/MYD09GA.A2004222.h19v10.005.2007303011606.hdf

/data/geospatial\PYGZus{}19/ucfajlg/fire/Angola/MYD09/MYD09GA.A2004223.h19v10.005.2007303073538.hdf
\end{Verbatim}

\textbf{You should modify the example above to make it simpler, if you can
spot any places for that (don't make it more complicated!).}

\textbf{You should then modify it so that the list of files that we want to
process is printed to a file.}


\section{Answer 2.7}
\label{Chapter2_Python_intro/main_answers:answer-2-7}
Probably the main place you could make the code simpler would be in the
loop:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} 3a. Read the file list}
\PYG{n}{fp} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{sub\PYGZus{}dict}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{file\PYGZus{}list}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{file\PYGZus{}data} \PYG{o}{=} \PYG{n}{fp}\PYG{o}{.}\PYG{n}{readlines}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{fp}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}

\PYG{c}{\PYGZsh{} 3b. find the doy range}
\PYG{n}{doy\PYGZus{}range} \PYG{o}{=} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{sub\PYGZus{}dict}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{doy\PYGZus{}start}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYGZbs{}
                      \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{sub\PYGZus{}dict}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{doy\PYGZus{}end}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}

\PYG{c}{\PYGZsh{} 3c. loop over each file read from}
\PYG{c}{\PYGZsh{}     sub\PYGZus{}dict[\PYGZsq{}file\PYGZus{}list\PYGZsq{}]}
\PYG{k}{for} \PYG{n}{count} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{file\PYGZus{}data}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{c}{\PYGZsh{} 3d. extract doy from the file name}
    \PYG{n}{this\PYGZus{}file} \PYG{o}{=} \PYG{n}{file\PYGZus{}data}\PYG{p}{[}\PYG{n}{count}\PYG{p}{]}

    \PYG{n}{doy} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{this\PYGZus{}file}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{.}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{:}\PYG{p}{]}\PYG{p}{)}

    \PYG{c}{\PYGZsh{} 3e. see if doy is in the range we want?}
    \PYG{k}{if} \PYG{n}{doy} \PYG{o+ow}{in} \PYG{n}{doy\PYGZus{}range}\PYG{p}{:}

        \PYG{c}{\PYGZsh{} 3f. put the directory on the fornt}
        \PYG{n}{full\PYGZus{}name} \PYG{o}{=} \PYG{n}{sub\PYGZus{}dict}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{dir}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{+} \PYGZbs{}
                    \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/}\PYG{l+s}{\PYGZsq{}} \PYG{o}{+} \PYG{n}{this\PYGZus{}file}
        \PYG{n}{wanted\PYGZus{}files}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{full\PYGZus{}name}\PYG{p}{)}
\end{Verbatim}

Really, we don't need the \code{count} variable and structure in here, and
we could replace this by:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} 3a. Read the file list}
\PYG{n}{fp} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{sub\PYGZus{}dict}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{file\PYGZus{}list}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{c}{\PYGZsh{} 3b. find the doy range}
\PYG{n}{doy\PYGZus{}range} \PYG{o}{=} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{sub\PYGZus{}dict}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{doy\PYGZus{}start}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYGZbs{}
                      \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{sub\PYGZus{}dict}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{doy\PYGZus{}end}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}

\PYG{c}{\PYGZsh{} 3c. loop over each file read from}
\PYG{c}{\PYGZsh{}     sub\PYGZus{}dict[\PYGZsq{}file\PYGZus{}list\PYGZsq{}]}
\PYG{k}{for} \PYG{n}{this\PYGZus{}file} \PYG{o+ow}{in} \PYG{n}{fp}\PYG{o}{.}\PYG{n}{readlines}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}

    \PYG{c}{\PYGZsh{} 3d. extract doy from the file name}
    \PYG{n}{doy} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{this\PYGZus{}file}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{.}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{:}\PYG{p}{]}\PYG{p}{)}

    \PYG{c}{\PYGZsh{} 3e. see if doy is in the range we want?}
    \PYG{k}{if} \PYG{n}{doy} \PYG{o+ow}{in} \PYG{n}{doy\PYGZus{}range}\PYG{p}{:}

        \PYG{c}{\PYGZsh{} 3f. store the filename in the list}
        \PYG{n}{wanted\PYGZus{}files}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{/}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{sub\PYGZus{}dict}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{dir}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{this\PYGZus{}file}\PYG{p}{)}\PYG{p}{)}

\PYG{c}{\PYGZsh{} close the file here now}
\PYG{n}{fp}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

If you wanted, you could also do some clever things with \code{and}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} 3a. Read the file list}
\PYG{n}{fp} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{sub\PYGZus{}dict}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{file\PYGZus{}list}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{c}{\PYGZsh{} 3b. find the doy range}
\PYG{n}{doy\PYGZus{}range} \PYG{o}{=} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{sub\PYGZus{}dict}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{doy\PYGZus{}start}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYGZbs{}
                      \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{sub\PYGZus{}dict}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{doy\PYGZus{}end}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}

\PYG{c}{\PYGZsh{} 3c. loop over each file read from}
\PYG{c}{\PYGZsh{}     sub\PYGZus{}dict[\PYGZsq{}file\PYGZus{}list\PYGZsq{}]}
\PYG{k}{for} \PYG{n}{this\PYGZus{}file} \PYG{o+ow}{in} \PYG{n}{fp}\PYG{o}{.}\PYG{n}{readlines}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}

    \PYG{c}{\PYGZsh{} 3d. extract doy from the file name}
    \PYG{n}{doy} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{this\PYGZus{}file}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{.}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{:}\PYG{p}{]}\PYG{p}{)}

    \PYG{c}{\PYGZsh{} 3e. see if doy is in the range we want}
    \PYG{c}{\PYGZsh{} and put in list if so}
    \PYG{n}{doy} \PYG{o+ow}{in} \PYG{n}{doy\PYGZus{}range} \PYG{o+ow}{and} \PYGZbs{}
        \PYG{n}{wanted\PYGZus{}files}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{/}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{sub\PYGZus{}dict}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{dir}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{this\PYGZus{}file}\PYG{p}{)}\PYG{p}{)}

\PYG{c}{\PYGZsh{} close the file here now}
\PYG{n}{fp}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

Writing the results to file should be straightforward enough for you
now.

You could do it at the end:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} 1. Read the configuration file}
\PYG{c}{\PYGZsh{} into the dict modis}
\PYG{k+kn}{import} \PYG{n+nn}{ConfigParser}

\PYG{c}{\PYGZsh{} good to open the file early on}
\PYG{c}{\PYGZsh{} in case it fails}
\PYG{n}{ofile} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/modis\PYGZus{}files.dat}\PYG{l+s}{\PYGZsq{}}
\PYG{n}{ofp} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{ofile}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{w}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}

\PYG{n}{config} \PYG{o}{=} \PYG{n}{ConfigParser}\PYG{o}{.}\PYG{n}{ConfigParser}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{config}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/modis.cfg}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{c}{\PYGZsh{} we can convert this to a normal dictionary}
\PYG{n}{modis} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n}{config}\PYG{o}{.}\PYG{n}{sections}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{modis}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]} \PYG{o}{=} \PYG{n+nb}{dict}\PYG{p}{(}\PYG{n}{config}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}\PYG{p}{)}

\PYG{c}{\PYGZsh{} 2. Now, loop over config sections}
\PYG{c}{\PYGZsh{} and get the sub\PYGZhy{}dictionary which we call sub\PYGZus{}dict}

\PYG{c}{\PYGZsh{} 3. set up anb empty list to contain the}
\PYG{c}{\PYGZsh{} files we want to process}
\PYG{n}{wanted\PYGZus{}files} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}

\PYG{k}{for} \PYG{n}{k}\PYG{p}{,}\PYG{n}{v} \PYG{o+ow}{in} \PYG{n}{modis}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}

    \PYG{n}{sub\PYGZus{}dict} \PYG{o}{=} \PYG{n}{v}

    \PYG{c}{\PYGZsh{} 3a. Read the file list}
    \PYG{n}{fp} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{sub\PYGZus{}dict}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{file\PYGZus{}list}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

    \PYG{c}{\PYGZsh{} 3b. find the doy range}
    \PYG{n}{doy\PYGZus{}range} \PYG{o}{=} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{sub\PYGZus{}dict}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{doy\PYGZus{}start}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYGZbs{}
                          \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{sub\PYGZus{}dict}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{doy\PYGZus{}end}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}

    \PYG{c}{\PYGZsh{} 3c. loop over each file read from}
    \PYG{c}{\PYGZsh{}     sub\PYGZus{}dict[\PYGZsq{}file\PYGZus{}list\PYGZsq{}]}
    \PYG{k}{for} \PYG{n}{this\PYGZus{}file} \PYG{o+ow}{in} \PYG{n}{fp}\PYG{o}{.}\PYG{n}{readlines}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}

        \PYG{c}{\PYGZsh{} 3d. extract doy from the file name}
        \PYG{n}{doy} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{this\PYGZus{}file}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{.}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{:}\PYG{p}{]}\PYG{p}{)}
        \PYG{c}{\PYGZsh{} 3e. see if doy is in the range we want}
        \PYG{c}{\PYGZsh{} and put in list if so}
        \PYG{n}{doy} \PYG{o+ow}{in} \PYG{n}{doy\PYGZus{}range} \PYG{o+ow}{and} \PYGZbs{}
            \PYG{n}{wanted\PYGZus{}files}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{/}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{sub\PYGZus{}dict}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{dir}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{this\PYGZus{}file}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{fp}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}

\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{I found }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{ files to process}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZpc{}}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{wanted\PYGZus{}files}\PYG{p}{)}

\PYG{n}{ofp}\PYG{o}{.}\PYG{n}{writelines}\PYG{p}{(}\PYG{n}{wanted\PYGZus{}files}\PYG{p}{)}
\PYG{n}{ofp}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
I found 62 files to process
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
!head \PYGZhy{}10 \PYGZlt{} files/data/modis\PYGZus{}files.dat
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
/data/geospatial\PYGZus{}19/ucfajlg/fire/Angola/MYD09/MYD09GA.A2004214.h19v10.005.2007299212915.hdf
/data/geospatial\PYGZus{}19/ucfajlg/fire/Angola/MYD09/MYD09GA.A2004215.h19v10.005.2007300042347.hdf
/data/geospatial\PYGZus{}19/ucfajlg/fire/Angola/MYD09/MYD09GA.A2004216.h19v10.005.2007300091257.hdf
/data/geospatial\PYGZus{}19/ucfajlg/fire/Angola/MYD09/MYD09GA.A2004217.h19v10.005.2007300153436.hdf
/data/geospatial\PYGZus{}19/ucfajlg/fire/Angola/MYD09/MYD09GA.A2004218.h19v10.005.2007300215826.hdf
/data/geospatial\PYGZus{}19/ucfajlg/fire/Angola/MYD09/MYD09GA.A2004219.h19v10.005.2007302194509.hdf
/data/geospatial\PYGZus{}19/ucfajlg/fire/Angola/MYD09/MYD09GA.A2004220.h19v10.005.2007302093547.hdf
/data/geospatial\PYGZus{}19/ucfajlg/fire/Angola/MYD09/MYD09GA.A2004221.h19v10.005.2007302222054.hdf
/data/geospatial\PYGZus{}19/ucfajlg/fire/Angola/MYD09/MYD09GA.A2004222.h19v10.005.2007303011606.hdf
/data/geospatial\PYGZus{}19/ucfajlg/fire/Angola/MYD09/MYD09GA.A2004223.h19v10.005.2007303073538.hdf
\end{Verbatim}

Or you could print as you go along in the loop:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} 1. Read the configuration file}
\PYG{c}{\PYGZsh{} into the dict modis}
\PYG{k+kn}{import} \PYG{n+nn}{ConfigParser}

\PYG{c}{\PYGZsh{} good to open the file early on}
\PYG{c}{\PYGZsh{} in case it fails}
\PYG{n}{ofile} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/modis\PYGZus{}files.dat}\PYG{l+s}{\PYGZsq{}}
\PYG{n}{ofp} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{ofile}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{w}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}

\PYG{n}{config} \PYG{o}{=} \PYG{n}{ConfigParser}\PYG{o}{.}\PYG{n}{ConfigParser}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{config}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/modis.cfg}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{c}{\PYGZsh{} we can convert this to a normal dictionary}
\PYG{n}{modis} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n}{config}\PYG{o}{.}\PYG{n}{sections}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{modis}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]} \PYG{o}{=} \PYG{n+nb}{dict}\PYG{p}{(}\PYG{n}{config}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}\PYG{p}{)}

\PYG{c}{\PYGZsh{} 2. Now, loop over config sections}
\PYG{c}{\PYGZsh{} and get the sub\PYGZhy{}dictionary which we call sub\PYGZus{}dict}

\PYG{c}{\PYGZsh{} 3. set up anb empty list to contain the}
\PYG{c}{\PYGZsh{} files we want to process}
\PYG{n}{wanted\PYGZus{}files} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}

\PYG{k}{for} \PYG{n}{k}\PYG{p}{,}\PYG{n}{v} \PYG{o+ow}{in} \PYG{n}{modis}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}

    \PYG{n}{sub\PYGZus{}dict} \PYG{o}{=} \PYG{n}{v}

    \PYG{c}{\PYGZsh{} 3a. Read the file list}
    \PYG{n}{fp} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{sub\PYGZus{}dict}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{file\PYGZus{}list}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

    \PYG{c}{\PYGZsh{} 3b. find the doy range}
    \PYG{n}{doy\PYGZus{}range} \PYG{o}{=} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{sub\PYGZus{}dict}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{doy\PYGZus{}start}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYGZbs{}
                          \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{sub\PYGZus{}dict}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{doy\PYGZus{}end}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}

    \PYG{c}{\PYGZsh{} 3c. loop over each file read from}
    \PYG{c}{\PYGZsh{}     sub\PYGZus{}dict[\PYGZsq{}file\PYGZus{}list\PYGZsq{}]}
    \PYG{k}{for} \PYG{n}{this\PYGZus{}file} \PYG{o+ow}{in} \PYG{n}{fp}\PYG{o}{.}\PYG{n}{readlines}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}

        \PYG{c}{\PYGZsh{} 3d. extract doy from the file name}
        \PYG{c}{\PYGZsh{} 3e. see if doy is in the range we want}
        \PYG{c}{\PYGZsh{} and put in list if so}
        \PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{this\PYGZus{}file}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{.}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{:}\PYG{p}{]}\PYG{p}{)} \PYG{o+ow}{in} \PYG{n}{doy\PYGZus{}range}\PYG{p}{)} \PYG{o+ow}{and} \PYGZbs{}
                \PYG{n}{ofp}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{/}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{sub\PYGZus{}dict}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{dir}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{this\PYGZus{}file}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{fp}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{ofp}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
!head \PYGZhy{}10 \PYGZlt{} files/data/modis\PYGZus{}files.dat
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
/data/geospatial\PYGZus{}19/ucfajlg/fire/Angola/MYD09/MYD09GA.A2004214.h19v10.005.2007299212915.hdf
/data/geospatial\PYGZus{}19/ucfajlg/fire/Angola/MYD09/MYD09GA.A2004215.h19v10.005.2007300042347.hdf
/data/geospatial\PYGZus{}19/ucfajlg/fire/Angola/MYD09/MYD09GA.A2004216.h19v10.005.2007300091257.hdf
/data/geospatial\PYGZus{}19/ucfajlg/fire/Angola/MYD09/MYD09GA.A2004217.h19v10.005.2007300153436.hdf
/data/geospatial\PYGZus{}19/ucfajlg/fire/Angola/MYD09/MYD09GA.A2004218.h19v10.005.2007300215826.hdf
/data/geospatial\PYGZus{}19/ucfajlg/fire/Angola/MYD09/MYD09GA.A2004219.h19v10.005.2007302194509.hdf
/data/geospatial\PYGZus{}19/ucfajlg/fire/Angola/MYD09/MYD09GA.A2004220.h19v10.005.2007302093547.hdf
/data/geospatial\PYGZus{}19/ucfajlg/fire/Angola/MYD09/MYD09GA.A2004221.h19v10.005.2007302222054.hdf
/data/geospatial\PYGZus{}19/ucfajlg/fire/Angola/MYD09/MYD09GA.A2004222.h19v10.005.2007303011606.hdf
/data/geospatial\PYGZus{}19/ucfajlg/fire/Angola/MYD09/MYD09GA.A2004223.h19v10.005.2007303073538.hdf
\end{Verbatim}


\chapter{A3. Advanced notes: Scientific and Numerical Python}
\label{Chapter3_Scientific_Numerical_Python/advanced:a3-advanced-notes-scientific-and-numerical-python}\label{Chapter3_Scientific_Numerical_Python/advanced::doc}

\section{A3.1 Pulling Compressed netCDF Files}
\label{Chapter3_Scientific_Numerical_Python/advanced:a3-1-pulling-compressed-netcdf-files}
Sometimes, such as when we want to pull data from netCDF files from some
data site such as \href{http://www.globalbedo.org}{http://www.globalbedo.org}, we might find that `older
style' formats have been used, such as netCDF3 which might not have
internal compression.

To save storage space, it is common to compress such files extrenally
(i.e. to gzip a file).

That makes direct reading from a url a bit more tricky, and in such
cases, we may as well uncompress the file to a local temporary file.


\subsection{Doing this in Python}
\label{Chapter3_Scientific_Numerical_Python/advanced:doing-this-in-python}
What we are going to do is to write a class to download a gzipped file
from a url and return a filename that can be read by other functions.

The file is available as gzurl.py, in the
directory \code{files/python}.

To be able to import this, we have to put \code{files/python} in the path
where Python looks for modules:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{sys}\PYG{o}{,}\PYG{n+nn}{os}
\PYG{c}{\PYGZsh{} put local directory into the path}
\PYG{n}{sys}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{abspath}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{python}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{n}{os}\PYG{o}{.}\PYG{n}{sep}\PYG{p}{)}\PYG{p}{)}

\PYG{c}{\PYGZsh{} import module}
\PYG{k+kn}{from} \PYG{n+nn}{gzurl} \PYG{k+kn}{import} \PYG{n}{gzurl}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{help}\PYG{p}{(}\PYG{n}{gzurl}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
Help on class gzurl in module gzurl:

class gzurl(\PYGZus{}\PYGZus{}builtin\PYGZus{}\PYGZus{}.object)
 \textbar{}  Download gzipped url to a local file or string
 \textbar{}
 \textbar{}  Prof. P. Lewis, UCL,
 \textbar{}  Thu 10 Oct 2013 12:01:00 BST
 \textbar{}  p.lewis@ucl.ac.uk
 \textbar{}
 \textbar{}  Methods defined here:
 \textbar{}
 \textbar{}  \PYGZus{}\PYGZus{}del\PYGZus{}\PYGZus{}(self)
 \textbar{}      Destriuctor
 \textbar{}
 \textbar{}      Tidy up
 \textbar{}
 \textbar{}  \PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}(self, url, filename=None, store=False, file=True)
 \textbar{}      initialise class instance
 \textbar{}
 \textbar{}      Parameters:
 \textbar{}
 \textbar{}      url   : url of gzipped file
 \textbar{}
 \textbar{}      Options:
 \textbar{}
 \textbar{}      filename:
 \textbar{}              specify a filename explicitly, rather than
 \textbar{}              a temporary file (default None)
 \textbar{}      store : boolean flag to store the uncompressed
 \textbar{}              data in self.data (default false)
 \textbar{}      file  : boolean flag to store data to a file
 \textbar{}              (default True)
 \textbar{}
 \textbar{}  close(self)
 \textbar{}      Tidy up
 \textbar{}
 \textbar{}  read(self, url)
 \textbar{}      read gzipped data from url
 \textbar{}      and uncompress
 \textbar{}
 \textbar{}  \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
 \textbar{}  Data descriptors defined here:
 \textbar{}
 \textbar{}  \PYGZus{}\PYGZus{}dict\PYGZus{}\PYGZus{}
 \textbar{}      dictionary for instance variables (if defined)
 \textbar{}
 \textbar{}  \PYGZus{}\PYGZus{}weakref\PYGZus{}\PYGZus{}
 \textbar{}      list of weak references to the object (if defined)
\end{Verbatim}

You can look through the file \code{{}`gzurl.py} \textless{}files/python/gzurl.py\textgreater{}{}`\_\_
at your leisure, but it is of interest to see how we have done this.

We need to load the following modules to do this:

\code{urllib2, io, gzip, tempfile}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{urllib2}\PYG{o}{,} \PYG{n+nn}{io}\PYG{o}{,} \PYG{n+nn}{gzip}\PYG{o}{,} \PYG{n+nn}{tempfile}
\end{Verbatim}

The first thing we do is attempt to open a file specified from a url:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} codes for url specification on globalbedo.org}
\PYG{n}{years} \PYG{o}{=} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1998}\PYG{p}{,}\PYG{l+m+mi}{2012}\PYG{p}{)}
\PYG{n}{codes} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{95}\PYG{p}{,}\PYG{l+m+mi}{95}\PYG{p}{,}\PYG{l+m+mi}{97}\PYG{p}{,}\PYG{l+m+mi}{97}\PYG{p}{,}\PYG{l+m+mi}{26}\PYG{p}{,}\PYG{l+m+mi}{66}\PYG{p}{,}\PYG{l+m+mi}{54}\PYG{p}{,}\PYG{l+m+mi}{54}\PYG{p}{,}\PYG{l+m+mi}{29}\PYG{p}{,}\PYG{l+m+mi}{25}\PYG{p}{,}\PYG{l+m+mi}{53}\PYG{p}{,}\PYG{l+m+mi}{56}\PYG{p}{,}\PYG{l+m+mi}{56}\PYG{p}{,}\PYG{l+m+mi}{78}\PYG{p}{]}
\PYG{n}{XX} \PYG{o}{=} \PYG{n+nb}{dict}\PYG{p}{(}\PYG{n+nb}{zip}\PYG{p}{(}\PYG{n}{years}\PYG{p}{,}\PYG{n}{codes}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{year} \PYG{o}{=} \PYG{l+m+mi}{2009}

\PYG{n}{root} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{http://www.globalbedo.org/GlobAlbedo}\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{/mosaics/}\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{/0.5/monthly/}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYGZbs{}
        \PYG{p}{(}\PYG{n}{XX}\PYG{p}{[}\PYG{n}{year}\PYG{p}{]}\PYG{p}{,}\PYG{n}{year}\PYG{p}{)}

\PYG{c}{\PYGZsh{} filename formatting string: use \PYGZpc{}02d for month eg 01 for 1}
\PYG{n}{month} \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{n}{url} \PYG{o}{=} \PYG{n}{root} \PYG{o}{+} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/GlobAlbedo.}\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s+si}{\PYGZpc{}02d}\PYG{l+s}{.mosaic.5.nc.gz}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{year}\PYG{p}{,}\PYG{n}{month}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{url}

\PYG{c}{\PYGZsh{} open file from url}
\PYG{n}{f} \PYG{o}{=} \PYG{n}{urllib2}\PYG{o}{.}\PYG{n}{urlopen}\PYG{p}{(}\PYG{n}{url}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
http://www.globalbedo.org/GlobAlbedo56/mosaics/2009/0.5/monthly//GlobAlbedo.200901.mosaic.5.nc.gz
\end{Verbatim}

We then read data from that with the statement:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{bdata} \PYG{o}{=} \PYG{n}{f}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{p}{)}

\PYG{c}{\PYGZsh{} which looks like this:}
\PYG{n}{bdata}\PYG{p}{[}\PYG{p}{:}\PYG{l+m+mi}{50}\PYG{p}{]}
\end{Verbatim}
\begin{alltt}
`x1fx8bx08x08xf5xe71Rx00x03GlobAlbedo.200901.mosaic.5.ncx00xecxdbwxTUxfexc7qx10'
\end{alltt}

We then create a buffered I/O stream from this using io.BytesIO, which
is the form we want the information in for the next part:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{f} \PYG{o}{=} \PYG{n}{urllib2}\PYG{o}{.}\PYG{n}{urlopen}\PYG{p}{(}\PYG{n}{url}\PYG{p}{)}
\PYG{n}{fileobj} \PYG{o}{=} \PYG{n}{io}\PYG{o}{.}\PYG{n}{BytesIO}\PYG{p}{(}\PYG{n}{f}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

Next, we use the module \code{gzip.GzipFile} which simulates the methods of
a gzip file:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{gzip}\PYG{o}{.}\PYG{n}{GzipFile}\PYG{p}{(}\PYG{n}{fileobj}\PYG{o}{=}\PYG{n}{fileobj}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}gzip \PYGZus{}io.BytesIO object at 0x105aea950 0x105bd2890\PYGZgt{}
\end{Verbatim}

And then we read from this:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{f} \PYG{o}{=} \PYG{n}{urllib2}\PYG{o}{.}\PYG{n}{urlopen}\PYG{p}{(}\PYG{n}{url}\PYG{p}{)}
\PYG{n}{data}\PYG{o}{=}\PYG{n}{gzip}\PYG{o}{.}\PYG{n}{GzipFile}\PYG{p}{(}\PYG{n}{fileobj}\PYG{o}{=}\PYG{n}{io}\PYG{o}{.}\PYG{n}{BytesIO}\PYG{p}{(}\PYG{n}{f}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

This is now binary of netCDF format in this case.

Next, we need to write these data to a file. In this case, we don't want
to really save the data anywhere, so we want to use a temporary file.

In Python, you can create a temporary file using the module tempfile,
which creates a temporary (unique) file on the system.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{tmp} \PYG{o}{=} \PYG{n}{tempfile}\PYG{o}{.}\PYG{n}{NamedTemporaryFile}\PYG{p}{(}\PYG{n}{delete}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{tmp}\PYG{o}{.}\PYG{n}{name}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
/var/folders/pt/z0y8dmcd7d77cs\PYGZus{}0hnygpwh80000gn/T/tmpN1LPzf
\end{Verbatim}

So we write the data to this file:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{tmp}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}
\end{Verbatim}

Then, after we have done something with the data, we will want to tidy
up and delete the file:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{tmp}\PYG{o}{.}\PYG{n}{unlink}\PYG{p}{(}\PYG{n}{tmp}\PYG{o}{.}\PYG{n}{name}\PYG{p}{)}
\end{Verbatim}

To use this module then:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{sys}\PYG{o}{,}\PYG{n+nn}{os}
\PYG{c}{\PYGZsh{} put local directory into the path}
\PYG{n}{sys}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{abspath}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{python}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{n}{os}\PYG{o}{.}\PYG{n}{sep}\PYG{p}{)}\PYG{p}{)}
\PYG{c}{\PYGZsh{} import local module gzurl}
\PYG{k+kn}{from} \PYG{n+nn}{gzurl} \PYG{k+kn}{import} \PYG{n}{gzurl}
\PYG{k+kn}{from} \PYG{n+nn}{netCDF4} \PYG{k+kn}{import} \PYG{n}{Dataset}

\PYG{c}{\PYGZsh{} codes for url specification on globalbedo.org}
\PYG{n}{years} \PYG{o}{=} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1998}\PYG{p}{,}\PYG{l+m+mi}{2012}\PYG{p}{)}
\PYG{n}{codes} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{95}\PYG{p}{,}\PYG{l+m+mi}{95}\PYG{p}{,}\PYG{l+m+mi}{97}\PYG{p}{,}\PYG{l+m+mi}{97}\PYG{p}{,}\PYG{l+m+mi}{26}\PYG{p}{,}\PYG{l+m+mi}{66}\PYG{p}{,}\PYG{l+m+mi}{54}\PYG{p}{,}\PYG{l+m+mi}{54}\PYG{p}{,}\PYG{l+m+mi}{29}\PYG{p}{,}\PYG{l+m+mi}{25}\PYG{p}{,}\PYG{l+m+mi}{53}\PYG{p}{,}\PYG{l+m+mi}{56}\PYG{p}{,}\PYG{l+m+mi}{56}\PYG{p}{,}\PYG{l+m+mi}{78}\PYG{p}{]}
\PYG{n}{XX} \PYG{o}{=} \PYG{n+nb}{dict}\PYG{p}{(}\PYG{n+nb}{zip}\PYG{p}{(}\PYG{n}{years}\PYG{p}{,}\PYG{n}{codes}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{year} \PYG{o}{=} \PYG{l+m+mi}{2009}

\PYG{n}{root} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{http://www.globalbedo.org/GlobAlbedo}\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{/mosaics/}\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{/0.5/monthly/}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYGZbs{}
        \PYG{p}{(}\PYG{n}{XX}\PYG{p}{[}\PYG{n}{year}\PYG{p}{]}\PYG{p}{,}\PYG{n}{year}\PYG{p}{)}

\PYG{k}{print} \PYG{n}{root}

\PYG{c}{\PYGZsh{} filename formatting string: use \PYGZpc{}02d for month eg 01 for 1}
\PYG{n}{month} \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{n}{url} \PYG{o}{=} \PYG{n}{root} \PYG{o}{+} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/GlobAlbedo.}\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s+si}{\PYGZpc{}02d}\PYG{l+s}{.mosaic.5.nc.gz}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{year}\PYG{p}{,}\PYG{n}{month}\PYG{p}{)}

\PYG{c}{\PYGZsh{} read the gzipped file}
\PYG{n}{f} \PYG{o}{=} \PYG{n}{gzurl}\PYG{p}{(}\PYG{n}{url}\PYG{p}{)}
\PYG{c}{\PYGZsh{} read the netCDF file from f.filename}
\PYG{n}{nc} \PYG{o}{=} \PYG{n}{Dataset}\PYG{p}{(}\PYG{n}{f}\PYG{o}{.}\PYG{n}{filename}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{c}{\PYGZsh{} close f}
\PYG{n}{f}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
http://www.globalbedo.org/GlobAlbedo56/mosaics/2009/0.5/monthly/
\end{Verbatim}

Alternatively, to read all of the files into the directory files/data
for the year 2011 and keep them:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{sys}\PYG{o}{,}\PYG{n+nn}{os}
\PYG{c}{\PYGZsh{} put local directory into the path}
\PYG{n}{sys}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{abspath}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{python}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{n}{os}\PYG{o}{.}\PYG{n}{sep}\PYG{p}{)}\PYG{p}{)}
\PYG{c}{\PYGZsh{} import local module gzurl}
\PYG{k+kn}{from} \PYG{n+nn}{gzurl} \PYG{k+kn}{import} \PYG{n}{gzurl}
\PYG{k+kn}{from} \PYG{n+nn}{netCDF4} \PYG{k+kn}{import} \PYG{n}{Dataset}

\PYG{c}{\PYGZsh{} codes for url specification on globalbedo.org}
\PYG{n}{years} \PYG{o}{=} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1998}\PYG{p}{,}\PYG{l+m+mi}{2012}\PYG{p}{)}
\PYG{n}{codes} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{95}\PYG{p}{,}\PYG{l+m+mi}{95}\PYG{p}{,}\PYG{l+m+mi}{97}\PYG{p}{,}\PYG{l+m+mi}{97}\PYG{p}{,}\PYG{l+m+mi}{26}\PYG{p}{,}\PYG{l+m+mi}{66}\PYG{p}{,}\PYG{l+m+mi}{54}\PYG{p}{,}\PYG{l+m+mi}{54}\PYG{p}{,}\PYG{l+m+mi}{29}\PYG{p}{,}\PYG{l+m+mi}{25}\PYG{p}{,}\PYG{l+m+mi}{53}\PYG{p}{,}\PYG{l+m+mi}{56}\PYG{p}{,}\PYG{l+m+mi}{56}\PYG{p}{,}\PYG{l+m+mi}{78}\PYG{p}{]}
\PYG{n}{XX} \PYG{o}{=} \PYG{n+nb}{dict}\PYG{p}{(}\PYG{n+nb}{zip}\PYG{p}{(}\PYG{n}{years}\PYG{p}{,}\PYG{n}{codes}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{year} \PYG{o}{=} \PYG{l+m+mi}{2009}

\PYG{n}{root} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{http://www.globalbedo.org/GlobAlbedo}\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{/mosaics/}\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{/0.5/monthly/}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYGZbs{}
        \PYG{p}{(}\PYG{n}{XX}\PYG{p}{[}\PYG{n}{year}\PYG{p}{]}\PYG{p}{,}\PYG{n}{year}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{month0} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{)}\PYG{p}{:}
    \PYG{c}{\PYGZsh{} filename formatting string: use \PYGZpc{}02d for month eg 01 for 1}
    \PYG{n}{base} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{GlobAlbedo.}\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s+si}{\PYGZpc{}02d}\PYG{l+s}{.mosaic.5.nc}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{year}\PYG{p}{,}\PYG{n}{month0}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{n}{url} \PYG{o}{=} \PYG{n}{root} \PYG{o}{+} \PYG{n}{base} \PYG{o}{+} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{.gz}\PYG{l+s}{\PYGZsq{}}
    \PYG{c}{\PYGZsh{} specify a local filename}
    \PYG{c}{\PYGZsh{} work out how / why this works ...}
    \PYG{n}{local} \PYG{o}{=} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files\PYGZob{}0\PYGZcb{}data\PYGZob{}0\PYGZcb{}}\PYG{l+s}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{os}\PYG{o}{.}\PYG{n}{sep}\PYG{p}{)}\PYG{p}{,}\PYG{n}{base}\PYG{p}{)}

    \PYG{c}{\PYGZsh{} read the gzipped file}
    \PYG{k}{print} \PYG{n}{local}
    \PYG{n}{f} \PYG{o}{=} \PYG{n}{gzurl}\PYG{p}{(}\PYG{n}{url}\PYG{p}{,}\PYG{n}{filename}\PYG{o}{=}\PYG{n}{local}\PYG{p}{)}
    \PYG{c}{\PYGZsh{} read the netCDF file from f.filename}
    \PYG{n}{nc} \PYG{o}{=} \PYG{n}{Dataset}\PYG{p}{(}\PYG{n}{f}\PYG{o}{.}\PYG{n}{filename}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
    \PYG{c}{\PYGZsh{} close f}
    \PYG{n}{f}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
files/data/GlobAlbedo.200901.mosaic.5.nc
files/data/GlobAlbedo.200902.mosaic.5.nc
files/data/GlobAlbedo.200903.mosaic.5.nc
files/data/GlobAlbedo.200904.mosaic.5.nc
files/data/GlobAlbedo.200905.mosaic.5.nc
files/data/GlobAlbedo.200906.mosaic.5.nc
files/data/GlobAlbedo.200907.mosaic.5.nc
files/data/GlobAlbedo.200908.mosaic.5.nc
files/data/GlobAlbedo.200909.mosaic.5.nc
files/data/GlobAlbedo.200910.mosaic.5.nc
files/data/GlobAlbedo.200911.mosaic.5.nc
files/data/GlobAlbedo.200912.mosaic.5.nc
\end{Verbatim}


\subsection{Doing this in unix}
\label{Chapter3_Scientific_Numerical_Python/advanced:doing-this-in-unix}
That's not too complicated, but you might often do this sort of thing
from unix instead:

\begin{Verbatim}[commandchars=\\\{\}]
!rm \PYGZhy{}f files/data/GlobAlbedo.200901.mosaic.5.nc.gz
!wget \PYGZhy{}O files/data/GlobAlbedo.200901.mosaic.5.nc.gz \PYGZbs{}
  http://www.globalbedo.org/GlobAlbedo56/mosaics/2009/0.5/monthly/GlobAlbedo.200901.mosaic.5.nc.gz
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZhy{}\PYGZhy{}2013\PYGZhy{}10\PYGZhy{}12 20:13:51\PYGZhy{}\PYGZhy{}  http://www.globalbedo.org/GlobAlbedo56/mosaics/2009/0.5/monthly/GlobAlbedo.200901.mosaic.5.nc.gz
Resolving www.globalbedo.org... 128.40.73.100
Connecting to www.globalbedo.org\textbar{}128.40.73.100\textbar{}:80... connected.
HTTP request sent, awaiting response... 200 OK
Length: 4540366 (4.3M) [application/x\PYGZhy{}gzip]
Saving to: {}`files/data/GlobAlbedo.200901.mosaic.5.nc.gz\PYGZsq{}

100\PYGZpc{}[======================================\PYGZgt{}] 4,540,366   2.78M/s   in 1.6s

2013\PYGZhy{}10\PYGZhy{}12 20:13:52 (2.78 MB/s) \PYGZhy{} {}`files/data/GlobAlbedo.200901.mosaic.5.nc.gz\PYGZsq{} saved [4540366/4540366]
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
!gunzip \PYGZhy{}f files/data/GlobAlbedo.200901.mosaic.5.nc.gz
!ls \PYGZhy{}l files/data/GlobAlbedo.200901.mosaic.5.nc
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{}r\PYGZhy{}\PYGZhy{}  1 plewis  staff  18669672 12 Sep 17:12 files/data/GlobAlbedo.200901.mosaic.5.nc
\end{Verbatim}


\section{A3.2 Logical combinations in numpy}
\label{Chapter3_Scientific_Numerical_Python/advanced:a3-2-logical-combinations-in-numpy}
Let's read in a different GlobAlbedo dataset.

This time, we will read 8 day tile data (day of year: \code{001}, \code{009}
etc. every 8 days).

The tile we will read is \code{h17v03} which covers most of the UK.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{sys}\PYG{o}{,}\PYG{n+nn}{os}
\PYG{n}{sys}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{abspath}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{python}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{n}{os}\PYG{o}{.}\PYG{n}{sep}\PYG{p}{)}\PYG{p}{)}
\PYG{k+kn}{from} \PYG{n+nn}{gzurl} \PYG{k+kn}{import} \PYG{n}{gzurl}
\PYG{k+kn}{from} \PYG{n+nn}{netCDF4} \PYG{k+kn}{import} \PYG{n}{Dataset}

\PYG{n}{years} \PYG{o}{=} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1998}\PYG{p}{,}\PYG{l+m+mi}{2012}\PYG{p}{)}
\PYG{n}{codes} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{95}\PYG{p}{,}\PYG{l+m+mi}{95}\PYG{p}{,}\PYG{l+m+mi}{97}\PYG{p}{,}\PYG{l+m+mi}{97}\PYG{p}{,}\PYG{l+m+mi}{26}\PYG{p}{,}\PYG{l+m+mi}{66}\PYG{p}{,}\PYG{l+m+mi}{54}\PYG{p}{,}\PYG{l+m+mi}{54}\PYG{p}{,}\PYG{l+m+mi}{29}\PYG{p}{,}\PYG{l+m+mi}{25}\PYG{p}{,}\PYG{l+m+mi}{53}\PYG{p}{,}\PYG{l+m+mi}{56}\PYG{p}{,}\PYG{l+m+mi}{56}\PYG{p}{,}\PYG{l+m+mi}{78}\PYG{p}{]}
\PYG{n}{XX} \PYG{o}{=} \PYG{n+nb}{dict}\PYG{p}{(}\PYG{n+nb}{zip}\PYG{p}{(}\PYG{n}{years}\PYG{p}{,}\PYG{n}{codes}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{year} \PYG{o}{=} \PYG{l+m+mi}{2009}
\PYG{n}{tile} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{h17v03}\PYG{l+s}{\PYGZsq{}}

\PYG{n}{root} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{http://www.globalbedo.org/GlobAlbedo}\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{/tiles/}\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{/}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{/}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYGZbs{}
        \PYG{p}{(}\PYG{n}{XX}\PYG{p}{[}\PYG{n}{year}\PYG{p}{]}\PYG{p}{,}\PYG{n}{year}\PYG{p}{,}\PYG{n}{tile}\PYG{p}{)}

\PYG{c}{\PYGZsh{} filename formatting string: use \PYGZpc{}03d for doy eg 001 for 1}
\PYG{n}{doy} \PYG{o}{=} \PYG{l+m+mi}{145}
\PYG{n}{url} \PYG{o}{=} \PYG{n}{root} \PYG{o}{+} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{GlobAlbedo.}\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s+si}{\PYGZpc{}03d}\PYG{l+s}{.}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{.nc.gz}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{year}\PYG{p}{,}\PYG{n}{doy}\PYG{p}{,}\PYG{n}{tile}\PYG{p}{)}
\PYG{c}{\PYGZsh{} see if you can make sense of this complicated formatting}
\PYG{n}{filename} \PYG{o}{=} \PYG{n}{url}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{replace}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{.gz}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{local\PYGZus{}file} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files\PYGZob{}0\PYGZcb{}data\PYGZob{}0\PYGZcb{}\PYGZob{}1\PYGZcb{}}\PYG{l+s}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{os}\PYG{o}{.}\PYG{n}{sep}\PYG{p}{,}\PYG{n}{filename}\PYG{p}{)}

\PYG{c}{\PYGZsh{} try to read local file}
\PYG{k}{try}\PYG{p}{:}
    \PYG{n}{nc} \PYG{o}{=} \PYG{n}{Dataset}\PYG{p}{(}\PYG{n}{local\PYGZus{}file}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{except}\PYG{p}{:}
    \PYG{n}{f} \PYG{o}{=} \PYG{n}{gzurl}\PYG{p}{(}\PYG{n}{url}\PYG{p}{,}\PYG{n}{filename}\PYG{o}{=}\PYG{n}{local\PYGZus{}file}\PYG{p}{)}
    \PYG{n}{nc} \PYG{o}{=} \PYG{n}{Dataset}\PYG{p}{(}\PYG{n}{f}\PYG{o}{.}\PYG{n}{filename}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{f}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} now pull some data}

\PYG{n}{vis} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{nc}\PYG{o}{.}\PYG{n}{variables}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{BHR\PYGZus{}VIS}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{nir} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{nc}\PYG{o}{.}\PYG{n}{variables}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{BHR\PYGZus{}NIR}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ndvi} \PYG{o}{=} \PYG{p}{(}\PYG{n}{nir} \PYG{o}{\PYGZhy{}} \PYG{n}{vis}\PYG{p}{)}\PYG{o}{/}\PYG{p}{(}\PYG{n}{nir} \PYG{o}{+} \PYG{n}{vis}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZhy{}c:5: RuntimeWarning: invalid value encountered in divide
\end{Verbatim}

Now plot it:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{pylab} \PYG{k+kn}{as} \PYG{n+nn}{plt}

\PYG{c}{\PYGZsh{} figure size}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{)}
\PYG{c}{\PYGZsh{} title}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{NDVI: Tile }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{ }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{ doy }\PYG{l+s+si}{\PYGZpc{}03d}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{tile}\PYG{p}{,}\PYG{n}{year}\PYG{p}{,}\PYG{n}{doy}\PYG{p}{)}\PYG{p}{)}
\PYG{c}{\PYGZsh{} colour map}
\PYG{n}{cmap} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{get\PYGZus{}cmap}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Spectral}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{c}{\PYGZsh{} plot the figure}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{ndvi}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{cmap}\PYG{o}{=}\PYG{n}{cmap}\PYG{p}{,}\PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{n}{vmax}\PYG{o}{=}\PYG{l+m+mf}{1.}\PYG{p}{)}
\PYG{c}{\PYGZsh{} colour bar}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.colorbar.Colorbar instance at 0x10687ce60\PYGZgt{}
\end{Verbatim}

\includegraphics{advanced_38_1.png}

We notice in this dataset that there are some `funnies' (unreliable
data) around the coastline, which are probably due to negative
reflectance values.

We could try, for instance to build a mask for these, supposing them to
be some other `invalid' number, but in this dataset, we have some other
data layers that can help:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{nc}\PYG{o}{.}\PYG{n}{variables}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{l+s}{u\PYGZsq{}}\PYG{l+s}{metadata}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}
 \PYG{l+s}{u\PYGZsq{}}\PYG{l+s}{DHR\PYGZus{}VIS}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}
 \PYG{l+s}{u\PYGZsq{}}\PYG{l+s}{DHR\PYGZus{}NIR}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}
 \PYG{l+s}{u\PYGZsq{}}\PYG{l+s}{DHR\PYGZus{}SW}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}
 \PYG{l+s}{u\PYGZsq{}}\PYG{l+s}{BHR\PYGZus{}VIS}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}
 \PYG{l+s}{u\PYGZsq{}}\PYG{l+s}{BHR\PYGZus{}NIR}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}
 \PYG{l+s}{u\PYGZsq{}}\PYG{l+s}{BHR\PYGZus{}SW}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}
 \PYG{l+s}{u\PYGZsq{}}\PYG{l+s}{DHR\PYGZus{}sigmaVIS}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}
 \PYG{l+s}{u\PYGZsq{}}\PYG{l+s}{DHR\PYGZus{}sigmaNIR}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}
 \PYG{l+s}{u\PYGZsq{}}\PYG{l+s}{DHR\PYGZus{}sigmaSW}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}
 \PYG{l+s}{u\PYGZsq{}}\PYG{l+s}{BHR\PYGZus{}sigmaVIS}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}
 \PYG{l+s}{u\PYGZsq{}}\PYG{l+s}{BHR\PYGZus{}sigmaNIR}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}
 \PYG{l+s}{u\PYGZsq{}}\PYG{l+s}{BHR\PYGZus{}sigmaSW}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}
 \PYG{l+s}{u\PYGZsq{}}\PYG{l+s}{Weighted\PYGZus{}Number\PYGZus{}of\PYGZus{}Samples}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}
 \PYG{l+s}{u\PYGZsq{}}\PYG{l+s}{Relative\PYGZus{}Entropy}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}
 \PYG{l+s}{u\PYGZsq{}}\PYG{l+s}{Goodness\PYGZus{}of\PYGZus{}Fit}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}
 \PYG{l+s}{u\PYGZsq{}}\PYG{l+s}{Snow\PYGZus{}Fraction}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}
 \PYG{l+s}{u\PYGZsq{}}\PYG{l+s}{Data\PYGZus{}Mask}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}
 \PYG{l+s}{u\PYGZsq{}}\PYG{l+s}{Solar\PYGZus{}Zenith\PYGZus{}Angle}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}
 \PYG{l+s}{u\PYGZsq{}}\PYG{l+s}{lat}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}
 \PYG{l+s}{u\PYGZsq{}}\PYG{l+s}{lon}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}
 \PYG{l+s}{u\PYGZsq{}}\PYG{l+s}{crs}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} better have a look at the individual bands as well}
\PYG{c}{\PYGZsh{} plot the vis and nir bands}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{VIS: Tile }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{ }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{ doy }\PYG{l+s+si}{\PYGZpc{}03d}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{tile}\PYG{p}{,}\PYG{n}{year}\PYG{p}{,}\PYG{n}{doy}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{cmap} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{get\PYGZus{}cmap}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Spectral}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{vis}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{cmap}\PYG{o}{=}\PYG{n}{cmap}\PYG{p}{,}\PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{n}{vmax}\PYG{o}{=}\PYG{l+m+mf}{1.}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{NIR: Tile }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{ }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{ doy }\PYG{l+s+si}{\PYGZpc{}03d}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{tile}\PYG{p}{,}\PYG{n}{year}\PYG{p}{,}\PYG{n}{doy}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{cmap} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{get\PYGZus{}cmap}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Spectral}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{nir}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{cmap}\PYG{o}{=}\PYG{n}{cmap}\PYG{p}{,}\PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{n}{vmax}\PYG{o}{=}\PYG{l+m+mf}{1.}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.colorbar.Colorbar instance at 0x107236d88\PYGZgt{}
\end{Verbatim}

\includegraphics{advanced_41_1.png}

\includegraphics{advanced_41_2.png}

Apart from a few minor outliers, these data look fine.

Let's try developing a mask from \code{Data\_Mask}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{mask} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{nc}\PYG{o}{.}\PYG{n}{variables}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Data\PYGZus{}Mask}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{astype}\PYG{p}{(}\PYG{n+nb}{bool}\PYG{p}{)}

\PYG{c}{\PYGZsh{} plot it}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Data\PYGZus{}Mask: Tile }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{ }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{ doy }\PYG{l+s+si}{\PYGZpc{}03d}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{tile}\PYG{p}{,}\PYG{n}{year}\PYG{p}{,}\PYG{n}{doy}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{cmap} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{get\PYGZus{}cmap}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Spectral}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{mask}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{cmap}\PYG{o}{=}\PYG{n}{cmap}\PYG{p}{,}\PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{n}{vmax}\PYG{o}{=}\PYG{l+m+mf}{1.}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.colorbar.Colorbar instance at 0x1068ab710\PYGZgt{}
\end{Verbatim}

\includegraphics{advanced_43_1.png}

The mask is \code{True} where there are valid (land) data.

In a masked array, we want the opposite of this.

We can'r directly use \code{not}, but we can use the bitwise operatoe
\code{\textasciitilde{}}:

Use the mask in a masked array:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy.ma} \PYG{k+kn}{as} \PYG{n+nn}{ma}

\PYG{n}{vis} \PYG{o}{=} \PYG{n}{ma}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{vis}\PYG{p}{,}\PYG{n}{mask}\PYG{o}{=}\PYG{o}{\PYGZti{}}\PYG{n}{mask}\PYG{p}{)}
\PYG{n}{nir} \PYG{o}{=} \PYG{n}{ma}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{nir}\PYG{p}{,}\PYG{n}{mask}\PYG{o}{=}\PYG{o}{\PYGZti{}}\PYG{n}{mask}\PYG{p}{)}
\PYG{n}{ndvi} \PYG{o}{=} \PYG{p}{(}\PYG{n}{nir} \PYG{o}{\PYGZhy{}} \PYG{n}{vis}\PYG{p}{)}\PYG{o}{/}\PYG{p}{(}\PYG{n}{nir} \PYG{o}{+} \PYG{n}{vis}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{NDVI: Tile }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{ }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{ doy }\PYG{l+s+si}{\PYGZpc{}03d}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{tile}\PYG{p}{,}\PYG{n}{year}\PYG{p}{,}\PYG{n}{doy}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{cmap} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{get\PYGZus{}cmap}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Spectral}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{ndvi}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{cmap}\PYG{o}{=}\PYG{n}{cmap}\PYG{p}{,}\PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{n}{vmax}\PYG{o}{=}\PYG{l+m+mf}{1.}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.colorbar.Colorbar instance at 0x1072aa290\PYGZgt{}
\end{Verbatim}

\includegraphics{advanced_45_1.png}

The data mask hasn't solved the problem for NDVI then.

A problem might arise from a small number of negative reflectance values
in the dataset.

We can create masks for these:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{mask1} \PYG{o}{=} \PYG{n}{vis} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{0.}
\PYG{n}{mask2} \PYG{o}{=} \PYG{n}{nir} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{number of \PYGZhy{}ve VIS pixels}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{mask1}\PYG{p}{)}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{number of \PYGZhy{}ve NIR pixels}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{mask2}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
number of \PYGZhy{}ve VIS pixels 317
number of \PYGZhy{}ve NIR pixels 934
\end{Verbatim}

and we can combine them with a bitwise operator, \code{\textbar{}} (or) or \code{\&}
(and) in this case (reversing the conditions):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{mask} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{nc}\PYG{o}{.}\PYG{n}{variables}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Data\PYGZus{}Mask}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{astype}\PYG{p}{(}\PYG{n+nb}{bool}\PYG{p}{)} \PYG{o}{\PYGZam{}} \PYG{p}{(}\PYG{n}{vis} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{\PYGZam{}} \PYG{p}{(}\PYG{n}{nir} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{)}

\PYG{c}{\PYGZsh{} plot it}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Data\PYGZus{}Mask: Tile }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{ }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{ doy }\PYG{l+s+si}{\PYGZpc{}03d}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{tile}\PYG{p}{,}\PYG{n}{year}\PYG{p}{,}\PYG{n}{doy}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{cmap} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{get\PYGZus{}cmap}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Spectral}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{mask}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{cmap}\PYG{o}{=}\PYG{n}{cmap}\PYG{p}{,}\PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{n}{vmax}\PYG{o}{=}\PYG{l+m+mf}{1.}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.colorbar.Colorbar instance at 0x107c865f0\PYGZgt{}
\end{Verbatim}

\includegraphics{advanced_49_1.png}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{vis} \PYG{o}{=} \PYG{n}{ma}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{vis}\PYG{p}{,}\PYG{n}{mask}\PYG{o}{=}\PYG{o}{\PYGZti{}}\PYG{n}{mask}\PYG{p}{)}
\PYG{n}{nir} \PYG{o}{=} \PYG{n}{ma}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{nir}\PYG{p}{,}\PYG{n}{mask}\PYG{o}{=}\PYG{o}{\PYGZti{}}\PYG{n}{mask}\PYG{p}{)}
\PYG{n}{ndvi} \PYG{o}{=} \PYG{p}{(}\PYG{n}{nir} \PYG{o}{\PYGZhy{}} \PYG{n}{vis}\PYG{p}{)}\PYG{o}{/}\PYG{p}{(}\PYG{n}{nir} \PYG{o}{+} \PYG{n}{vis}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{NDVI: Tile }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{ }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{ doy }\PYG{l+s+si}{\PYGZpc{}03d}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{tile}\PYG{p}{,}\PYG{n}{year}\PYG{p}{,}\PYG{n}{doy}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{cmap} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{get\PYGZus{}cmap}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Spectral}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{ndvi}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{cmap}\PYG{o}{=}\PYG{n}{cmap}\PYG{p}{,}\PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{n}{vmax}\PYG{o}{=}\PYG{l+m+mf}{1.}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.colorbar.Colorbar instance at 0x107320830\PYGZgt{}
\end{Verbatim}

\includegraphics{advanced_50_1.png}

This hasn't entirely sorted it either.

Next have a look at a few more fields before going further:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} demonstration of multiple subplots}

\PYG{n}{datasets} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{DHR\PYGZus{}VIS}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{DHR\PYGZus{}NIR}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYGZbs{}
                     \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{DHR\PYGZus{}sigmaVIS}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{DHR\PYGZus{}sigmaNIR}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYGZbs{}
                     \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Data\PYGZus{}Mask}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Weighted\PYGZus{}Number\PYGZus{}of\PYGZus{}Samples}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}

\PYG{c}{\PYGZsh{} load up all datasets in dict data}
\PYG{n}{data} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}

\PYG{n}{dlist} \PYG{o}{=} \PYG{n}{datasets}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{flatten}\PYG{p}{(}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{d} \PYG{o+ow}{in} \PYG{n}{dlist}\PYG{p}{:}
    \PYG{n}{data}\PYG{p}{[}\PYG{n}{d}\PYG{p}{]} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{nc}\PYG{o}{.}\PYG{n}{variables}\PYG{p}{[}\PYG{n}{d}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{mask} \PYG{o}{=}  \PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Data\PYGZus{}Mask}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{astype}\PYG{p}{(}\PYG{n+nb}{bool}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{p}{(} \PYGZbs{}
        \PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{DHR\PYGZus{}VIS}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{0.}\PYG{p}{)} \PYG{o}{\textbar{}} \PYGZbs{}
        \PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{DHR\PYGZus{}NIR}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{0.}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{s} \PYG{o}{=} \PYG{n}{datasets}\PYG{o}{.}\PYG{n}{shape}

\PYG{c}{\PYGZsh{} how big for each subplot ?}
\PYG{n}{big} \PYG{o}{=} \PYG{l+m+mi}{5}

\PYG{c}{\PYGZsh{} set the figure size}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{n}{s}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{*}\PYG{n}{big}\PYG{p}{,}\PYG{n}{s}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{*}\PYG{n}{big}\PYG{p}{)}\PYG{p}{)}

\PYG{c}{\PYGZsh{} colorbars for subplots are a bit tricky}
\PYG{c}{\PYGZsh{} here\PYGZsq{}s one way of sorting this}
\PYG{c}{\PYGZsh{} using dataset shapes}
\PYG{k+kn}{from} \PYG{n+nn}{matplotlib} \PYG{k+kn}{import} \PYG{n}{gridspec}
\PYG{n}{gs} \PYG{o}{=} \PYG{n}{gridspec}\PYG{o}{.}\PYG{n}{GridSpec}\PYG{p}{(}\PYG{n}{s}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{s}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}

\PYG{c}{\PYGZsh{} colour map}
\PYG{n}{cmap} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{get\PYGZus{}cmap}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Spectral}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}


\PYG{k}{for} \PYG{n}{i}\PYG{p}{,}\PYG{n}{d0} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{datasets}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{for} \PYG{n}{j}\PYG{p}{,}\PYG{n}{d} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{d0}\PYG{p}{)}\PYG{p}{:}

        \PYG{n}{data}\PYG{p}{[}\PYG{n}{d}\PYG{p}{]} \PYG{o}{=} \PYG{n}{ma}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{n}{d}\PYG{p}{]}\PYG{p}{,}\PYG{n}{mask}\PYG{o}{=}\PYG{o}{\PYGZti{}}\PYG{n}{mask}\PYG{p}{)}

        \PYG{n}{axes} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplot}\PYG{p}{(}\PYG{n}{gs}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{axes}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{n}{d}\PYG{p}{)}
        \PYG{c}{\PYGZsh{} no axis ticks}
        \PYG{n}{axes}\PYG{o}{.}\PYG{n}{set\PYGZus{}xticks}\PYG{p}{(}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{axes}\PYG{o}{.}\PYG{n}{set\PYGZus{}yticks}\PYG{p}{(}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}

        \PYG{n}{im} \PYG{o}{=} \PYG{n}{axes}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{n}{d}\PYG{p}{]}\PYG{p}{,}\PYG{n}{cmap}\PYG{o}{=}\PYG{n}{cmap}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{)}
        \PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{n}{im}\PYG{p}{)}


\PYG{n}{ndvi} \PYG{o}{=} \PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{DHR\PYGZus{}NIR}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{DHR\PYGZus{}VIS}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}\PYG{o}{/}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{DHR\PYGZus{}NIR}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{+} \PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{DHR\PYGZus{}VIS}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{NDVI: Tile }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{ }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{ doy }\PYG{l+s+si}{\PYGZpc{}03d}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{tile}\PYG{p}{,}\PYG{n}{year}\PYG{p}{,}\PYG{n}{doy}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{cmap} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{get\PYGZus{}cmap}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Spectral}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{ndvi}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{cmap}\PYG{o}{=}\PYG{n}{cmap}\PYG{p}{,}\PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{n}{vmax}\PYG{o}{=}\PYG{l+m+mf}{1.}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.colorbar.Colorbar instance at 0x116dd8ab8\PYGZgt{}
\end{Verbatim}

\includegraphics{advanced_52_1.png}

\includegraphics{advanced_52_2.png}

So it looks as though we need to filter on
\code{'Weighted\_Number\_of\_Samples'} as well, and perhaps on uncertainty:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} demonstration of multiple subplots}

\PYG{n}{datasets} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{DHR\PYGZus{}VIS}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{DHR\PYGZus{}NIR}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYGZbs{}
                     \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{DHR\PYGZus{}sigmaVIS}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{DHR\PYGZus{}sigmaNIR}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYGZbs{}
                     \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Data\PYGZus{}Mask}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Weighted\PYGZus{}Number\PYGZus{}of\PYGZus{}Samples}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}

\PYG{c}{\PYGZsh{} load up all datasets in dict data}
\PYG{n}{data} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}

\PYG{n}{dlist} \PYG{o}{=} \PYG{n}{datasets}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{flatten}\PYG{p}{(}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{d} \PYG{o+ow}{in} \PYG{n}{dlist}\PYG{p}{:}
    \PYG{n}{data}\PYG{p}{[}\PYG{n}{d}\PYG{p}{]} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{nc}\PYG{o}{.}\PYG{n}{variables}\PYG{p}{[}\PYG{n}{d}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{mask} \PYG{o}{=}  \PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Data\PYGZus{}Mask}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{astype}\PYG{p}{(}\PYG{n+nb}{bool}\PYG{p}{)} \PYG{o}{\PYGZam{}} \PYGZbs{}
        \PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Weighted\PYGZus{}Number\PYGZus{}of\PYGZus{}Samples}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{0.5}\PYG{p}{)} \PYG{o}{\PYGZam{}} \PYGZbs{}
        \PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{DHR\PYGZus{}sigmaVIS}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mf}{0.8}\PYG{p}{)} \PYG{o}{\PYGZam{}} \PYGZbs{}
        \PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{DHR\PYGZus{}sigmaNIR}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mf}{0.8}\PYG{p}{)} \PYG{o}{\PYGZam{}} \PYGZbs{}
        \PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{DHR\PYGZus{}VIS}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{)} \PYG{o}{\PYGZam{}} \PYGZbs{}
        \PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{DHR\PYGZus{}NIR}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{)}

\PYG{n}{s} \PYG{o}{=} \PYG{n}{datasets}\PYG{o}{.}\PYG{n}{shape}

\PYG{c}{\PYGZsh{} how big for each subplot ?}
\PYG{n}{big} \PYG{o}{=} \PYG{l+m+mi}{5}

\PYG{c}{\PYGZsh{} set the figure size}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{n}{s}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{*}\PYG{n}{big}\PYG{p}{,}\PYG{n}{s}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{*}\PYG{n}{big}\PYG{p}{)}\PYG{p}{)}

\PYG{c}{\PYGZsh{} colorbars for subplots are a bit tricky}
\PYG{c}{\PYGZsh{} here\PYGZsq{}s one way of sorting this}
\PYG{c}{\PYGZsh{} using dataset shapes}
\PYG{k+kn}{from} \PYG{n+nn}{matplotlib} \PYG{k+kn}{import} \PYG{n}{gridspec}
\PYG{n}{gs} \PYG{o}{=} \PYG{n}{gridspec}\PYG{o}{.}\PYG{n}{GridSpec}\PYG{p}{(}\PYG{n}{s}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{s}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}

\PYG{c}{\PYGZsh{} colour map}
\PYG{n}{cmap} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{get\PYGZus{}cmap}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Spectral}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}


\PYG{k}{for} \PYG{n}{i}\PYG{p}{,}\PYG{n}{d0} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{datasets}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{for} \PYG{n}{j}\PYG{p}{,}\PYG{n}{d} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{d0}\PYG{p}{)}\PYG{p}{:}

        \PYG{n}{data}\PYG{p}{[}\PYG{n}{d}\PYG{p}{]} \PYG{o}{=} \PYG{n}{ma}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{n}{d}\PYG{p}{]}\PYG{p}{,}\PYG{n}{mask}\PYG{o}{=}\PYG{o}{\PYGZti{}}\PYG{n}{mask}\PYG{p}{)}

        \PYG{n}{axes} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplot}\PYG{p}{(}\PYG{n}{gs}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{axes}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{n}{d}\PYG{p}{)}
        \PYG{c}{\PYGZsh{} no axis ticks}
        \PYG{n}{axes}\PYG{o}{.}\PYG{n}{set\PYGZus{}xticks}\PYG{p}{(}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{axes}\PYG{o}{.}\PYG{n}{set\PYGZus{}yticks}\PYG{p}{(}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}

        \PYG{n}{im} \PYG{o}{=} \PYG{n}{axes}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{n}{d}\PYG{p}{]}\PYG{p}{,}\PYG{n}{cmap}\PYG{o}{=}\PYG{n}{cmap}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{)}
        \PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{n}{im}\PYG{p}{)}
\end{Verbatim}

\includegraphics{advanced_54_0.png}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{ndvi} \PYG{o}{=} \PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{DHR\PYGZus{}NIR}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{DHR\PYGZus{}VIS}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}\PYG{o}{/}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{DHR\PYGZus{}NIR}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{+} \PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{DHR\PYGZus{}VIS}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{13}\PYG{p}{,}\PYG{l+m+mi}{13}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{NDVI: Tile }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{ }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{ doy }\PYG{l+s+si}{\PYGZpc{}03d}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{tile}\PYG{p}{,}\PYG{n}{year}\PYG{p}{,}\PYG{n}{doy}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{cmap} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{get\PYGZus{}cmap}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Spectral}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{ndvi}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{cmap}\PYG{o}{=}\PYG{n}{cmap}\PYG{p}{,}\PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{n}{vmax}\PYG{o}{=}\PYG{l+m+mf}{1.}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.colorbar.Colorbar instance at 0x115bb1cb0\PYGZgt{}
\end{Verbatim}

\includegraphics{advanced_55_1.png}

Thats quite a bit better, but still not perfect.

\textbf{Experiment with the conditions of the masking to see how you can get
rid of the odd pixels (the `red' ones in the above). Do *not* filter on
{}`{}`ndvi{}`{}` itself, as we *might* be interested in negative {}`{}`ndvi{}`{}` values
in some cases.}

Once you think you have some useful filtering conditions, try it out on
some different dates and tiles.

Some other things to try:
\begin{itemize}
\item {} 
Write parts of the code as functions.

\item {} 
Put the code developed into a file and run it from the unix command
line.

\end{itemize}


\section{A3.3 Solar Radiation model}
\label{Chapter3_Scientific_Numerical_Python/advanced:a3-3-solar-radiation-model}
If you followed the advanced material for the previous chapter, you will
have noted the use of \code{pyephem} as a module that we can use for
calculating the solar zenith angle.

There is a similar package \code{pysolar} that is a little easier to use
for solar radiation calculations.

We will install a package \code{pysolar} into your user area:

at a unix prompt, type:

\begin{Verbatim}[commandchars=\\\{\}]
!easy\PYGZus{}install \PYGZhy{}\PYGZhy{}user pysolar
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
Searching for pysolar
Best match: Pysolar 0.5
Processing Pysolar\PYGZhy{}0.5\PYGZhy{}py2.7.egg
Pysolar 0.5 is already the active version in easy\PYGZhy{}install.pth

Using /Users/plewis/.local/lib/python2.7/site\PYGZhy{}packages/Pysolar\PYGZhy{}0.5\PYGZhy{}py2.7.egg
Processing dependencies for pysolar
Finished processing dependencies for pysolar
\end{Verbatim}

If all goes well, the text that comes up at the terminal should tell you
that this has installed (e.g. in
\code{/home/plewis/.local/lib/python2.7/site-packages/Pysolar-0.5-py2.7.egg}).

We can test to see if we can load and run this package:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} from https://github.com/pingswept/pysolar/wiki/examples}
\PYG{k+kn}{import} \PYG{n+nn}{Pysolar}
\PYG{k+kn}{from} \PYG{n+nn}{datetime} \PYG{k+kn}{import} \PYG{n}{datetime}

\PYG{c}{\PYGZsh{} UCL lat/lon}
\PYG{n}{lat} \PYG{o}{=} \PYG{l+m+mf}{51.5248}
\PYG{n}{lon} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.1336}

\PYG{n}{hour} \PYG{o}{=} \PYG{l+m+mi}{12}
\PYG{n}{minute} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{second} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{month} \PYG{o}{=} \PYG{l+m+mi}{10} \PYG{c}{\PYGZsh{} ie October}
\PYG{n}{day} \PYG{o}{=} \PYG{l+m+mi}{13}
\PYG{n}{year} \PYG{o}{=} \PYG{l+m+mi}{2013}

\PYG{n}{d} \PYG{o}{=} \PYG{n}{datetime}\PYG{p}{(}\PYG{n}{year}\PYG{p}{,} \PYG{n}{month}\PYG{p}{,} \PYG{n}{day}\PYG{p}{,} \PYG{n}{hour}\PYG{p}{,} \PYG{n}{minute}\PYG{p}{,} \PYG{n}{second}\PYG{p}{)}
\PYG{n}{altitude\PYGZus{}deg} \PYG{o}{=} \PYG{n}{Pysolar}\PYG{o}{.}\PYG{n}{GetAltitude}\PYG{p}{(}\PYG{n}{lat}\PYG{p}{,} \PYG{n}{lon}\PYG{p}{,} \PYG{n}{d}\PYG{p}{)}
\PYG{n}{zenith} \PYG{o}{=} \PYG{l+m+mf}{90.} \PYG{o}{\PYGZhy{}} \PYG{n}{altitude\PYGZus{}deg}
\PYG{c}{\PYGZsh{} W m\PYGZca{}\PYGZhy{}2}
\PYG{n}{solar} \PYG{o}{=} \PYG{n}{Pysolar}\PYG{o}{.}\PYG{n}{solar}\PYG{o}{.}\PYG{n}{radiation}\PYG{o}{.}\PYG{n}{GetRadiationDirect}\PYG{p}{(}\PYG{n}{d}\PYG{p}{,} \PYG{n}{altitude\PYGZus{}deg}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{zenith}\PYG{p}{,}\PYG{n}{solar}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
59.5052193764 834.866993323
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{solar}\PYG{p}{(}\PYG{n}{year}\PYG{p}{,} \PYG{n}{month}\PYG{p}{,} \PYG{n}{day}\PYG{p}{,} \PYG{n}{hour}\PYG{p}{,} \PYG{n}{lat\PYGZus{}deg}\PYG{p}{,} \PYG{n}{lon\PYGZus{}deg}\PYG{p}{,} \PYG{n}{minute}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{second}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}Return solar zenith and clear sky radiation}
\PYG{l+s+sd}{       for given lat, lon and time/date}
\PYG{l+s+sd}{    \PYGZsq{}\PYGZsq{}\PYGZsq{}}
    \PYG{k+kn}{from} \PYG{n+nn}{datetime} \PYG{k+kn}{import} \PYG{n}{datetime}
    \PYG{k+kn}{import} \PYG{n+nn}{Pysolar}

    \PYG{n}{d} \PYG{o}{=} \PYG{n}{datetime}\PYG{p}{(}\PYG{n}{year}\PYG{p}{,} \PYG{n}{month}\PYG{p}{,} \PYG{n}{day}\PYG{p}{,} \PYG{n}{hour}\PYG{p}{,} \PYG{n}{minute}\PYG{p}{,} \PYG{n}{second}\PYG{p}{)}
    \PYG{n}{altitude\PYGZus{}deg} \PYG{o}{=} \PYG{n}{Pysolar}\PYG{o}{.}\PYG{n}{GetAltitude}\PYG{p}{(}\PYG{n}{lat\PYGZus{}deg}\PYG{p}{,} \PYG{n}{lon\PYGZus{}deg}\PYG{p}{,} \PYG{n}{d}\PYG{p}{)}
    \PYG{c}{\PYGZsh{} W m\PYGZca{}\PYGZhy{}2}
    \PYG{n}{solar\PYGZus{}rad} \PYG{o}{=} \PYG{n}{Pysolar}\PYG{o}{.}\PYG{n}{solar}\PYG{o}{.}\PYG{n}{radiation}\PYG{o}{.}\PYG{n}{GetRadiationDirect}\PYG{p}{(}\PYG{n}{d}\PYG{p}{,} \PYG{n}{altitude\PYGZus{}deg}\PYG{p}{)}
    \PYG{k}{return} \PYG{l+m+mf}{90.} \PYG{o}{\PYGZhy{}} \PYG{n}{altitude\PYGZus{}deg}\PYG{p}{,}\PYG{n}{solar\PYGZus{}rad}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} or import from local module}

\PYG{k+kn}{import} \PYG{n+nn}{sys}\PYG{o}{,}\PYG{n+nn}{os}
\PYG{c}{\PYGZsh{} put local directory into the path}
\PYG{n}{sys}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{abspath}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{python}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{n}{os}\PYG{o}{.}\PYG{n}{sep}\PYG{p}{)}\PYG{p}{)}

\PYG{k+kn}{from} \PYG{n+nn}{solar} \PYG{k+kn}{import} \PYG{n}{solar}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}

\PYG{c}{\PYGZsh{} UCL lat/lon}
\PYG{n}{lat} \PYG{o}{=} \PYG{l+m+mf}{51.5248}
\PYG{n}{lon} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.1336}

\PYG{n}{second} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{month} \PYG{o}{=} \PYG{l+m+mi}{10} \PYG{c}{\PYGZsh{} ie October}
\PYG{n}{day} \PYG{o}{=} \PYG{l+m+mi}{13}
\PYG{n}{year} \PYG{o}{=} \PYG{l+m+mi}{2013}

\PYG{n}{radiation\PYGZus{}fields} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZsh{}hour zenith solar\PYGZus{}rad month day lat lon}\PYG{l+s}{\PYGZsq{}}

\PYG{n}{radiation} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{hour} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{l+m+mi}{24}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{for} \PYG{n}{minute} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{l+m+mi}{60}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{thr} \PYG{o}{=} \PYG{n}{hour} \PYG{o}{+} \PYG{n}{minute}\PYG{o}{/}\PYG{l+m+mf}{60.}
        \PYG{c}{\PYGZsh{} append data line as tuple}
        \PYG{n}{radiation}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{p}{(}\PYG{n}{thr}\PYG{p}{,}\PYG{p}{)} \PYG{o}{+} \PYGZbs{}
                         \PYG{n}{solar}\PYG{p}{(}\PYG{n}{year}\PYG{p}{,} \PYG{n}{month}\PYG{p}{,} \PYG{n}{day}\PYG{p}{,} \PYG{n}{hour}\PYG{p}{,} \PYG{n}{lat}\PYG{p}{,} \PYG{n}{lon}\PYG{p}{,} \PYG{n}{minute}\PYG{o}{=}\PYG{n}{minute}\PYG{p}{)} \PYG{o}{+}\PYGZbs{}
                         \PYG{p}{(}\PYG{n}{month}\PYG{p}{,} \PYG{n}{day}\PYG{p}{,} \PYG{n}{lat}\PYG{p}{,} \PYG{n}{lon}\PYG{p}{)}\PYG{p}{)}
\PYG{c}{\PYGZsh{} convert to numpy array}
\PYG{c}{\PYGZsh{} transpose so access eg zenith as}
\PYG{c}{\PYGZsh{} radiation[0]}
\PYG{n}{radiation} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{radiation}\PYG{p}{)}\PYG{o}{.}\PYG{n}{T}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} so we have radiation as}
\PYG{k}{print} \PYG{n}{radiation}\PYG{o}{.}\PYG{n}{shape}
\PYG{k}{print} \PYG{n}{radiation}\PYG{o}{.}\PYG{n}{ndim}
\PYG{k}{print} \PYG{n}{radiation}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
(7, 1440)
2
[[  0.00000000e+00   1.66666667e\PYGZhy{}02   3.33333333e\PYGZhy{}02 ...,   2.39500000e+01
    2.39666667e+01   2.39833333e+01]
 [  1.36158787e+02   1.36145826e+02   1.36131901e+02 ...,   1.36561804e+02
    1.36551449e+02   1.36540121e+02]
 [  0.00000000e+00   0.00000000e+00   0.00000000e+00 ...,   0.00000000e+00
    0.00000000e+00   0.00000000e+00]
 ...,
 [  1.30000000e+01   1.30000000e+01   1.30000000e+01 ...,   1.30000000e+01
    1.30000000e+01   1.30000000e+01]
 [  5.15248000e+01   5.15248000e+01   5.15248000e+01 ...,   5.15248000e+01
    5.15248000e+01   5.15248000e+01]
 [ \PYGZhy{}1.33600000e\PYGZhy{}01  \PYGZhy{}1.33600000e\PYGZhy{}01  \PYGZhy{}1.33600000e\PYGZhy{}01 ...,  \PYGZhy{}1.33600000e\PYGZhy{}01
   \PYGZhy{}1.33600000e\PYGZhy{}01  \PYGZhy{}1.33600000e\PYGZhy{}01]]
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{pylab} \PYG{k+kn}{as} \PYG{n+nn}{plt}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Solar radiation at UCL}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{hour}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{solar radiation / Wm\PYGZca{}\PYGZhy{}2}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{radiation}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{radiation}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
[\PYGZlt{}matplotlib.lines.Line2D at 0x10681fed0\PYGZgt{}]
\end{Verbatim}

\includegraphics{advanced_66_1.png}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{pylab} \PYG{k+kn}{as} \PYG{n+nn}{plt}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Solar zenith UCL}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{hour}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{solar zenith / degrees}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{radiation}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{radiation}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
[\PYGZlt{}matplotlib.lines.Line2D at 0x1068bde50\PYGZgt{}]
\end{Verbatim}

\includegraphics{advanced_67_1.png}

E3.3 Exercise: Solar radiation modelling

This is a better modelling of solar radiation that we did in the main
part of the class today.

There are several things we could do with this.

For example, if we know the albedo, we can calculate the absorbed
radiation as previously done (if we assume for the moment albedo is
constant with solar zenith angle ... which it isn't, generally), but can
now extend over the whole day and integrate to get the total energy per
metre squared.

From above, we have \href{http://en.wikipedia.org/wiki/Watt}{power} per
unit area, in Watts per metre squared.

This is the same as \href{http://en.wikipedia.org/wiki/Joule}{energy} per
unit area per second (i.e. the same as J/(m s)).

So if we sum up the solar radiation from above over the day and multiply
by the time interval in seconds (time interval above is 1 minute, so 60
seconds), we get:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{power\PYGZus{}density} \PYG{o}{=} \PYG{n}{radiation}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{p}{)} \PYG{o}{*} \PYG{l+m+mi}{60}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{power per unit area = }\PYG{l+s+si}{\PYGZpc{}.3f}\PYG{l+s}{ MJ / m\PYGZca{}2}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{power\PYGZus{}density}\PYG{o}{/}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{6}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
power per unit area = 23.687 MJ / m\PYGZca{}2
\end{Verbatim}

and we could now look at e.g. variations in this over the year (NB this
will take some time to calculate if you step every day and minute, so we
step every 30 minutes here):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}

\PYG{k}{def} \PYG{n+nf}{radiation}\PYG{p}{(}\PYG{n}{year}\PYG{p}{,} \PYG{n}{month}\PYG{p}{,} \PYG{n}{day}\PYG{p}{,} \PYG{n}{lat}\PYG{p}{,} \PYG{n}{lon}\PYG{p}{,}\PYG{n}{minute\PYGZus{}step}\PYG{o}{=}\PYG{l+m+mi}{30}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{rad} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    \PYG{k}{for} \PYG{n}{hour} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{l+m+mi}{24}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{minute} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{60}\PYG{p}{,}\PYG{n}{minute\PYGZus{}step}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{thr} \PYG{o}{=} \PYG{n}{hour} \PYG{o}{+} \PYG{n}{minute}\PYG{o}{/}\PYG{l+m+mf}{60.}
            \PYG{c}{\PYGZsh{} append data line as tuple}
            \PYG{n}{rad}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{p}{(}\PYG{n}{thr}\PYG{p}{,}\PYG{p}{)} \PYG{o}{+} \PYGZbs{}
                     \PYG{n}{solar}\PYG{p}{(}\PYG{n}{year}\PYG{p}{,} \PYG{n}{month}\PYG{p}{,} \PYG{n}{day}\PYG{p}{,} \PYG{n}{hour}\PYG{p}{,} \PYG{n}{lat}\PYG{p}{,} \PYG{n}{lon}\PYG{p}{,} \PYG{n}{minute}\PYG{o}{=}\PYG{n}{minute}\PYG{p}{)} \PYG{o}{+}\PYGZbs{}
                     \PYG{p}{(}\PYG{n}{month}\PYG{p}{,} \PYG{n}{day}\PYG{p}{,} \PYG{n}{lat}\PYG{p}{,} \PYG{n}{lon}\PYG{p}{)}\PYG{p}{)}
    \PYG{c}{\PYGZsh{} convert to numpy array}
    \PYG{c}{\PYGZsh{} transpose so access eg zenith as}
    \PYG{c}{\PYGZsh{} rad[0]}
    \PYG{n}{rad} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{rad}\PYG{p}{)}\PYG{o}{.}\PYG{n}{T}
    \PYG{k}{return} \PYG{n}{rad}

\PYG{k}{def} \PYG{n+nf}{days\PYGZus{}in\PYGZus{}month}\PYG{p}{(}\PYG{n}{month}\PYG{p}{,}\PYG{n}{year}\PYG{o}{=}\PYG{l+m+mi}{2013}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{} number of days in month\PYGZsq{}\PYGZsq{}\PYGZsq{}}
    \PYG{k+kn}{import} \PYG{n+nn}{calendar}
    \PYG{k}{return} \PYG{n}{calendar}\PYG{o}{.}\PYG{n}{monthrange}\PYG{p}{(}\PYG{n}{year}\PYG{p}{,}\PYG{n}{month}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}

\PYG{c}{\PYGZsh{} UCL lat/lon}
\PYG{n}{lat} \PYG{o}{=} \PYG{l+m+mf}{51.5248}
\PYG{n}{lon} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.1336}

\PYG{n}{year} \PYG{o}{=} \PYG{l+m+mi}{2013}

\PYG{n}{minute\PYGZus{}step} \PYG{o}{=} \PYG{l+m+mi}{30}

\PYG{n}{pd} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{month} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{ndays} \PYG{o}{=} \PYG{n}{days\PYGZus{}in\PYGZus{}month}\PYG{p}{(}\PYG{n}{month}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{year}\PYG{o}{=}\PYG{n}{year}\PYG{p}{)}
    \PYG{k}{print} \PYG{n}{month}\PYG{p}{,}\PYG{n}{ndays}
    \PYG{k}{for} \PYG{n}{day} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{n}{ndays}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{rad} \PYG{o}{=} \PYG{n}{radiation}\PYG{p}{(}\PYG{n}{year}\PYG{p}{,} \PYG{n}{month}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{day}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{lat}\PYG{p}{,} \PYG{n}{lon}\PYG{p}{,}\PYG{n}{minute\PYGZus{}step}\PYG{o}{=}\PYG{n}{minute\PYGZus{}step}\PYG{p}{)}
        \PYG{n}{pd}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{p}{[}\PYG{n}{month}\PYG{o}{+}\PYG{n}{day}\PYG{o}{/}\PYG{n+nb}{float}\PYG{p}{(}\PYG{n}{ndays}\PYG{p}{)}\PYG{p}{,}\PYG{n}{rad}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{p}{)} \PYG{o}{*} \PYG{l+m+mi}{60} \PYG{o}{*} \PYG{n}{minute\PYGZus{}step}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{pd} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{pd}\PYG{p}{)}\PYG{o}{.}\PYG{n}{T}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
0 31
1 28
2 31
3 30
4 31
5 30
6 31
7 31
8 30
9 31
10 30
11 31
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{pylab} \PYG{k+kn}{as} \PYG{n+nn}{plt}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Power per unit area, UCL}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{month}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Power per unit area / MJ m\PYGZca{}\PYGZhy{}2}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{pd}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{pd}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{/}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{6}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
[\PYGZlt{}matplotlib.lines.Line2D at 0x106abdc50\PYGZgt{}]
\end{Verbatim}

\includegraphics{advanced_73_1.png}

or, if we want to sum over a month:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} UCL lat/lon}
\PYG{n}{lat} \PYG{o}{=} \PYG{l+m+mf}{51.5248}
\PYG{n}{lon} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.1336}

\PYG{n}{year} \PYG{o}{=} \PYG{l+m+mi}{2013}

\PYG{n}{pd} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}

\PYG{k}{for} \PYG{n}{month} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{pd\PYGZus{}month} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    \PYG{n}{ndays} \PYG{o}{=} \PYG{n}{days\PYGZus{}in\PYGZus{}month}\PYG{p}{(}\PYG{n}{month}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{year}\PYG{o}{=}\PYG{n}{year}\PYG{p}{)}
    \PYG{k}{print} \PYG{n}{month}\PYG{p}{,}\PYG{n}{ndays}
    \PYG{k}{for} \PYG{n}{day} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{n}{ndays}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{rad} \PYG{o}{=} \PYG{n}{radiation}\PYG{p}{(}\PYG{n}{year}\PYG{p}{,} \PYG{n}{month}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{day}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{lat}\PYG{p}{,} \PYG{n}{lon}\PYG{p}{)}
        \PYG{n}{pd\PYGZus{}month}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{p}{[}\PYG{n}{rad}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{p}{)} \PYG{o}{*} \PYG{l+m+mi}{60} \PYG{o}{*} \PYG{l+m+mi}{30}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{pd\PYGZus{}month} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{pd\PYGZus{}month}\PYG{p}{)}\PYG{o}{.}\PYG{n}{T}
    \PYG{n}{pd}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{p}{[}\PYG{n}{month}\PYG{p}{,}\PYG{n}{pd\PYGZus{}month}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{pd} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{pd}\PYG{p}{)}\PYG{o}{.}\PYG{n}{T}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
0 31
1 28
2 31
3 30
4 31
5 30
6 31
7 31
8 30
9 31
10 30
11 31
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{pylab} \PYG{k+kn}{as} \PYG{n+nn}{plt}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Monthly total Power per unit area, UCL}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{month}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Power per unit area / MJ m\PYGZca{}\PYGZhy{}2}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{pd}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{pd}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{/}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{6}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
[\PYGZlt{}matplotlib.lines.Line2D at 0x107234d10\PYGZgt{}]
\end{Verbatim}

\includegraphics{advanced_76_1.png}


\section{E3.3 Improved Solar Radiation Modelling}
\label{Chapter3_Scientific_Numerical_Python/advanced:e3-3-improved-solar-radiation-modelling}
Using the material above and the global albedo datasets from the main
class material, \textbf{calculate an improved estimate of the total absorbed
power per unit area per month (MJ per m\textasciicircum{}2 per month) for the Earth land
surface}.

You should do this with a function that will take as input the year and
returns the monthly total absorbed power density (MJ m\textasciicircum{}-2 per month) and
the monthly total power density (MJ m\textasciicircum{}-2 per month).

You might have an optional argument \code{minute\_step} to control the
resolution of the calculation as above.

You could then use this to derive latitudinal variations in annual and
latitudinal total absorbed power per unit area.


\chapter{E3.3: Exercise: Improved Solar Radiation Modelling}
\label{Chapter3_Scientific_Numerical_Python/advanced_answers:e3-3-exercise-improved-solar-radiation-modelling}\label{Chapter3_Scientific_Numerical_Python/advanced_answers::doc}
Using the material above and the global albedo datasets from the main
class material, \textbf{calculate an improved estimate of the total absorbed
power per unit area per month (MJ per m\textasciicircum{}2 per month) for the Earth land
surface}.

You should do this with a function that will take as input the year and
returns the monthly total absorbed power density (MJ m\textasciicircum{}-2 per month) and
the monthly total power density (MJ m\textasciicircum{}-2 per month).

You might have an optional argument \code{minute\_step} to control the
resolution of the calculation as above.

You could then use this to derive latitudinal variations in annual and
latitudinal total absorbed power per unit area.


\chapter{AE3.3 Answer: Improved Solar Radiation Modelling}
\label{Chapter3_Scientific_Numerical_Python/advanced_answers:ae3-3-answer-improved-solar-radiation-modelling}
The function definition should look something like:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{absorbed\PYGZus{}power\PYGZus{}density}\PYG{p}{(}\PYG{n}{year}\PYG{p}{,}\PYG{n}{minute\PYGZus{}step}\PYG{o}{=}\PYG{l+m+mi}{60}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}Function to calculate the monthly total absorbed solar radiation}
\PYG{l+s+sd}{        power density in MJ / m\PYGZca{}2 for a given year}
\PYG{l+s+sd}{        given an input dataset albedo and associated lat and lon}
\PYG{l+s+sd}{        information (in degrees).}

\PYG{l+s+sd}{        The shape of the albedo dataset is: (12,nlat,nlon)}

\PYG{l+s+sd}{        Aguments:}

\PYG{l+s+sd}{        year  : integer of the year}

\PYG{l+s+sd}{        Options:}

\PYG{l+s+sd}{        minute\PYGZus{}step : integer: resolution of steps in minutes. Must be}
\PYG{l+s+sd}{                      a divisor of 60 (e.g. 10, 15, 30, 60)}

\PYG{l+s+sd}{    \PYGZsq{}\PYGZsq{}\PYGZsq{}}
\end{Verbatim}

The first thing to do is sort out the \code{lat} and \code{lon} arrays to be
the same shape as \code{albedo}.

Before that, we'd better read in the \code{albedo}, \code{lat} and \code{lon}
datasets here though:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{n}{sys}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/python}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{c}{\PYGZsh{} modification of masked.py}
\PYG{k+kn}{from} \PYG{n+nn}{masked2} \PYG{k+kn}{import} \PYG{n}{masked}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}

\PYG{n}{year} \PYG{o}{=} \PYG{l+m+mi}{2010}

\PYG{n}{data} \PYG{o}{=} \PYG{n}{masked}\PYG{p}{(}\PYG{n}{dataset}\PYG{o}{=}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{lat}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{lon}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{BHR\PYGZus{}SW}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{year}\PYG{o}{=}\PYG{n}{year}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} take the first lat and lon only as they are all the same}
\PYG{n}{lat} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{lat}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{lon} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{lon}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{albedo} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{BHR\PYGZus{}SW}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{s} \PYG{o}{=} \PYG{n}{albedo}\PYG{o}{.}\PYG{n}{shape}
\PYG{k}{print} \PYG{n}{s}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{360}\PYG{p}{,} \PYG{l+m+mi}{720}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{}pad out the lat and lon arrays}
\PYG{c}{\PYGZsh{} this is a bit tricky so test this in parts}
\PYG{c}{\PYGZsh{} we dont need this repeated for each month though}
\PYG{n}{lat2} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{n}{lat}\PYG{p}{]} \PYG{o}{*} \PYG{n}{s}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{T}
\PYG{n}{lon2} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{n}{lon}\PYG{p}{]} \PYG{o}{*} \PYG{n}{s}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{n}{lat2}\PYG{o}{.}\PYG{n}{shape}
\PYG{k}{print} \PYG{n}{lon2}\PYG{o}{.}\PYG{n}{shape}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{l+m+mi}{360}\PYG{p}{,} \PYG{l+m+mi}{720}\PYG{p}{)}
\PYG{p}{(}\PYG{l+m+mi}{360}\PYG{p}{,} \PYG{l+m+mi}{720}\PYG{p}{)}
\end{Verbatim}

Now put together the code for solar radiation modelling for a given
lat/lon

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{Pysolar}
\PYG{k+kn}{from} \PYG{n+nn}{datetime} \PYG{k+kn}{import} \PYG{n}{datetime}

\PYG{k}{def} \PYG{n+nf}{solar}\PYG{p}{(}\PYG{n}{year}\PYG{p}{,} \PYG{n}{month}\PYG{p}{,} \PYG{n}{day}\PYG{p}{,} \PYG{n}{hour}\PYG{p}{,} \PYG{n}{lat\PYGZus{}deg}\PYG{p}{,} \PYG{n}{lon\PYGZus{}deg}\PYG{p}{,} \PYG{n}{minute}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{second}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}Return solar zenith and clear sky radiation}
\PYG{l+s+sd}{       for given lat, lon and time/date}
\PYG{l+s+sd}{    \PYGZsq{}\PYGZsq{}\PYGZsq{}}
    \PYG{k+kn}{from} \PYG{n+nn}{datetime} \PYG{k+kn}{import} \PYG{n}{datetime}
    \PYG{k+kn}{import} \PYG{n+nn}{Pysolar}

    \PYG{n}{d} \PYG{o}{=} \PYG{n}{datetime}\PYG{p}{(}\PYG{n}{year}\PYG{p}{,} \PYG{n}{month}\PYG{p}{,} \PYG{n}{day}\PYG{p}{,} \PYG{n}{hour}\PYG{p}{,} \PYG{n}{minute}\PYG{p}{,} \PYG{n}{second}\PYG{p}{)}
    \PYG{n}{altitude\PYGZus{}deg} \PYG{o}{=} \PYG{n}{Pysolar}\PYG{o}{.}\PYG{n}{GetAltitude}\PYG{p}{(}\PYG{n}{lat\PYGZus{}deg}\PYG{p}{,} \PYG{n}{lon\PYGZus{}deg}\PYG{p}{,} \PYG{n}{d}\PYG{p}{)}
    \PYG{c}{\PYGZsh{} W m\PYGZca{}\PYGZhy{}2}
    \PYG{n}{solar\PYGZus{}rad} \PYG{o}{=} \PYG{n}{Pysolar}\PYG{o}{.}\PYG{n}{solar}\PYG{o}{.}\PYG{n}{radiation}\PYG{o}{.}\PYG{n}{GetRadiationDirect}\PYG{p}{(}\PYG{n}{d}\PYG{p}{,} \PYG{n}{altitude\PYGZus{}deg}\PYG{p}{)}
    \PYG{k}{return} \PYG{l+m+mf}{90.} \PYG{o}{\PYGZhy{}} \PYG{n}{altitude\PYGZus{}deg}\PYG{p}{,}\PYG{n}{solar\PYGZus{}rad}

\PYG{k}{def} \PYG{n+nf}{radiation}\PYG{p}{(}\PYG{n}{year}\PYG{p}{,} \PYG{n}{month}\PYG{p}{,} \PYG{n}{day}\PYG{p}{,} \PYG{n}{lat}\PYG{p}{,} \PYG{n}{lon}\PYG{p}{,}\PYG{n}{minute\PYGZus{}step}\PYG{o}{=}\PYG{l+m+mi}{30}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{rad} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    \PYG{k}{for} \PYG{n}{hour} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{l+m+mi}{24}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{minute} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{60}\PYG{p}{,}\PYG{n}{minute\PYGZus{}step}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{thr} \PYG{o}{=} \PYG{n}{hour} \PYG{o}{+} \PYG{n}{minute}\PYG{o}{/}\PYG{l+m+mf}{60.}
            \PYG{c}{\PYGZsh{} append data line as tuple}
            \PYG{n}{rad}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{p}{(}\PYG{n}{thr}\PYG{p}{,}\PYG{p}{)} \PYG{o}{+} \PYGZbs{}
                     \PYG{n}{solar}\PYG{p}{(}\PYG{n}{year}\PYG{p}{,} \PYG{n}{month}\PYG{p}{,} \PYG{n}{day}\PYG{p}{,} \PYG{n}{hour}\PYG{p}{,} \PYG{n}{lat}\PYG{p}{,} \PYG{n}{lon}\PYG{p}{,} \PYG{n}{minute}\PYG{o}{=}\PYG{n}{minute}\PYG{p}{)} \PYG{o}{+}\PYGZbs{}
                     \PYG{p}{(}\PYG{n}{month}\PYG{p}{,} \PYG{n}{day}\PYG{p}{,} \PYG{n}{lat}\PYG{p}{,} \PYG{n}{lon}\PYG{p}{)}\PYG{p}{)}
    \PYG{c}{\PYGZsh{} convert to numpy array}
    \PYG{c}{\PYGZsh{} transpose so access eg zenith as}
    \PYG{c}{\PYGZsh{} rad[0]}
    \PYG{n}{rad} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{rad}\PYG{p}{)}\PYG{o}{.}\PYG{n}{T}
    \PYG{k}{return} \PYG{n}{rad}

\PYG{k}{def} \PYG{n+nf}{days\PYGZus{}in\PYGZus{}month}\PYG{p}{(}\PYG{n}{month}\PYG{p}{,}\PYG{n}{year}\PYG{o}{=}\PYG{l+m+mi}{2013}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{} number of days in month\PYGZsq{}\PYGZsq{}\PYGZsq{}}
    \PYG{k+kn}{import} \PYG{n+nn}{calendar}
    \PYG{k}{return} \PYG{n}{calendar}\PYG{o}{.}\PYG{n}{monthrange}\PYG{p}{(}\PYG{n}{year}\PYG{p}{,}\PYG{n}{month}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} UCL lat/lon}
\PYG{n}{lat} \PYG{o}{=} \PYG{l+m+mf}{51.5248}
\PYG{n}{lon} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.1336}

\PYG{n}{year} \PYG{o}{=} \PYG{l+m+mi}{2013}

\PYG{n}{pd} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{month} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{pd\PYGZus{}month} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    \PYG{n}{ndays} \PYG{o}{=} \PYG{n}{days\PYGZus{}in\PYGZus{}month}\PYG{p}{(}\PYG{n}{month}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{year}\PYG{o}{=}\PYG{n}{year}\PYG{p}{)}
    \PYG{k}{print} \PYG{n}{month}\PYG{p}{,}\PYG{n}{ndays}
    \PYG{k}{for} \PYG{n}{day} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{n}{ndays}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{rad} \PYG{o}{=} \PYG{n}{radiation}\PYG{p}{(}\PYG{n}{year}\PYG{p}{,} \PYG{n}{month}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{day}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{lat}\PYG{p}{,} \PYG{n}{lon}\PYG{p}{)}
        \PYG{n}{pd\PYGZus{}month}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{p}{[}\PYG{n}{rad}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{p}{)} \PYG{o}{*} \PYG{l+m+mi}{60} \PYG{o}{*} \PYG{l+m+mi}{30}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{pd\PYGZus{}month} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{pd\PYGZus{}month}\PYG{p}{)}\PYG{o}{.}\PYG{n}{T}
    \PYG{n}{pd}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{p}{[}\PYG{n}{month}\PYG{p}{,}\PYG{n}{pd\PYGZus{}month}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{pd} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{pd}\PYG{p}{)}\PYG{o}{.}\PYG{n}{T}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
0 31
1 28
2 31
3 30
4 31
5 30
6 31
7 31
8 30
9 31
10 30
11 31
\end{Verbatim}

Putiing that all together now:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} functions so far}

\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{n}{sys}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/python}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{c}{\PYGZsh{} modification of masked.py}
\PYG{k+kn}{from} \PYG{n+nn}{masked2} \PYG{k+kn}{import} \PYG{n}{masked}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{Pysolar}
\PYG{k+kn}{from} \PYG{n+nn}{datetime} \PYG{k+kn}{import} \PYG{n}{datetime}

\PYG{k}{def} \PYG{n+nf}{solar}\PYG{p}{(}\PYG{n}{year}\PYG{p}{,} \PYG{n}{month}\PYG{p}{,} \PYG{n}{day}\PYG{p}{,} \PYG{n}{hour}\PYG{p}{,} \PYG{n}{lat\PYGZus{}deg}\PYG{p}{,} \PYG{n}{lon\PYGZus{}deg}\PYG{p}{,} \PYG{n}{minute}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{second}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}Return solar zenith and clear sky radiation}
\PYG{l+s+sd}{       for given lat, lon and time/date}
\PYG{l+s+sd}{    \PYGZsq{}\PYGZsq{}\PYGZsq{}}
    \PYG{k+kn}{from} \PYG{n+nn}{datetime} \PYG{k+kn}{import} \PYG{n}{datetime}
    \PYG{k+kn}{import} \PYG{n+nn}{Pysolar}

    \PYG{n}{d} \PYG{o}{=} \PYG{n}{datetime}\PYG{p}{(}\PYG{n}{year}\PYG{p}{,} \PYG{n}{month}\PYG{p}{,} \PYG{n}{day}\PYG{p}{,} \PYG{n}{hour}\PYG{p}{,} \PYG{n}{minute}\PYG{p}{,} \PYG{n}{second}\PYG{p}{)}
    \PYG{n}{altitude\PYGZus{}deg} \PYG{o}{=} \PYG{n}{Pysolar}\PYG{o}{.}\PYG{n}{GetAltitude}\PYG{p}{(}\PYG{n}{lat\PYGZus{}deg}\PYG{p}{,} \PYG{n}{lon\PYGZus{}deg}\PYG{p}{,} \PYG{n}{d}\PYG{p}{)}
    \PYG{c}{\PYGZsh{} W m\PYGZca{}\PYGZhy{}2}
    \PYG{n}{solar\PYGZus{}rad} \PYG{o}{=} \PYG{n}{Pysolar}\PYG{o}{.}\PYG{n}{solar}\PYG{o}{.}\PYG{n}{radiation}\PYG{o}{.}\PYG{n}{GetRadiationDirect}\PYG{p}{(}\PYG{n}{d}\PYG{p}{,} \PYG{n}{altitude\PYGZus{}deg}\PYG{p}{)}
    \PYG{k}{return} \PYG{l+m+mf}{90.} \PYG{o}{\PYGZhy{}} \PYG{n}{altitude\PYGZus{}deg}\PYG{p}{,}\PYG{n}{solar\PYGZus{}rad}

\PYG{k}{def} \PYG{n+nf}{radiation}\PYG{p}{(}\PYG{n}{year}\PYG{p}{,} \PYG{n}{month}\PYG{p}{,} \PYG{n}{day}\PYG{p}{,} \PYG{n}{lat}\PYG{p}{,} \PYG{n}{lon}\PYG{p}{,}\PYG{n}{minute\PYGZus{}step}\PYG{o}{=}\PYG{l+m+mi}{30}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{rad} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    \PYG{k}{for} \PYG{n}{hour} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{l+m+mi}{24}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{minute} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{60}\PYG{p}{,}\PYG{n}{minute\PYGZus{}step}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{thr} \PYG{o}{=} \PYG{n}{hour} \PYG{o}{+} \PYG{n}{minute}\PYG{o}{/}\PYG{l+m+mf}{60.}
            \PYG{c}{\PYGZsh{} append data line as tuple}
            \PYG{n}{rad}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{p}{(}\PYG{n}{thr}\PYG{p}{,}\PYG{p}{)} \PYG{o}{+} \PYGZbs{}
                     \PYG{n}{solar}\PYG{p}{(}\PYG{n}{year}\PYG{p}{,} \PYG{n}{month}\PYG{p}{,} \PYG{n}{day}\PYG{p}{,} \PYG{n}{hour}\PYG{p}{,} \PYG{n}{lat}\PYG{p}{,} \PYG{n}{lon}\PYG{p}{,} \PYG{n}{minute}\PYG{o}{=}\PYG{n}{minute}\PYG{p}{)} \PYG{o}{+}\PYGZbs{}
                     \PYG{p}{(}\PYG{n}{month}\PYG{p}{,} \PYG{n}{day}\PYG{p}{,} \PYG{n}{lat}\PYG{p}{,} \PYG{n}{lon}\PYG{p}{)}\PYG{p}{)}
    \PYG{c}{\PYGZsh{} convert to numpy array}
    \PYG{c}{\PYGZsh{} transpose so access eg zenith as}
    \PYG{c}{\PYGZsh{} rad[0]}
    \PYG{n}{rad} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{rad}\PYG{p}{)}\PYG{o}{.}\PYG{n}{T}
    \PYG{k}{return} \PYG{n}{rad}

\PYG{k}{def} \PYG{n+nf}{days\PYGZus{}in\PYGZus{}month}\PYG{p}{(}\PYG{n}{month}\PYG{p}{,}\PYG{n}{year}\PYG{o}{=}\PYG{l+m+mi}{2013}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{} number of days in month\PYGZsq{}\PYGZsq{}\PYGZsq{}}
    \PYG{k+kn}{import} \PYG{n+nn}{calendar}
    \PYG{k}{return} \PYG{n}{calendar}\PYG{o}{.}\PYG{n}{monthrange}\PYG{p}{(}\PYG{n}{year}\PYG{p}{,}\PYG{n}{month}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
\end{Verbatim}

Before proceeding, let us examine the variation in total monthly power
density with latitude.

With the model developed in the main notes, we would expect no varition
with longitude (it was a function of latitude only).

In this more precise model, we would expect only small variation, but we
should examine this:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+sd}{Processing \PYGZhy{}\PYGZhy{} test for several lat/long}
\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}

\PYG{k+kn}{import} \PYG{n+nn}{numpy.ma} \PYG{k+kn}{as} \PYG{n+nn}{ma}

\PYG{n}{year} \PYG{o}{=} \PYG{l+m+mi}{2010}

\PYG{n}{minute\PYGZus{}step} \PYG{o}{=} \PYG{l+m+mi}{60}

\PYG{n}{data} \PYG{o}{=} \PYG{n}{masked}\PYG{p}{(}\PYG{n}{dataset}\PYG{o}{=}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{lat}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{lon}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{BHR\PYGZus{}SW}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{year}\PYG{o}{=}\PYG{n}{year}\PYG{p}{)}

\PYG{n}{lat} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{lat}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{lon} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{lon}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{albedo} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{BHR\PYGZus{}SW}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{s} \PYG{o}{=} \PYG{n}{albedo}\PYG{o}{.}\PYG{n}{shape}
\PYG{n}{lat} \PYG{o}{=} \PYG{n}{ma}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(} \PYG{p}{[}\PYG{n}{lat}\PYG{p}{]} \PYG{o}{*}\PYG{n}{s}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{T}
\PYG{n}{lon} \PYG{o}{=} \PYG{n}{ma}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{n}{lon}\PYG{p}{]} \PYG{o}{*} \PYG{n}{s}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}

\PYG{c}{\PYGZsh{} array for output}
\PYG{n}{absorbed} \PYG{o}{=} \PYG{n}{ma}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros\PYGZus{}like}\PYG{p}{(}\PYG{n}{albedo}\PYG{p}{)}\PYG{p}{,}\PYG{n}{mask}\PYG{o}{=}\PYG{n}{albedo}\PYG{o}{.}\PYG{n}{mask}\PYG{p}{)}
\PYG{c}{\PYGZsh{}}

\PYG{c}{\PYGZsh{}for i in xrange(lat.shape[0]):}
\PYG{c}{\PYGZsh{}    for j in xrange(lat.shape[1]):}

\PYG{c}{\PYGZsh{} try it out for 6 samples in longitude, including first and last}
\PYG{n}{lons} \PYG{o}{=} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{lon}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{n}{lon}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{/}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{p}{[}\PYG{n}{lon}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}

\PYG{c}{\PYGZsh{} an array to hold the sample pd for the sample}
\PYG{c}{\PYGZsh{} longitudes}
\PYG{n}{all\PYGZus{}pd} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}

\PYG{n}{i} \PYG{o}{=} \PYG{n}{lon}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{/}\PYG{l+m+mi}{2}
\PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n}{lons}\PYG{p}{:}
    \PYG{n}{pd} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    \PYG{c}{\PYGZsh{} loop over month}
    \PYG{k}{for} \PYG{n}{month} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{pd\PYGZus{}month} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
        \PYG{n}{ndays} \PYG{o}{=} \PYG{n}{days\PYGZus{}in\PYGZus{}month}\PYG{p}{(}\PYG{n}{month}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{year}\PYG{o}{=}\PYG{n}{year}\PYG{p}{)}
        \PYG{k}{print} \PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{,}\PYG{n}{month}\PYG{p}{,}\PYG{n}{ndays}
        \PYG{c}{\PYGZsh{} loop over days}
        \PYG{k}{for} \PYG{n}{day} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{n}{ndays}\PYG{p}{)}\PYG{p}{:}
            \PYG{c}{\PYGZsh{} solar radiation for that day}
            \PYG{n}{rad} \PYG{o}{=} \PYG{n}{radiation}\PYG{p}{(}\PYG{n}{year}\PYG{p}{,} \PYG{n}{month}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{day}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,} \PYGZbs{}
                            \PYG{n}{lat}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,} \PYG{n}{lon}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,}\PYG{n}{minute\PYGZus{}step}\PYG{o}{=}\PYG{n}{minute\PYGZus{}step}\PYG{p}{)}
            \PYG{n}{pd\PYGZus{}month}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{p}{[}\PYG{n}{rad}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{p}{)} \PYG{o}{*} \PYG{l+m+mi}{60} \PYG{o}{*} \PYG{n}{minute\PYGZus{}step}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{pd\PYGZus{}month} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{pd\PYGZus{}month}\PYG{p}{)}\PYG{o}{.}\PYG{n}{T}
        \PYG{n}{pd}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{p}{[}\PYG{n}{pd\PYGZus{}month}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}
    \PYG{c}{\PYGZsh{} pd is the power density for each month}
    \PYG{n}{all\PYGZus{}pd}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{pd}\PYG{p}{)}

\PYG{c}{\PYGZsh{} MJ per m2}
\PYG{n}{all\PYGZus{}pd} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{all\PYGZus{}pd}\PYG{p}{)}\PYG{o}{.}\PYG{n}{squeeze}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
180 0 0 31
180 0 1 28
180 0 2 31
180 0 3 30
180 0 4 31
180 0 5 30
180 0 6 31
180 0 7 31
180 0 8 30
180 0 9 31
180 0 10 30
180 0 11 31
180 144 0 31
180 144 1 28
180 144 2 31
180 144 3 30
180 144 4 31
180 144 5 30
180 144 6 31
180 144 7 31
180 144 8 30
180 144 9 31
180 144 10 30
180 144 11 31
180 288 0 31
180 288 1 28
180 288 2 31
180 288 3 30
180 288 4 31
180 288 5 30
180 288 6 31
180 288 7 31
180 288 8 30
180 288 9 31
180 288 10 30
180 288 11 31
180 432 0 31
180 432 1 28
180 432 2 31
180 432 3 30
180 432 4 31
180 432 5 30
180 432 6 31
180 432 7 31
180 432 8 30
180 432 9 31
180 432 10 30
180 432 11 31
180 576 0 31
180 576 1 28
180 576 2 31
180 576 3 30
180 576 4 31
180 576 5 30
180 576 6 31
180 576 7 31
180 576 8 30
180 576 9 31
180 576 10 30
180 576 11 31
180 719 0 31
180 719 1 28
180 719 2 31
180 719 3 30
180 719 4 31
180 719 5 30
180 719 6 31
180 719 7 31
180 719 8 30
180 719 9 31
180 719 10 30
180 719 11 31
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{pylab} \PYG{k+kn}{as} \PYG{n+nn}{plt}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{lon}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{lons}\PYG{p}{]}\PYG{p}{,}\PYG{n}{all\PYGZus{}pd}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlim}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{180.}\PYG{p}{,}\PYG{l+m+mf}{180.}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{latitude}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{power density total per month}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.text.Text at 0x108fc52d0\PYGZgt{}
\end{Verbatim}

\includegraphics{advanced_answers_17_1.png}

So, with this in mind, let's just take a single value per latitude as
otherwise the processing cost will be rather high.

Putting this into a function (in this case, reading the albedo, lat and
long internally):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{absorbed\PYGZus{}power\PYGZus{}density}\PYG{p}{(}\PYG{n}{year}\PYG{p}{,}\PYG{n}{minute\PYGZus{}step}\PYG{o}{=}\PYG{l+m+mi}{60}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}Function to calculate the monthly total absorbed solar radiation}
\PYG{l+s+sd}{        power density in MJ / m\PYGZca{}2 for a given year}
\PYG{l+s+sd}{        given an input dataset albedo and associated lat and lon}
\PYG{l+s+sd}{        information (in degrees).}

\PYG{l+s+sd}{        The shape of the albedo dataset is: (12,nlat,nlon)}

\PYG{l+s+sd}{        Aguments:}

\PYG{l+s+sd}{        year  : integer of the year}

\PYG{l+s+sd}{        Options:}

\PYG{l+s+sd}{        minute\PYGZus{}step : integer: resolution of steps in minutes. Must be}
\PYG{l+s+sd}{                      a divisor of 60 (e.g. 10, 15, 30, 60)}

\PYG{l+s+sd}{    \PYGZsq{}\PYGZsq{}\PYGZsq{}}

    \PYG{n}{data} \PYG{o}{=} \PYG{n}{masked}\PYG{p}{(}\PYG{n}{dataset}\PYG{o}{=}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{lat}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{lon}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{BHR\PYGZus{}SW}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{year}\PYG{o}{=}\PYG{n}{year}\PYG{p}{)}

    \PYG{n}{lat} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{lat}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
    \PYG{n}{lon} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{lon}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
    \PYG{n}{albedo} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{BHR\PYGZus{}SW}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
    \PYG{n}{s} \PYG{o}{=} \PYG{n}{albedo}\PYG{o}{.}\PYG{n}{shape}
    \PYG{n}{lat} \PYG{o}{=} \PYG{n}{ma}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(} \PYG{p}{[}\PYG{n}{lat}\PYG{p}{]} \PYG{o}{*}\PYG{n}{s}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{T}
    \PYG{n}{lon} \PYG{o}{=} \PYG{n}{ma}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{n}{lon}\PYG{p}{]} \PYG{o}{*} \PYG{n}{s}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}

    \PYG{c}{\PYGZsh{} array for output}
    \PYG{n}{absorbed} \PYG{o}{=} \PYG{n}{ma}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros\PYGZus{}like}\PYG{p}{(}\PYG{n}{albedo}\PYG{p}{)}\PYG{p}{,}\PYG{n}{mask}\PYG{o}{=}\PYG{n}{albedo}\PYG{o}{.}\PYG{n}{mask}\PYG{p}{)}
    \PYG{n}{power\PYGZus{}density} \PYG{o}{=} \PYG{n}{ma}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros\PYGZus{}like}\PYG{p}{(}\PYG{n}{albedo}\PYG{p}{)}\PYG{p}{,}\PYG{n}{mask}\PYG{o}{=}\PYG{n}{albedo}\PYG{o}{.}\PYG{n}{mask}\PYG{p}{)}
    \PYG{c}{\PYGZsh{}}

    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{lat}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{lat}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{lat}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}
        \PYG{c}{\PYGZsh{} single longitude}
        \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{p}{[}\PYG{n}{lat}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{:}
            \PYG{n}{pd} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
            \PYG{c}{\PYGZsh{} loop over month}
            \PYG{k}{for} \PYG{n}{month} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{pd\PYGZus{}month} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
                \PYG{n}{ndays} \PYG{o}{=} \PYG{n}{days\PYGZus{}in\PYGZus{}month}\PYG{p}{(}\PYG{n}{month}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{year}\PYG{o}{=}\PYG{n}{year}\PYG{p}{)}
                \PYG{c}{\PYGZsh{} loop over days}
                \PYG{k}{for} \PYG{n}{day} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{n}{ndays}\PYG{p}{)}\PYG{p}{:}
                    \PYG{c}{\PYGZsh{} solar radiation for that day}
                    \PYG{n}{rad} \PYG{o}{=} \PYG{n}{radiation}\PYG{p}{(}\PYG{n}{year}\PYG{p}{,} \PYG{n}{month}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{day}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,} \PYGZbs{}
                                    \PYG{n}{lat}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,} \PYG{n}{lon}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,}\PYG{n}{minute\PYGZus{}step}\PYG{o}{=}\PYG{n}{minute\PYGZus{}step}\PYG{p}{)}
                    \PYG{c}{\PYGZsh{} get rid of \PYGZhy{}ves}
                    \PYG{n}{rad}\PYG{p}{[}\PYG{n}{rad}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}
                    \PYG{n}{pd\PYGZus{}month}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{p}{[}\PYG{n}{rad}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{p}{)} \PYG{o}{*} \PYG{l+m+mi}{60} \PYG{o}{*} \PYG{n}{minute\PYGZus{}step}\PYG{p}{]}\PYG{p}{)}
                \PYG{n}{pd\PYGZus{}month} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{pd\PYGZus{}month}\PYG{p}{)}\PYG{o}{.}\PYG{n}{T}
                \PYG{n}{pd}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{p}{[}\PYG{n}{pd\PYGZus{}month}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}
            \PYG{n}{pd} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{pd}\PYG{p}{)}\PYG{o}{.}\PYG{n}{squeeze}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{T}

            \PYG{c}{\PYGZsh{} pd is the power density for each month}
            \PYG{c}{\PYGZsh{} load this into all longitudes}
            \PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{n}{power\PYGZus{}density}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{power\PYGZus{}density}\PYG{p}{[}\PYG{n}{k}\PYG{p}{,}\PYG{n}{i}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{n}{pd}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}
    \PYG{n}{power\PYGZus{}density} \PYG{o}{/}\PYG{o}{=} \PYG{l+m+mf}{10.}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{6} \PYG{c}{\PYGZsh{} MJ per m2}
    \PYG{n}{absorbed} \PYG{o}{=} \PYG{n}{power\PYGZus{}density} \PYG{o}{*} \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}} \PYG{n}{albedo}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{absorbed}\PYG{p}{,}\PYG{n}{power\PYGZus{}density}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} this will still take some minutes to calculate}
\PYG{n}{absorbed}\PYG{p}{,}\PYG{n}{power\PYGZus{}density} \PYG{o}{=} \PYG{n}{absorbed\PYGZus{}power\PYGZus{}density}\PYG{p}{(}\PYG{n}{year}\PYG{p}{,}\PYG{n}{minute\PYGZus{}step}\PYG{o}{=}\PYG{l+m+mi}{60}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
lat 89.6957
lat 89.196
lat 88.6963
lat 88.1966
lat 87.6969
lat 87.1972
lat 86.6975
lat 86.1978
lat 85.6981
lat 85.1984
lat 84.6987
lat 84.1991
lat 83.6994
lat 83.1997
lat 82.7
lat 82.2003
lat 81.7006
lat 81.2009
lat 80.7012
lat 80.2015
lat 79.7018
lat 79.2021
lat 78.7024
lat 78.2027
lat 77.703
lat 77.2033
lat 76.7036
lat 76.2039
lat 75.7042
lat 75.2045
lat 74.7048
lat 74.2051
lat 73.7054
lat 73.2057
lat 72.706
lat 72.2063
lat 71.7066
lat 71.2069
lat 70.7072
lat 70.2075
lat 69.7078
lat 69.2081
lat 68.7084
lat 68.2087
lat 67.709
lat 67.2093
lat 66.7096
lat 66.2099
lat 65.7102
lat 65.2105
lat 64.7108
lat 64.2111
lat 63.7114
lat 63.2118
lat 62.7121
lat 62.2124
lat 61.7127
lat 61.213
lat 60.7133
lat 60.2136
lat 59.7139
lat 59.2142
lat 58.7145
lat 58.2148
lat 57.7151
lat 57.2154
lat 56.7157
lat 56.216
lat 55.7163
lat 55.2166
lat 54.7169
lat 54.2172
lat 53.7175
lat 53.2178
lat 52.7181
lat 52.2184
lat 51.7187
lat 51.219
lat 50.7193
lat 50.2196
lat 49.7199
lat 49.2202
lat 48.7205
lat 48.2208
lat 47.7211
lat 47.2214
lat 46.7217
lat 46.222
lat 45.7223
lat 45.2226
lat 44.7229
lat 44.2232
lat 43.7235
lat 43.2238
lat 42.7241
lat 42.2245
lat 41.7248
lat 41.2251
lat 40.7254
lat 40.2257
lat 39.726
lat 39.2263
lat 38.7266
lat 38.2269
lat 37.7272
lat 37.2275
lat 36.7278
lat 36.2281
lat 35.7284
lat 35.2287
lat 34.729
lat 34.2293
lat 33.7296
lat 33.2299
lat 32.7302
lat 32.2305
lat 31.7308
lat 31.2311
lat 30.7314
lat 30.2317
lat 29.732
lat 29.2323
lat 28.7326
lat 28.2329
lat 27.7332
lat 27.2335
lat 26.7338
lat 26.2341
lat 25.7344
lat 25.2347
lat 24.735
lat 24.2353
lat 23.7356
lat 23.2359
lat 22.7362
lat 22.2365
lat 21.7369
lat 21.2372
lat 20.7375
lat 20.2378
lat 19.7381
lat 19.2384
lat 18.7387
lat 18.239
lat 17.7393
lat 17.2396
lat 16.7399
lat 16.2402
lat 15.7405
lat 15.2408
lat 14.7411
lat 14.2414
lat 13.7417
lat 13.242
lat 12.7423
lat 12.2426
lat 11.7429
lat 11.2432
lat 10.7435
lat 10.2438
lat 9.74411
lat 9.24441
lat 8.74471
lat 8.24501
lat 7.74532
lat 7.24562
lat 6.74592
lat 6.24622
lat 5.74653
lat 5.24683
lat 4.74713
lat 4.24743
lat 3.74774
lat 3.24804
lat 2.74834
lat 2.24864
lat 1.74895
lat 1.24925
lat 0.74955
lat 0.249853
lat \PYGZhy{}0.249845
lat \PYGZhy{}0.749542
lat \PYGZhy{}1.24924
lat \PYGZhy{}1.74894
lat \PYGZhy{}2.24864
lat \PYGZhy{}2.74833
lat \PYGZhy{}3.24803
lat \PYGZhy{}3.74773
lat \PYGZhy{}4.24743
lat \PYGZhy{}4.74712
lat \PYGZhy{}5.24682
lat \PYGZhy{}5.74652
lat \PYGZhy{}6.24622
lat \PYGZhy{}6.74591
lat \PYGZhy{}7.24561
lat \PYGZhy{}7.74531
lat \PYGZhy{}8.24501
lat \PYGZhy{}8.7447
lat \PYGZhy{}9.2444
lat \PYGZhy{}9.7441
lat \PYGZhy{}10.2438
lat \PYGZhy{}10.7435
lat \PYGZhy{}11.2432
lat \PYGZhy{}11.7429
lat \PYGZhy{}12.2426
lat \PYGZhy{}12.7423
lat \PYGZhy{}13.242
lat \PYGZhy{}13.7417
lat \PYGZhy{}14.2414
lat \PYGZhy{}14.7411
lat \PYGZhy{}15.2408
lat \PYGZhy{}15.7405
lat \PYGZhy{}16.2402
lat \PYGZhy{}16.7399
lat \PYGZhy{}17.2396
lat \PYGZhy{}17.7393
lat \PYGZhy{}18.239
lat \PYGZhy{}18.7387
lat \PYGZhy{}19.2384
lat \PYGZhy{}19.7381
lat \PYGZhy{}20.2377
lat \PYGZhy{}20.7374
lat \PYGZhy{}21.2371
lat \PYGZhy{}21.7368
lat \PYGZhy{}22.2365
lat \PYGZhy{}22.7362
lat \PYGZhy{}23.2359
lat \PYGZhy{}23.7356
lat \PYGZhy{}24.2353
lat \PYGZhy{}24.735
lat \PYGZhy{}25.2347
lat \PYGZhy{}25.7344
lat \PYGZhy{}26.2341
lat \PYGZhy{}26.7338
lat \PYGZhy{}27.2335
lat \PYGZhy{}27.7332
lat \PYGZhy{}28.2329
lat \PYGZhy{}28.7326
lat \PYGZhy{}29.2323
lat \PYGZhy{}29.732
lat \PYGZhy{}30.2317
lat \PYGZhy{}30.7314
lat \PYGZhy{}31.2311
lat \PYGZhy{}31.7308
lat \PYGZhy{}32.2305
lat \PYGZhy{}32.7302
lat \PYGZhy{}33.2299
lat \PYGZhy{}33.7296
lat \PYGZhy{}34.2293
lat \PYGZhy{}34.729
lat \PYGZhy{}35.2287
lat \PYGZhy{}35.7284
lat \PYGZhy{}36.2281
lat \PYGZhy{}36.7278
lat \PYGZhy{}37.2275
lat \PYGZhy{}37.7272
lat \PYGZhy{}38.2269
lat \PYGZhy{}38.7266
lat \PYGZhy{}39.2263
lat \PYGZhy{}39.726
lat \PYGZhy{}40.2257
lat \PYGZhy{}40.7253
lat \PYGZhy{}41.225
lat \PYGZhy{}41.7247
lat \PYGZhy{}42.2244
lat \PYGZhy{}42.7241
lat \PYGZhy{}43.2238
lat \PYGZhy{}43.7235
lat \PYGZhy{}44.2232
lat \PYGZhy{}44.7229
lat \PYGZhy{}45.2226
lat \PYGZhy{}45.7223
lat \PYGZhy{}46.222
lat \PYGZhy{}46.7217
lat \PYGZhy{}47.2214
lat \PYGZhy{}47.7211
lat \PYGZhy{}48.2208
lat \PYGZhy{}48.7205
lat \PYGZhy{}49.2202
lat \PYGZhy{}49.7199
lat \PYGZhy{}50.2196
lat \PYGZhy{}50.7193
lat \PYGZhy{}51.219
lat \PYGZhy{}51.7187
lat \PYGZhy{}52.2184
lat \PYGZhy{}52.7181
lat \PYGZhy{}53.2178
lat \PYGZhy{}53.7175
lat \PYGZhy{}54.2172
lat \PYGZhy{}54.7169
lat \PYGZhy{}55.2166
lat \PYGZhy{}55.7163
lat \PYGZhy{}56.216
lat \PYGZhy{}56.7157
lat \PYGZhy{}57.2154
lat \PYGZhy{}57.7151
lat \PYGZhy{}58.2148
lat \PYGZhy{}58.7145
lat \PYGZhy{}59.2142
lat \PYGZhy{}59.7139
lat \PYGZhy{}60.2136
lat \PYGZhy{}60.7133
lat \PYGZhy{}61.213
lat \PYGZhy{}61.7127
lat \PYGZhy{}62.2123
lat \PYGZhy{}62.712
lat \PYGZhy{}63.2117
lat \PYGZhy{}63.7114
lat \PYGZhy{}64.2111
lat \PYGZhy{}64.7108
lat \PYGZhy{}65.2105
lat \PYGZhy{}65.7102
lat \PYGZhy{}66.2099
lat \PYGZhy{}66.7096
lat \PYGZhy{}67.2093
lat \PYGZhy{}67.709
lat \PYGZhy{}68.2087
lat \PYGZhy{}68.7084
lat \PYGZhy{}69.2081
lat \PYGZhy{}69.7078
lat \PYGZhy{}70.2075
lat \PYGZhy{}70.7072
lat \PYGZhy{}71.2069
lat \PYGZhy{}71.7066
lat \PYGZhy{}72.2063
lat \PYGZhy{}72.706
lat \PYGZhy{}73.2057
lat \PYGZhy{}73.7054
lat \PYGZhy{}74.2051
lat \PYGZhy{}74.7048
lat \PYGZhy{}75.2045
lat \PYGZhy{}75.7042
lat \PYGZhy{}76.2039
lat \PYGZhy{}76.7036
lat \PYGZhy{}77.2033
lat \PYGZhy{}77.703
lat \PYGZhy{}78.2027
lat \PYGZhy{}78.7024
lat \PYGZhy{}79.2021
lat \PYGZhy{}79.7018
lat \PYGZhy{}80.2015
lat \PYGZhy{}80.7012
lat \PYGZhy{}81.2009
lat \PYGZhy{}81.7006
lat \PYGZhy{}82.2002
lat \PYGZhy{}82.7
lat \PYGZhy{}83.1996
lat \PYGZhy{}83.6993
lat \PYGZhy{}84.199
lat \PYGZhy{}84.6987
lat \PYGZhy{}85.1984
lat \PYGZhy{}85.6981
lat \PYGZhy{}86.1978
lat \PYGZhy{}86.6975
lat \PYGZhy{}87.1972
lat \PYGZhy{}87.6969
lat \PYGZhy{}88.1966
lat \PYGZhy{}88.6963
lat \PYGZhy{}89.196
lat \PYGZhy{}89.6957
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} this is how you can save a numpy array}
\PYG{n}{np}\PYG{o}{.}\PYG{n}{savez}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/absorbed.npz}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{absorbed}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{absorbed}\PYG{p}{)}\PYG{p}{,}\PYGZbs{}
         \PYG{n}{power\PYGZus{}density}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{power\PYGZus{}density}\PYG{p}{)}\PYG{p}{,}\PYG{n}{mask}\PYG{o}{=}\PYG{n}{absorbed}\PYG{o}{.}\PYG{n}{mask}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} now next time we should be able to load it}
\PYG{k}{try}\PYG{p}{:}
    \PYG{n}{f} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{load}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/absorbed.npz}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{mask} \PYG{o}{=} \PYG{n}{f}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{mask}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
    \PYG{n}{absorbed}\PYG{p}{,}\PYG{n}{power\PYGZus{}density} \PYG{o}{=} \PYG{n}{ma}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{f}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{absorbed}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{mask}\PYG{o}{=}\PYG{n}{mask}\PYG{p}{)}\PYG{p}{,}\PYGZbs{}
                             \PYG{n}{ma}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{f}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{power\PYGZus{}density}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{mask}\PYG{o}{=}\PYG{n}{mask}\PYG{p}{)}
\PYG{k}{except}\PYG{p}{:}
    \PYG{n}{absorbed}\PYG{p}{,}\PYG{n}{power\PYGZus{}density} \PYG{o}{=} \PYG{n}{absorbed\PYGZus{}power\PYGZus{}density}\PYG{p}{(}\PYG{n}{year}\PYG{p}{,}\PYG{n}{minute\PYGZus{}step}\PYG{o}{=}\PYG{l+m+mi}{60}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{pylab} \PYG{k+kn}{as} \PYG{n+nn}{plt}

\PYG{n}{cmap} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{get\PYGZus{}cmap}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Spectral}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{vmax} \PYG{o}{=} \PYG{n}{absorbed}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{2}
\PYG{n}{vmin} \PYG{o}{=} \PYG{l+m+mf}{0.}

\PYG{k}{for} \PYG{n}{m} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Absorbed radiation Month }\PYG{l+s+si}{\PYGZpc{}02d}\PYG{l+s}{ }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{ MJ / m\PYGZca{}2}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,}\PYG{n}{year}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{absorbed}\PYG{p}{[}\PYG{n}{m}\PYG{p}{]}\PYG{p}{,}\PYG{n}{cmap}\PYG{o}{=}\PYG{n}{cmap}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{vmin}\PYG{o}{=}\PYG{n}{vmin}\PYG{p}{,}\PYG{n}{vmax}\PYG{o}{=}\PYG{n}{vmax}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/absorbed}\PYG{l+s+si}{\PYGZpc{}02d}\PYG{l+s}{.jpg}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{n}{m}\PYG{p}{)}
\end{Verbatim}

\includegraphics{advanced_answers_24_0.png}

\includegraphics{advanced_answers_24_1.png}

\includegraphics{advanced_answers_24_2.png}

\includegraphics{advanced_answers_24_3.png}

\includegraphics{advanced_answers_24_4.png}

\includegraphics{advanced_answers_24_5.png}

\includegraphics{advanced_answers_24_6.png}

\includegraphics{advanced_answers_24_7.png}

\includegraphics{advanced_answers_24_8.png}

\includegraphics{advanced_answers_24_9.png}

\includegraphics{advanced_answers_24_10.png}

\includegraphics{advanced_answers_24_11.png}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{pylab} \PYG{k+kn}{as} \PYG{n+nn}{plt}

\PYG{n}{cmap} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{get\PYGZus{}cmap}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Spectral}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{vmax} \PYG{o}{=} \PYG{n}{absorbed}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{p}{)} \PYG{o}{*} \PYG{l+m+mf}{2.}\PYG{o}{/}\PYG{l+m+mf}{3.}
\PYG{n}{vmin} \PYG{o}{=} \PYG{l+m+mf}{0.}

\PYG{k}{for} \PYG{n}{m} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Solar radiation power density Month }\PYG{l+s+si}{\PYGZpc{}02d}\PYG{l+s}{ }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{ MJ / m\PYGZca{}2}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,}\PYG{n}{year}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{power\PYGZus{}density}\PYG{p}{[}\PYG{n}{m}\PYG{p}{]}\PYG{p}{,}\PYG{n}{cmap}\PYG{o}{=}\PYG{n}{cmap}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{vmin}\PYG{o}{=}\PYG{n}{vmin}\PYG{p}{,}\PYG{n}{vmax}\PYG{o}{=}\PYG{n}{vmax}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/power}\PYG{l+s+si}{\PYGZpc{}02d}\PYG{l+s}{.jpg}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{n}{m}\PYG{p}{)}
\end{Verbatim}

\includegraphics{advanced_answers_25_0.png}

\includegraphics{advanced_answers_25_1.png}

\includegraphics{advanced_answers_25_2.png}

\includegraphics{advanced_answers_25_3.png}

\includegraphics{advanced_answers_25_4.png}

\includegraphics{advanced_answers_25_5.png}

\includegraphics{advanced_answers_25_6.png}

\includegraphics{advanced_answers_25_7.png}

\includegraphics{advanced_answers_25_8.png}

\includegraphics{advanced_answers_25_9.png}

\includegraphics{advanced_answers_25_10.png}

\includegraphics{advanced_answers_25_11.png}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{}make some movies!???}
\PYG{k+kn}{import} \PYG{n+nn}{os}

\PYG{k}{for} \PYG{n}{t} \PYG{o+ow}{in} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{power}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{absorbed}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{:}
    \PYG{k}{for} \PYG{n}{m} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{cmd} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{convert files/data/}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+si}{\PYGZpc{}02d}\PYG{l+s}{.jpg files/data/}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+si}{\PYGZpc{}02d}\PYG{l+s}{.gif}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{t}\PYG{p}{,}\PYG{n}{m}\PYG{p}{,}\PYG{n}{t}\PYG{p}{,}\PYG{n}{m}\PYG{p}{)}
        \PYG{k}{print} \PYG{n}{cmd}
        \PYG{n}{os}\PYG{o}{.}\PYG{n}{system}\PYG{p}{(}\PYG{n}{cmd}\PYG{p}{)}

    \PYG{n}{cmd} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{convert \PYGZhy{}delay 100  \PYGZhy{}loop 0  }\PYG{l+s+se}{\PYGZbs{}}
\PYG{l+s}{            files/data/}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{??.gif files/data/}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZus{}movie.gif}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{t}\PYG{p}{,}\PYG{n}{t}\PYG{p}{)}
    \PYG{n}{os}\PYG{o}{.}\PYG{n}{system}\PYG{p}{(}\PYG{n}{cmd}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
convert files/data/power00.jpg files/data/power00.gif
convert files/data/power01.jpg files/data/power01.gif
convert files/data/power02.jpg files/data/power02.gif
convert files/data/power03.jpg files/data/power03.gif
convert files/data/power04.jpg files/data/power04.gif
convert files/data/power05.jpg files/data/power05.gif
convert files/data/power06.jpg files/data/power06.gif
convert files/data/power07.jpg files/data/power07.gif
convert files/data/power08.jpg files/data/power08.gif
convert files/data/power09.jpg files/data/power09.gif
convert files/data/power10.jpg files/data/power10.gif
convert files/data/power11.jpg files/data/power11.gif
convert files/data/absorbed00.jpg files/data/absorbed00.gif
convert files/data/absorbed01.jpg files/data/absorbed01.gif
convert files/data/absorbed02.jpg files/data/absorbed02.gif
convert files/data/absorbed03.jpg files/data/absorbed03.gif
convert files/data/absorbed04.jpg files/data/absorbed04.gif
convert files/data/absorbed05.jpg files/data/absorbed05.gif
convert files/data/absorbed06.jpg files/data/absorbed06.gif
convert files/data/absorbed07.jpg files/data/absorbed07.gif
convert files/data/absorbed08.jpg files/data/absorbed08.gif
convert files/data/absorbed09.jpg files/data/absorbed09.gif
convert files/data/absorbed10.jpg files/data/absorbed10.gif
convert files/data/absorbed11.jpg files/data/absorbed11.gif
\end{Verbatim}

\includegraphics{Chapter3_Scientific_Numerical_Python/files/data/power_movie.gif} \includegraphics{Chapter3_Scientific_Numerical_Python/files/data/absorbed_movie.gif}

This code is still quite slow (even for a single longitude).

You should look it over and see how you might make it more efficient.

Some ideas:
\begin{itemize}
\item {} 
interpolate the radiation field (over latitude?) and possibly improve
by sub sampling over longitude and interpolating that as well

\item {} 
when calculating daily integrals, don't start the calculations until
the sun is above the horizon (and the same for sunset).

\end{itemize}

The exercise asks you to perform summations over latitude. This should
be simple enough, being of the form:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{absorbed}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{axis}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

which will sum over axes 0 (month) and 2 (longitude).

Total absorbed involves working out the area for each sample pixel and
including that in teh calculation. That is left as an exercise here.


\chapter{E3 Answers to Exercise}
\label{Chapter3_Scientific_Numerical_Python/answers:e3-answers-to-exercise}\label{Chapter3_Scientific_Numerical_Python/answers::doc}

\section{E3.2 Exercise: listing}
\label{Chapter3_Scientific_Numerical_Python/answers:e3-2-exercise-listing}
\textbf{Using Python, produce a listing of the files in the subdirectory
{}`{}`data{}`{}` of {}`{}`geogg122/Chapter3\_Scientific\_Numerical\_Python{}`{}` that end
with {}`{}`.nc{}`{}` and put this listing in a file called
{}`{}`files/data/data.dat{}`{}` with each entry on a different line}


\section{A3.2 Answer: listing}
\label{Chapter3_Scientific_Numerical_Python/answers:a3-2-answer-listing}
Hopefully, you should already be in the directory
\code{geogg122/Chapter3\_Scientific\_Numerical\_Python}, if not, you may like
to go there before starting this exercise.

If you were to do this from unix, you would getr the listing with:

\begin{Verbatim}[commandchars=\\\{\}]
!ls \PYGZhy{}l data/*.nc
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{}r\PYGZhy{}\PYGZhy{}  1 plewis  staff  115202868 11 Oct 09:53 data/GlobAlbedo.1998145.h17v03.nc
\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{}r\PYGZhy{}\PYGZhy{}  1 plewis  staff   18669672 11 Oct 20:07 data/GlobAlbedo.200901.mosaic.5.nc
\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{}r\PYGZhy{}\PYGZhy{}  1 plewis  staff   18669672 11 Oct 20:07 data/GlobAlbedo.200902.mosaic.5.nc
\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{}r\PYGZhy{}\PYGZhy{}  1 plewis  staff   18669672 11 Oct 20:08 data/GlobAlbedo.200903.mosaic.5.nc
\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{}r\PYGZhy{}\PYGZhy{}  1 plewis  staff   18669672 11 Oct 20:08 data/GlobAlbedo.200904.mosaic.5.nc
\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{}r\PYGZhy{}\PYGZhy{}  1 plewis  staff   18669672 11 Oct 20:08 data/GlobAlbedo.200905.mosaic.5.nc
\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{}r\PYGZhy{}\PYGZhy{}  1 plewis  staff   18669672 11 Oct 20:08 data/GlobAlbedo.200906.mosaic.5.nc
\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{}r\PYGZhy{}\PYGZhy{}  1 plewis  staff   18758652 11 Oct 20:08 data/GlobAlbedo.200907.mosaic.5.nc
\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{}r\PYGZhy{}\PYGZhy{}  1 plewis  staff   18669672 11 Oct 20:08 data/GlobAlbedo.200908.mosaic.5.nc
\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{}r\PYGZhy{}\PYGZhy{}  1 plewis  staff   18669672 11 Oct 20:08 data/GlobAlbedo.200909.mosaic.5.nc
\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{}r\PYGZhy{}\PYGZhy{}  1 plewis  staff   18669672 11 Oct 20:08 data/GlobAlbedo.200910.mosaic.5.nc
\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{}r\PYGZhy{}\PYGZhy{}  1 plewis  staff   18669672 11 Oct 20:08 data/GlobAlbedo.200911.mosaic.5.nc
\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{}r\PYGZhy{}\PYGZhy{}  1 plewis  staff   18669672 11 Oct 20:08 data/GlobAlbedo.200912.mosaic.5.nc
\end{Verbatim}

or similar.

To do this in Python, you should use \code{glob}, and the same `pattern':

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{glob}

\PYG{n}{files} \PYG{o}{=} \PYG{n}{glob}\PYG{o}{.}\PYG{n}{glob}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{data/*.nc}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{files}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{data/GlobAlbedo.1998145.h17v03.nc}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{data/GlobAlbedo.200901.mosaic.5.nc}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{data/GlobAlbedo.200902.mosaic.5.nc}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{data/GlobAlbedo.200903.mosaic.5.nc}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{data/GlobAlbedo.200904.mosaic.5.nc}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{data/GlobAlbedo.200905.mosaic.5.nc}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{data/GlobAlbedo.200906.mosaic.5.nc}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{data/GlobAlbedo.200907.mosaic.5.nc}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{data/GlobAlbedo.200908.mosaic.5.nc}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{data/GlobAlbedo.200909.mosaic.5.nc}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{data/GlobAlbedo.200910.mosaic.5.nc}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{data/GlobAlbedo.200911.mosaic.5.nc}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{data/GlobAlbedo.200912.mosaic.5.nc}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\end{Verbatim}

This is a list. We want to write this to a file called
\code{files/data/data.dat}.

First we open it, then simply use \code{writelines} to write the list of
strings, the close the file.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{filename} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/data.dat}\PYG{l+s}{\PYGZsq{}}

\PYG{c}{\PYGZsh{} open in write mode}
\PYG{n}{fp} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{w}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{fp}\PYG{o}{.}\PYG{n}{writelines}\PYG{p}{(}\PYG{n}{files}\PYG{p}{)}
\PYG{n}{fp}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

Hopefully, that all worked well, but just to check from unix:

\begin{Verbatim}[commandchars=\\\{\}]
!cat files/data/data.dat
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
data/GlobAlbedo.1998145.h17v03.ncdata/GlobAlbedo.200901.mosaic.5.ncdata/GlobAlbedo.200902.mosaic.5.ncdata/GlobAlbedo.200903.mosaic.5.ncdata/GlobAlbedo.200904.mosaic.5.ncdata/GlobAlbedo.200905.mosaic.5.ncdata/GlobAlbedo.200906.mosaic.5.ncdata/GlobAlbedo.200907.mosaic.5.ncdata/GlobAlbedo.200908.mosaic.5.ncdata/GlobAlbedo.200909.mosaic.5.ncdata/GlobAlbedo.200910.mosaic.5.ncdata/GlobAlbedo.200911.mosaic.5.ncdata/GlobAlbedo.200912.mosaic.5.nc
\end{Verbatim}

which isn't quite what we wanted: we need to insert a newline character
at the end of each string before writing.

There are several ways to do this, e.g.:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{files} \PYG{o}{=} \PYG{n}{glob}\PYG{o}{.}\PYG{n}{glob}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{data/*.nc}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{i}\PYG{p}{,}\PYG{n+nb}{file} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{files}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{files}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n+nb}{file} \PYG{o}{+} \PYG{l+s}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZsq{}}
\PYG{k}{print} \PYG{n}{files}
\end{Verbatim}
\begin{alltt}
{[}'data/GlobAlbedo.1998145.h17v03.ncn', `data/GlobAlbedo.200901.mosaic.5.ncn', `data/GlobAlbedo.200902.mosaic.5.ncn', `data/GlobAlbedo.200903.mosaic.5.ncn', `data/GlobAlbedo.200904.mosaic.5.ncn', `data/GlobAlbedo.200905.mosaic.5.ncn', `data/GlobAlbedo.200906.mosaic.5.ncn', `data/GlobAlbedo.200907.mosaic.5.ncn', `data/GlobAlbedo.200908.mosaic.5.ncn', `data/GlobAlbedo.200909.mosaic.5.ncn', `data/GlobAlbedo.200910.mosaic.5.ncn', `data/GlobAlbedo.200911.mosaic.5.ncn', `data/GlobAlbedo.200912.mosaic.5.ncn'{]}
\end{alltt}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{files} \PYG{o}{=} \PYG{n}{glob}\PYG{o}{.}\PYG{n}{glob}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{data/*.nc}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{c}{\PYGZsh{} or:}
\PYG{n}{files} \PYG{o}{=} \PYG{p}{[}\PYG{n+nb}{file} \PYG{o}{+} \PYG{l+s}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZsq{}} \PYG{k}{for} \PYG{n+nb}{file} \PYG{o+ow}{in} \PYG{n}{files}\PYG{p}{]}

\PYG{k}{print} \PYG{n}{files}
\end{Verbatim}
\begin{alltt}
{[}'data/GlobAlbedo.1998145.h17v03.ncn', `data/GlobAlbedo.200901.mosaic.5.ncn', `data/GlobAlbedo.200902.mosaic.5.ncn', `data/GlobAlbedo.200903.mosaic.5.ncn', `data/GlobAlbedo.200904.mosaic.5.ncn', `data/GlobAlbedo.200905.mosaic.5.ncn', `data/GlobAlbedo.200906.mosaic.5.ncn', `data/GlobAlbedo.200907.mosaic.5.ncn', `data/GlobAlbedo.200908.mosaic.5.ncn', `data/GlobAlbedo.200909.mosaic.5.ncn', `data/GlobAlbedo.200910.mosaic.5.ncn', `data/GlobAlbedo.200911.mosaic.5.ncn', `data/GlobAlbedo.200912.mosaic.5.ncn'{]}
\end{alltt}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} or all at once if you like:}

\PYG{n}{files} \PYG{o}{=} \PYG{p}{[}\PYG{n+nb}{file} \PYG{o}{+} \PYG{l+s}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZsq{}} \PYG{k}{for} \PYG{n+nb}{file} \PYG{o+ow}{in} \PYG{n}{glob}\PYG{o}{.}\PYG{n}{glob}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{data/*.nc}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{]}

\PYG{k}{print} \PYG{n}{files}
\end{Verbatim}
\begin{alltt}
{[}'data/GlobAlbedo.1998145.h17v03.ncn', `data/GlobAlbedo.200901.mosaic.5.ncn', `data/GlobAlbedo.200902.mosaic.5.ncn', `data/GlobAlbedo.200903.mosaic.5.ncn', `data/GlobAlbedo.200904.mosaic.5.ncn', `data/GlobAlbedo.200905.mosaic.5.ncn', `data/GlobAlbedo.200906.mosaic.5.ncn', `data/GlobAlbedo.200907.mosaic.5.ncn', `data/GlobAlbedo.200908.mosaic.5.ncn', `data/GlobAlbedo.200909.mosaic.5.ncn', `data/GlobAlbedo.200910.mosaic.5.ncn', `data/GlobAlbedo.200911.mosaic.5.ncn', `data/GlobAlbedo.200912.mosaic.5.ncn'{]}
\end{alltt}

or several other ways ...

Putting this together:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{glob}

\PYG{n}{files} \PYG{o}{=} \PYG{p}{[}\PYG{n+nb}{file} \PYG{o}{+} \PYG{l+s}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZsq{}} \PYG{k}{for} \PYG{n+nb}{file} \PYG{o+ow}{in} \PYG{n}{glob}\PYG{o}{.}\PYG{n}{glob}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{data/*.nc}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{]}

\PYG{n}{filename} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/data.dat}\PYG{l+s}{\PYGZsq{}}

\PYG{c}{\PYGZsh{} open in write mode}
\PYG{n}{fp} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{w}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{fp}\PYG{o}{.}\PYG{n}{writelines}\PYG{p}{(}\PYG{n}{files}\PYG{p}{)}
\PYG{n}{fp}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

then checking:

\begin{Verbatim}[commandchars=\\\{\}]
!cat files/data/data.dat
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
data/GlobAlbedo.1998145.h17v03.nc
data/GlobAlbedo.200901.mosaic.5.nc
data/GlobAlbedo.200902.mosaic.5.nc
data/GlobAlbedo.200903.mosaic.5.nc
data/GlobAlbedo.200904.mosaic.5.nc
data/GlobAlbedo.200905.mosaic.5.nc
data/GlobAlbedo.200906.mosaic.5.nc
data/GlobAlbedo.200907.mosaic.5.nc
data/GlobAlbedo.200908.mosaic.5.nc
data/GlobAlbedo.200909.mosaic.5.nc
data/GlobAlbedo.200910.mosaic.5.nc
data/GlobAlbedo.200911.mosaic.5.nc
data/GlobAlbedo.200912.mosaic.5.nc
\end{Verbatim}

which \emph{is} what we wanted.


\section{E3.2 Exercise: Making Movies}
\label{Chapter3_Scientific_Numerical_Python/answers:e3-2-exercise-making-movies}

\subsection{E3.2.1 Software}
\label{Chapter3_Scientific_Numerical_Python/answers:e3-2-1-software}
You can \emph{sort of} make \href{http://matplotlib.org/faq/howto\_faq.html\#make-a-movie}{movies in
pylab}, but
you generally have to make a system call to unix at some point, so it's
probably easier to do this all in unix with the utility
\code{{}`convert} \textless{}\href{http://www.imagemagick.org/script/convert.php}{http://www.imagemagick.org/script/convert.php}\textgreater{}{}`\_\_.

At the unix prompt, chack that you have access to convert:

\begin{Verbatim}[commandchars=\\\{\}]
berlin\PYGZpc{} which convert
/usr/bin/convert
\end{Verbatim}

If this doesn't come up with anything useful, there is probably a
version in \code{/usr/bin/convert} or \code{/usr/local/bin/convert} (If you
don't have it on your local machine, install
\code{{}`ImageMagick} \textless{}\href{http://www.imagemagick.org/script/index.php}{http://www.imagemagick.org/script/index.php}\textgreater{}{}`\_\_ which
contains the command line tool \code{convert}).

To use this, e.g.:

from the unix command line:

\begin{Verbatim}[commandchars=\\\{\}]
berlin\PYGZpc{} cd \PYGZti{}/Data/geogg122/Chapter3\PYGZus{}Scientific\PYGZus{}Numerical\PYGZus{}Python
berlin\PYGZpc{} convert files/data/albedo.jpg files/data/albedo.gif
\end{Verbatim}

or from within a notebook:

\begin{Verbatim}[commandchars=\\\{\}]
!convert files/data/albedo.jpg files/data/albedo.gif
\end{Verbatim}

Or, more practically here, you can run a unix command directly from
Python:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{os}
\PYG{n}{cmd} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{convert files/data/albedo.jpg files/data/albedo.gif}\PYG{l+s}{\PYGZsq{}}
\PYG{n}{os}\PYG{o}{.}\PYG{n}{system}\PYG{p}{(}\PYG{n}{cmd}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{0}
\end{Verbatim}

This will convert the file \code{files/data/albedo.jpg} (in jpeg format) to
\code{files/data/albedo.gif} (in gif format).
\begin{figure}[htbp]
\centering
\capstart

\includegraphics{Chapter3_Scientific_Numerical_Python/files/data/albedo.gif}
\caption{albedo}\end{figure}

We can also use \code{convert} to make animated gifs, which is one way of
making a movie.


\subsection{E3.2.2 Looping over a set of images}
\label{Chapter3_Scientific_Numerical_Python/answers:e3-2-2-looping-over-a-set-of-images}
You have all of the code you need above to be able to read a GlobAlbedo
file for a given month and waveband in Python and save a picture in jpeg
format, but to recap for \code{BHR\_VIS}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{netCDF4} \PYG{k+kn}{import} \PYG{n}{Dataset}
\PYG{k+kn}{import} \PYG{n+nn}{pylab} \PYG{k+kn}{as} \PYG{n+nn}{plt}
\PYG{k+kn}{import} \PYG{n+nn}{os}

\PYG{n}{root} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/}\PYG{l+s}{\PYGZsq{}}

\PYG{n}{month\PYGZus{}list} \PYG{o}{=} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{January}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{February}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{March}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{April}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{May}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{June}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYGZbs{}
              \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{July}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{August}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{September}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{October}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{November}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{December}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\PYG{c}{\PYGZsh{} make a dictionary from 2 lists}
\PYG{n}{month\PYGZus{}dict} \PYG{o}{=} \PYG{n+nb}{dict}\PYG{p}{(}\PYG{n+nb}{zip}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{13}\PYG{p}{)}\PYG{p}{,}\PYG{n}{month\PYGZus{}list}\PYG{p}{)}\PYG{p}{)}

\PYG{c}{\PYGZsh{} example filename : use formatting string:}
\PYG{c}{\PYGZsh{} \PYGZpc{}d\PYGZpc{}02d}
\PYG{n}{year} \PYG{o}{=} \PYG{l+m+mi}{2009}


\PYG{c}{\PYGZsh{} set the month}
\PYG{n}{month} \PYG{o}{=} \PYG{l+m+mi}{1}

\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{} Read the data \PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{n}{local\PYGZus{}file} \PYG{o}{=} \PYG{n}{root} \PYG{o}{+} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{GlobAlbedo.}\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s+si}{\PYGZpc{}02d}\PYG{l+s}{.mosaic.5.nc}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{year}\PYG{p}{,}\PYG{n}{month}\PYG{p}{)}
\PYG{c}{\PYGZsh{} load the netCDF data from the file f.filename}
\PYG{n}{nc} \PYG{o}{=} \PYG{n}{Dataset}\PYG{p}{(}\PYG{n}{local\PYGZus{}file}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{band} \PYG{o}{=} \PYG{n}{nc}\PYG{o}{.}\PYG{n}{variables}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{DHR\PYGZus{}VIS}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}

\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{} Plot the data and save as picture jpeg format \PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{c}{\PYGZsh{} make a string with the output file name}
\PYG{n}{out\PYGZus{}file} \PYG{o}{=} \PYG{n}{root} \PYG{o}{+} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{GlobAlbedo.}\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s+si}{\PYGZpc{}02d}\PYG{l+s}{.jpg}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{year}\PYG{p}{,}\PYG{n}{month}\PYG{p}{)}
\PYG{c}{\PYGZsh{} plot}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{clf}\PYG{p}{(}\PYG{p}{)}
\PYG{c}{\PYGZsh{} \PYGZpc{}9s forces the string to be 9 characters long}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{VIS BHR albedo for }\PYG{l+s+si}{\PYGZpc{}9s}\PYG{l+s}{ }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{month\PYGZus{}dict}\PYG{p}{[}\PYG{n}{month}\PYG{p}{]}\PYG{p}{,}\PYG{n}{year}\PYG{p}{)}\PYG{p}{)}
\PYG{c}{\PYGZsh{} use nearest neighbour interpolation}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{band}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nearest}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{cmap}\PYG{o}{=}\PYG{n}{plt}\PYG{o}{.}\PYG{n}{get\PYGZus{}cmap}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Spectral}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}\PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mf}{0.0}\PYG{p}{,}\PYG{n}{vmax}\PYG{o}{=}\PYG{l+m+mf}{1.0}\PYG{p}{)}
\PYG{c}{\PYGZsh{} show a colour bar}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{n}{out\PYGZus{}file}\PYG{p}{)}

\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{} Convert the file to gif \PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{c}{\PYGZsh{} set up the unix command which is of the form}
\PYG{c}{\PYGZsh{} convert input output}
\PYG{c}{\PYGZsh{} Here input will be out\PYGZus{}file}
\PYG{c}{\PYGZsh{} and output we can get with out\PYGZus{}file.replace(\PYGZsq{}.jpg\PYGZsq{},\PYGZsq{}.gif\PYGZsq{})}
\PYG{c}{\PYGZsh{} i.e. replacing where it says .jpg with .gif}
\PYG{n}{cmd} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{convert }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{ }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{out\PYGZus{}file}\PYG{p}{,}\PYG{n}{out\PYGZus{}file}\PYG{o}{.}\PYG{n}{replace}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{.jpg}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{.gif}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{os}\PYG{o}{.}\PYG{n}{system}\PYG{p}{(}\PYG{n}{cmd}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{0}
\end{Verbatim}

\includegraphics{answers_32_1.png}

\textbf{Modify the code above to loop over each month, so that it generates a
set of gif format files for the TOTAL SHORTWAVE ALBEDO}

You should confirm that these exist, and that the file modification time
is when you ran it (not when I generated the files for these notes,
which is Oct 10 2013).

\begin{Verbatim}[commandchars=\\\{\}]
ls \PYGZhy{}l files/data/GlobAlbedo*gif
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{}r\PYGZhy{}\PYGZhy{}  1 plewis  staff  340658 11 Oct 20:00 files/data/GlobAlbedo.2009.SW.1.gif
\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{}r\PYGZhy{}\PYGZhy{}  1 plewis  staff  340658 11 Oct 19:59 files/data/GlobAlbedo.2009.SW.gif
\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{}r\PYGZhy{}\PYGZhy{}  1 plewis  staff   55299 11 Oct 20:21 files/data/GlobAlbedo.200901.gif
\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{}r\PYGZhy{}\PYGZhy{}  1 plewis  staff   28139 11 Oct 19:59 files/data/GlobAlbedo.200902.gif
\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{}r\PYGZhy{}\PYGZhy{}  1 plewis  staff   28259 11 Oct 19:59 files/data/GlobAlbedo.200903.gif
\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{}r\PYGZhy{}\PYGZhy{}  1 plewis  staff   28249 11 Oct 19:59 files/data/GlobAlbedo.200904.gif
\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{}r\PYGZhy{}\PYGZhy{}  1 plewis  staff   28468 11 Oct 19:59 files/data/GlobAlbedo.200905.gif
\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{}r\PYGZhy{}\PYGZhy{}  1 plewis  staff   28672 11 Oct 19:59 files/data/GlobAlbedo.200906.gif
\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{}r\PYGZhy{}\PYGZhy{}  1 plewis  staff   28656 11 Oct 19:59 files/data/GlobAlbedo.200907.gif
\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{}r\PYGZhy{}\PYGZhy{}  1 plewis  staff   28275 11 Oct 19:59 files/data/GlobAlbedo.200908.gif
\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{}r\PYGZhy{}\PYGZhy{}  1 plewis  staff   28952 11 Oct 19:59 files/data/GlobAlbedo.200909.gif
\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{}r\PYGZhy{}\PYGZhy{}  1 plewis  staff   28450 11 Oct 19:59 files/data/GlobAlbedo.200910.gif
\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{}r\PYGZhy{}\PYGZhy{}  1 plewis  staff   28570 11 Oct 19:59 files/data/GlobAlbedo.200911.gif
\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{}r\PYGZhy{}\PYGZhy{}  1 plewis  staff   28438 11 Oct 19:59 files/data/GlobAlbedo.200912.gif
\end{Verbatim}


\subsection{A3.2.2 Answer: Looping over a set of images}
\label{Chapter3_Scientific_Numerical_Python/answers:a3-2-2-answer-looping-over-a-set-of-images}
Really all you need to do here is to make \code{month} appear in a loop,
e.g. using:

\code{for month in range(1,13):}

and then make sure that all of the code below is in that loop (i.e.
indented) as below.

One additional thing is to make sure you select the waveband you were
supposed to (shortwave albedo)

\code{band = nc.variables{[}'DHR\_SW'{]}}

and finally, make sure you change the title:

You should \emph{also} however, go through the code above line by line,
making sure you appreciate what is going on at each stage and why we
have done these things (in this oroder).

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{netCDF4} \PYG{k+kn}{import} \PYG{n}{Dataset}
\PYG{k+kn}{import} \PYG{n+nn}{pylab} \PYG{k+kn}{as} \PYG{n+nn}{plt}
\PYG{k+kn}{import} \PYG{n+nn}{os}

\PYG{n}{root} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/}\PYG{l+s}{\PYGZsq{}}

\PYG{n}{month\PYGZus{}list} \PYG{o}{=} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{January}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{February}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{March}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{April}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{May}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{June}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYGZbs{}
              \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{July}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{August}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{September}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{October}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{November}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{December}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\PYG{c}{\PYGZsh{} make a dictionary from 2 lists}
\PYG{n}{month\PYGZus{}dict} \PYG{o}{=} \PYG{n+nb}{dict}\PYG{p}{(}\PYG{n+nb}{zip}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{13}\PYG{p}{)}\PYG{p}{,}\PYG{n}{month\PYGZus{}list}\PYG{p}{)}\PYG{p}{)}

\PYG{c}{\PYGZsh{} example filename : use formatting string:}
\PYG{c}{\PYGZsh{} \PYGZpc{}d\PYGZpc{}02d}
\PYG{n}{year} \PYG{o}{=} \PYG{l+m+mi}{2009}


\PYG{c}{\PYGZsh{} set the month}
\PYG{k}{for} \PYG{n}{month} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{13}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{} Read the data \PYGZsq{}\PYGZsq{}\PYGZsq{}}
    \PYG{n}{local\PYGZus{}file} \PYG{o}{=} \PYG{n}{root} \PYG{o}{+} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{GlobAlbedo.}\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s+si}{\PYGZpc{}02d}\PYG{l+s}{.mosaic.5.nc}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{year}\PYG{p}{,}\PYG{n}{month}\PYG{p}{)}
    \PYG{c}{\PYGZsh{} load the netCDF data from the file f.filename}
    \PYG{n}{nc} \PYG{o}{=} \PYG{n}{Dataset}\PYG{p}{(}\PYG{n}{local\PYGZus{}file}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
    \PYG{c}{\PYGZsh{} select which band we want}
    \PYG{n}{band} \PYG{o}{=} \PYG{n}{nc}\PYG{o}{.}\PYG{n}{variables}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{DHR\PYGZus{}SW}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}

    \PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{} Plot the data and save as picture jpeg format \PYGZsq{}\PYGZsq{}\PYGZsq{}}
    \PYG{c}{\PYGZsh{} make a string with the output file name}
    \PYG{n}{out\PYGZus{}file} \PYG{o}{=} \PYG{n}{root} \PYG{o}{+} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{GlobAlbedo.}\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s+si}{\PYGZpc{}02d}\PYG{l+s}{.jpg}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{year}\PYG{p}{,}\PYG{n}{month}\PYG{p}{)}
    \PYG{c}{\PYGZsh{} plot}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{clf}\PYG{p}{(}\PYG{p}{)}
    \PYG{c}{\PYGZsh{} \PYGZpc{}9s forces the string to be 9 characters long}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{SW BHR albedo for }\PYG{l+s+si}{\PYGZpc{}9s}\PYG{l+s}{ }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{month\PYGZus{}dict}\PYG{p}{[}\PYG{n}{month}\PYG{p}{]}\PYG{p}{,}\PYG{n}{year}\PYG{p}{)}\PYG{p}{)}
    \PYG{c}{\PYGZsh{} use nearest neighbour interpolation}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{band}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nearest}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{cmap}\PYG{o}{=}\PYG{n}{plt}\PYG{o}{.}\PYG{n}{get\PYGZus{}cmap}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Spectral}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}\PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mf}{0.0}\PYG{p}{,}\PYG{n}{vmax}\PYG{o}{=}\PYG{l+m+mf}{1.0}\PYG{p}{)}
    \PYG{c}{\PYGZsh{} show a colour bar}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{n}{out\PYGZus{}file}\PYG{p}{)}

    \PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{} Convert the file to gif \PYGZsq{}\PYGZsq{}\PYGZsq{}}
    \PYG{c}{\PYGZsh{} set up the unix command which is of the form}
    \PYG{c}{\PYGZsh{} convert input output}
    \PYG{c}{\PYGZsh{} Here input will be out\PYGZus{}file}
    \PYG{c}{\PYGZsh{} and output we can get with out\PYGZus{}file.replace(\PYGZsq{}.jpg\PYGZsq{},\PYGZsq{}.gif\PYGZsq{})}
    \PYG{c}{\PYGZsh{} i.e. replacing where it says .jpg with .gif}
    \PYG{n}{cmd} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{convert }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{ }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{out\PYGZus{}file}\PYG{p}{,}\PYG{n}{out\PYGZus{}file}\PYG{o}{.}\PYG{n}{replace}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{.jpg}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{.gif}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{os}\PYG{o}{.}\PYG{n}{system}\PYG{p}{(}\PYG{n}{cmd}\PYG{p}{)}
\end{Verbatim}

\includegraphics{answers_37_0.png}

\includegraphics{answers_37_1.png}

\includegraphics{answers_37_2.png}

\includegraphics{answers_37_3.png}

\includegraphics{answers_37_4.png}

\includegraphics{answers_37_5.png}

\includegraphics{answers_37_6.png}

\includegraphics{answers_37_7.png}

\includegraphics{answers_37_8.png}

\includegraphics{answers_37_9.png}

\includegraphics{answers_37_10.png}

\includegraphics{answers_37_11.png}


\subsection{E3.2.3 Make the movie}
\label{Chapter3_Scientific_Numerical_Python/answers:e3-2-3-make-the-movie}
The unix command to convert these files to an animated gif is:

\begin{Verbatim}[commandchars=\\\{\}]
convert \PYGZhy{}delay 100 \PYGZhy{}loop 0 files/data/GlobAlbedo.2009??.gif files/data/GlobAlbedo.2009.SW.gif
\end{Verbatim}

\textbf{Run this (ideally, from within Python) to create the animated gif
GlobAlbedo.2009.SW.gif}

Again, confirm that \emph{you} created this file (and it is not just a
version you downloaded):

\begin{Verbatim}[commandchars=\\\{\}]
ls \PYGZhy{}l files/data/GlobAlbedo.2009.SW.gif
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{}r\PYGZhy{}\PYGZhy{}  1 plewis  staff  340658 11 Oct 19:59 files/data/GlobAlbedo.2009.SW.gif
\end{Verbatim}


\subsection{A3.2.3 Answer: Make the movie}
\label{Chapter3_Scientific_Numerical_Python/answers:a3-2-3-answer-make-the-movie}
You could just type the command at the unix prompt ... but to do it
using a \code{system} call from within Python, e.g.:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{os}

\PYG{c}{\PYGZsh{} this is quite a neat way of generating the string for the input files}
\PYG{n}{out\PYGZus{}file} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/GlobAlbedo.}\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{.SW.1.gif}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{n}{year}
\PYG{n}{in\PYGZus{}files} \PYG{o}{=} \PYG{n}{out\PYGZus{}file}\PYG{o}{.}\PYG{n}{replace}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{.SW.1.gif}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{??.gif}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{cmd} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{convert \PYGZhy{}delay 100 \PYGZhy{}loop 0 }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{ }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{in\PYGZus{}files}\PYG{p}{,}\PYG{n}{out\PYGZus{}file}\PYG{p}{)}
\PYG{c}{\PYGZsh{} check the cmd is ok}
\PYG{k}{print} \PYG{n}{cmd}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
convert \PYGZhy{}delay 100 \PYGZhy{}loop 0 files/data/GlobAlbedo.2009??.gif files/data/GlobAlbedo.2009.SW.1.gif
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} good ... so now run it}
\PYG{n}{os}\PYG{o}{.}\PYG{n}{system}\PYG{p}{(}\PYG{n}{cmd}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{0}
\end{Verbatim}
\begin{figure}[htbp]
\centering

\includegraphics{Chapter3_Scientific_Numerical_Python/files/data/GlobAlbedo.2009.SW.1.gif}
\end{figure}

To view the animated gif you have generated, open it in a browser.


\section{E3.3 Exercise: 3D Masked Array}
\label{Chapter3_Scientific_Numerical_Python/answers:e3-3-exercise-3d-masked-array}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{netCDF4} \PYG{k+kn}{import} \PYG{n}{Dataset}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}

\PYG{n}{root} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/}\PYG{l+s}{\PYGZsq{}}
\PYG{n}{year} \PYG{o}{=} \PYG{l+m+mi}{2009}

\PYG{c}{\PYGZsh{} which months?}
\PYG{n}{months} \PYG{o}{=} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{13}\PYG{p}{)}

\PYG{c}{\PYGZsh{} empty list}
\PYG{n}{data} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}

\PYG{c}{\PYGZsh{} loop over month}
\PYG{c}{\PYGZsh{} use enumerate so we have an index counter}
\PYG{k}{for} \PYG{n}{i}\PYG{p}{,}\PYG{n}{month} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{months}\PYG{p}{)}\PYG{p}{:}
    \PYG{c}{\PYGZsh{} this then is the file we want}
    \PYG{n}{local\PYGZus{}file} \PYG{o}{=} \PYG{n}{root} \PYG{o}{+} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{GlobAlbedo.}\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s+si}{\PYGZpc{}02d}\PYG{l+s}{.mosaic.5.nc}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{year}\PYG{p}{,}\PYG{n}{month}\PYG{p}{)}

    \PYG{c}{\PYGZsh{} load the netCDF data from the file local\PYGZus{}file}
    \PYG{n}{nc} \PYG{o}{=} \PYG{n}{Dataset}\PYG{p}{(}\PYG{n}{local\PYGZus{}file}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
    \PYG{c}{\PYGZsh{} append what we read to the list called data}
    \PYG{n}{data}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{nc}\PYG{o}{.}\PYG{n}{variables}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{DHR\PYGZus{}SW}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}

\PYG{c}{\PYGZsh{} convert data to a numpy array (its a list of arrays at the moment)}
\PYG{n}{data} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}
\end{Verbatim}

N.B. Do this exercise before proceeding to the next section.

\textbf{Taking the code above as a starting point, generate a masked array of
the GlobAlbedo dataset for the year 2009.}


\section{A3.3 Answer: 3D Masked Array}
\label{Chapter3_Scientific_Numerical_Python/answers:a3-3-answer-3d-masked-array}
To recap, to make a masked array, we use some code such as:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy.ma} \PYG{k+kn}{as} \PYG{n+nn}{ma}

\PYG{n}{band} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{nc}\PYG{o}{.}\PYG{n}{variables}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{DHR\PYGZus{}SW}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{masked\PYGZus{}band} \PYG{o}{=} \PYG{n}{ma}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{band}\PYG{p}{,}\PYG{n}{mask}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{isnan}\PYG{p}{(}\PYG{n}{band}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{masked\PYGZus{}band}\PYG{o}{.}\PYG{n}{mask}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
[[ True  True  True ...,  True  True  True]
 [ True  True  True ...,  True  True  True]
 [ True  True  True ...,  True  True  True]
 ...,
 [False False False ..., False False False]
 [False False False ..., False False False]
 [False False False ..., False False False]]
\end{Verbatim}

So we can do this for each band as we loop over each month:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{netCDF4} \PYG{k+kn}{import} \PYG{n}{Dataset}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{numpy.ma} \PYG{k+kn}{as} \PYG{n+nn}{ma}

\PYG{n}{root} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/}\PYG{l+s}{\PYGZsq{}}
\PYG{n}{year} \PYG{o}{=} \PYG{l+m+mi}{2009}

\PYG{c}{\PYGZsh{} which months?}
\PYG{n}{months} \PYG{o}{=} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{13}\PYG{p}{)}

\PYG{c}{\PYGZsh{} empty list}
\PYG{n}{data} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}

\PYG{c}{\PYGZsh{} loop over month}
\PYG{c}{\PYGZsh{} use enumerate so we have an index counter}
\PYG{k}{for} \PYG{n}{i}\PYG{p}{,}\PYG{n}{month} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{months}\PYG{p}{)}\PYG{p}{:}
    \PYG{c}{\PYGZsh{} this then is the file we want}
    \PYG{n}{local\PYGZus{}file} \PYG{o}{=} \PYG{n}{root} \PYG{o}{+} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{GlobAlbedo.}\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s+si}{\PYGZpc{}02d}\PYG{l+s}{.mosaic.5.nc}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{year}\PYG{p}{,}\PYG{n}{month}\PYG{p}{)}

    \PYG{c}{\PYGZsh{} load the netCDF data from the file local\PYGZus{}file}
    \PYG{n}{nc} \PYG{o}{=} \PYG{n}{Dataset}\PYG{p}{(}\PYG{n}{local\PYGZus{}file}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
    \PYG{c}{\PYGZsh{} load into the variable \PYGZsq{}band\PYGZsq{}}
    \PYG{n}{band} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{nc}\PYG{o}{.}\PYG{n}{variables}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{DHR\PYGZus{}SW}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
    \PYG{c}{\PYGZsh{} convert to a masked array}
    \PYG{n}{masked\PYGZus{}band} \PYG{o}{=} \PYG{n}{ma}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{band}\PYG{p}{,}\PYG{n}{mask}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{isnan}\PYG{p}{(}\PYG{n}{band}\PYG{p}{)}\PYG{p}{)}
    \PYG{c}{\PYGZsh{} append what we read to the list called data}
    \PYG{n}{data}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{masked\PYGZus{}band}\PYG{p}{)}

\PYG{c}{\PYGZsh{} convert data to a numpy array (its a list of arrays at the moment)}
\PYG{n}{data} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}
\end{Verbatim}

That's a good start, but we used:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{data} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}
\end{Verbatim}

at the end, which means that we have a 3D numpy array ... rather than a
masked array:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{data}\PYG{o}{.}\PYG{n}{shape}
\PYG{k}{print} \PYG{n}{data}\PYG{o}{.}\PYG{n}{ndim}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}type \PYGZsq{}numpy.ndarray\PYGZsq{}\PYGZgt{}
(12, 360, 720)
3
\end{Verbatim}

so we need to replace this with a function to make it into a masked
array:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{netCDF4} \PYG{k+kn}{import} \PYG{n}{Dataset}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{numpy.ma} \PYG{k+kn}{as} \PYG{n+nn}{ma}

\PYG{n}{root} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/}\PYG{l+s}{\PYGZsq{}}
\PYG{n}{year} \PYG{o}{=} \PYG{l+m+mi}{2009}

\PYG{c}{\PYGZsh{} which months?}
\PYG{n}{months} \PYG{o}{=} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{13}\PYG{p}{)}

\PYG{c}{\PYGZsh{} empty list}
\PYG{n}{data} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}

\PYG{c}{\PYGZsh{} loop over month}
\PYG{c}{\PYGZsh{} use enumerate so we have an index counter}
\PYG{k}{for} \PYG{n}{i}\PYG{p}{,}\PYG{n}{month} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{months}\PYG{p}{)}\PYG{p}{:}
    \PYG{c}{\PYGZsh{} this then is the file we want}
    \PYG{n}{local\PYGZus{}file} \PYG{o}{=} \PYG{n}{root} \PYG{o}{+} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{GlobAlbedo.}\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s+si}{\PYGZpc{}02d}\PYG{l+s}{.mosaic.5.nc}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{year}\PYG{p}{,}\PYG{n}{month}\PYG{p}{)}

    \PYG{c}{\PYGZsh{} load the netCDF data from the file local\PYGZus{}file}
    \PYG{n}{nc} \PYG{o}{=} \PYG{n}{Dataset}\PYG{p}{(}\PYG{n}{local\PYGZus{}file}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
    \PYG{c}{\PYGZsh{} load into the variable \PYGZsq{}band\PYGZsq{}}
    \PYG{n}{band} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{nc}\PYG{o}{.}\PYG{n}{variables}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{DHR\PYGZus{}SW}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
    \PYG{c}{\PYGZsh{} convert to a masked array}
    \PYG{n}{masked\PYGZus{}band} \PYG{o}{=} \PYG{n}{ma}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{band}\PYG{p}{,}\PYG{n}{mask}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{isnan}\PYG{p}{(}\PYG{n}{band}\PYG{p}{)}\PYG{p}{)}
    \PYG{c}{\PYGZsh{} append what we read to the list called data}
    \PYG{n}{data}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{masked\PYGZus{}band}\PYG{p}{)}

\PYG{c}{\PYGZsh{} convert data to a numpy array (its a list of arrays at the moment)}
\PYG{n}{data} \PYG{o}{=} \PYG{n}{ma}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{data}\PYG{o}{.}\PYG{n}{shape}
\PYG{k}{print} \PYG{n}{data}\PYG{o}{.}\PYG{n}{ndim}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}class \PYGZsq{}numpy.ma.core.MaskedArray\PYGZsq{}\PYGZgt{}
(12, 360, 720)
3
\end{Verbatim}

we might notice that now, the data mask (\code{data.mask}) is a 3D mask:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{n}{data}\PYG{o}{.}\PYG{n}{mask}\PYG{o}{.}\PYG{n}{shape}
\PYG{k}{print} \PYG{n}{data}\PYG{o}{.}\PYG{n}{mask}\PYG{o}{.}\PYG{n}{ndim}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{360}\PYG{p}{,} \PYG{l+m+mi}{720}\PYG{p}{)}
\PYG{l+m+mi}{3}
\end{Verbatim}

and we might just check that the mask is the same for all months:

First, lets sum the masks over axis 0 (i.e. over all months):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nb}{sum} \PYG{o}{=} \PYG{p}{(}\PYG{n}{data}\PYG{o}{.}\PYG{n}{mask}\PYG{p}{)}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{k}{print} \PYG{n+nb}{sum}\PYG{o}{.}\PYG{n}{shape}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{l+m+mi}{360}\PYG{p}{,} \PYG{l+m+mi}{720}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{n+nb}{sum}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
[[12 12 12 ..., 12 12 12]
 [12 12 12 ..., 12 12 12]
 [12 12 12 ..., 12 12 12]
 ...,
 [ 0  0  0 ...,  0  0  0]
 [ 0  0  0 ...,  0  0  0]
 [ 0  0  0 ...,  0  0  0]]
\end{Verbatim}

This should be 12 (where \code{mask} is \code{True}) or 0 (where mask is
\code{False}). How can we chack that quickly?

Fortunately, there is a convenient numpy function \code{np.unique} that
will give you the unique values in an array:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{np}\PYG{o}{.}\PYG{n}{unique}\PYG{p}{(}\PYG{n+nb}{sum}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{array}\PYG{p}{(}\PYG{p}{[} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

The only values in here are 12 and 0, so the masks must be consistent!

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZpc{}pylab inline
\PYGZpc{}config InlineBackend.figure\PYGZus{}format = \PYGZsq{}svg\PYGZsq{}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
Populating the interactive namespace from numpy and matplotlib
\end{Verbatim}


\chapter{Incoming solar radiation}
\label{Chapter3_Scientific_Numerical_Python/solar_radiation:incoming-solar-radiation}\label{Chapter3_Scientific_Numerical_Python/solar_radiation::doc}
Incoming solar radiation, \(A\), ignoring the effect of the
atmosphere, clouds, etc is given by
\begin{gather}
\begin{split}A = E_{0}\sin\theta\end{split}\notag
\end{gather}
where \(E_{0}\) is the solar constant (given as
\(1360Wm^{-2}\)), and \(\theta\) is the \href{http://en.wikipedia.org/wiki/Solar\_elevation\_angle\#Solar\_elevation\_angle}{solar elevation
angle}.
The solar elevation angle is approximately given by
\begin{gather}
\begin{split}\sin \theta = \cos h \cos \delta \cos \varphi + \sin \delta \sin \varphi\end{split}\notag
\end{gather}
where \(h\) is the \href{http://en.wikipedia.org/wiki/Hour\_angle\#Solar\_hour\_angle}{hour
angle},
\(\delta\) is the \href{http://en.wikipedia.org/wiki/Position\_of\_the\_Sun\#Calculations}{solar declination
angle}
and \(\varphi\) is the latitude. The solar declination can be
approximated by
\begin{gather}
\begin{split}\delta = - \arcsin \left [ 0.39779 \cos \left ( 0.98565 \left (N + 10 \right ) + 1.914 \sin \left ( 0.98565 \left ( N - 2 \right ) \right ) \right ) \right ]\end{split}\notag
\end{gather}
where \(N\) is the day of year beginning with N=0 at 00:00:00 UTC on
January 1

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{e0} \PYG{o}{=} \PYG{l+m+mf}{1360.}
\PYG{n}{latitude} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{deg2rad} \PYG{p}{(} \PYG{l+m+mf}{45.} \PYG{p}{)}
\PYG{n}{N} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange} \PYG{p}{(} \PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mi}{366}\PYG{p}{,} \PYG{l+m+mi}{1} \PYG{p}{)}
\PYG{n}{h} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{22.5}
\PYG{n}{t0} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{deg2rad} \PYG{p}{(}\PYG{l+m+mf}{0.98565}\PYG{o}{*}\PYG{p}{(}\PYG{n}{N}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{t1} \PYG{o}{=} \PYG{l+m+mf}{0.39779}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(} \PYG{n}{np}\PYG{o}{.}\PYG{n}{deg2rad} \PYG{p}{(} \PYG{l+m+mf}{0.98565}\PYG{o}{*}\PYG{p}{(}\PYG{n}{N}\PYG{o}{+}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mf}{1.914}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{sin} \PYG{p}{(} \PYG{n}{t0} \PYG{p}{)} \PYG{p}{)} \PYG{p}{)}
\PYG{n}{t2} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{arcsin} \PYG{p}{(} \PYG{n}{t1} \PYG{p}{)}

\PYG{n}{sin\PYGZus{}theta} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{cos} \PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{deg2rad}\PYG{p}{(}\PYG{n}{h}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{cos} \PYG{p}{(}\PYG{n}{t2}\PYG{p}{)}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{n}{latitude}\PYG{p}{)} \PYG{o}{+} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sin} \PYG{p}{(} \PYG{n}{t2}\PYG{p}{)}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{n}{latitude}\PYG{p}{)}
\PYG{n}{incoming\PYGZus{}rad} \PYG{o}{=} \PYG{n}{e0}\PYG{o}{*}\PYG{n}{sin\PYGZus{}theta}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot} \PYG{p}{(} \PYG{n}{N}\PYG{p}{,} \PYG{n}{incoming\PYGZus{}rad} \PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{10:30AM}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{h} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{t0} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{deg2rad} \PYG{p}{(}\PYG{l+m+mf}{0.98565}\PYG{o}{*}\PYG{p}{(}\PYG{n}{N}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{t1} \PYG{o}{=} \PYG{l+m+mf}{0.39779}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(} \PYG{n}{np}\PYG{o}{.}\PYG{n}{deg2rad} \PYG{p}{(} \PYG{l+m+mf}{0.98565}\PYG{o}{*}\PYG{p}{(}\PYG{n}{N}\PYG{o}{+}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mf}{1.914}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{sin} \PYG{p}{(} \PYG{n}{t0} \PYG{p}{)} \PYG{p}{)} \PYG{p}{)}
\PYG{n}{t2} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{arcsin} \PYG{p}{(} \PYG{n}{t1} \PYG{p}{)}

\PYG{n}{sin\PYGZus{}theta} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{cos} \PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{deg2rad}\PYG{p}{(}\PYG{n}{h}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{cos} \PYG{p}{(}\PYG{n}{t2}\PYG{p}{)}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{n}{latitude}\PYG{p}{)} \PYG{o}{+} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sin} \PYG{p}{(} \PYG{n}{t2}\PYG{p}{)}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{n}{latitude}\PYG{p}{)}
\PYG{n}{incoming\PYGZus{}rad} \PYG{o}{=} \PYG{n}{e0}\PYG{o}{*}\PYG{n}{sin\PYGZus{}theta}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot} \PYG{p}{(} \PYG{n}{N}\PYG{p}{,} \PYG{n}{incoming\PYGZus{}rad} \PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{12:00PM}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Day of Year}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Incoming solar radiation \PYGZdl{}[W}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s}{cdot m\PYGZca{}\PYGZob{}\PYGZhy{}2\PYGZcb{}]\PYGZdl{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.text.Text at 0x4543590\PYGZgt{}
\end{Verbatim}

\includegraphics{solar_radiation_3_1.svg}


\chapter{Chapter 4. Geospatial data}
\label{Chapter4_GDAL/GDAL_HDF:chapter-4-geospatial-data}\label{Chapter4_GDAL/GDAL_HDF::doc}
In this session, we will introduced the \code{gdal} geospatial module which
can read a wide range of scientific data formats. You will find that
using it to read data is quite similar to the work we did last week on
netCDF datasets.

The main challenges are also much the same: very often, you need to be
able to read data from a `stack' of image files and generate a useful 3D
(space and time) dataset from these. Once you have the data in such a
form, there are \emph{many} things we can do with it, and very many of these
are convenient to do using array-based expressions such as in numpy
(consider the simplicity of the expression
\code{absorbed = rad * (1 - albedo)} from last week's exercise).

That said, it can sometimes be quite an effort to prepare datasets in
this form. Last week, we developed a `valid data' mask from the
GlobAlbedo dataset, as invalid data were stored as \code{nan}. Very often
though, scientific datasets have more complex `Quality Control' (QC)
information, that gives per-pixel information describing the quality of
the product at that location (e.g. it was very cloudy so the results are
not so good).

To explore this, we will first consider the \href{http://modis.gsfc.nasa.gov/data/dataprod/dataproducts.php?MOD\_NUMBER=15}{MODIS Leaf Area Index
(LAI)}
product taht is mapped at 1 km resolution, every 8 days from the year
2000.

We will learn how to read in these data (in \code{hdf} format) using
\code{gdal}, and how to interpret the QC information in such products to
produce valid data masks. As an exercise, you will wrap some code around
that to form a 3D masked array of the dataset.

Next, we will consider how to download such data. This should be a
reinforcement of material from last week, but it is useful to know how
to conveniently access NASA data products. A challenge in the exercise
then is to download a different dataset (MODIS snow cover) for the UK,
and form a masked 3D dataset from this.

Finally, we will introduce vector datasets and show you python tools
that allow you (among many other things) to build a mask in the
projection and sampling of your spatial dataset (MODIS LAI in this
case).

There are many features and as many complexities to the Python tools we
will deal with today, but in this material, we cover some very typical
tasks you will want to do. They all revolve around generating masked 3D
datasets from NASA MODIS datasets, which is a very useful form of global
biophysical information over the last decade+. We also provide much
material for further reading and use when you are more confident in your
programming.

A final point here is that the material we cover today is very closely
related to what you will need to do in the first section of your
assessed practical that we will introduce next week, so you really need
to get to grips with this now.

There is not as much `new' material as in previous weeks now, but we
assume that you have understood, and can make use of, material from
those lectures.

First, we will examine data from a NASA MODIS product on Leaf Area Index
(LAI).
\begin{itemize}
\item {} 
4.1 {\hyperref[Chapter4_GDAL/GDAL_HDF:4.1-MODIS-LAI-product]{MODIS LAI product}}

\item {} 
4.2 {\hyperref[Chapter4_GDAL/GDAL_HDF:4.2-Downloading-data]{Downloading data}}

\item {} 
4.3 {\hyperref[Chapter4_GDAL/GDAL_HDF:4.3-Vector-masking]{Vector masking}}

\end{itemize}


\section{4.1 MODIS LAI product}
\label{Chapter4_GDAL/GDAL_HDF:modis-lai-product}
GDAL covers a much wider set of file formats and methods than the netCDF
library that we previously used.

Basic operation involves:
\begin{itemize}
\item {} 
load gdal

\item {} 
open a spatial dataset (an hdf format file here)

\item {} 
specify which subsets you want.

\end{itemize}

We can explore the subsets in the file with \code{GetSubDatasets()}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} how to find out which datasets are in the file}

\PYG{k+kn}{import} \PYG{n+nn}{gdal} \PYG{c}{\PYGZsh{} Import GDAL library bindings}

\PYG{c}{\PYGZsh{} The file that we shall be using}
\PYG{c}{\PYGZsh{} Needs to be on current directory}
\PYG{n}{filename} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MCD15A2.A2011185.h09v05.005.2011213154534.hdf}\PYG{l+s}{\PYGZsq{}}

\PYG{n}{g} \PYG{o}{=} \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{Open}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{)}
\PYG{c}{\PYGZsh{} g should now be a GDAL dataset, but if the file isn\PYGZsq{}t found}
\PYG{c}{\PYGZsh{} g will be none. Let\PYGZsq{}s test this:}
\PYG{k}{if} \PYG{n}{g} \PYG{o+ow}{is} \PYG{n+nb+bp}{None}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Problem opening file }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{!}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n}{filename}
\PYG{k}{else}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{File }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{ opened fine}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n}{filename}


\PYG{n}{subdatasets} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{GetSubDatasets}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{fname}\PYG{p}{,} \PYG{n}{name} \PYG{o+ow}{in} \PYG{n}{subdatasets}\PYG{p}{:}
    \PYG{k}{print} \PYG{n}{name}
    \PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{fname}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
File files/data/MCD15A2.A2011185.h09v05.005.2011213154534.hdf opened fine
[1200x1200] Fpar\PYGZus{}1km MOD\PYGZus{}Grid\PYGZus{}MOD15A2 (8\PYGZhy{}bit unsigned integer)
    HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:\PYGZdq{}files/data/MCD15A2.A2011185.h09v05.005.2011213154534.hdf\PYGZdq{}:MOD\PYGZus{}Grid\PYGZus{}MOD15A2:Fpar\PYGZus{}1km
[1200x1200] Lai\PYGZus{}1km MOD\PYGZus{}Grid\PYGZus{}MOD15A2 (8\PYGZhy{}bit unsigned integer)
    HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:\PYGZdq{}files/data/MCD15A2.A2011185.h09v05.005.2011213154534.hdf\PYGZdq{}:MOD\PYGZus{}Grid\PYGZus{}MOD15A2:Lai\PYGZus{}1km
[1200x1200] FparLai\PYGZus{}QC MOD\PYGZus{}Grid\PYGZus{}MOD15A2 (8\PYGZhy{}bit unsigned integer)
    HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:\PYGZdq{}files/data/MCD15A2.A2011185.h09v05.005.2011213154534.hdf\PYGZdq{}:MOD\PYGZus{}Grid\PYGZus{}MOD15A2:FparLai\PYGZus{}QC
[1200x1200] FparExtra\PYGZus{}QC MOD\PYGZus{}Grid\PYGZus{}MOD15A2 (8\PYGZhy{}bit unsigned integer)
    HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:\PYGZdq{}files/data/MCD15A2.A2011185.h09v05.005.2011213154534.hdf\PYGZdq{}:MOD\PYGZus{}Grid\PYGZus{}MOD15A2:FparExtra\PYGZus{}QC
[1200x1200] FparStdDev\PYGZus{}1km MOD\PYGZus{}Grid\PYGZus{}MOD15A2 (8\PYGZhy{}bit unsigned integer)
    HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:\PYGZdq{}files/data/MCD15A2.A2011185.h09v05.005.2011213154534.hdf\PYGZdq{}:MOD\PYGZus{}Grid\PYGZus{}MOD15A2:FparStdDev\PYGZus{}1km
[1200x1200] LaiStdDev\PYGZus{}1km MOD\PYGZus{}Grid\PYGZus{}MOD15A2 (8\PYGZhy{}bit unsigned integer)
    HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:\PYGZdq{}files/data/MCD15A2.A2011185.h09v05.005.2011213154534.hdf\PYGZdq{}:MOD\PYGZus{}Grid\PYGZus{}MOD15A2:LaiStdDev\PYGZus{}1km
\end{Verbatim}

In the previous code snippet we have done a number of different things:
\begin{enumerate}
\item {} 
Import the GDAL library

\item {} 
Open a file with GDAL, storing a handler to the file in \code{g}

\item {} 
Test that \code{g} is not \code{None} (as this indicates failure opening
the file. Try changing \code{filename} above to something else)

\item {} 
We then use the \code{GetSubDatasets()} method to read out information
on the different subdatasets available from this file (compare to the
output of \code{gdalinfo} on the shelf earlier)

\item {} 
Loop over the retrieved subdatasets to print the name (human-readable
information) and the GDAL filename. This last item is the filename
that you need to use to tell GDAL to open a particular data layer of
the 6 layers present in this example

\end{enumerate}

Let's say that we want to access the LAI information. By contrasting the
output of the above code (or \code{gdalinfo}) to the contents of the
\href{https://lpdaac.usgs.gov/products/modis\_products\_table/leaf\_area\_index\_fraction\_of\_photosynthetically\_active\_radiation/8\_day\_l4\_global\_1km/mod15a2}{LAI/fAPAR product information
page},
we find out that we want the layers for \code{Lai\_1km}, \code{FparLai\_Qc},
\code{FparExtra\_QC} and \code{LaiStdDev\_1km}.

To read these individual datasets, we need to open each of them
individually using GDAL, and the GDAL filenames used above:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} How to access specific datasets in gdal}

\PYG{c}{\PYGZsh{} Let\PYGZsq{}s create a list with the selected layer names}
\PYG{n}{selected\PYGZus{}layers} \PYG{o}{=} \PYG{p}{[}  \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{FparLai\PYGZus{}QC}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{LaiStdDev\PYGZus{}1km}\PYG{l+s}{\PYGZdq{}} \PYG{p}{]}

\PYG{c}{\PYGZsh{} We will store the data in a dictionary}
\PYG{c}{\PYGZsh{} Initialise an empty dictionary}
\PYG{n}{data} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}

\PYG{c}{\PYGZsh{} for convenience, we will use string substitution to create a}
\PYG{c}{\PYGZsh{} template for GDAL filenames, which we\PYGZsq{}ll substitute on the fly:}
\PYG{n}{file\PYGZus{}template} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{:MOD\PYGZus{}Grid\PYGZus{}MOD15A2:}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZsq{}}
\PYG{c}{\PYGZsh{} This has two substitutions (the \PYGZpc{}s parts) which will refer to:}
\PYG{c}{\PYGZsh{}\PYGZhy{} the filename}
\PYG{c}{\PYGZsh{} \PYGZhy{} the data layer}

\PYG{k}{for} \PYG{n}{i}\PYG{p}{,} \PYG{n}{layer} \PYG{o+ow}{in} \PYG{n+nb}{enumerate} \PYG{p}{(} \PYG{n}{selected\PYGZus{}layers} \PYG{p}{)}\PYG{p}{:}
    \PYG{n}{this\PYGZus{}file} \PYG{o}{=} \PYG{n}{file\PYGZus{}template} \PYG{o}{\PYGZpc{}} \PYG{p}{(} \PYG{n}{filename}\PYG{p}{,} \PYG{n}{layer} \PYG{p}{)}
    \PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Opening Layer }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{: }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{this\PYGZus{}file} \PYG{p}{)}
    \PYG{n}{g} \PYG{o}{=} \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{Open} \PYG{p}{(} \PYG{n}{this\PYGZus{}file} \PYG{p}{)}

    \PYG{k}{if} \PYG{n}{g} \PYG{o+ow}{is} \PYG{n+nb+bp}{None}\PYG{p}{:}
        \PYG{k}{raise} \PYG{n+ne}{IOError}
    \PYG{n}{data}\PYG{p}{[}\PYG{n}{layer}\PYG{p}{]} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{ReadAsArray}\PYG{p}{(}\PYG{p}{)}
    \PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZgt{}\PYGZgt{}\PYGZgt{} Read }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{!}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n}{layer}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
Opening Layer 1: HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:\PYGZdq{}files/data/MCD15A2.A2011185.h09v05.005.2011213154534.hdf\PYGZdq{}:MOD\PYGZus{}Grid\PYGZus{}MOD15A2:Lai\PYGZus{}1km
    \PYGZgt{}\PYGZgt{}\PYGZgt{} Read Lai\PYGZus{}1km!
Opening Layer 2: HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:\PYGZdq{}files/data/MCD15A2.A2011185.h09v05.005.2011213154534.hdf\PYGZdq{}:MOD\PYGZus{}Grid\PYGZus{}MOD15A2:FparLai\PYGZus{}QC
    \PYGZgt{}\PYGZgt{}\PYGZgt{} Read FparLai\PYGZus{}QC!
Opening Layer 3: HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:\PYGZdq{}files/data/MCD15A2.A2011185.h09v05.005.2011213154534.hdf\PYGZdq{}:MOD\PYGZus{}Grid\PYGZus{}MOD15A2:LaiStdDev\PYGZus{}1km
    \PYGZgt{}\PYGZgt{}\PYGZgt{} Read LaiStdDev\PYGZus{}1km!
\end{Verbatim}

In the previous code, we have seen a way of neatly creating the
filenames required by GDAL to access the independent datasets: a
template string that gets substituted with the \code{filename} and the
\code{layer} name. Note that the presence of double quotes in the template
requires us to use single quotes around it. The data is now stored in a
dictionary, and can be accessed as e.g. \code{data{[}'Lai\_1km'{]}} which is a
numpy array:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{numpy}\PYG{o}{.}\PYG{n}{ndarray}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
[[ 3  3  2 ...,  6  8 21]
 [ 4  3  6 ...,  8 18 14]
 [ 3 12 11 ..., 12  8  8]
 ...,
 [ 2  3  2 ..., 18 11 17]
 [ 2  3  3 ..., 16 19 15]
 [ 3  2  2 ..., 15 16 15]]
\end{Verbatim}

Now we have to translate the LAI values into meaningful quantities.
According to the
\href{https://lpdaac.usgs.gov/products/modis\_products\_table/leaf\_area\_index\_fraction\_of\_photosynthetically\_active\_radiation/8\_day\_l4\_global\_1km/mod15a2}{LAI}
webpage, there is a scale factor of 0.1 involved for LAI and SD LAI:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{lai} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{*} \PYG{l+m+mf}{0.1}
\PYG{n}{lai\PYGZus{}sd} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{LaiStdDev\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{*} \PYG{l+m+mf}{0.1}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{LAI}\PYG{l+s}{\PYGZdq{}}
\PYG{k}{print} \PYG{n}{lai}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{SD}\PYG{l+s}{\PYGZdq{}}
\PYG{k}{print} \PYG{n}{lai\PYGZus{}sd}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
LAI
[[ 0.3  0.3  0.2 ...,  0.6  0.8  2.1]
 [ 0.4  0.3  0.6 ...,  0.8  1.8  1.4]
 [ 0.3  1.2  1.1 ...,  1.2  0.8  0.8]
 ...,
 [ 0.2  0.3  0.2 ...,  1.8  1.1  1.7]
 [ 0.2  0.3  0.3 ...,  1.6  1.9  1.5]
 [ 0.3  0.2  0.2 ...,  1.5  1.6  1.5]]
SD
[[ 0.2  0.2  0.1 ...,  0.2  0.1  0.3]
 [ 0.2  0.2  0.2 ...,  0.2  0.3  0.2]
 [ 0.   0.1  0.2 ...,  0.1  0.2  0.2]
 ...,
 [ 0.1  0.1  0.1 ...,  0.3  0.   0.1]
 [ 0.1  0.1  0.1 ...,  0.2  0.2  0.1]
 [ 0.1  0.1  0.1 ...,  0.1  0.2  0.1]]
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} plot the LAI}

\PYG{k+kn}{import} \PYG{n+nn}{pylab} \PYG{k+kn}{as} \PYG{n+nn}{plt}

\PYG{c}{\PYGZsh{} colormap}
\PYG{n}{cmap} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{cm}\PYG{o}{.}\PYG{n}{Greens}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{lai}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mf}{0.1}\PYG{p}{,}\PYG{n}{vmax}\PYG{o}{=}\PYG{l+m+mf}{4.}\PYG{p}{,}\PYG{n}{cmap}\PYG{o}{=}\PYG{n}{cmap}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MODIS LAI data: DOY 185 2011}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.colorbar.Colorbar instance at 0x2adc680e1830\PYGZgt{}
\end{Verbatim}

\includegraphics{GDAL_HDF_13_1.png}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} plot the LAI std}

\PYG{k+kn}{import} \PYG{n+nn}{pylab} \PYG{k+kn}{as} \PYG{n+nn}{plt}

\PYG{c}{\PYGZsh{} colormap}
\PYG{n}{cmap} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{cm}\PYG{o}{.}\PYG{n}{spectral}
\PYG{c}{\PYGZsh{} this sets the no data colour. \PYGZsq{}k\PYGZsq{} is black}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{lai\PYGZus{}sd}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{vmax}\PYG{o}{=}\PYG{l+m+mf}{1.}\PYG{p}{,}\PYG{n}{cmap}\PYG{o}{=}\PYG{n}{cmap}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MODIS LAI STD data: DOY 185 2011}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.colorbar.Colorbar instance at 0x2adc6954c098\PYGZgt{}
\end{Verbatim}

\includegraphics{GDAL_HDF_14_1.png}

It is not possible to produce LAI estimates if it is persistently
cloudy, so the dataset may contain some gaps.

These are identified in the dataset using the QC (Quality Control)
information.

We should then examine this.

The codes for this are also given on the LAI product page. They are
described as bit combinations:

Bit No.

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}th\PYGZgt{}Parameter Name\PYGZlt{}/th\PYGZgt{}\PYGZlt{}th\PYGZgt{} Bit Combination\PYGZlt{}/th\PYGZgt{}\PYGZlt{}th\PYGZgt{}Explanation\PYGZlt{}/th\PYGZgt{}
\end{Verbatim}

0

MODLAND\_QC bits

0

Good quality (main algorithm with or without saturation)

1

Other Quality (back-up algorithm or fill values)

1

Sensor

\begin{Verbatim}[commandchars=\\\{\}]
0\PYGZlt{}/td\PYGZgt{}\PYGZlt{}td\PYGZgt{}  TERRA\PYGZlt{}/td\PYGZgt{}
\end{Verbatim}

1

AQUA

2

DeadDetector

0

Detectors apparently fine for up to 50\% of channels 1 2

1

Dead detectors caused \textgreater{}50\% adjacent detector retrieval

3-4

CloudState

00

Significant clouds NOT present (clear)

01

Significant clouds WERE present

10

Mixed clouds present on pixel

11

Cloud state not defined assumed clear

5-7

CF\_QC

000

\begin{Verbatim}[commandchars=\\\{\}]
Main (RT) method used   best result possible (no saturation)     \PYGZlt{}/td\PYGZgt{}
\end{Verbatim}

001

Main (RT) method used with saturation. Good very usable

010

Main (RT) method failed due to bad geometry empirical algorithm used

011

Main (RT) method failed due to problems other than geometry empirical
algorithm used

100

Pixel not produced at all value coudnt be retrieved (possible reasons:
bad L1B data unusable MODAGAGG data)

In using this information, it is up to the use which data he/she wants
to pass through for any further processing. There are clearly
trade-offs: if you look for only the highest quality data, then the
number of samples is likely to be lower than if you were more tolerant.
But if you are too tolerant, you will get spurious results. You may find
useful information on how to convert from actual QA flags to diagnostics
in \href{http://gis.cri.fmach.it/modis-ndvi-evi/}{this page} (they focus
on NDVI/EVI, but the theory is the same).

But let's just say that we want to use only the highest quality data.

This means we want bit 0 to be 0 ...

Let's have a look at the QC data:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{qc} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{FparLai\PYGZus{}QC}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]} \PYG{c}{\PYGZsh{} Get the QC data which is an unsigned 8 bit byte}
\PYG{k}{print} \PYG{n}{qc} \PYG{p}{,} \PYG{n}{qc}\PYG{o}{.}\PYG{n}{dtype}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
[[2 2 0 ..., 0 2 2]
[2 2 0 ..., 2 0 2]
[0 2 0 ..., 0 0 0]
...,
[0 0 2 ..., 0 8 0]
[0 0 0 ..., 0 0 2]
[0 2 0 ..., 2 2 2]] uint8
\end{Verbatim}

We see various byte values:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{np}\PYG{o}{.}\PYG{n}{unique}\PYG{p}{(}\PYG{n}{qc}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}  \PYG{l+m+mi}{0}\PYG{p}{,}   \PYG{l+m+mi}{2}\PYG{p}{,}   \PYG{l+m+mi}{8}\PYG{p}{,}  \PYG{l+m+mi}{10}\PYG{p}{,}  \PYG{l+m+mi}{16}\PYG{p}{,}  \PYG{l+m+mi}{18}\PYG{p}{,}  \PYG{l+m+mi}{32}\PYG{p}{,}  \PYG{l+m+mi}{34}\PYG{p}{,}  \PYG{l+m+mi}{40}\PYG{p}{,}  \PYG{l+m+mi}{42}\PYG{p}{,}  \PYG{l+m+mi}{48}\PYG{p}{,}  \PYG{l+m+mi}{50}\PYG{p}{,}  \PYG{l+m+mi}{97}\PYG{p}{,}
        \PYG{l+m+mi}{99}\PYG{p}{,} \PYG{l+m+mi}{105}\PYG{p}{,} \PYG{l+m+mi}{107}\PYG{p}{,} \PYG{l+m+mi}{113}\PYG{p}{,} \PYG{l+m+mi}{115}\PYG{p}{,} \PYG{l+m+mi}{157}\PYG{p}{]}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n}{uint8}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} translated into binary using bin()}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{np}\PYG{o}{.}\PYG{n}{unique}\PYG{p}{(}\PYG{n}{qc}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{print} \PYG{n}{i}\PYG{p}{,}\PYG{n+nb}{bin}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
0 0b0
2 0b10
8 0b1000
10 0b1010
16 0b10000
18 0b10010
32 0b100000
34 0b100010
40 0b101000
42 0b101010
48 0b110000
50 0b110010
97 0b1100001
99 0b1100011
105 0b1101001
107 0b1101011
113 0b1110001
115 0b1110011
157 0b10011101
\end{Verbatim}

We could try to come up with an interpretation of each of these ... or
we could try to mask the qc bytes to see bit 0 only if that's what we
are interested in. This is quite possibly a new concept for most of you,
but it is very common that when interpreting QC data in data products,
you need to think about bit masking. You will find more details on this
in the advanced section of Chapter 1, but we will consider the minimum
we need right now.

Byte data are formed of 8 bits, e.g.:

\code{105 ==  (1 * 2**6) +          (1 * 2**5) +          (0 * 2**4) +          (1 * 2**3) +          (0 * 2**2) +          (0 * 2**1) +          (1 * 2**0)}

So, in binary, we represent the decimal number \code{105} by \code{1101001} as
we saw above.

The QC values are to be interpreted in this manner.

If we want \emph{only} bit 1, we can perform a \emph{bitwise} operation with the
byte data.

In this case, it would be an `and' operation (\code{\&}) with the value
\code{1}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} suppose we consider the value 105}
\PYG{c}{\PYGZsh{} which from above, we know to have}
\PYG{c}{\PYGZsh{} bit 0 set as 1}
\PYG{n}{test} \PYG{o}{=} \PYG{l+m+mi}{105}
\PYG{n}{bit\PYGZus{}zero} \PYG{o}{=} \PYG{n}{test} \PYG{o}{\PYGZam{}} \PYG{l+m+mi}{1}
\PYG{k}{print} \PYG{n}{bit\PYGZus{}zero}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{1}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} suppose we consider the value 104}
\PYG{c}{\PYGZsh{} which we could work out has bit 1 as 0}
\PYG{n}{test} \PYG{o}{=} \PYG{l+m+mi}{104}
\PYG{n}{bit\PYGZus{}zero} \PYG{o}{=} \PYG{n}{test} \PYG{o}{\PYGZam{}} \PYG{l+m+mi}{1}
\PYG{k}{print} \PYG{n}{bit\PYGZus{}zero}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{0}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} other bit fields are a \PYGZsq{}little\PYGZsq{} more complicated}
\PYG{n}{tests} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{unique}\PYG{p}{(}\PYG{n}{qc}\PYG{p}{)}


\PYG{k}{for} \PYG{n}{t} \PYG{o+ow}{in} \PYG{n}{tests}\PYG{p}{:}
    \PYG{c}{\PYGZsh{} if we want bit field 5\PYGZhy{}7}
    \PYG{c}{\PYGZsh{} we form a binary mask}
    \PYG{n}{mask57} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{n}{b11100000}
    \PYG{c}{\PYGZsh{} but 0}
    \PYG{n}{mask0} \PYG{o}{=}  \PYG{l+m+mi}{0}\PYG{n}{b00000001}
    \PYG{c}{\PYGZsh{} and use \PYGZam{} as before and right shift 5 (\PYGZgt{}\PYGZgt{} 5)}
    \PYG{n}{qa57} \PYG{o}{=} \PYG{p}{(}\PYG{n}{t} \PYG{o}{\PYGZam{}} \PYG{n}{mask57}\PYG{p}{)} \PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{l+m+mi}{5}
    \PYG{n}{qa0}  \PYG{o}{=} \PYG{p}{(}\PYG{n}{t} \PYG{o}{\PYGZam{}} \PYG{n}{mask0}\PYG{p}{)} \PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{l+m+mi}{0}
    \PYG{k}{print} \PYG{n}{t}\PYG{p}{,}\PYG{n}{qa57}\PYG{p}{,}\PYG{n}{qa0}\PYG{p}{,}\PYG{n+nb}{bin}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
0 0 0 0b0
2 0 0 0b10
8 0 0 0b1000
10 0 0 0b1010
16 0 0 0b10000
18 0 0 0b10010
32 1 0 0b100000
34 1 0 0b100010
40 1 0 0b101000
42 1 0 0b101010
48 1 0 0b110000
50 1 0 0b110010
97 3 1 0b1100001
99 3 1 0b1100011
105 3 1 0b1101001
107 3 1 0b1101011
113 3 1 0b1110001
115 3 1 0b1110011
157 4 1 0b10011101
\end{Verbatim}

So, for example (examining the table above) \code{105} is interpreted at
\code{0b011} in fields 5 to 7 (which is 3 in decimal). This indicates that
`Main (RT) method failed due to problems other than geometry empirical
algorithm used'. Here, bit zero is set to \code{1}, so this is a `bad'
pixel.

In this case, we are only interested in bit 0, which is an easier task
than inmterpreting all of the bits.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} the good data are where qc bit 1 is 0}

\PYG{n}{qc} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{FparLai\PYGZus{}QC}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]} \PYG{c}{\PYGZsh{} Get the QC data}
\PYG{c}{\PYGZsh{} find bit 0}
\PYG{n}{qc} \PYG{o}{=} \PYG{n}{qc} \PYG{o}{\PYGZam{}} \PYG{l+m+mi}{1}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{qc}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{QC bit 1}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.colorbar.Colorbar instance at 0xc6b71b8\PYGZgt{}
\end{Verbatim}

\includegraphics{GDAL_HDF_26_1.png}

We can use this mask to generate a masked array. Masked arrays, as we
have seen before, are like normal arrays, but they have an associated
mask.

Remember that the mask in a masked array should be \code{False} for good
data, so we can directly use \code{qc} as defined above.

We shall also choose another colormap (there are \href{http://wiki.scipy.org/Cookbook/Matplotlib/Show\_colormaps}{lots to choose
from}), and
set values outside the 0.1 and 4 to be shown as black pixels.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} colormap}
\PYG{n}{cmap} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{cm}\PYG{o}{.}\PYG{n}{Greens}
\PYG{n}{cmap}\PYG{o}{.}\PYG{n}{set\PYGZus{}bad} \PYG{p}{(} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{k}\PYG{l+s}{\PYGZsq{}} \PYG{p}{)}
\PYG{c}{\PYGZsh{} this sets the no data colour. \PYGZsq{}k\PYGZsq{} is black}

\PYG{c}{\PYGZsh{} generate the masked array}
\PYG{n}{laim} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ma}\PYG{o}{.}\PYG{n}{array} \PYG{p}{(} \PYG{n}{lai}\PYG{p}{,} \PYG{n}{mask}\PYG{o}{=}\PYG{n}{qc} \PYG{p}{)}

\PYG{c}{\PYGZsh{} and plot it}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow} \PYG{p}{(} \PYG{n}{laim}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{n}{cmap}\PYG{p}{,} \PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{n}{vmax}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.colorbar.Colorbar instance at 0x2adc6b8dd5a8\PYGZgt{}
\end{Verbatim}

\includegraphics{GDAL_HDF_28_1.png}

Similarly, we can do a similar thing for Standard Deviation

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{cmap} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{cm}\PYG{o}{.}\PYG{n}{spectral}
\PYG{n}{cmap}\PYG{o}{.}\PYG{n}{set\PYGZus{}bad} \PYG{p}{(} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{k}\PYG{l+s}{\PYGZsq{}} \PYG{p}{)}
\PYG{n}{stdm} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ma}\PYG{o}{.}\PYG{n}{array} \PYG{p}{(} \PYG{n}{lai\PYGZus{}sd}\PYG{p}{,} \PYG{n}{mask}\PYG{o}{=}\PYG{n}{qc} \PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow} \PYG{p}{(} \PYG{n}{stdm}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{n}{cmap}\PYG{p}{,} \PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mf}{0.001}\PYG{p}{,} \PYG{n}{vmax}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.colorbar.Colorbar instance at 0x2adc70725878\PYGZgt{}
\end{Verbatim}

\includegraphics{GDAL_HDF_30_1.png}

For convenience, we might wrap all of this up into a function:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{gdal}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{numpy.ma} \PYG{k+kn}{as} \PYG{n+nn}{ma}


\PYG{k}{def} \PYG{n+nf}{getLAI}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{,} \PYGZbs{}
           \PYG{n}{qc\PYGZus{}layer} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{FparLai\PYGZus{}QC}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYGZbs{}
           \PYG{n}{scale} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{l+m+mf}{0.1}\PYG{p}{]}\PYG{p}{,}\PYGZbs{}
           \PYG{n}{selected\PYGZus{}layers} \PYG{o}{=} \PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{LaiStdDev\PYGZus{}1km}\PYG{l+s}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{:}

    \PYG{c}{\PYGZsh{} get the QC layer too}
    \PYG{n}{selected\PYGZus{}layers}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{qc\PYGZus{}layer}\PYG{p}{)}
    \PYG{n}{scale}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{c}{\PYGZsh{} We will store the data in a dictionary}
    \PYG{c}{\PYGZsh{} Initialise an empty dictionary}
    \PYG{n}{data} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
    \PYG{c}{\PYGZsh{} for convenience, we will use string substitution to create a}
    \PYG{c}{\PYGZsh{} template for GDAL filenames, which we\PYGZsq{}ll substitute on the fly:}
    \PYG{n}{file\PYGZus{}template} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{:MOD\PYGZus{}Grid\PYGZus{}MOD15A2:}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZsq{}}
    \PYG{c}{\PYGZsh{} This has two substitutions (the \PYGZpc{}s parts) which will refer to:}
    \PYG{c}{\PYGZsh{} \PYGZhy{} the filename}
    \PYG{c}{\PYGZsh{} \PYGZhy{} the data layer}
    \PYG{k}{for} \PYG{n}{i}\PYG{p}{,}\PYG{n}{layer} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{selected\PYGZus{}layers}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{this\PYGZus{}file} \PYG{o}{=} \PYG{n}{file\PYGZus{}template} \PYG{o}{\PYGZpc{}} \PYG{p}{(} \PYG{n}{filename}\PYG{p}{,} \PYG{n}{layer} \PYG{p}{)}
        \PYG{n}{g} \PYG{o}{=} \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{Open} \PYG{p}{(} \PYG{n}{this\PYGZus{}file} \PYG{p}{)}

        \PYG{k}{if} \PYG{n}{g} \PYG{o+ow}{is} \PYG{n+nb+bp}{None}\PYG{p}{:}
            \PYG{k}{raise} \PYG{n+ne}{IOError}

        \PYG{n}{data}\PYG{p}{[}\PYG{n}{layer}\PYG{p}{]} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{ReadAsArray}\PYG{p}{(}\PYG{p}{)} \PYG{o}{*} \PYG{n}{scale}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}

    \PYG{n}{qc} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{n}{qc\PYGZus{}layer}\PYG{p}{]} \PYG{c}{\PYGZsh{} Get the QC data}
    \PYG{c}{\PYGZsh{} find bit 0}
    \PYG{n}{qc} \PYG{o}{=} \PYG{n}{qc} \PYG{o}{\PYGZam{}} \PYG{l+m+mi}{1}

    \PYG{n}{odata} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
    \PYG{k}{for} \PYG{n}{layer} \PYG{o+ow}{in} \PYG{n}{selected\PYGZus{}layers}\PYG{p}{[}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{:}
        \PYG{n}{odata}\PYG{p}{[}\PYG{n}{layer}\PYG{p}{]} \PYG{o}{=} \PYG{n}{ma}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{n}{layer}\PYG{p}{]}\PYG{p}{,}\PYG{n}{mask}\PYG{o}{=}\PYG{n}{qc}\PYG{p}{)}

    \PYG{k}{return} \PYG{n}{odata}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{filename} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MCD15A2.A2011185.h09v05.005.2011213154534.hdf}\PYG{l+s}{\PYGZsq{}}

\PYG{n}{lai\PYGZus{}data} \PYG{o}{=} \PYG{n}{getLAI}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{)}

\PYG{c}{\PYGZsh{} colormap}
\PYG{n}{cmap} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{cm}\PYG{o}{.}\PYG{n}{Greens}
\PYG{n}{cmap}\PYG{o}{.}\PYG{n}{set\PYGZus{}bad} \PYG{p}{(} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{k}\PYG{l+s}{\PYGZsq{}} \PYG{p}{)}
\PYG{c}{\PYGZsh{} this sets the no data colour. \PYGZsq{}k\PYGZsq{} is black}

\PYG{c}{\PYGZsh{} and plot it}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow} \PYG{p}{(} \PYG{n}{lai\PYGZus{}data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{n}{cmap}\PYG{p}{,} \PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nearest}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{n}{vmax}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.colorbar.Colorbar instance at 0x2adc709ffe18\PYGZgt{}
\end{Verbatim}

\includegraphics{GDAL_HDF_33_1.png}


\section{Exercise 4.1}
\label{Chapter4_GDAL/GDAL_HDF:exercise-4-1}
You are given the MODIS LAI data files for the year 2012 in the
directory \code{files/data} for the UK (MODIS tile h17v03).

Read these LAI datasets into a masked array, using QA bit 0 to mask the
data (i.e. good quality data only) and generate a movie of LAI.

You should end up with something like:
\begin{figure}[htbp]
\centering

\includegraphics{Chapter4_GDAL/files/images/lai_uk02.gif}
\end{figure}


\section{4.2 Downloading data}
\label{Chapter4_GDAL/GDAL_HDF:downloading-data}
For the exercise and notes above, you were supplied with several
datasets that had been previously downloaded.


\subsection{4.2.1 Reverb}
\label{Chapter4_GDAL/GDAL_HDF:reverb}
These NASA data can be accessed in several ways (except on Wednesdays
when they go down for maintainance (or when there is a Government
shutdown ...)). The most direct way is to use
\href{http://reverb.echo.nasa.gov/reverb/\#utf8=\%E2\%9C\%93\&spatial\_map=satellite\&spatial\_type=rectangle}{Reverb}
to explore and access data. If you do this, you can, for example \href{http://reverb.echo.nasa.gov/reverb/\#utf8=\%E2\%9C\%93\&spatial\_map=satellite\&spatial\_type=rectangle\&spatial=47.517\%2C\%202.813\%2C\%2056.907\%2C\%20-10.547\&keywords=modis\%20snow\%20cover\%20mod10\&temporal\_start=2013-02-21\%2000\%3A00\%3A00\&temporal\_end=2013-03-21\%2023\%3A59\%3A59}{search
for MODIS snow cover MOD10 datasets covering the
UK}
for some given time period. If you follow this through, e.g. selecting
\href{http://reverb.echo.nasa.gov/reverb/granules?utf8=\%E2\%9C\%93\&new\_view=true\&spatial\_map=satellite\&spatial\_type=rectangle\&spatial=47.517\%2C+2.813\%2C+56.907\%2C+-10.547\&keywords=modis+snow+cover+mod10\&temporal\_start=2013-02-21+00\%3A00\%3A00\&temporal\_end=2013-03-21+23\%3A59\%3A59\&datasets=C92711294-NSIDC\_ECS}{MODIS/Terra Snow Cover Daily L3 Global 500m SIN Grid
V005}
and then search for `granules', you should get access to the datasets
you want (select e.g. one of the files for gid \code{h17v03} and save to
cart). You then view the items in your cart, click `download' and then
`save'.

This should give you a text file with some urls in it, e.g.:

\code{ftp://n4ftl01u.ecs.nasa.gov/DP0/MOST/MOD10A1.005/2013.02.21/MOD10A1.A2013052.h17v03.005.2013054054219.hdf ftp://n4ftl01u.ecs.nasa.gov/DP0/MOST/MOD10A1.005/2013.02.21/MOD10A1.A2013052.h17v03.005.2013054054219.hdf.xml ftp://n4ftl01u.ecs.nasa.gov/DP0/BRWS/Browse.001/2013.02.23/BROWSE.MOD10A1.A2013052.h17v03.005.2013054054219.1.jpg http://browse.echo.nasa.gov/NSIDC\_ECS/2013/02/23/:BR:Browse.001:46841269:1.BINARY}

Here, we can note that one of them is a jpeg file:
\begin{figure}[htbp]
\centering
\end{figure}

which is the quicklook (BROWSE file) for that tile / date.

The hdf dataset is, in this case
\code{ftp://n4ftl01u.ecs.nasa.gov/DP0/MOST/MOD10A1.005/2013.02.21/MOD10A1.A2013052.h17v03.005.2013054054219.hdf}.

From this, we see that the data server is \code{n4ftl01u.ecs.nasa.gov} and
that the MODIS snow products for the MODIS Terra instrument are in the
directory:

\code{ftp://n4ftl01u.ecs.nasa.gov/DP0/MOST}.

If we explored that, we would find the datasets from the MODIS Aqua
platform were in:

\code{ftp://n4ftl01u.ecs.nasa.gov/DP0/MOSA}.

The directories below that give the date and filename.


\subsection{4.2.2 FTP access}
\label{Chapter4_GDAL/GDAL_HDF:ftp-access}
Now we have discovered something about the directory structure on the
server, we could explore this to get the datasets we want (rather than
having to go through Reverb).

Some of the datasets on Reverb are acessible only through \code{http}, but
the snow products (at present) are availble by \code{ftp}.

In either case, if we want to run some `batch' process to download many
files (e.g. all files for a year for some tile), the first thing we need
is the set of urls for the files we want.

We won't go into detail here about how to get this, but it is covered in
the advanced section (at the very least, you could always get the set of
urls from Reverb).

So, let's suppose now that we have a file containing some urls that we
want to pull:

\begin{Verbatim}[commandchars=\\\{\}]
!head \PYGZhy{}10 \PYGZlt{} files/data/robot\PYGZus{}snow.2012.txt
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
ftp://n4ftl01u.ecs.nasa.gov/MOSA/MYD10A1.005/2012.01.01/MYD10A1.A2012001.h00v08.005.2012006235251.hdf
ftp://n4ftl01u.ecs.nasa.gov/MOSA/MYD10A1.005/2012.01.01/MYD10A1.A2012001.h00v09.005.2012006235244.hdf
ftp://n4ftl01u.ecs.nasa.gov/MOSA/MYD10A1.005/2012.01.01/MYD10A1.A2012001.h00v10.005.2012006234603.hdf
ftp://n4ftl01u.ecs.nasa.gov/MOSA/MYD10A1.005/2012.01.01/MYD10A1.A2012001.h01v08.005.2012006234607.hdf
ftp://n4ftl01u.ecs.nasa.gov/MOSA/MYD10A1.005/2012.01.01/MYD10A1.A2012001.h01v09.005.2012006234607.hdf
ftp://n4ftl01u.ecs.nasa.gov/MOSA/MYD10A1.005/2012.01.01/MYD10A1.A2012001.h01v10.005.2012006235245.hdf
ftp://n4ftl01u.ecs.nasa.gov/MOSA/MYD10A1.005/2012.01.01/MYD10A1.A2012001.h01v11.005.2012006234656.hdf
ftp://n4ftl01u.ecs.nasa.gov/MOSA/MYD10A1.005/2012.01.01/MYD10A1.A2012001.h02v06.005.2012006235323.hdf
ftp://n4ftl01u.ecs.nasa.gov/MOSA/MYD10A1.005/2012.01.01/MYD10A1.A2012001.h02v08.005.2012006234419.hdf
ftp://n4ftl01u.ecs.nasa.gov/MOSA/MYD10A1.005/2012.01.01/MYD10A1.A2012001.h02v09.005.2012006234416.hdf
\end{Verbatim}

This is a file containing the filenames of \emph{all} \code{MOD10A1} (daily snow
cover) files for a given year, pulled from the ftp server. It is
possible to do this in Python (see advanced section), but actually must
easier and faster with an ftp script
{}`files/python/zat-snow. You don't need to
run this, as it has already been run for you and the results put in the
files:

\begin{Verbatim}[commandchars=\\\{\}]
ls \PYGZhy{}l files/data/robot\PYGZus{}snow*txt
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
[0m\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis  9034752 Oct 22 09:25 [0mfiles/data/robot\PYGZus{}snow.2000.txt[0m
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis 10820568 Oct 22 09:25 [0mfiles/data/robot\PYGZus{}snow.2001.txt[0m
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis 16321938 Oct 22 09:25 [0mfiles/data/robot\PYGZus{}snow.2002.txt[0m
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis 22423068 Oct 22 09:25 [0mfiles/data/robot\PYGZus{}snow.2003.txt[0m
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis  7633374 Oct 22 09:25 [0mfiles/data/robot\PYGZus{}snow.2004.txt[0m
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis 18872448 Oct 22 09:25 [0mfiles/data/robot\PYGZus{}snow.2005.txt[0m
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis 11433078 Oct 22 09:25 [0mfiles/data/robot\PYGZus{}snow.2006.txt[0m
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis 22663686 Oct 22 09:25 [0mfiles/data/robot\PYGZus{}snow.2007.txt[0m
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis 22668990 Oct 22 09:25 [0mfiles/data/robot\PYGZus{}snow.2008.txt[0m
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis 22705317 Oct 22 09:25 [0mfiles/data/robot\PYGZus{}snow.2009.txt[0m
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis 22712370 Oct 22 09:25 [0mfiles/data/robot\PYGZus{}snow.2010.txt[0m
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis 17129166 Oct 22 09:25 [0mfiles/data/robot\PYGZus{}snow.2011.txt[0m
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis 22756824 Oct 22 09:25 [0mfiles/data/robot\PYGZus{}snow.2012.txt[0m
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis 18104898 Oct 22 09:25 [0mfiles/data/robot\PYGZus{}snow.2013.txt[0m
[m
\end{Verbatim}

We can do similar things for http, but that is a little more complicated
(again, see advanced notes or
\code{{}`files/zat \textgreater{} files/data/robot.txt} \textless{}files/zat\textgreater{}{}`\_\_ for the MODIS LAI
product.

\begin{Verbatim}[commandchars=\\\{\}]
!head \PYGZhy{}10 \PYGZlt{} files/data/robot.txt
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2002.07.04/MCD15A2.A2002185.h00v08.005.2007172150237.hdf
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2002.07.04/MCD15A2.A2002185.h00v09.005.2007172150920.hdf
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2002.07.04/MCD15A2.A2002185.h00v10.005.2007172151610.hdf
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2002.07.04/MCD15A2.A2002185.h01v07.005.2007172152152.hdf
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2002.07.04/MCD15A2.A2002185.h01v08.005.2007172150246.hdf
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2002.07.04/MCD15A2.A2002185.h01v09.005.2007172150923.hdf
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2002.07.04/MCD15A2.A2002185.h01v10.005.2007177210359.hdf
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2002.07.04/MCD15A2.A2002185.h01v11.005.2007172151611.hdf
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2002.07.04/MCD15A2.A2002185.h02v06.005.2007172144545.hdf
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2002.07.04/MCD15A2.A2002185.h02v08.005.2007172150221.hdf
\end{Verbatim}

The file \code{files/data/robot\_snow.2012.txt} contains the names for all
tiles and all files.

So if we want just e.g. tile \code{h17v03} and sensor (\code{MOST}), we can
most easily filter this in unix:

\begin{Verbatim}[commandchars=\\\{\}]
tile=h17v03
year=2012
type=MOST

file=files/data/robot\PYGZus{}snow.\PYGZdl{}\PYGZob{}year\PYGZcb{}\PYGZus{}\PYGZdl{}\PYGZob{}type\PYGZcb{}\PYGZus{}\PYGZdl{}\PYGZob{}tile\PYGZcb{}.txt

grep \PYGZdl{}tile \PYGZlt{} files/data/robot\PYGZus{}snow.\PYGZdl{}year.txt \textbar{} grep \PYGZdl{}type \PYGZgt{} \PYGZdl{}file

\PYGZsh{} how many files?
wc \PYGZhy{}l \PYGZlt{} \PYGZdl{}file

\PYGZsh{} look at the first 10 ...
head \PYGZhy{}10 \PYGZlt{} \PYGZdl{}file
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
366
ftp://n4ftl01u.ecs.nasa.gov/MOST/MOD10A1.005/2012.01.01/MOD10A1.A2012001.h17v03.005.2012003054416.hdf
ftp://n4ftl01u.ecs.nasa.gov/MOST/MOD10A1.005/2012.01.02/MOD10A1.A2012002.h17v03.005.2012004061011.hdf
ftp://n4ftl01u.ecs.nasa.gov/MOST/MOD10A1.005/2012.01.03/MOD10A1.A2012003.h17v03.005.2012005061244.hdf
ftp://n4ftl01u.ecs.nasa.gov/MOST/MOD10A1.005/2012.01.04/MOD10A1.A2012004.h17v03.005.2012006054639.hdf
ftp://n4ftl01u.ecs.nasa.gov/MOST/MOD10A1.005/2012.01.05/MOD10A1.A2012005.h17v03.005.2012007052708.hdf
ftp://n4ftl01u.ecs.nasa.gov/MOST/MOD10A1.005/2012.01.06/MOD10A1.A2012006.h17v03.005.2012008070328.hdf
ftp://n4ftl01u.ecs.nasa.gov/MOST/MOD10A1.005/2012.01.07/MOD10A1.A2012007.h17v03.005.2012011144012.hdf
ftp://n4ftl01u.ecs.nasa.gov/MOST/MOD10A1.005/2012.01.08/MOD10A1.A2012008.h17v03.005.2012011154609.hdf
ftp://n4ftl01u.ecs.nasa.gov/MOST/MOD10A1.005/2012.01.09/MOD10A1.A2012009.h17v03.005.2012011222125.hdf
ftp://n4ftl01u.ecs.nasa.gov/MOST/MOD10A1.005/2012.01.10/MOD10A1.A2012010.h17v03.005.2012012062821.hdf
\end{Verbatim}

With a more sensible set of urls now (only a few hundred), we can
consider how to download them.

We can (of course) do this in Python (see advanced notes), but we can
also use unix tools such as \code{curl} or \code{wget}, which may be easier.

For example, in \code{bash}:

\begin{Verbatim}[commandchars=\\\{\}]
tile=h17v03
year=2012
type=MOST

file=snow\PYGZus{}list\PYGZus{}\PYGZdl{}\PYGZob{}tile\PYGZcb{}\PYGZus{}\PYGZdl{}\PYGZob{}year\PYGZcb{}\PYGZus{}\PYGZdl{}\PYGZob{}type\PYGZcb{}.txt

\PYGZsh{} cd temporarily to the local directory
pushd files/data
\PYGZsh{} \PYGZhy{}nc : no clobber : dont download if its there already
\PYGZsh{} \PYGZhy{}nH \PYGZhy{}\PYGZhy{}cut\PYGZhy{}dirs=3 : ignore the directories
wget \PYGZhy{}nc \PYGZhy{}i \PYGZdl{}file \PYGZhy{}nH \PYGZhy{}\PYGZhy{}cut\PYGZhy{}dirs=3
popd
\end{Verbatim}

or in \code{tcsh}:

\begin{Verbatim}[commandchars=\\\{\}]
set tile=h17v03
set year=2012
set type=MOST

file=snow\PYGZus{}list\PYGZus{}\PYGZdl{}\PYGZob{}tile\PYGZcb{}\PYGZus{}\PYGZdl{}\PYGZob{}year\PYGZcb{}\PYGZus{}\PYGZdl{}\PYGZob{}type\PYGZcb{}.txt

\PYGZsh{} cd temporarily to the local directory
pushd files/data
\PYGZsh{} \PYGZhy{}nc : no clobber : dont download if its there already
\PYGZsh{} \PYGZhy{}nH \PYGZhy{}\PYGZhy{}cut\PYGZhy{}dirs=3 : ignore the directories
wget \PYGZhy{}nc \PYGZhy{}i \PYGZdl{}file \PYGZhy{}nH \PYGZhy{}\PYGZhy{}cut\PYGZhy{}dirs=3
popd
\end{Verbatim}

For the moment, let's just pull only some of these by filtering the
month as well:

\begin{Verbatim}[commandchars=\\\{\}]
tile=h17v03
year=2012
type=MOST
month=01

file=files/data/robot\PYGZus{}snow.\PYGZdl{}\PYGZob{}year\PYGZcb{}\PYGZus{}\PYGZdl{}\PYGZob{}type\PYGZcb{}\PYGZus{}\PYGZdl{}\PYGZob{}tile\PYGZcb{}\PYGZus{}\PYGZdl{}\PYGZob{}month\PYGZcb{}.txt

\PYGZsh{} the dot in the year / month grep need to be escaped
\PYGZsh{} because dot means something special to grep
grep \PYGZdl{}tile \PYGZlt{} files/data/robot\PYGZus{}snow.\PYGZdl{}year.txt \textbar{} grep \PYGZdl{}type \textbar{} grep \PYGZdq{}\PYGZdl{}\PYGZob{}year\PYGZcb{}\PYGZbs{}.\PYGZdl{}\PYGZob{}month\PYGZcb{}\PYGZdq{} \PYGZgt{} \PYGZdl{}file

\PYGZsh{} how many files?
wc \PYGZhy{}l \PYGZlt{} \PYGZdl{}file

\PYGZsh{} look at the first 10 ...
head \PYGZhy{}10 \PYGZlt{} \PYGZdl{}file
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
31
ftp://n4ftl01u.ecs.nasa.gov/MOST/MOD10A1.005/2012.01.01/MOD10A1.A2012001.h17v03.005.2012003054416.hdf
ftp://n4ftl01u.ecs.nasa.gov/MOST/MOD10A1.005/2012.01.02/MOD10A1.A2012002.h17v03.005.2012004061011.hdf
ftp://n4ftl01u.ecs.nasa.gov/MOST/MOD10A1.005/2012.01.03/MOD10A1.A2012003.h17v03.005.2012005061244.hdf
ftp://n4ftl01u.ecs.nasa.gov/MOST/MOD10A1.005/2012.01.04/MOD10A1.A2012004.h17v03.005.2012006054639.hdf
ftp://n4ftl01u.ecs.nasa.gov/MOST/MOD10A1.005/2012.01.05/MOD10A1.A2012005.h17v03.005.2012007052708.hdf
ftp://n4ftl01u.ecs.nasa.gov/MOST/MOD10A1.005/2012.01.06/MOD10A1.A2012006.h17v03.005.2012008070328.hdf
ftp://n4ftl01u.ecs.nasa.gov/MOST/MOD10A1.005/2012.01.07/MOD10A1.A2012007.h17v03.005.2012011144012.hdf
ftp://n4ftl01u.ecs.nasa.gov/MOST/MOD10A1.005/2012.01.08/MOD10A1.A2012008.h17v03.005.2012011154609.hdf
ftp://n4ftl01u.ecs.nasa.gov/MOST/MOD10A1.005/2012.01.09/MOD10A1.A2012009.h17v03.005.2012011222125.hdf
ftp://n4ftl01u.ecs.nasa.gov/MOST/MOD10A1.005/2012.01.10/MOD10A1.A2012010.h17v03.005.2012012062821.hdf
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
tile=h17v03
year=2012
type=MOST
month=01

file=robot\PYGZus{}snow.\PYGZdl{}\PYGZob{}year\PYGZcb{}\PYGZus{}\PYGZdl{}\PYGZob{}type\PYGZcb{}\PYGZus{}\PYGZdl{}\PYGZob{}tile\PYGZcb{}\PYGZus{}\PYGZdl{}\PYGZob{}month\PYGZcb{}.txt

\PYGZsh{} cd temporarily to the local directory
pushd files/data
\PYGZsh{} \PYGZhy{}nc : no clobber : dont download if its there already
\PYGZsh{} \PYGZhy{}nH \PYGZhy{}\PYGZhy{}cut\PYGZhy{}dirs=3 : ignore the directories
wget \PYGZhy{}nc \PYGZhy{}i \PYGZdl{}file \PYGZhy{}nH \PYGZhy{}\PYGZhy{}cut\PYGZhy{}dirs=3
\PYGZsh{} cd back again
popd
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
Process is terminated.
\end{Verbatim}


\section{Exercise 4.2 A Different Dataset}
\label{Chapter4_GDAL/GDAL_HDF:exercise-4-2-a-different-dataset}
We have now dowloaded a different dataset, the \href{http://www.icess.ucsb.edu/modis/SnowUsrGuide/usrguide\_1dtil.html}{MOD10A
product},
which is the 500 m MODIS daily snow cover product, over the UK.

This is a good opportunity to see if you can apply what was learned
above about interpreting QC information and using \code{gdal} to examine a
dataset.

If you examine the \href{http://nsidc.org/data/docs/daac/modis\_v5/mod10a1\_modis\_terra\_snow\_daily\_global\_500m\_grid.gd.html}{data description
page},
you will see that the data are in HDF EOS format (the same as the LAI
product).


\subsection{E4.2.1 Download}
\label{Chapter4_GDAL/GDAL_HDF:e4-2-1-download}
Download the MODIS Terra daily snow product for the UK for the year 2012
for the month of February using the urls in
files/data/robot\_snow.2012.txt and
put them in the directory \code{files/data}.


\subsection{E4.2.1 Explore}
\label{Chapter4_GDAL/GDAL_HDF:e4-2-1-explore}
Show all of the subset data layers in this dataset.


\subsection{E4.3.3 Read a dataset}
\label{Chapter4_GDAL/GDAL_HDF:e4-3-3-read-a-dataset}
Suppose we are interested in the dataset \code{Fractional\_Snow\_Cover} over
the land surface.

Read this dataset for one of the files into a numpy array and show a
plot of the dataset.


\subsection{E4.3.4 Water mask}
\label{Chapter4_GDAL/GDAL_HDF:e4-3-4-water-mask}
The \href{http://nsidc.org/data/docs/daac/modis\_v5/mod10a1\_modis\_terra\_snow\_daily\_global\_500m\_grid.gd.html}{data description
page}
tells us that values of \code{239} will indicate whether the data is ocean.
You can use this information to build the water mask.

Demonstrate how to build a water mask from one of these files, setting
the mask \code{False} for land and \code{True} for water.

Produce a plot of this.


\subsection{E3.4.5 Valid pixel mask}
\label{Chapter4_GDAL/GDAL_HDF:e3-4-5-valid-pixel-mask}
As well as having a land/water mask, we should generate a mask for valid
pixels. For the snow dataset, values between 0 and 100 (inclusive)
represent valid snow cover data values. Other values are not valid for
some reason. Set the mask to \code{False} for valid pixels and \code{True} for
others. Produce a plot of the mask.


\subsection{E4.3.6 3D dataset}
\label{Chapter4_GDAL/GDAL_HDF:e4-3-6-3d-dataset}
Generate a 3D masked numpy array using the valid pixel mask for masking,
of \code{Fractional\_Snow\_Cover} for each day of February 2012.

You might like to produce a movie of the result.

Hint: you will need a list of filenames for this. You can either use
\code{glob} as in previous exercises, or you might notice that you have the
file \code{files/data/robot\_snow.2012\_MOST\_h17v03\_02.txt} with the urls,
from which you should be able to derive the file names. However you get
your list of filenames, you should probably apply a \code{sort()} to the
result to make sure they are in the correct order.


\section{4.3 Vector masking}
\label{Chapter4_GDAL/GDAL_HDF:vector-masking}
In this section, we will use a pre-defined function to generate a mask
from some vector boundary data.

In this case, we will generate a mask for Ireland, projected into the
coordinate system of the MODIS LAI dataset, and use that to generate a
new LAI data only for Ireland.

Sometimes, geospatial data is acquired and recorded for particular
geometric objects such as polygons or lines. An example is a road
layout, where each road is represented as a geometric object (a line,
with points given in a geographical projection), with a number of added
\emph{features} associated with it, such as the road name, whether it is a
toll road, or whether it is dual-carriageway, etc. This data is quite
different to a raster, where the entire scene is tessellated into
pixels, and each pixel holds a value (or an array of value in the case
of multiband rasterfiles).

If you are familiar with databases, vector files are effectively a
database, where one of the fields is a geometry object (a line in our
previous road example, or a polygon if you consider a cadastral system).
We can thus select different records by writing queries on the features.
Some of these queries might be spatial (e.g. check whether a point is
inside a particular country polygon).

The most common format for vector data is the \textbf{ESRI Shapfile}, which
is a multifile format (i.e., several files are needed in order to access
the data). We'll start by getting hold of a shapefile that contains the
countries of the world as polygons, together with information on country
name, capital name, population, etc. The file is available
\href{http://aprsworld.net/gisdata/world/world.zip}{here}.
\begin{figure}[htbp]
\centering
\capstart
\caption{World}\end{figure}

We will download the file with wget (or curl if you want to), and
uncompress it using unzip in the shell:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{} Downloads the data using wget
!wget \PYGZhy{}nc http://aprsworld.net/gisdata/world/world.zip \PYGZhy{}O files/data/world.zip
\PYGZsh{} or if you want to use curl...
\PYGZsh{}! curl http://aprsworld.net/gisdata/world/world.zip \PYGZhy{}o world.zip
!pushd files/data;unzip \PYGZhy{}o \PYGZhy{}x world.zip;popd
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZhy{}\PYGZhy{}2013\PYGZhy{}10\PYGZhy{}22 15:32:06\PYGZhy{}\PYGZhy{}  http://aprsworld.net/gisdata/world/world.zip
Resolving aprsworld.net... 72.251.203.219
Connecting to aprsworld.net\textbar{}72.251.203.219\textbar{}:80... connected.
HTTP request sent, awaiting response... 200 OK
Length: 3436277 (3.3M) [application/zip]
Saving to: {}`files/data/world.zip\PYGZsq{}

100\PYGZpc{}[======================================\PYGZgt{}] 3,436,277   3.38M/s   in 1.0s

2013\PYGZhy{}10\PYGZhy{}22 15:32:07 (3.38 MB/s) \PYGZhy{} {}`files/data/world.zip\PYGZsq{} saved [3436277/3436277]

/archive/rsu\PYGZus{}raid\PYGZus{}0/plewis/public\PYGZus{}html/geogg122\PYGZus{}local/geogg122/Chapter4\PYGZus{}GDAL/files/data /archive/rsu\PYGZus{}raid\PYGZus{}0/plewis/public\PYGZus{}html/geogg122\PYGZus{}local/geogg122/Chapter4\PYGZus{}GDAL
Archive:  world.zip
  inflating: world.dbf
  inflating: world.shp
  inflating: world.shx
/archive/rsu\PYGZus{}raid\PYGZus{}0/plewis/public\PYGZus{}html/geogg122\PYGZus{}local/geogg122/Chapter4\PYGZus{}GDAL
\end{Verbatim}

We need to import \code{ogr}, and then open the file. As with GDAL, we get
a handler to the file, (\code{g} in this case). OGR files can have
different layers, although Shapefiles only have one. We need to select
the layer using \code{GetLayer(0)} (selecting the first layer).

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{osgeo} \PYG{k+kn}{import} \PYG{n}{ogr}

\PYG{n}{g} \PYG{o}{=} \PYG{n}{ogr}\PYG{o}{.}\PYG{n}{Open}\PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{files/data/world.shp}\PYG{l+s}{\PYGZdq{}} \PYG{p}{)}
\PYG{n}{layer} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{GetLayer}\PYG{p}{(} \PYG{l+m+mi}{0} \PYG{p}{)}
\end{Verbatim}

In order to see a field (the field \code{NAME}) we can loop over the
features in the layer, and use the \code{GetField('NAME')} method. We'll
only do ten features here:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{n\PYGZus{}feat} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{k}{for} \PYG{n}{feat} \PYG{o+ow}{in} \PYG{n}{layer}\PYG{p}{:}

    \PYG{k}{print} \PYG{n}{feat}\PYG{o}{.}\PYG{n}{GetField}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{NAME}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

    \PYG{n}{n\PYGZus{}feat} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
    \PYG{k}{if} \PYG{n}{n\PYGZus{}feat} \PYG{o}{==} \PYG{l+m+mi}{10}\PYG{p}{:}
        \PYG{k}{break}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
GUATEMALA
BOLIVIA
PARAGUAY
URUGUAY
SURINAME
FRENCH GUIANA
WESTERN SAHARA
GAMBIA
MOROCCO
MALI
\end{Verbatim}

If you wanted to see the different layers, we could do this using:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{layerDefinition} \PYG{o}{=} \PYG{n}{layer}\PYG{o}{.}\PYG{n}{GetLayerDefn}\PYG{p}{(}\PYG{p}{)}


\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{layerDefinition}\PYG{o}{.}\PYG{n}{GetFieldCount}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Field }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{: }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{p}{(} \PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{layerDefinition}\PYG{o}{.}\PYG{n}{GetFieldDefn}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{o}{.}\PYG{n}{GetName}\PYG{p}{(}\PYG{p}{)} \PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
Field 1: NAME
Field 2: CAPITAL
Field 3: APPROX
Field 4: AREA
Field 5: SOURCETHM
\end{Verbatim}

There is much more information on using \code{ogr} on the associated
notebook OGR\_Python that you should explore at
some point.

One thing we may often wish to dowith such vector datsets is produce a
mask, e.g. for national boundaries. One of the complexities of this is
changing the projection that the vector data come in to that of the
raster dataset.

This is too involved to go over in this session, so we will simply
present you with a function to achieve this.

This is available as
files/python/raster\_mask.py.

Most of the code below should be familiar from above (we make use of the
\code{getLAI()} function we developed).

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{n}{sys}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/python}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{k+kn}{from} \PYG{n+nn}{raster\PYGZus{}mask} \PYG{k+kn}{import} \PYG{n}{raster\PYGZus{}mask}\PYG{p}{,}\PYG{n}{getLAI}

\PYG{c}{\PYGZsh{} test this on an LAI file}

\PYG{c}{\PYGZsh{} the data file name}
\PYG{n}{filename} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MCD15A2.A2012273.h17v03.005.2012297134400.hdf}\PYG{l+s}{\PYGZsq{}}

\PYG{c}{\PYGZsh{} a layer (doesn\PYGZsq{}t matter so much which: use for geometry info)}
\PYG{n}{layer} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}
\PYG{c}{\PYGZsh{} the full dataset specification}
\PYG{n}{file\PYGZus{}template} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{:MOD\PYGZus{}Grid\PYGZus{}MOD15A2:}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZsq{}}
\PYG{n}{file\PYGZus{}spec} \PYG{o}{=} \PYG{n}{file\PYGZus{}template}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{,}\PYG{n}{layer}\PYG{p}{)}

\PYG{c}{\PYGZsh{} make a raster mask}
\PYG{c}{\PYGZsh{} from the layer IRELAND in world.shp}
\PYG{n}{mask} \PYG{o}{=} \PYG{n}{raster\PYGZus{}mask}\PYG{p}{(}\PYG{n}{file\PYGZus{}spec}\PYG{p}{,}\PYGZbs{}
                   \PYG{n}{target\PYGZus{}vector\PYGZus{}file} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{files/data/world.shp}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYGZbs{}
                   \PYG{n}{attribute\PYGZus{}filter} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{NAME = }\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{IRELAND}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}

\PYG{c}{\PYGZsh{} get the LAI data}
\PYG{n}{data} \PYG{o}{=} \PYG{n}{getLAI}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{)}

\PYG{c}{\PYGZsh{} reset the data mask}
\PYG{c}{\PYGZsh{} \PYGZsq{}mask\PYGZsq{} is True for Ireland}
\PYG{c}{\PYGZsh{} so take the opposite}
\PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{ma}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{mask}\PYG{o}{=}\PYG{n}{mask}\PYG{p}{)}
\PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{LaiStdDev\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{ma}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{mask}\PYG{o}{=}\PYG{n}{mask}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{LAI for Eire: 2012273}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{vmax}\PYG{o}{=}\PYG{l+m+mi}{6}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.colorbar.Colorbar instance at 0x7153878\PYGZgt{}
\end{Verbatim}

\includegraphics{GDAL_HDF_65_1.png}


\section{Exercise 4.3}
\label{Chapter4_GDAL/GDAL_HDF:exercise-4-3}
Apply the concepts above to generate a 3D masked numpy data array of LAI
and std LAI for Eire for the year 2012.

Plot your results and make a move of LAI.

Plot average LAI for Eire as a function of day of year for 2012.


\chapter{Summary}
\label{Chapter4_GDAL/GDAL_HDF:summary}
In this session, we have learned to use some geospatial tools using GDAL
in Python. A good set of \href{http://jgomezdans.github.io/gdal\_notes/}{working notes on how to use
GDAL} has been developed
that you will find useful for further reading, as well as looking at the
advanced section.

We have also very briefly introduced dealing with vector datasets in
\code{ogr}, but this was mainly through the use of a pre-defined function
that will take an ESRI shapefile (vector dataset), warp this to the
projection of a raster dataset, and produce a mask for a given layer in
the vector file.

If there is time in the class, we will develop some exercises to examine
the datasets we have generated and/or to explore some different datasets
or different locations.


\chapter{GDAL and OGR libraries}
\label{Chapter4_GDAL/GDAL_Python_bindings::doc}\label{Chapter4_GDAL/GDAL_Python_bindings:gdal-and-ogr-libraries}
In the previous session, we used the GDAL library to open HDF files.
GDAL is not limited to a single file format, but can actually cope with
many different raster file formats semalessly. For \emph{vector} data (i.e.,
data that is stored by features, each being made up of fields containing
different types of information, one of them being a \emph{geometry}, such as
polygon, line or point), GDAL has a sister library called OGR. The
usefulness of these two libraries is that they allow the user to deal
with many of the different file formats in a consistent way.

It is important to note that both GDAL and OGR come with a suite of
command line tools that let you do many complex tasks on the command
line directly. A listing of the GDAL command line tools is available
\href{http://www.gdal.org/gdal\_utilities.html}{here}, but bear in mind
that many blogs etc. carry out examples of using GDAL tools in practice.
For OGR, most of the library can be accessed using
\href{http://www.gdal.org/ogr2ogr.html}{ogr2ogr}, but as usual, you might
find more useful information on
\href{http://www.bostongis.com/PrinterFriendly.aspx?content\_name=ogr\_cheatsheet}{blogs}
etc.


\section{GDAL data type}
\label{Chapter4_GDAL/GDAL_Python_bindings:gdal-data-type}
GDAL provides a very handy way of dealing with raster data in many
different formats, not only by making access to the data easy, but also
abstracting the nuances and complications of different file formats. In
GDAL, a raster file is made up of the actual raster data (i.e., the
values of each pixel of LAI that we saw before), and of some \emph{metadata}.
Metadata is data that describes something, and in this case it could be
the projection, the location of corners and pixel spacing, etc.


\subsection{The GeoTransform}
\label{Chapter4_GDAL/GDAL_Python_bindings:the-geotransform}
GDAL stores information about the location of each pixel using the
GeoTransform. The GeoTransform contains the coordinates (in some
projection) of the upper left (UL) corner of the image (taken to be the
\textbf{borders of the pixel} in the UL corner, not the center), the pixel
spacing and an additional rotation. By knowing these figures, we can
calculate the location of each pixel in the image easily. Let's see how
this works with an easy example. We have prepared a GeoTIFF file
(GeoTIFF is the more ubiquitous file format for EO data) of the MODIS
landcover product for the UK. The data has been extracted from the
HDF-EOS files that are similar to the LAI product that we have seen
before, and converted. The file is
\code{{}`lc\_h17v03.tif} \textless{}\href{https://raw.github.com/jgomezdans/geogg122/master/ChapterX\_GDAL/lc\_h17v03.tif}{https://raw.github.com/jgomezdans/geogg122/master/ChapterX\_GDAL/lc\_h17v03.tif}\textgreater{}{}`\_\_.
We will open the file in Python, and have a look at finding a particular
location.

Assume we are interested in locating \href{http://toolserver.org/~rhaworth/os/coor\_g.php?pagename=Kinder\_Scout\&params=SK086875\_region\%3AGB\_scale\%3A25000}{Kinder
Scout},
a moorland in the Peak District National Park. Its coordinates are
1.871417W, 53.384726N. In the MODIS integerised sinusoidal projection,
the coordinates are (-124114.3, 5936117.4) (you can use the \href{http://landweb.nascom.nasa.gov/cgi-bin/developer/tilemap.cgi}{MODLAND
tile calculator
website}
to do this calculation yourself).

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{gdal} \PYG{c}{\PYGZsh{} Import GDAL library}
\PYG{n}{g} \PYG{o}{=} \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{Open} \PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{lc\PYGZus{}h17v03.tif}\PYG{l+s}{\PYGZdq{}} \PYG{p}{)} \PYG{c}{\PYGZsh{} Open the file}
\PYG{k}{if} \PYG{n}{g} \PYG{o+ow}{is} \PYG{n+nb+bp}{None}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Could not open the file!}\PYG{l+s}{\PYGZdq{}}
\PYG{n}{geo\PYGZus{}transform} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{GetGeoTransform} \PYG{p}{(}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{geo\PYGZus{}transform}
\PYG{k}{print} \PYG{n}{g}\PYG{o}{.}\PYG{n}{RasterXSize}\PYG{p}{,} \PYG{n}{g}\PYG{o}{.}\PYG{n}{RasterYSize}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
(\PYGZhy{}1111950.519667, 463.3127165279167, 0.0, 6671703.118, 0.0, \PYGZhy{}463.3127165279165)
2400 2400
\end{Verbatim}

In the previous code, we open the file (we just use the filename), and
then query the object for its GeoTransform, which we then print out. The
6-element tuple comprises
\begin{enumerate}
\item {} 
The Upper Left \emph{easting} coordinate (i.e., \emph{horizontal})

\item {} 
The E-W pixel spacing

\item {} 
The rotation (0 degrees if image is ``North Up'')

\item {} 
The Upper left \emph{northing} coordinate (i.e., \emph{vertical})

\item {} 
The rotation (0 degrees)

\item {} 
The N-S pixel spacing, negative as we will be counting from the UL
corner

\end{enumerate}

We have also seen that the dataset is of size 2400x2400, using
\code{RasterXSize} and \code{RasterYSize}. The goal is to find the pixel
number \((i,j), \;\;0\le i,j < 2400\) that corresponds to Kinder
Scout. To do this, we use the following calculations:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{pixel\PYGZus{}x} \PYG{o}{=} \PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{124114.3} \PYG{o}{\PYGZhy{}} \PYG{n}{geo\PYGZus{}transform}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{o}{/}\PYG{n}{geo\PYGZus{}transform}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYGZbs{}
        \PYG{c}{\PYGZsh{} The difference in distance between the UL corner (geot[0] \PYGZbs{}}
        \PYG{c}{\PYGZsh{}and point of interest. Scaled by geot[1] to get pixel number}

\PYG{n}{pixel\PYGZus{}y} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mf}{5936117.4} \PYG{o}{\PYGZhy{}} \PYG{n}{geo\PYGZus{}transform}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}\PYG{o}{/}\PYG{p}{(}\PYG{n}{geo\PYGZus{}transform}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{)} \PYG{c}{\PYGZsh{} Like for pixel\PYGZus{}x, \PYGZbs{}}
        \PYG{c}{\PYGZsh{}but in vertical direction. Note the different elements of geot \PYGZbs{}}
        \PYG{c}{\PYGZsh{}being used}

\PYG{k}{print} \PYG{n}{pixel\PYGZus{}x}\PYG{p}{,} \PYG{n}{pixel\PYGZus{}y}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
2132.11549009 1587.66572071
\end{Verbatim}

So the pixel number is a floating point number, which we might need to
round off as an integer. Let's plot the entire raster map (with minimum
value 0 to ignore the ocean) using
\code{{}`plt.imshow} \textless{}\href{http://matplotlib.org/api/pyplot\_api.html\#matplotlib.pyplot.imshow}{http://matplotlib.org/api/pyplot\_api.html\#matplotlib.pyplot.imshow}\textgreater{}{}`\_\_
and plot the location of Kinder Scout using
\code{{}`plt.plot} \textless{}\href{http://matplotlib.org/api/pyplot\_api.html\#matplotlib.pyplot.plt}{http://matplotlib.org/api/pyplot\_api.html\#matplotlib.pyplot.plt}\textgreater{}{}`\_\_.
We will also use
\code{{}`plt.annotate} \textless{}\href{http://matplotlib.org/api/pyplot\_api.html\#matplotlib.pyplot.annotate}{http://matplotlib.org/api/pyplot\_api.html\#matplotlib.pyplot.annotate}\textgreater{}{}`\_\_
to add a label with an arrow:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{lc} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{ReadAsArray}\PYG{p}{(}\PYG{p}{)} \PYG{c}{\PYGZsh{} Read raster data}
\PYG{c}{\PYGZsh{} Now plot the raster data using gist\PYGZus{}earth palette}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow} \PYG{p}{(} \PYG{n}{lc}\PYG{p}{,} \PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nearest}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{n}{plt}\PYG{o}{.}\PYG{n}{cm}\PYG{o}{.}\PYG{n}{gist\PYGZus{}earth} \PYG{p}{)}
\PYG{c}{\PYGZsh{} Plot location of our area of interest as a red dot (\PYGZsq{}ro\PYGZsq{})}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot} \PYG{p}{(} \PYG{n}{pixel\PYGZus{}x}\PYG{p}{,} \PYG{n}{pixel\PYGZus{}y}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{ro}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{c}{\PYGZsh{} Annotate}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{annotate}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Kinder Scout}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{xy}\PYG{o}{=}\PYG{p}{(}\PYG{n}{pixel\PYGZus{}x}\PYG{p}{,} \PYG{n}{pixel\PYGZus{}y}\PYG{p}{)}\PYG{p}{,}  \PYGZbs{}
        \PYG{n}{xycoords}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{data}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{xytext}\PYG{o}{=}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{150}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{60}\PYG{p}{)}\PYG{p}{,} \PYGZbs{}
        \PYG{n}{textcoords}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{offset points}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}  \PYG{n}{size}\PYG{o}{=}\PYG{l+m+mi}{12}\PYG{p}{,} \PYGZbs{}
        \PYG{n}{bbox}\PYG{o}{=}\PYG{n+nb}{dict}\PYG{p}{(}\PYG{n}{boxstyle}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{round4,pad=.5}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{fc}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0.8}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,} \PYGZbs{}
        \PYG{n}{arrowprops}\PYG{o}{=}\PYG{n+nb}{dict}\PYG{p}{(}\PYG{n}{arrowstyle}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}\PYGZgt{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYGZbs{}
        \PYG{n}{connectionstyle}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{angle,angleA=0,angleB=\PYGZhy{}90,rad=10}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYGZbs{}
        \PYG{n}{color}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{w}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,} \PYG{p}{)}
\PYG{c}{\PYGZsh{} Remove vertical and horizontal ticks}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xticks}\PYG{p}{(}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{yticks}\PYG{p}{(}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
([], \PYGZlt{}a list of 0 Text yticklabel objects\PYGZgt{})
\end{Verbatim}

\includegraphics{GDAL_Python_bindings_10_1.svg}


\subsubsection{Try it out in some other places!}
\label{Chapter4_GDAL/GDAL_Python_bindings:try-it-out-in-some-other-places}
Find the longitude and latitude of some places of interest in the
British isles (West of Greenwich!) and using the MODLAND MODIS tile
calculator and the geotransform, repeat the above experiment. Note that
the \href{http://landweb.nascom.nasa.gov/cgi-bin/developer/tilemap.cgi}{MODIS
calculator}
calculates both the projected coordinates in the MODIS sinusoidal
projection, as well as the pixel number, so it is a helpful way to check
whether you got the right result.

Park name

Longitude {[}deg{]}

Latitude {[}deg{]}

Dartmoor national park

-3.904

50.58

New forest national park

-1.595

50.86

Exmoor national park

-3.651

51.14

Pembrokeshire coast national park

-4.694

51.64

Brecon beacons national park

-3.432

\begin{Verbatim}[commandchars=\\\{\}]
51.88\PYGZlt{}/td\PYGZgt{}
\end{Verbatim}

Pembrokeshire coast national park

-4.79

51.99

Norfolk and suffolk broads

1.569

52.62

Snowdonia national park

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZhy{}3.898  \PYGZlt{}/td\PYGZgt{}\PYGZlt{}td\PYGZgt{}52.9\PYGZlt{}/td\PYGZgt{}
\end{Verbatim}

Peak district national park

-1.802

53.3

Yorkshire dales national park

-2.157

54.23

North yorkshire moors national park

-0.8855

54.37

Lake district national park

-3.084

54.47

Galloway forest park

-4.171

54.87

Northumberland national park

-2.228

55.28

Loch lomond and the trossachs national park

-4.593

56.24

Tay forest park

-4.025

\begin{Verbatim}[commandchars=\\\{\}]
56.59\PYGZlt{}/td\PYGZgt{}
\end{Verbatim}

Cairngorms national park

-3.545

57.08


\section{The projection}
\label{Chapter4_GDAL/GDAL_Python_bindings:the-projection}
Projections in GDAL objects are stored can be accessed by querying the
dataset using the \code{GetProjection()} method. If we do that on the
currently opened dataset (stored in variable \code{g}), we get:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{n}{g}\PYG{o}{.}\PYG{n}{GetProjection}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{PROJCS}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{unnamed}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{GEOGCS}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Unknown datum based upon the custom spheroid}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{DATUM}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Not\PYGZus{}specified\PYGZus{}based\PYGZus{}on\PYGZus{}custom\PYGZus{}spheroid}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{SPHEROID}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Custom spheroid}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+m+mf}{6371007.181}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,}\PYG{n}{PRIMEM}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Greenwich}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{UNIT}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{degree}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+m+mf}{0.0174532925199433}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,}\PYG{n}{PROJECTION}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Sinusoidal}\PYG{l+s}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{PARAMETER}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{longitude\PYGZus{}of\PYGZus{}center}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{PARAMETER}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{false\PYGZus{}easting}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{PARAMETER}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{false\PYGZus{}northing}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{UNIT}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{metre}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{AUTHORITY}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{EPSG}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{9001}\PYG{l+s}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{]}\PYG{p}{]}
\end{Verbatim}

The above is the description of the projection (in this case, MODIS
sinusoidal) in \code{WKT} (well-known text) format. There are a number of
different ways of specifying projections, the most important being
\begin{itemize}
\item {} 
WKT

\item {} 
Proj4

\item {} 
EPSG codes

\end{itemize}

The site \href{http://spatialreference.org}{spatialreference.org} allows
you to search a large collection of projections, and get the
representation that you want to use.


\section{Saving files}
\label{Chapter4_GDAL/GDAL_Python_bindings:saving-files}
So far, we have read data from files, but lets see how we can save
raster data \textbf{to} a new file. We will use the previous landcover map as
an example. We will write a method to save the data in a format provided
by the user. The procedure is fairly straightforward: we get a handler
to a driver (e.g. a GeoTIFF or Erdas Imagine format), we create the
output file (giving a filename, number of rows, columns, bands, the data
type), and then add the relevant metadata (projection, geotransform,
...). We then select a band from the output and copy the array that we
want to write to that band.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{g} \PYG{o}{=} \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{Open} \PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{lc\PYGZus{}h17v03.tif}\PYG{l+s}{\PYGZdq{}} \PYG{p}{)} \PYG{c}{\PYGZsh{} Open original file}
\PYG{c}{\PYGZsh{} Get the x, y and number of bands from the original file}
\PYG{n}{x\PYGZus{}size}\PYG{p}{,} \PYG{n}{y\PYGZus{}size}\PYG{p}{,} \PYG{n}{n\PYGZus{}bands} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{RasterXSize}\PYG{p}{,} \PYG{n}{g}\PYG{o}{.}\PYG{n}{RasterYSize}\PYG{p}{,} \PYG{n}{g}\PYG{o}{.}\PYG{n}{RasterCount}
\PYG{n}{data} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{ReadAsArray} \PYG{p}{(}\PYG{p}{)}
\PYG{n}{driver} \PYG{o}{=} \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{GetDriverByName} \PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{HFA}\PYG{l+s}{\PYGZdq{}} \PYG{p}{)} \PYG{c}{\PYGZsh{} Get a handler to a driver}
                                        \PYG{c}{\PYGZsh{} Maybe try \PYGZdq{}GeoTIFF\PYGZdq{} here}
\PYG{c}{\PYGZsh{} Next line creates the output dataset with}
\PYG{c}{\PYGZsh{} 1. The filename (\PYGZdq{}test\PYGZus{}lc\PYGZus{}h17v03.img\PYGZdq{})}
\PYG{c}{\PYGZsh{} 2. The raster size (x\PYGZus{}size, y\PYGZus{}size)}
\PYG{c}{\PYGZsh{} 3. The number of bands}
\PYG{c}{\PYGZsh{} 4.The data type (in this case, Byte.}
\PYG{c}{\PYGZsh{}     Other typical values might be gdal.GDT\PYGZus{}Int16}
\PYG{c}{\PYGZsh{}     or gdal.GDT\PYGZus{}Float32)}

\PYG{n}{dataset\PYGZus{}out} \PYG{o}{=} \PYG{n}{driver}\PYG{o}{.}\PYG{n}{Create} \PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{test\PYGZus{}lc\PYGZus{}h17v03.img}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{x\PYGZus{}size}\PYG{p}{,} \PYG{n}{y\PYGZus{}size}\PYG{p}{,} \PYG{n}{n\PYGZus{}bands}\PYG{p}{,} \PYGZbs{}
                             \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{GDT\PYGZus{}Byte} \PYG{p}{)}
\PYG{c}{\PYGZsh{} Set the output geotransform by reading the input one}
\PYG{n}{dataset\PYGZus{}out}\PYG{o}{.}\PYG{n}{SetGeoTransform} \PYG{p}{(} \PYG{n}{g}\PYG{o}{.}\PYG{n}{GetGeoTransform}\PYG{p}{(}\PYG{p}{)} \PYG{p}{)}
\PYG{c}{\PYGZsh{} Set the output projection by reading the input one}
\PYG{n}{dataset\PYGZus{}out}\PYG{o}{.}\PYG{n}{SetProjection} \PYG{p}{(} \PYG{n}{g}\PYG{o}{.}\PYG{n}{GetProjectionRef}\PYG{p}{(}\PYG{p}{)} \PYG{p}{)}
\PYG{c}{\PYGZsh{} Now, get band \PYGZsh{} 1, and write our data array.}
\PYG{c}{\PYGZsh{} Note that the data array needs to have the same type}
\PYG{c}{\PYGZsh{} as the one specified for dataset\PYGZus{}out}
\PYG{n}{dataset\PYGZus{}out}\PYG{o}{.}\PYG{n}{GetRasterBand} \PYG{p}{(} \PYG{l+m+mi}{1} \PYG{p}{)}\PYG{o}{.}\PYG{n}{WriteArray} \PYG{p}{(} \PYG{n}{data} \PYG{p}{)}
\PYG{c}{\PYGZsh{} This bit forces GDAL to close the file and write to it}
\PYG{n}{dataset\PYGZus{}out} \PYG{o}{=} \PYG{n+nb+bp}{None}
\end{Verbatim}

The output file should hopefully exist in this directory. Let's use
\code{{}`gdalinfo} \textless{}\href{http://www.gdal.org/gdalinfo.html}{http://www.gdal.org/gdalinfo.html}\textgreater{}{}`\_\_ to find out about
it

\begin{Verbatim}[commandchars=\\\{\}]
!gdalinfo test\PYGZus{}lc\PYGZus{}h17v03.img
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
Driver: HFA/Erdas Imagine Images (.img)
Files: test\PYGZus{}lc\PYGZus{}h17v03.img
Size is 2400, 2400
Coordinate System is:
PROJCS[\PYGZdq{}Sinusoidal\PYGZdq{},
    GEOGCS[\PYGZdq{}GCS\PYGZus{}Unknown datum based upon the custom spheroid\PYGZdq{},
        DATUM[\PYGZdq{}Not\PYGZus{}specified\PYGZus{}based\PYGZus{}on\PYGZus{}custom\PYGZus{}spheroid\PYGZdq{},
            SPHEROID[\PYGZdq{}Custom\PYGZus{}spheroid\PYGZdq{},6371007.181,0]],
        PRIMEM[\PYGZdq{}Greenwich\PYGZdq{},0],
        UNIT[\PYGZdq{}Degree\PYGZdq{},0.017453292519943295]],
    PROJECTION[\PYGZdq{}Sinusoidal\PYGZdq{}],
    PARAMETER[\PYGZdq{}longitude\PYGZus{}of\PYGZus{}center\PYGZdq{},0],
    PARAMETER[\PYGZdq{}false\PYGZus{}easting\PYGZdq{},0],
    PARAMETER[\PYGZdq{}false\PYGZus{}northing\PYGZdq{},0],
    UNIT[\PYGZdq{}Meter\PYGZdq{},1]]
Origin = (\PYGZhy{}1111950.519667000044137,6671703.117999999783933)
Pixel Size = (463.312716527916677,\PYGZhy{}463.312716527916507)
Corner Coordinates:
Upper Left  (\PYGZhy{}1111950.520, 6671703.118) ( 20d 0\PYGZsq{} 0.00\PYGZdq{}W, 60d 0\PYGZsq{} 0.00\PYGZdq{}N)
Lower Left  (\PYGZhy{}1111950.520, 5559752.598) ( 15d33\PYGZsq{}26.06\PYGZdq{}W, 50d 0\PYGZsq{} 0.00\PYGZdq{}N)
Upper Right (       0.000, 6671703.118) (  0d 0\PYGZsq{} 0.01\PYGZdq{}E, 60d 0\PYGZsq{} 0.00\PYGZdq{}N)
Lower Right (       0.000, 5559752.598) (  0d 0\PYGZsq{} 0.01\PYGZdq{}E, 50d 0\PYGZsq{} 0.00\PYGZdq{}N)
Center      ( \PYGZhy{}555975.260, 6115727.858) (  8d43\PYGZsq{} 2.04\PYGZdq{}W, 55d 0\PYGZsq{} 0.00\PYGZdq{}N)
Band 1 Block=64x64 Type=Byte, ColorInterp=Undefined
  Description = Layer\PYGZus{}1
  Metadata:
    LAYER\PYGZus{}TYPE=athematic
\end{Verbatim}

So the previous code works. Since this is something we typically do
(read some data from one or more files, manipulate it and save the
result in output files), it makes a lot of sense to try to put this code
in a method that is more or less generic, that we can test and then
re-use. Here's a first attempt at it:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{save\PYGZus{}raster} \PYG{p}{(} \PYG{n}{output\PYGZus{}name}\PYG{p}{,} \PYG{n}{raster\PYGZus{}data}\PYG{p}{,} \PYG{n}{dataset}\PYG{p}{,} \PYG{n}{driver}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{GTiff}\PYG{l+s}{\PYGZdq{}} \PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    A function to save a 1\PYGZhy{}band raster using GDAL to the file indicated}
\PYG{l+s+sd}{    by {}`{}`output\PYGZus{}name{}`{}`. It requires a GDAL\PYGZhy{}accesible dataset to collect}
\PYG{l+s+sd}{    the projection and geotransform.}

\PYG{l+s+sd}{    Parameters}
\PYG{l+s+sd}{    \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{l+s+sd}{    output\PYGZus{}name: str}
\PYG{l+s+sd}{        The output filename, with full path and extension if required}
\PYG{l+s+sd}{    raster\PYGZus{}data: array}
\PYG{l+s+sd}{        The array that we want to save}
\PYG{l+s+sd}{    dataset: str}
\PYG{l+s+sd}{        Filename of a GDAL\PYGZhy{}friendly dataset that we want to use to}
\PYG{l+s+sd}{        read geotransform \PYGZam{} projection information}
\PYG{l+s+sd}{    driver: str}
\PYG{l+s+sd}{        A GDAL driver string, like GTiff or HFA.}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}

    \PYG{c}{\PYGZsh{} Open the reference dataset}
    \PYG{n}{g} \PYG{o}{=} \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{Open} \PYG{p}{(} \PYG{n}{dataset} \PYG{p}{)}
    \PYG{c}{\PYGZsh{} Get the Geotransform vector}
    \PYG{n}{geo\PYGZus{}transform} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{GetGeoTransform} \PYG{p}{(}\PYG{p}{)}
    \PYG{n}{x\PYGZus{}size} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{RasterXSize} \PYG{c}{\PYGZsh{} Raster xsize}
    \PYG{n}{y\PYGZus{}size} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{RasterYSize} \PYG{c}{\PYGZsh{} Raster ysize}
    \PYG{n}{srs} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{GetProjectionRef} \PYG{p}{(}\PYG{p}{)} \PYG{c}{\PYGZsh{} Projection}
    \PYG{c}{\PYGZsh{} Need a driver object. By default, we use GeoTIFF}
    \PYG{n}{driver} \PYG{o}{=} \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{GetDriverByName} \PYG{p}{(} \PYG{n}{driver} \PYG{p}{)}
    \PYG{n}{dataset\PYGZus{}out} \PYG{o}{=} \PYG{n}{driver}\PYG{o}{.}\PYG{n}{Create} \PYG{p}{(} \PYG{n}{output\PYGZus{}name}\PYG{p}{,} \PYG{n}{x\PYGZus{}size}\PYG{p}{,} \PYG{n}{y\PYGZus{}size}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYGZbs{}
            \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{GDT\PYGZus{}Float32} \PYG{p}{)}
    \PYG{n}{dataset\PYGZus{}out}\PYG{o}{.}\PYG{n}{SetGeoTransform} \PYG{p}{(} \PYG{n}{geo\PYGZus{}transform} \PYG{p}{)}
    \PYG{n}{dataset\PYGZus{}out}\PYG{o}{.}\PYG{n}{SetProjection} \PYG{p}{(} \PYG{n}{srs} \PYG{p}{)}
    \PYG{n}{dataset\PYGZus{}out}\PYG{o}{.}\PYG{n}{GetRasterBand} \PYG{p}{(} \PYG{l+m+mi}{1} \PYG{p}{)}\PYG{o}{.}\PYG{n}{WriteArray} \PYG{p}{(} \PYGZbs{}
            \PYG{n}{raster\PYGZus{}data}\PYG{o}{.}\PYG{n}{astype}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{float32}\PYG{p}{)} \PYG{p}{)}
    \PYG{n}{dataset\PYGZus{}out} \PYG{o}{=} \PYG{n+nb+bp}{None}
\end{Verbatim}

Now try modifying that method so that you can
\begin{enumerate}
\item {} 
Select the output data type diffrent to Float32

\item {} 
Provide a given projection and geotransform (e.g. if you don't have a
GDAL filename)

\end{enumerate}


\section{Reprojecting things}
\label{Chapter4_GDAL/GDAL_Python_bindings:reprojecting-things}
Previously, we have used the \href{http://landweb.nascom.nasa.gov/cgi-bin/developer/tilemap.cgi}{MODLAND grid
converter}
site to go from latitude/longitude pairs to MODIS projection. However,
in practice, we might want to use a range of different projections, and
convert many points at the same time, so how do we go about that?

In GDAL/OGR, most projection-related tools are in the \code{osr} package,
which needs to be imported like e.g. \code{gdal} itself. The main tools are
the \code{osr.SpatialReference} object, which defines a projection object
(with no projection to start with), and the
\code{osr.CoordinateTransformation} object.

Once you instantiate \code{osr.SpatialReference}, it holds no projection
information. You need to use methods to set it up, using EPSG codes,
Proj4 strings, or whatever. These methods typically start by
\code{ImportFrom} (e.g. \code{ImportFromEPSG}, \code{ImportFromProj4}, ...).

The \code{CoordinateTransformation} requires a source and destination
spatial references that have been configured. Once this is done, it
expose the method \code{TransformPoint} to convert coordinates from the
source to the destination projection.

Let's see how this works by converting some latitude/longitude pairs to
the Ordnance Survey's \href{http://en.wikipedia.org/wiki/Ordnance\_Survey\_National\_Grid}{National
Grid}
projection. The projection is also available in
\href{http://spatialreference.org/ref/epsg/27700/}{spatialreference.org},
where we can gleam its EPSG code (27700). The EPSG code for longitude
latitude is \href{http://spatialreference.org/ref/epsg/4326/}{4326}. Let's
see this in practice:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{osgeo} \PYG{k+kn}{import} \PYG{n}{osr}

\PYG{c}{\PYGZsh{} Define the source projection, WGS84 lat/lon.}
\PYG{n}{wgs84} \PYG{o}{=} \PYG{n}{osr}\PYG{o}{.}\PYG{n}{SpatialReference}\PYG{p}{(} \PYG{p}{)} \PYG{c}{\PYGZsh{} Define a SpatialReference object}
\PYG{n}{wgs84}\PYG{o}{.}\PYG{n}{ImportFromEPSG}\PYG{p}{(} \PYG{l+m+mi}{4326} \PYG{p}{)} \PYG{c}{\PYGZsh{} And set it to WGS84 using the EPSG code}

\PYG{c}{\PYGZsh{} Now for the target projection, Ordnance Survey\PYGZsq{}s British National Grid}
\PYG{n}{osng} \PYG{o}{=} \PYG{n}{osr}\PYG{o}{.}\PYG{n}{SpatialReference}\PYG{p}{(}\PYG{p}{)} \PYG{c}{\PYGZsh{} define the SpatialReference object}
\PYG{c}{\PYGZsh{} In this case, we get the projection from a Proj4 string}
\PYG{n}{osng}\PYG{o}{.}\PYG{n}{ImportFromEPSG}\PYG{p}{(} \PYG{l+m+mi}{27700}\PYG{p}{)}
\PYG{c}{\PYGZsh{} or, if using the proj4 representation}
\PYG{n}{osng}\PYG{o}{.}\PYG{n}{ImportFromProj4} \PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{+proj=tmerc +lat\PYGZus{}0=49 +lon\PYGZus{}0=\PYGZhy{}2 }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYGZbs{}
                      \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{+k=0.9996012717 +x\PYGZus{}0=400000 +y\PYGZus{}0=\PYGZhy{}100000 }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYGZbs{}
                      \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{+ellps=airy +datum=OSGB36 +units=m +no\PYGZus{}defs}\PYG{l+s}{\PYGZdq{}} \PYG{p}{)}


\PYG{c}{\PYGZsh{} Now, we define a coordinate transformtion object, *from* wgs84 *to* OSNG}
\PYG{n}{tx} \PYG{o}{=} \PYG{n}{osr}\PYG{o}{.}\PYG{n}{CoordinateTransformation}\PYG{p}{(} \PYG{n}{wgs84}\PYG{p}{,} \PYG{n}{osng}\PYG{p}{)}
\PYG{c}{\PYGZsh{} We loop over the lines of park\PYGZus{}data,}
\PYG{c}{\PYGZsh{}         using the split method to split by newline characters}
\PYG{n}{park\PYGZus{}name}\PYG{p}{,} \PYG{n}{lon}\PYG{p}{,} \PYG{n}{lat} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Snowdonia national park}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{3.898}\PYG{p}{,}    \PYG{l+m+mf}{52.9}

\PYG{c}{\PYGZsh{} Actually do the transformation using the TransformPoint method}
\PYG{n}{osng\PYGZus{}x}\PYG{p}{,} \PYG{n}{osng\PYGZus{}y}\PYG{p}{,} \PYG{n}{osng\PYGZus{}z} \PYG{o}{=} \PYG{n}{tx}\PYG{o}{.}\PYG{n}{TransformPoint} \PYG{p}{(} \PYG{n}{lon}\PYG{p}{,} \PYG{n}{lat} \PYG{p}{)}
\PYG{c}{\PYGZsh{} Print out}
\PYG{k}{print} \PYG{n}{park\PYGZus{}name}\PYG{p}{,} \PYG{n}{lon}\PYG{p}{,} \PYG{n}{lat}\PYG{p}{,} \PYG{n}{osng\PYGZus{}x}\PYG{p}{,} \PYG{n}{osng\PYGZus{}y}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
Snowdonia national park \PYGZhy{}3.898 52.9 272430.180112 335304.936823
\end{Verbatim}

You can test the result is reasonable by feeding the data for \code{osng\_x}
and \code{osng\_y} in the OS own \href{http://www.ordnancesurvey.co.uk/gps/transformation}{coordinate conversion
website} and
making sure that the calculated longitude latitude pair is the same as
the one you started with.


\section{Reprojecting whole rasters}
\label{Chapter4_GDAL/GDAL_Python_bindings:reprojecting-whole-rasters}

\subsection{Using command line tools}
\label{Chapter4_GDAL/GDAL_Python_bindings:using-command-line-tools}
The easiest way to reproject a raster file is to use GDAL's
\code{{}`gdalwarp} \textless{}\href{http://www.gdal.org/gdalwarp.html}{http://www.gdal.org/gdalwarp.html}\textgreater{}{}`\_\_ tool. As an
example, let's say we want to reproject the landcover file from earlier
on into latitude/longitude (WGS84):

\begin{Verbatim}[commandchars=\\\{\}]
!gdalwarp \PYGZhy{}of GTiff \PYGZhy{}t\PYGZus{}srs \PYGZdq{}EPSG:4326\PYGZdq{} \PYGZhy{}ts 2400 2400 test\PYGZus{}lc\PYGZus{}h17v03.img  lc\PYGZus{}h17v03\PYGZus{}wgs84.tif
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
Output dataset lc\PYGZus{}h17v03\PYGZus{}wgs84.tif exists,
but some commandline options were provided indicating a new dataset
should be created.  Please delete existing dataset and run again.
\end{Verbatim}

We see here that the command takes a number of arguments:
\begin{enumerate}
\item {} 
\code{-of GTiff} is the outut format (in this case GeoTIFF)

\item {} 
\code{-t\_srs "EPSG:4326"} is the \textbf{to} projection (the \textbf{from}
projection is already specified in the source dataset), in this case,
lat/long WGS84, known by its \href{http://spatialreference.org/ref/epsg/4326/}{EPSG
code}

\item {} 
\code{-ts 2400 2400} instructs \code{gdalwarp} to use an output of size
\code{2400*2400}.

\item {} 
\code{test\_lc\_h17v03.img} is the \textbf{input dataset}

\item {} 
\code{lc\_h17v03\_wgs84.tif} is the \textbf{output dataset}

\end{enumerate}

Note that \code{gdalwarp} will reproject the data, and decide on the pixel
size based on some considerations. This can result in the size of the
raster changing. If you wanted to still keep the same raster size, we
use the \code{-ts 2400 2400} option, or select an appropriate pixel size
using \code{-tr xres yres} (note it has to be in the target projection, so
degrees in this case). We can use \code{gdalinfo} to see what we've done.

\begin{Verbatim}[commandchars=\\\{\}]
!gdalinfo test\PYGZus{}lc\PYGZus{}h17v03.img
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
Driver: HFA/Erdas Imagine Images (.img)
Files: test\PYGZus{}lc\PYGZus{}h17v03.img
Size is 2400, 2400
Coordinate System is:
PROJCS[\PYGZdq{}Sinusoidal\PYGZdq{},
    GEOGCS[\PYGZdq{}GCS\PYGZus{}Unknown datum based upon the custom spheroid\PYGZdq{},
        DATUM[\PYGZdq{}Not\PYGZus{}specified\PYGZus{}based\PYGZus{}on\PYGZus{}custom\PYGZus{}spheroid\PYGZdq{},
            SPHEROID[\PYGZdq{}Custom\PYGZus{}spheroid\PYGZdq{},6371007.181,0]],
        PRIMEM[\PYGZdq{}Greenwich\PYGZdq{},0],
        UNIT[\PYGZdq{}Degree\PYGZdq{},0.017453292519943295]],
    PROJECTION[\PYGZdq{}Sinusoidal\PYGZdq{}],
    PARAMETER[\PYGZdq{}longitude\PYGZus{}of\PYGZus{}center\PYGZdq{},0],
    PARAMETER[\PYGZdq{}false\PYGZus{}easting\PYGZdq{},0],
    PARAMETER[\PYGZdq{}false\PYGZus{}northing\PYGZdq{},0],
    UNIT[\PYGZdq{}Meter\PYGZdq{},1]]
Origin = (\PYGZhy{}1111950.519667000044137,6671703.117999999783933)
Pixel Size = (463.312716527916677,\PYGZhy{}463.312716527916507)
Corner Coordinates:
Upper Left  (\PYGZhy{}1111950.520, 6671703.118) ( 20d 0\PYGZsq{} 0.00\PYGZdq{}W, 60d 0\PYGZsq{} 0.00\PYGZdq{}N)
Lower Left  (\PYGZhy{}1111950.520, 5559752.598) ( 15d33\PYGZsq{}26.06\PYGZdq{}W, 50d 0\PYGZsq{} 0.00\PYGZdq{}N)
Upper Right (       0.000, 6671703.118) (  0d 0\PYGZsq{} 0.01\PYGZdq{}E, 60d 0\PYGZsq{} 0.00\PYGZdq{}N)
Lower Right (       0.000, 5559752.598) (  0d 0\PYGZsq{} 0.01\PYGZdq{}E, 50d 0\PYGZsq{} 0.00\PYGZdq{}N)
Center      ( \PYGZhy{}555975.260, 6115727.858) (  8d43\PYGZsq{} 2.04\PYGZdq{}W, 55d 0\PYGZsq{} 0.00\PYGZdq{}N)
Band 1 Block=64x64 Type=Byte, ColorInterp=Undefined
  Description = Layer\PYGZus{}1
  Metadata:
    LAYER\PYGZus{}TYPE=athematic
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
!gdalinfo lc\PYGZus{}h17v03\PYGZus{}wgs84.tif
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
Driver: GTiff/GeoTIFF
Files: lc\PYGZus{}h17v03\PYGZus{}wgs84.tif
Size is 2400, 2400
Coordinate System is:
GEOGCS[\PYGZdq{}WGS 84\PYGZdq{},
    DATUM[\PYGZdq{}WGS\PYGZus{}1984\PYGZdq{},
        SPHEROID[\PYGZdq{}WGS 84\PYGZdq{},6378137,298.257223563,
            AUTHORITY[\PYGZdq{}EPSG\PYGZdq{},\PYGZdq{}7030\PYGZdq{}]],
        AUTHORITY[\PYGZdq{}EPSG\PYGZdq{},\PYGZdq{}6326\PYGZdq{}]],
    PRIMEM[\PYGZdq{}Greenwich\PYGZdq{},0],
    UNIT[\PYGZdq{}degree\PYGZdq{},0.0174532925199433],
    AUTHORITY[\PYGZdq{}EPSG\PYGZdq{},\PYGZdq{}4326\PYGZdq{}]]
Origin = (\PYGZhy{}19.999999994952233,59.999999994611805)
Pixel Size = (0.008333919248404,\PYGZhy{}0.004166959624202)
Metadata:
  AREA\PYGZus{}OR\PYGZus{}POINT=Area
Image Structure Metadata:
  INTERLEAVE=BAND
Corner Coordinates:
Upper Left  ( \PYGZhy{}20.0000000,  60.0000000) ( 20d 0\PYGZsq{} 0.00\PYGZdq{}W, 60d 0\PYGZsq{} 0.00\PYGZdq{}N)
Lower Left  ( \PYGZhy{}20.0000000,  49.9992969) ( 20d 0\PYGZsq{} 0.00\PYGZdq{}W, 49d59\PYGZsq{}57.47\PYGZdq{}N)
Upper Right (   0.0014062,  60.0000000) (  0d 0\PYGZsq{} 5.06\PYGZdq{}E, 60d 0\PYGZsq{} 0.00\PYGZdq{}N)
Lower Right (   0.0014062,  49.9992969) (  0d 0\PYGZsq{} 5.06\PYGZdq{}E, 49d59\PYGZsq{}57.47\PYGZdq{}N)
Center      (  \PYGZhy{}9.9992969,  54.9996484) (  9d59\PYGZsq{}57.47\PYGZdq{}W, 54d59\PYGZsq{}58.73\PYGZdq{}N)
Band 1 Block=2400x3 Type=Byte, ColorInterp=Gray
  Description = Layer\PYGZus{}1
  Metadata:
    LAYER\PYGZus{}TYPE=athematic
\end{Verbatim}

Let's see how different these two datasets are:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{g} \PYG{o}{=} \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{Open} \PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{lc\PYGZus{}h17v03\PYGZus{}wgs84.tif}\PYG{l+s}{\PYGZdq{}} \PYG{p}{)}
\PYG{n}{wgs84} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{ReadAsArray}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{g} \PYG{o}{=} \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{Open}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{test\PYGZus{}lc\PYGZus{}h17v03.img}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{modis} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{ReadAsArray}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplot} \PYG{p}{(} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1} \PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow} \PYG{p}{(} \PYG{n}{modis}\PYG{p}{,} \PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nearest}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{n}{plt}\PYG{o}{.}\PYG{n}{cm}\PYG{o}{.}\PYG{n}{gist\PYGZus{}earth} \PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplot} \PYG{p}{(} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2} \PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow} \PYG{p}{(} \PYG{n}{wgs84}\PYG{p}{,} \PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nearest}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{n}{plt}\PYG{o}{.}\PYG{n}{cm}\PYG{o}{.}\PYG{n}{gist\PYGZus{}earth} \PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.image.AxesImage at 0xe566950\PYGZgt{}
\end{Verbatim}

\includegraphics{GDAL_Python_bindings_39_1.svg}


\subsection{Reprojecting using the Python bindings}
\label{Chapter4_GDAL/GDAL_Python_bindings:reprojecting-using-the-python-bindings}
The previous section demonstrated how you can reproject raster files
using command line tools. Sometimes, you might want to do this from
inside a Python script. Ideally, you would have a python method that
would perform the projection for you. GDAL allows this by defining
in-memory raster files. These are normal GDAL datasets, but that dont
exist on the filesystem, only in the computers memory. They are a
convenient scratchpad for quick intermediate calculations. GDAL also
makes available a function, gdal.ReprojectImage that exposes most of the
abilities of gdalwarp. We shall combine these two tricks to carry out
the reprojection. As an example, we shall look at the case where the
landcover data for the British Isles mentioned in the previous section
needs to be reprojected to the Ordnance Survey National Grid, an
appropriate projection for the UK.

The main complication comes from the need of gdal.ReprojectImage to
operate on GDAL datasets. In the previous section, we saved the data to
a GeoTIFF file, so this gives us a starting dataset. We still need to
create the output dataset. This means that we need to define the
geotransform and size of the output dataset before the projection is
made. This entails gathering information on the extent of the original
dataset, projecting it to the destination projection, and calculating
the number of pixels and geotransform parameters from there. This is a
(heavily commented) function that performs just that task:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{reproject\PYGZus{}dataset} \PYG{p}{(} \PYG{n}{dataset}\PYG{p}{,} \PYGZbs{}
            \PYG{n}{pixel\PYGZus{}spacing}\PYG{o}{=}\PYG{l+m+mf}{463.}\PYG{p}{,} \PYG{n}{epsg\PYGZus{}from}\PYG{o}{=}\PYG{l+m+mi}{4326}\PYG{p}{,} \PYG{n}{epsg\PYGZus{}to}\PYG{o}{=}\PYG{l+m+mi}{27700} \PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    A sample function to reproject and resample a GDAL dataset from within}
\PYG{l+s+sd}{    Python. The idea here is to reproject from one system to another, as well}
\PYG{l+s+sd}{    as to change the pixel size. The procedure is slightly long\PYGZhy{}winded, but}
\PYG{l+s+sd}{    goes like this:}

\PYG{l+s+sd}{    1. Set up the two Spatial Reference systems.}
\PYG{l+s+sd}{    2. Open the original dataset, and get the geotransform}
\PYG{l+s+sd}{    3. Calculate bounds of new geotransform by projecting the UL corners}
\PYG{l+s+sd}{    4. Calculate the number of pixels with the new projection \PYGZam{} spacing}
\PYG{l+s+sd}{    5. Create an in\PYGZhy{}memory raster dataset}
\PYG{l+s+sd}{    6. Perform the projection}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{c}{\PYGZsh{} Define the UK OSNG, see \PYGZlt{}http://spatialreference.org/ref/epsg/27700/\PYGZgt{}}
    \PYG{n}{osng} \PYG{o}{=} \PYG{n}{osr}\PYG{o}{.}\PYG{n}{SpatialReference} \PYG{p}{(}\PYG{p}{)}
    \PYG{n}{osng}\PYG{o}{.}\PYG{n}{ImportFromEPSG} \PYG{p}{(} \PYG{n}{epsg\PYGZus{}to} \PYG{p}{)}
    \PYG{n}{wgs84} \PYG{o}{=} \PYG{n}{osr}\PYG{o}{.}\PYG{n}{SpatialReference} \PYG{p}{(}\PYG{p}{)}
    \PYG{n}{wgs84}\PYG{o}{.}\PYG{n}{ImportFromEPSG} \PYG{p}{(} \PYG{n}{epsg\PYGZus{}from} \PYG{p}{)}
    \PYG{n}{tx} \PYG{o}{=} \PYG{n}{osr}\PYG{o}{.}\PYG{n}{CoordinateTransformation} \PYG{p}{(} \PYG{n}{wgs84}\PYG{p}{,} \PYG{n}{osng} \PYG{p}{)}
    \PYG{c}{\PYGZsh{} Up to here, all  the projection have been defined, as well as a}
    \PYG{c}{\PYGZsh{} transformation from the from to the  to :)}
    \PYG{c}{\PYGZsh{} We now open the dataset}
    \PYG{n}{g} \PYG{o}{=} \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{Open} \PYG{p}{(} \PYG{n}{dataset} \PYG{p}{)}

    \PYG{c}{\PYGZsh{} Get the Geotransform vector}
    \PYG{n}{geo\PYGZus{}t} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{GetGeoTransform} \PYG{p}{(}\PYG{p}{)}
    \PYG{n}{x\PYGZus{}size} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{RasterXSize} \PYG{c}{\PYGZsh{} Raster xsize}
    \PYG{n}{y\PYGZus{}size} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{RasterYSize} \PYG{c}{\PYGZsh{} Raster ysize}

    \PYG{c}{\PYGZsh{} Work out the boundaries of the new dataset in the target projection}
    \PYG{p}{(}\PYG{n}{ulx}\PYG{p}{,} \PYG{n}{uly}\PYG{p}{,} \PYG{n}{ulz} \PYG{p}{)} \PYG{o}{=} \PYG{n}{tx}\PYG{o}{.}\PYG{n}{TransformPoint}\PYG{p}{(} \PYG{n}{geo\PYGZus{}t}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{geo\PYGZus{}t}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}
    \PYG{p}{(}\PYG{n}{lrx}\PYG{p}{,} \PYG{n}{lry}\PYG{p}{,} \PYG{n}{lrz} \PYG{p}{)} \PYG{o}{=} \PYG{n}{tx}\PYG{o}{.}\PYG{n}{TransformPoint}\PYG{p}{(} \PYG{n}{geo\PYGZus{}t}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{+} \PYG{n}{geo\PYGZus{}t}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{*}\PYG{n}{x\PYGZus{}size}\PYG{p}{,} \PYGZbs{}
                                          \PYG{n}{geo\PYGZus{}t}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]} \PYG{o}{+} \PYG{n}{geo\PYGZus{}t}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{o}{*}\PYG{n}{y\PYGZus{}size} \PYG{p}{)}
    \PYG{k}{print} \PYG{n}{ulx}\PYG{p}{,} \PYG{n}{uly}\PYG{p}{,} \PYG{n}{ulz}
    \PYG{k}{print} \PYG{n}{lrx}\PYG{p}{,} \PYG{n}{lry}\PYG{p}{,} \PYG{n}{lrz}
    \PYG{c}{\PYGZsh{} See how using 27700 and WGS84 introduces a z\PYGZhy{}value!}
    \PYG{c}{\PYGZsh{} Now, we create an in\PYGZhy{}memory raster}
    \PYG{n}{mem\PYGZus{}drv} \PYG{o}{=} \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{GetDriverByName}\PYG{p}{(} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MEM}\PYG{l+s}{\PYGZsq{}} \PYG{p}{)}
    \PYG{c}{\PYGZsh{} The size of the raster is given the new projection and pixel spacing}
    \PYG{c}{\PYGZsh{} Using the values we calculated above. Also, setting it to store one band}
    \PYG{c}{\PYGZsh{} and to use Float32 data type.}
    \PYG{n}{dest} \PYG{o}{=} \PYG{n}{mem\PYGZus{}drv}\PYG{o}{.}\PYG{n}{Create}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{int}\PYG{p}{(}\PYG{p}{(}\PYG{n}{lrx} \PYG{o}{\PYGZhy{}} \PYG{n}{ulx}\PYG{p}{)}\PYG{o}{/}\PYG{n}{pixel\PYGZus{}spacing}\PYG{p}{)}\PYG{p}{,} \PYGZbs{}
            \PYG{n+nb}{int}\PYG{p}{(}\PYG{p}{(}\PYG{n}{uly} \PYG{o}{\PYGZhy{}} \PYG{n}{lry}\PYG{p}{)}\PYG{o}{/}\PYG{n}{pixel\PYGZus{}spacing}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{GDT\PYGZus{}Float32}\PYG{p}{)}
    \PYG{c}{\PYGZsh{} Calculate the new geotransform}
    \PYG{n}{new\PYGZus{}geo} \PYG{o}{=} \PYG{p}{(} \PYG{n}{ulx}\PYG{p}{,} \PYG{n}{pixel\PYGZus{}spacing}\PYG{p}{,} \PYG{n}{geo\PYGZus{}t}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYGZbs{}
                \PYG{n}{uly}\PYG{p}{,} \PYG{n}{geo\PYGZus{}t}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{pixel\PYGZus{}spacing} \PYG{p}{)}
    \PYG{c}{\PYGZsh{} Set the geotransform}
    \PYG{n}{dest}\PYG{o}{.}\PYG{n}{SetGeoTransform}\PYG{p}{(} \PYG{n}{new\PYGZus{}geo} \PYG{p}{)}
    \PYG{n}{dest}\PYG{o}{.}\PYG{n}{SetProjection} \PYG{p}{(} \PYG{n}{osng}\PYG{o}{.}\PYG{n}{ExportToWkt}\PYG{p}{(}\PYG{p}{)} \PYG{p}{)}
    \PYG{c}{\PYGZsh{} Perform the projection/resampling}
    \PYG{n}{res} \PYG{o}{=} \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{ReprojectImage}\PYG{p}{(} \PYG{n}{g}\PYG{p}{,} \PYG{n}{dest}\PYG{p}{,} \PYGZbs{}
                \PYG{n}{wgs84}\PYG{o}{.}\PYG{n}{ExportToWkt}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{osng}\PYG{o}{.}\PYG{n}{ExportToWkt}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYGZbs{}
                \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{GRA\PYGZus{}Bilinear} \PYG{p}{)}
    \PYG{k}{return} \PYG{n}{dest}
\end{Verbatim}

The function returns a GDAL in-memory file object, where you can
\code{ReadAsArray} etc. As it stands, \code{reproject\_dataset} does not write
to disk. However, we can save the in-memory raster to any format
supported by GDAL very conveniently by making a copy of the dataset.
This takes a few lines of code:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} Do in memory reprojection}
\PYG{n}{reprojected\PYGZus{}dataset} \PYG{o}{=} \PYG{n}{reproject\PYGZus{}dataset} \PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{lc\PYGZus{}h17v03\PYGZus{}wgs84.tif}\PYG{l+s}{\PYGZdq{}} \PYG{p}{)}
\PYG{c}{\PYGZsh{} Output driver, as before}
\PYG{n}{driver} \PYG{o}{=} \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{GetDriverByName} \PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{GTiff}\PYG{l+s}{\PYGZdq{}} \PYG{p}{)}
\PYG{c}{\PYGZsh{} Create a copy of the in memory dataset {}`reprojected\PYGZus{}dataset{}`, and save it}
\PYG{n}{dst\PYGZus{}ds} \PYG{o}{=} \PYG{n}{driver}\PYG{o}{.}\PYG{n}{CreateCopy}\PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{test\PYGZus{}lc\PYGZus{}h17v03\PYGZus{}OSNG.tif}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{reprojected\PYGZus{}dataset}\PYG{p}{,} \PYG{l+m+mi}{0} \PYG{p}{)}
\PYG{n}{dst\PYGZus{}ds} \PYG{o}{=} \PYG{n+nb+bp}{None} \PYG{c}{\PYGZsh{} Flush the dataset to disk}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZhy{}595472.202548 1261034.77555 \PYGZhy{}55.2326775854
543532.18509 12933.1712342 \PYGZhy{}43.993001678
\end{Verbatim}

Let's see how the different projections look like by plotting them side
by side

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplot} \PYG{p}{(} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{1} \PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MODIS sinusoidal}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow} \PYG{p}{(} \PYG{n}{modis}\PYG{p}{,} \PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nearest}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{n}{plt}\PYG{o}{.}\PYG{n}{cm}\PYG{o}{.}\PYG{n}{gist\PYGZus{}earth} \PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplot} \PYG{p}{(} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{2} \PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow} \PYG{p}{(} \PYG{n}{wgs84}\PYG{p}{,} \PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nearest}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{n}{plt}\PYG{o}{.}\PYG{n}{cm}\PYG{o}{.}\PYG{n}{gist\PYGZus{}earth} \PYG{p}{)}
\PYG{n}{g} \PYG{o}{=} \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{Open}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{test\PYGZus{}lc\PYGZus{}h17v03\PYGZus{}OSNG.tif}\PYG{l+s}{\PYGZdq{}} \PYG{p}{)}
\PYG{n}{osng} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{ReadAsArray}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{WGS84, Lat/Long}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplot} \PYG{p}{(} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{3} \PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow} \PYG{p}{(} \PYG{n}{osng}\PYG{p}{,} \PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nearest}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{n}{plt}\PYG{o}{.}\PYG{n}{cm}\PYG{o}{.}\PYG{n}{gist\PYGZus{}earth} \PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{OSNG}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.text.Text at 0x2b9eac0b4ed0\PYGZgt{}
\end{Verbatim}

\includegraphics{GDAL_Python_bindings_46_1.svg}


\chapter{GDAL and related codes and libraries}
\label{Chapter4_GDAL/Installation:gdal-and-related-codes-and-libraries}\label{Chapter4_GDAL/Installation::doc}
GDAL does not always come with your Python distribution.

It can sometimes be a little tricky to install.

Yopu \textbf{do not} need it for this class as you can always run things on
the UCL Geography system via \code{ssh}, but \emph{might like} to install it, so
we'll try to keep some notes up to date here on how to do that (and
typical problems you encounter).

Since it relies on libraries not written in Python, you need to get
these libraries installed. You may also want to install the GDAL tools.

There are many ways of doing this that you can find by searching on the
internet.

A good place to start is
\href{http://trac.osgeo.org/gdal/wiki/DownloadingGdalBinaries}{trac.osgeo.org}.

Here, we try to give some practical guidance. (Note: I've note been able
to test this under windows, so \href{mailto:p.lewis@ucl.ac.uk}{give me some
feedback} about what works or doesn't).


\section{OS X}
\label{Chapter4_GDAL/Installation:os-x}

\subsection{Pre-compiled GDAL utilities}
\label{Chapter4_GDAL/Installation:pre-compiled-gdal-utilities}
There are several places you can download pre-compiled versions of the
GDAL utilities from.

Oner example is \href{http://www.kyngchaos.com/software:frameworks}{http://www.kyngchaos.com/software:frameworks}. If you
install \code{GDAL complete} from there, you should find the GDAL utilities
in \code{/Library/Frameworks/GDAL.framework/Programs}:

\begin{Verbatim}[commandchars=\\\{\}]
!ls /Library/Frameworks/GDAL.framework/Programs
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
[31mepsg\PYGZus{}tr.py[m[m         [31mgdal\PYGZus{}fillnodata.py[m[m [31mgdalchksum.py[m[m      [31mgdaltindex[m[m
[31mesri2wkt.py[m[m        [31mgdal\PYGZus{}grid[m[m          [31mgdaldem[m[m            [31mgdaltransform[m[m
[31mgcps2vec.py[m[m        [31mgdal\PYGZus{}merge.py[m[m      [31mgdalenhance[m[m        [31mgdalwarp[m[m
[31mgcps2wld.py[m[m        [31mgdal\PYGZus{}polygonize.py[m[m [31mgdalident.py[m[m       [31mmkgraticule.py[m[m
[31mgdal\PYGZhy{}config[m[m        [31mgdal\PYGZus{}proximity.py[m[m  [31mgdalimport.py[m[m      [31mnearblack[m[m
[31mgdal2tiles.py[m[m      [31mgdal\PYGZus{}rasterize[m[m     [31mgdalinfo[m[m           [31mogr2ogr[m[m
[31mgdal2xyz.py[m[m        [31mgdal\PYGZus{}retile.py[m[m     [31mgdallocationinfo[m[m   [31mogrinfo[m[m
[31mgdal\PYGZus{}auth.py[m[m       [31mgdal\PYGZus{}sieve.py[m[m      [31mgdalmanage[m[m         [31mogrtindex[m[m
[31mgdal\PYGZus{}calc.py[m[m       [31mgdal\PYGZus{}translate[m[m     [31mgdalmove.py[m[m        [31mpct2rgb.py[m[m
[31mgdal\PYGZus{}contour[m[m       [31mgdaladdo[m[m           [31mgdalserver[m[m         [31mrgb2pct.py[m[m
[31mgdal\PYGZus{}edit.py[m[m       [31mgdalbuildvrt[m[m       [31mgdalsrsinfo[m[m        [31mtestepsg[m[m
\end{Verbatim}

If you want this in your path, put the following line at the bottom of
the file \code{\textasciitilde{}/.bashrc} (if using \code{bash}):

\code{export PATH=/Library/Frameworks/GDAL.framework/Programs:\$PATH}

or, if using \code{tcsh} or \code{csh}, puth this at the end of your file
\code{\textasciitilde{}/.cshrc}:

\code{setenv PATH "/Library/Frameworks/GDAL.framework/Programs:\$\{PATH\}"}

or

\code{set path = (/Library/Frameworks/GDAL.framework/Programs \$path)}

and then type:

\code{source \textasciitilde{}/.bashrc}

or

\code{source \textasciitilde{}/.cshrc}

as appropriate (or open new shells).

You can test that you can access the gdal commands with e.g.:

\begin{Verbatim}[commandchars=\\\{\}]
!which gdalinfo
!gdalinfo \PYGZhy{}\PYGZhy{}version
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
/Library/Frameworks/GDAL.framework/Programs/gdalinfo
GDAL 1.10.1, released 2013/08/26
\end{Verbatim}


\subsection{Compiling source (use \texttt{homebrew})}
\label{Chapter4_GDAL/Installation:compiling-source-use-homebrew}
If you want to compile \code{GDAL} yourself for OS X, it is probably
easiest to install the \href{http://brew.sh/}{Homebrew} software, type:

\code{rehash}

at the unix prompt (to update your path) and follow any instructions it
gives you to sort out any conflicts you might have, then simply:

\code{brew install gdal}


\chapter{Working with vector data: OGR}
\label{Chapter4_GDAL/OGR_Python:working-with-vector-data-ogr}\label{Chapter4_GDAL/OGR_Python::doc}

\section{Vector data}
\label{Chapter4_GDAL/OGR_Python:vector-data}
Sometimes, geospatial data is acquired and recorded for particular
geometric objects such as polygons or lines. An example is a road
layout, where each road is represented as a geometric object (a line,
with points given in a geographical projection), with a number of added
\emph{features} associated with it, such as the road name, whether it is a
toll road, or whether it is dual-carriageway, etc. This data is quite
different to a raster, where the entire scene is tessellated into
pixels, and each pixel holds a value (or an array of value in the case
of multiband rasterfiles).

If you are familiar with databases, vector files are effectively a
database, where one of the fields is a geometry object (a line in our
previous road example, or a polygon if you consider a cadastral system).
We can thus select different records by writing queries on the features.
Some of these queries might be spatial (e.g. check whether a point is
inside a particular country polygon).

The most common format for vector data is the \textbf{ESRI Shapfile}, which
is a multifile format (i.e., several files are needed in order to access
the data). We'll start by getting hold of a shapefile that contains the
countries of the world as polygons, together with information on country
name, capital name, population, etc. The file is available
\href{http://aprsworld.net/gisdata/world/world.zip}{here}.
\begin{figure}[htbp]
\centering
\capstart
\caption{World}\end{figure}

We will download the file with \code{wget} (or \code{curl} if you want to),
and uncompress it using \code{unzip} in the shell:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{} Downloads the data using wget
!wget http://aprsworld.net/gisdata/world/world.zip
\PYGZsh{} or if you want to use curl...
\PYGZsh{}! curl http://aprsworld.net/gisdata/world/world.zip \PYGZhy{}o world.zip
!unzip \PYGZhy{}o \PYGZhy{}x world.zip
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZhy{}\PYGZhy{}2013\PYGZhy{}10\PYGZhy{}22 15:47:43\PYGZhy{}\PYGZhy{}  http://aprsworld.net/gisdata/world/world.zip
Resolving aprsworld.net... 72.251.203.219
Connecting to aprsworld.net\textbar{}72.251.203.219\textbar{}:80... connected.
HTTP request sent, awaiting response... 200 OK
Length: 3436277 (3.3M) [application/zip]
Saving to: {}`world.zip.1\PYGZsq{}

100\PYGZpc{}[======================================\PYGZgt{}] 3,436,277   3.28M/s   in 1.0s

2013\PYGZhy{}10\PYGZhy{}22 15:47:45 (3.28 MB/s) \PYGZhy{} {}`world.zip.1\PYGZsq{} saved [3436277/3436277]

Archive:  world.zip
  inflating: world.dbf
  inflating: world.shp
  inflating: world.shx
\end{Verbatim}

We need to import \code{ogr}, and then open the file. As with GDAL, we get
a handler to the file, (\code{g} in this case). OGR files can have
different layers, although Shapefiles only have one. We need to select
the layer using \code{GetLayer(0)} (selecting the first layer).

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{osgeo} \PYG{k+kn}{import} \PYG{n}{ogr}

\PYG{n}{g} \PYG{o}{=} \PYG{n}{ogr}\PYG{o}{.}\PYG{n}{Open}\PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{world.shp}\PYG{l+s}{\PYGZdq{}} \PYG{p}{)}
\PYG{n}{layer} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{GetLayer}\PYG{p}{(} \PYG{l+m+mi}{0} \PYG{p}{)}
\end{Verbatim}

In order to see a field (the field \code{NAME}) we can loop over the
features in the layer, and use the \code{GetField('NAME')} method. We'll
only do ten features here:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{n\PYGZus{}feat} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{k}{for} \PYG{n}{feat} \PYG{o+ow}{in} \PYG{n}{layer}\PYG{p}{:}

    \PYG{k}{print} \PYG{n}{feat}\PYG{o}{.}\PYG{n}{GetField}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{NAME}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

    \PYG{n}{n\PYGZus{}feat} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
    \PYG{k}{if} \PYG{n}{n\PYGZus{}feat} \PYG{o}{==} \PYG{l+m+mi}{10}\PYG{p}{:}
        \PYG{k}{break}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
GUATEMALA
BOLIVIA
PARAGUAY
URUGUAY
SURINAME
FRENCH GUIANA
WESTERN SAHARA
GAMBIA
MOROCCO
MALI
\end{Verbatim}

If you wanted to see the different layers, we could do this using:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{layerDefinition} \PYG{o}{=} \PYG{n}{layer}\PYG{o}{.}\PYG{n}{GetLayerDefn}\PYG{p}{(}\PYG{p}{)}


\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{layerDefinition}\PYG{o}{.}\PYG{n}{GetFieldCount}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Field }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{: }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{p}{(} \PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{layerDefinition}\PYG{o}{.}\PYG{n}{GetFieldDefn}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{o}{.}\PYG{n}{GetName}\PYG{p}{(}\PYG{p}{)} \PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
Field 1: NAME
Field 2: CAPITAL
Field 3: APPROX
Field 4: AREA
Field 5: SOURCETHM
\end{Verbatim}

Each feature, in addition to the fields shown agove, will have a
\code{Geometry} field. We get a handle to this using the
\code{GetGeometryRef()} method. Geometries have many methods, such as
\code{ExportToKML()} to export to KML (Google Maps/Earth format):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{the\PYGZus{}geometry} \PYG{o}{=} \PYG{n}{feat}\PYG{o}{.}\PYG{n}{GetGeometryRef}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{the\PYGZus{}geometry}\PYG{o}{.}\PYG{n}{ExportToKML}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZlt{}Polygon\PYGZgt{}\PYGZlt{}outerBoundaryIs\PYGZgt{}\PYGZlt{}LinearRing\PYGZgt{}\PYGZlt{}coordinates\PYGZgt{}\PYGZhy{}12.0443,14.669667 \PYGZhy{}11.87845,14.8252 \PYGZhy{}11.76455,15.039033 \PYGZhy{}11.63345,15.335633 \PYGZhy{}11.58515,15.634533 \PYGZhy{}11.52995,15.6713 \PYGZhy{}11.34705,15.6736 \PYGZhy{}11.26425,15.6529 \PYGZhy{}11.2125,15.549433 \PYGZhy{}11.1849,15.3092 \PYGZhy{}11.0503,15.097667 \PYGZhy{}10.9675,15.086167 \PYGZhy{}10.53275,15.365533 \PYGZhy{}9.70465,15.364367 \PYGZhy{}9.52175,15.373567 \PYGZhy{}9.4631,15.440233 \PYGZhy{}9.43205,15.619567 \PYGZhy{}9.37685,15.658667 \PYGZhy{}9.13185,15.656367 \PYGZhy{}9.1385,15.489433 \PYGZhy{}8.1165,15.487567 \PYGZhy{}6.83415,15.504167 \PYGZhy{}5.513,15.483867 \PYGZhy{}5.25265,16.2627 \PYGZhy{}5.2693,16.3033 \PYGZhy{}5.58505,16.439867 \PYGZhy{}5.63765,16.5635 \PYGZhy{}5.7623,17.728033 \PYGZhy{}5.8814,18.589933 \PYGZhy{}6.02265,19.525633 \PYGZhy{}6.1362,20.697567 \PYGZhy{}6.3107,21.8621 \PYGZhy{}6.4575,22.952833 \PYGZhy{}6.4686,23.543433 \PYGZhy{}6.52675,23.8627 \PYGZhy{}6.7123,24.997733 \PYGZhy{}5.05065,24.9834 \PYGZhy{}5.00065,24.982967 \PYGZhy{}4.51805,24.628633 \PYGZhy{}2.77295,23.4557 \PYGZhy{}2.17905,23.0869 \PYGZhy{}1.6281,22.7265 \PYGZhy{}0.5692,22.030967 0.6009,21.241133 1.0281,21.001933 1.10095,20.985233 1.21475,20.9807 1.21475,20.807767 1.24435,20.7486 1.40825,20.609033 1.5517,20.5514 1.6678,20.3724 1.9421,20.185067 2.0514,20.172933 2.2221,20.168367 2.27785,20.157 2.3348,20.1312 2.4031,20.028033 2.4486,20.009833 2.6307,19.971933 2.8208,19.887733 3.12355,19.778533 3.21345,19.6458 3.19755,19.4501 3.15885,19.3242 3.10535,19.174767 3.13495,19.065567 3.2738,18.875933 3.3091,18.853933 3.3774,18.852433 3.52535,18.9131 3.82355,18.996533 4.34825,19.149 4.34725,19.115667 4.3451,19.045533 4.29825,18.466367 4.23895,17.8664 4.1984,17.276833 4.1766,16.666467 4.1423,16.331633 3.97065,16.208933 3.8864,16.099767 3.85205,15.8315 3.8146,15.700467 3.6305,15.5809 3.4245,15.5081 3.07805,15.428033 2.75035,15.396833 2.3197,15.323 2.10435,15.2731 1.8297,15.216967 1.62995,15.213833 1.41145,15.120267 1.05565,15.0402 0.8809,15.046433 0.6905,15.0402 0.61245,14.965333 0.52195,14.890467 0.419,14.856167 0.238,14.858267 0.1196,14.8782 \PYGZhy{}0.2863,15.048533 \PYGZhy{}0.614,15.108833 \PYGZhy{}0.75445,15.1109 \PYGZhy{}0.82935,15.094267 \PYGZhy{}0.94485,15.018367 \PYGZhy{}1.285,14.7418 \PYGZhy{}1.4754,14.625333 \PYGZhy{}1.6439,14.5723 \PYGZhy{}1.94035,14.462067 \PYGZhy{}2.16195,14.312333 \PYGZhy{}2.24625,14.2094 \PYGZhy{}2.3118,14.0472 \PYGZhy{}2.42415,13.939067 \PYGZhy{}2.69255,13.824667 \PYGZhy{}2.77995,13.596967 \PYGZhy{}3.1014,13.524167 \PYGZhy{}3.3573,13.452433 \PYGZhy{}3.53205,13.248633 \PYGZhy{}3.6725,13.2341 \PYGZhy{}3.84105,13.232 \PYGZhy{}4.0564,13.2653 \PYGZhy{}4.1001,13.256967 \PYGZhy{}4.22805,13.0386 \PYGZhy{}4.24135,12.8486 \PYGZhy{}4.5398,12.277633 \PYGZhy{}4.72495,12.088433 \PYGZhy{}4.7833,12.04 \PYGZhy{}4.8209,12.017533 \PYGZhy{}4.8687,12.0 \PYGZhy{}5.03205,11.943633 \PYGZhy{}5.40485,11.807433 \PYGZhy{}5.4576,11.7805 \PYGZhy{}5.46435,11.758033 \PYGZhy{}5.39025,11.609867 \PYGZhy{}5.38015,11.431733 \PYGZhy{}5.43175,11.337433 \PYGZhy{}5.443,11.246133 \PYGZhy{}5.39135,11.051533 \PYGZhy{}5.40035,10.9767 \PYGZhy{}5.5171,10.836 \PYGZhy{}5.52835,10.806067 \PYGZhy{}5.5073,10.733367 \PYGZhy{}5.5285,10.681033 \PYGZhy{}5.5168,10.6259 \PYGZhy{}5.46805,10.575 \PYGZhy{}5.4553,10.5029 \PYGZhy{}5.46805,10.409567 \PYGZhy{}5.50265,10.376233 \PYGZhy{}5.5873,10.2946 \PYGZhy{}5.72715,10.208567 \PYGZhy{}5.8078,10.1817 \PYGZhy{}5.96645,10.1602 \PYGZhy{}6.0444,10.1602 \PYGZhy{}6.13045,10.187067 \PYGZhy{}6.1466,10.212167 \PYGZhy{}6.1466,10.260567 \PYGZhy{}6.0928,10.3466 \PYGZhy{}6.13855,10.4595 \PYGZhy{}6.17615,10.486367 \PYGZhy{}6.20305,10.486367 \PYGZhy{}6.238,10.477433 \PYGZhy{}6.2837,10.429033 \PYGZhy{}6.3469,10.4165 \PYGZhy{}6.40875,10.421867 \PYGZhy{}6.5405,10.4595 \PYGZhy{}6.5835,10.450533 \PYGZhy{}6.6319,10.423667 \PYGZhy{}6.6561,10.3878 \PYGZhy{}6.66415,10.307167 \PYGZhy{}6.7018,10.267733 \PYGZhy{}6.74755,10.256967 \PYGZhy{}6.8228,10.256967 \PYGZhy{}6.87255,10.239033 \PYGZhy{}6.9801,10.151233 \PYGZhy{}7.06885,10.1315 \PYGZhy{}7.20595,10.1315 \PYGZhy{}7.30005,10.1602 \PYGZhy{}7.33095,10.194267 \PYGZhy{}7.35785,10.310767 \PYGZhy{}7.41165,10.341233 \PYGZhy{}7.45735,10.353767 \PYGZhy{}7.7101,10.351967 \PYGZhy{}7.7531,10.4882 \PYGZhy{}7.8284,10.525833 \PYGZhy{}7.9427,10.529433 \PYGZhy{}8.19545,10.5366 \PYGZhy{}8.26805,10.545533 \PYGZhy{}8.33525,10.5814 \PYGZhy{}8.3339,10.619033 \PYGZhy{}8.28015,10.7176 \PYGZhy{}8.17795,10.921933 \PYGZhy{}8.20755,10.9524 \PYGZhy{}8.3124,10.982867 \PYGZhy{}8.385,10.9739 \PYGZhy{}8.42265,10.947033 \PYGZhy{}8.51945,10.807233 \PYGZhy{}8.627,10.771367 \PYGZhy{}8.67,10.7696 \PYGZhy{}8.68615,10.783933 \PYGZhy{}8.68615,10.8162 \PYGZhy{}8.6458,10.889667 \PYGZhy{}8.6458,10.904 \PYGZhy{}8.68885,10.9273 \PYGZhy{}8.6915,10.9775 \PYGZhy{}8.68615,11.038433 \PYGZhy{}8.666,11.102967 \PYGZhy{}8.6176,11.149567 \PYGZhy{}8.28955,11.3449 \PYGZhy{}8.4401,11.4435 \PYGZhy{}8.77625,11.5761 \PYGZhy{}8.86635,11.6263 \PYGZhy{}8.8986,11.674667 \PYGZhy{}8.88245,11.7123 \PYGZhy{}8.76415,11.8969 \PYGZhy{}8.748,11.998 \PYGZhy{}8.75615,12.0537 \PYGZhy{}8.9702,12.136333 \PYGZhy{}8.90365,12.335867 \PYGZhy{}9.1426,12.388267 \PYGZhy{}9.36645,12.279433 \PYGZhy{}9.7355,12.1323 \PYGZhy{}9.80655,12.0866 \PYGZhy{}9.96635,12.0 \PYGZhy{}10.0388,11.958267 \PYGZhy{}10.1407,11.925833 \PYGZhy{}10.31445,11.925867 \PYGZhy{}10.3944,11.966 \PYGZhy{}10.4546,11.986067 \PYGZhy{}10.4917,11.987633 \PYGZhy{}10.5241,11.975267 \PYGZhy{}10.5465,11.9559 \PYGZhy{}10.5583,11.948633 \PYGZhy{}10.56825,11.944533 \PYGZhy{}10.5777,11.943933 \PYGZhy{}10.58715,11.9458 \PYGZhy{}10.6018,11.9581 \PYGZhy{}10.6155,11.973867 \PYGZhy{}10.6342,12.0 \PYGZhy{}10.6706,12.034 \PYGZhy{}10.6969,12.058533 \PYGZhy{}10.72995,12.058533 \PYGZhy{}10.8209,12.019967 \PYGZhy{}10.8457,12.019967 \PYGZhy{}10.8953,12.053 \PYGZhy{}10.92835,12.149433 \PYGZhy{}10.91185,12.3257 \PYGZhy{}10.9201,12.3615 \PYGZhy{}10.97385,12.358733 \PYGZhy{}11.12265,12.237567 \PYGZhy{}11.17225,12.033733 \PYGZhy{}11.4244,12.141167 \PYGZhy{}11.56495,12.254067 \PYGZhy{}11.60215,12.303667 \PYGZhy{}11.3913,12.429 \PYGZhy{}11.4946,12.489567 \PYGZhy{}11.4326,12.610767 \PYGZhy{}11.5401,12.6824 \PYGZhy{}11.5649,12.7237 \PYGZhy{}11.57315,12.756767 \PYGZhy{}11.4905,12.988133 \PYGZhy{}11.5194,13.096933 \PYGZhy{}11.7385,13.336567 \PYGZhy{}11.8625,13.325567 \PYGZhy{}11.9989,13.344833 \PYGZhy{}12.08155,13.416433 \PYGZhy{}12.08985,13.4798 \PYGZhy{}12.0774,13.866767 \PYGZhy{}12.0443,14.669667\PYGZlt{}/coordinates\PYGZgt{}\PYGZlt{}/LinearRing\PYGZgt{}\PYGZlt{}/outerBoundaryIs\PYGZgt{}\PYGZlt{}/Polygon\PYGZgt{}}\PYG{l+s}{\PYGZsq{}}
\end{Verbatim}

Many of the methods that don't start with \code{\_\_} are interesting. Let's
see what these are. typically, the interesting methods start with an
upper case letter, so we'll only show those:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{m} \PYG{o+ow}{in} \PYG{n+nb}{dir} \PYG{p}{(} \PYG{n}{the\PYGZus{}geometry} \PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{m}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{isupper}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{print} \PYG{n}{m}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{AddGeometry}
\PYG{n}{AddGeometryDirectly}
\PYG{n}{AddPoint}
\PYG{n}{AddPoint\PYGZus{}2D}
\PYG{n}{Area}
\PYG{n}{AssignSpatialReference}
\PYG{n}{Boundary}
\PYG{n}{Buffer}
\PYG{n}{Centroid}
\PYG{n}{Clone}
\PYG{n}{CloseRings}
\PYG{n}{Contains}
\PYG{n}{ConvexHull}
\PYG{n}{Crosses}
\PYG{n}{Destroy}
\PYG{n}{Difference}
\PYG{n}{Disjoint}
\PYG{n}{Distance}
\PYG{n}{Empty}
\PYG{n}{Equal}
\PYG{n}{Equals}
\PYG{n}{ExportToGML}
\PYG{n}{ExportToJson}
\PYG{n}{ExportToKML}
\PYG{n}{ExportToWkb}
\PYG{n}{ExportToWkt}
\PYG{n}{FlattenTo2D}
\PYG{n}{GetArea}
\PYG{n}{GetBoundary}
\PYG{n}{GetCoordinateDimension}
\PYG{n}{GetDimension}
\PYG{n}{GetEnvelope}
\PYG{n}{GetEnvelope3D}
\PYG{n}{GetGeometryCount}
\PYG{n}{GetGeometryName}
\PYG{n}{GetGeometryRef}
\PYG{n}{GetGeometryType}
\PYG{n}{GetPoint}
\PYG{n}{GetPointCount}
\PYG{n}{GetPoint\PYGZus{}2D}
\PYG{n}{GetPoints}
\PYG{n}{GetSpatialReference}
\PYG{n}{GetX}
\PYG{n}{GetY}
\PYG{n}{GetZ}
\PYG{n}{Intersect}
\PYG{n}{Intersection}
\PYG{n}{Intersects}
\PYG{n}{IsEmpty}
\PYG{n}{IsRing}
\PYG{n}{IsSimple}
\PYG{n}{IsValid}
\PYG{n}{Length}
\PYG{n}{Overlaps}
\PYG{n}{PointOnSurface}
\PYG{n}{Segmentize}
\PYG{n}{SetCoordinateDimension}
\PYG{n}{SetPoint}
\PYG{n}{SetPoint\PYGZus{}2D}
\PYG{n}{Simplify}
\PYG{n}{SimplifyPreserveTopology}
\PYG{n}{SymDifference}
\PYG{n}{SymmetricDifference}
\PYG{n}{Touches}
\PYG{n}{Transform}
\PYG{n}{TransformTo}
\PYG{n}{Union}
\PYG{n}{UnionCascaded}
\PYG{n}{Within}
\PYG{n}{WkbSize}
\end{Verbatim}

You'll notice that many of these mechanisms e.g. \code{Overlaps} or
\code{Touches} are effectively geoprocessing operations (they operate on
geometries and return \code{True} if one geometry overlaps or touches,
respectively, the other). Other operations, such as \code{Buffer} return a
buffered version of the same geometry. This allows you to actually do
fairly complicated geoprocessing operations with OGR. However, if you
want to do geoprocessing in earnest, you should really be using
\href{http://toblerity.org/shapely/manual.html}{Shapely}.

A particularly useful webpage for this section is \href{http://pcjericks.github.io/py-gdalogr-cookbook/}{available in the OGR
cookbook}. Have a
look through that if you want more in depth information.


\section{Selecting attributes and/or data extents}
\label{Chapter4_GDAL/OGR_Python:selecting-attributes-and-or-data-extents}
OGR provides an easy way to select attributes on a given layer. This is
done using a SQL-like syntax (you can read more on \href{http://www.gdal.org/ogr/ogr\_sql.html}{OGR's SQL subset
here}. The main point is that
the \emph{attribute filter} is applied to a complete layer. For example,
let's say that we want to select only countries with a population (field
APPROX) larger than 90 000 000 inhabitants:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{g} \PYG{o}{=} \PYG{n}{ogr}\PYG{o}{.}\PYG{n}{Open} \PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{world.shp}\PYG{l+s}{\PYGZdq{}} \PYG{p}{)}
\PYG{n}{lyr} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{GetLayer}\PYG{p}{(} \PYG{l+m+mi}{0} \PYG{p}{)}
\PYG{n}{lyr}\PYG{o}{.}\PYG{n}{SetAttributeFilter} \PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{APPROX \PYGZgt{} 90000000}\PYG{l+s}{\PYGZdq{}} \PYG{p}{)}
\PYG{k}{for} \PYG{n}{feat} \PYG{o+ow}{in} \PYG{n}{lyr}\PYG{p}{:}
    \PYG{k}{print} \PYG{n}{feat}\PYG{o}{.}\PYG{n}{GetFieldAsString} \PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{NAME}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ has }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{ inhabitants}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYGZbs{}
        \PYG{n}{feat}\PYG{o}{.}\PYG{n}{GetFieldAsInteger}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{APPROX}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
PAKISTAN has 123490000 inhabitants
JAPAN has 124710000 inhabitants
RUSSIAN FEDERATION has 150500000 inhabitants
INDIA has 873850000 inhabitants
BANGLADESH has 120850000 inhabitants
BRAZIL has 159630000 inhabitants
NIGERIA has 91700000 inhabitants
CHINA has 1179030000 inhabitants
INDONESIA has 186180000 inhabitants
JOHNSTON ATOLL has 256420000 inhabitants
KINGMAN REEF \PYGZhy{} PALMYRA ATOLL has 256420000 inhabitants
UNITED STATES has 256420000 inhabitants
\end{Verbatim}

So we get a list of popoulous countries (note that Johnston Atoll and
Palmyra are part of the US, and report the sample popuation as the US!)

An additional way to filter the data is by geographical extent. Let's
say we wanted a list of all the countries in (broadly speaking) Europe,
\emph{i.e.} a geographical extent in longitude from 14W to 37E, and in
latitude from 72N to 38N. We can use \code{SetSpatialFilterRect} to do
this:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{g} \PYG{o}{=} \PYG{n}{ogr}\PYG{o}{.}\PYG{n}{Open} \PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{world.shp}\PYG{l+s}{\PYGZdq{}} \PYG{p}{)}
\PYG{n}{lyr} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{GetLayer}\PYG{p}{(} \PYG{l+m+mi}{0} \PYG{p}{)}
\PYG{n}{lyr}\PYG{o}{.}\PYG{n}{SetSpatialFilterRect} \PYG{p}{(} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{14}\PYG{p}{,} \PYG{l+m+mi}{37}\PYG{p}{,} \PYG{l+m+mi}{38}\PYG{p}{,} \PYG{l+m+mi}{72}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{feat} \PYG{o+ow}{in} \PYG{n}{lyr}\PYG{p}{:}
    \PYG{k}{print} \PYG{n}{feat}\PYG{o}{.}\PYG{n}{GetFieldAsString} \PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{NAME}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{feat}\PYG{o}{.}\PYG{n}{GetFieldAsString} \PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{CAPITAL}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
ALGERIA \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} ALGIERS
BELGIUM \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} BRUSSELS
LUXEMBOURG \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} LUXEMBOURG
SAN MARINO \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} SAN MARINO
AUSTRIA \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} VIENNA
CZECH REPUBLIC \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} PRAGUE
SLOVENIA \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} LJUBLJANA
HUNGARY \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} BUDAPEST
SLOVAKIA \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} BRATISLAVA
YUGOSLAVIA \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} BELGRADE [BEOGRADE]
BOSNIA AND HERZEGOVINA \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} SARAJEVO
ALBANIA \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} TIRANE
MACEDONIA, THE FORMER YUGOSLAV REPUBLIC \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} SKOPJE
LITHUANIA \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} VILNIUS
LATVIA \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} RIGA
BULGARIA \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} SOFIA
BELARUS \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} MINSK
MOLDOVA, REPUBLIC OF \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} KISHINEV
IRELAND \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} DUBLIN
ICELAND \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} REYKJAVIK
SPAIN \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} MADRID
SWEDEN \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} STOCKHOLM
FINLAND \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} HELSINKI
TURKEY \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} ANKARA
RUSSIAN FEDERATION \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} MOSCOW
GREECE \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} ATHENS
PORTUGAL \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} LISBON
POLAND \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} WARSAW
NORWAY \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} OSLO
GERMANY \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} BERLIN
ESTONIA \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} TALLINN
TUNISIA \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} TUNIS
CROATIA \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} ZAGREB
ROMANIA \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} BUCURESTI
UKRAINE \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} KIEV
NETHERLANDS \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} AMSTERDAM
JERSEY \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} SAINT HELIER
GUERNSEY \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} SAINT PETER PORT
FAROE ISLANDS \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} TORSHAVN
DENMARK \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} COPENHAGEN
MONACO \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} MONACO
ANDORRA \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} ANDORRA LA VELLA
LIECHTENSTEIN \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} VADUZ
SWITZERLAND \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} BERN
ISLE OF MAN \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} DOUGLAS
UNITED KINGDOM \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} LONDON
FRANCE \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} PARIS
VATICAN CITY (HOLY SEE) \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} VATICAN CITY
ITALY \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} ROME
\end{Verbatim}


\section{Saving a vector file}
\label{Chapter4_GDAL/OGR_Python:saving-a-vector-file}
Saving a vector file using OGR requires a number of steps:
\begin{enumerate}
\item {} 
Definition of the format

\item {} 
Definition of the layer projection and geometry type (e.g. lines,
polygons...)

\item {} 
Definition of the data type of the different fields

\item {} 
Creation of a feature, population of the different fields, and
setting a geometry

\item {} 
Addition of the feature to the layer

\item {} 
Destruction of the feature

\end{enumerate}

This appears quite involved, but let's see how this works. Note that
when you generate a new vector file, OGR will fail if the file already
exists. You might want to use \code{os.remove()} to get rid of the file if
it exists.

Let's see how this is done with an example which is a snippet that
creates a GeoJSON file with the location of the different national
parks. GeoJSON is a nice geographic format, and \href{https://github.com/blog/1528-there-s-a-map-for-that}{github allows you to
display it easily as a
map}.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} National park information, separated by TABs}
\PYG{k+kn}{import} \PYG{n+nn}{os}
\PYG{k+kn}{from} \PYG{n+nn}{osgeo} \PYG{k+kn}{import} \PYG{n}{ogr}\PYG{p}{,}\PYG{n}{osr}


\PYG{n}{parks} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}\PYG{l+s}{Dartmoor national park}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZhy{}3.904}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{50.58}
\PYG{l+s}{New forest national park}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZhy{}1.595}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{50.86}
\PYG{l+s}{Exmoor national park}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZhy{}3.651}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{51.14}
\PYG{l+s}{Pembrokeshire coast national park}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZhy{}4.694}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{51.64}
\PYG{l+s}{Brecon beacons national park}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZhy{}3.432}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{51.88}
\PYG{l+s}{Pembrokeshire coast national park}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZhy{}4.79}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{51.99}
\PYG{l+s}{Norfolk and suffolk broads}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{1.569}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{52.62}
\PYG{l+s}{Snowdonia national park}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZhy{}3.898}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{52.9}
\PYG{l+s}{Peak district national park}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZhy{}1.802}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{53.3}
\PYG{l+s}{Yorkshire dales national park}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZhy{}2.157}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{54.23}
\PYG{l+s}{North yorkshire moors national park}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZhy{}0.8855}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{54.37}
\PYG{l+s}{Lake district national park}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZhy{}3.084}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{54.47}
\PYG{l+s}{Galloway forest park}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZhy{}4.171}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{54.87}
\PYG{l+s}{Northumberland national park}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZhy{}2.228}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{55.28}
\PYG{l+s}{Loch lomond and the trossachs national park}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZhy{}4.593}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{56.24}
\PYG{l+s}{Tay forest park}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZhy{}4.025}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{56.59}
\PYG{l+s}{Cairngorms national park}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZhy{}3.545}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{57.08}\PYG{l+s}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}

\PYG{c}{\PYGZsh{} See if the file exists from a previous run of this snippet}
\PYG{k}{if} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{exists} \PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{parks.json}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{:}
    \PYG{c}{\PYGZsh{} It does exist, so remove it}
    \PYG{n}{os}\PYG{o}{.}\PYG{n}{remove} \PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{parks.json}\PYG{l+s}{\PYGZdq{}} \PYG{p}{)}

\PYG{c}{\PYGZsh{} We need the output projection to bet set to Lat/Long}
\PYG{n}{latlong} \PYG{o}{=} \PYG{n}{osr}\PYG{o}{.}\PYG{n}{SpatialReference}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{latlong}\PYG{o}{.}\PYG{n}{ImportFromEPSG}\PYG{p}{(} \PYG{l+m+mi}{4326} \PYG{p}{)}

\PYG{c}{\PYGZsh{} Invoke the GeoJSON driver}
\PYG{n}{drv} \PYG{o}{=} \PYG{n}{ogr}\PYG{o}{.}\PYG{n}{GetDriverByName}\PYG{p}{(} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{GeoJSON}\PYG{l+s}{\PYGZsq{}} \PYG{p}{)}
\PYG{c}{\PYGZsh{} This is the output filename}
\PYG{n}{dst\PYGZus{}ds} \PYG{o}{=} \PYG{n}{drv}\PYG{o}{.}\PYG{n}{CreateDataSource}\PYG{p}{(} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{parks.json}\PYG{l+s}{\PYGZsq{}} \PYG{p}{)}
\PYG{c}{\PYGZsh{} This is a single layer dataset. The layer needs to be of points}
\PYG{c}{\PYGZsh{} and needs to have the WGS84 projection, which we defined above}
\PYG{n}{dst\PYGZus{}layer} \PYG{o}{=} \PYG{n}{dst\PYGZus{}ds}\PYG{o}{.}\PYG{n}{CreateLayer}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{srs} \PYG{o}{=}\PYG{n}{latlong} \PYG{p}{,} \PYGZbs{}
                               \PYG{n}{geom\PYGZus{}type}\PYG{o}{=}\PYG{n}{ogr}\PYG{o}{.}\PYG{n}{wkbPoint} \PYG{p}{)}

\PYG{c}{\PYGZsh{} We just need a field with the Park\PYGZsq{}s name, and its type is a String}
\PYG{n}{field\PYGZus{}defn}\PYG{o}{=}\PYG{n}{ogr}\PYG{o}{.}\PYG{n}{FieldDefn}\PYG{p}{(} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{name}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{ogr}\PYG{o}{.}\PYG{n}{OFTString} \PYG{p}{)}
\PYG{n}{dst\PYGZus{}layer}\PYG{o}{.}\PYG{n}{CreateField}\PYG{p}{(} \PYG{n}{field\PYGZus{}defn} \PYG{p}{)}


\PYG{c}{\PYGZsh{} Algorithm is as follows:}
\PYG{c}{\PYGZsh{} 1. Loop over lines}
\PYG{c}{\PYGZsh{} 2. Split line into park name, longitude, latitude}
\PYG{c}{\PYGZsh{} 3. Create WKT of the point}
\PYG{c}{\PYGZsh{} 4. Set the attribute name to name of park}
\PYG{c}{\PYGZsh{} 5. Clean up}

\PYG{k}{for} \PYG{n}{park\PYGZus{}id}\PYG{p}{,} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(} \PYG{n}{parks}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{p}{)} \PYG{p}{)}\PYG{p}{:}
    \PYG{c}{\PYGZsh{} Get the relevant information}
    \PYG{n}{park\PYGZus{}name}\PYG{p}{,} \PYG{n}{lon}\PYG{p}{,} \PYG{n}{lat} \PYG{o}{=} \PYG{n}{line}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
    \PYG{c}{\PYGZsh{} Create a geogrpahical representation of the current park}
    \PYG{n}{wkt} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{POINT ( }\PYG{l+s+si}{\PYGZpc{}f}\PYG{l+s}{ }\PYG{l+s+si}{\PYGZpc{}f}\PYG{l+s}{ )}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{p}{(} \PYG{n+nb}{float}\PYG{p}{(}\PYG{n}{lon}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{float}\PYG{p}{(}\PYG{n}{lat}\PYG{p}{)} \PYG{p}{)}
    \PYG{c}{\PYGZsh{} Create a feature, using the attributes/fields that are}
    \PYG{c}{\PYGZsh{} required for this layer}
    \PYG{n}{feat} \PYG{o}{=} \PYG{n}{ogr}\PYG{o}{.}\PYG{n}{Feature}\PYG{p}{(}\PYG{n}{feature\PYGZus{}def}\PYG{o}{=}\PYG{n}{dst\PYGZus{}layer}\PYG{o}{.}\PYG{n}{GetLayerDefn}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{c}{\PYGZsh{} Feed the WKT into a geometry}
    \PYG{n}{p} \PYG{o}{=} \PYG{n}{ogr}\PYG{o}{.}\PYG{n}{CreateGeometryFromWkt}\PYG{p}{(} \PYG{n}{wkt} \PYG{p}{)}
    \PYG{c}{\PYGZsh{} Feed the geometry into a WKT}
    \PYG{n}{feat}\PYG{o}{.}\PYG{n}{SetGeometryDirectly}\PYG{p}{(} \PYG{n}{p} \PYG{p}{)}
    \PYG{c}{\PYGZsh{} Set the name field to its value}
    \PYG{n}{feat}\PYG{o}{.}\PYG{n}{SetField} \PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{name}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{park\PYGZus{}name} \PYG{p}{)}
    \PYG{c}{\PYGZsh{} Attach the feature to the layer}
    \PYG{n}{dst\PYGZus{}layer}\PYG{o}{.}\PYG{n}{CreateFeature}\PYG{p}{(} \PYG{n}{feat} \PYG{p}{)}
    \PYG{c}{\PYGZsh{} Clean up}
    \PYG{n}{feat}\PYG{o}{.}\PYG{n}{Destroy}\PYG{p}{(}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Close file}
\PYG{n}{dst\PYGZus{}ds} \PYG{o}{=} \PYG{n+nb+bp}{None}
\end{Verbatim}

You can see the result of this on
\href{https://gist.github.com/jgomezdans/6811102}{github}.

Additionally, note that if we had defined a coordinate transformation as
in the raster session, we could apply this transformation to an OGR
geometry entity (in the snippet above, \code{p} would be such), and it
would be reprojected.

\textbf{Exercise} Modify the above snippet to output a GeoJSON file for the
Peak District National Park, whose UTM30N (\href{http://spatialreference.org/ref/epsg/32630/}{EPSG code:
32630}) co-ordinates are
\(577659, 5911841\).


\section{Rasterising}
\label{Chapter4_GDAL/OGR_Python:rasterising}
A very frequent problem one finds is how to mask out an area in a raster
file that is defined as polygon in a shapefile. For example, if you have
a raster of the worlds population density, and you want to extract all
the pixels that belong to one particular country, how do you go about
that? One way around this is to \emph{rasterise} the polygon(s), which
translates into ``burning'' pixels that fall within the polygon with a
number, resulting in a mask.

The way to do this is to use GDAL's \code{RasterizeLayer} method. The
method takes a handle to a GDAL dataset (one that you create yourself,
with the right projection and geotransform, as you've seen above), and a
OGR layer. The syntax for \code{RasterizeLayer} is

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{err} \PYG{o}{=} \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{RasterizeLayer} \PYG{p}{(} \PYG{n}{raster\PYGZus{}ds}\PYG{p}{,} \PYG{p}{[}\PYG{n}{raster\PYGZus{}band\PYGZus{}no}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ogr\PYGZus{}layer}\PYG{p}{,} \PYG{n}{burn\PYGZus{}values}\PYG{o}{=}\PYG{p}{[}\PYG{n}{burn\PYGZus{}val}\PYG{p}{]} \PYG{p}{)}
\end{Verbatim}

where \code{raster\_ds} is the GDAL raster datasource (note that it needs to
be georreferenced, \emph{i.e.} it requires projection and geotransform),
\code{raster\_band\_no} is the band of the GDAL dataset where we want to burn
pixels, \code{ogr\_layer} is the vector layer object, and \code{burn\_val} is
the value that we want to burn.

Let's use \code{gdal.RasterizeLayer} in conjunction with all that we have
covered above. Say we want to create a mask that only selects the UK or
Ireland in \code{world.shp}, and we want to apply this mask to the MODIS
landcover product that we used in the GDAL session (h17v03 tile ), file
\code{lc\_h17v03.tif}. We find that in this case, \code{world.shp} is in
longitude latitude, and the MODIS data is in the MODIS projection, so we
will reproject the vector data to match the MODIS data (so the latter is
not interpolated and artifacts introduced). To make this efficient and
avoid saving to disk, we shall use \emph{in-memory vector and rasters}, and
we will output a numpy array as our mask. Note then the steps:
\begin{enumerate}
\item {} 
Crate the projection conversion object (as for GDAL before)

\item {} 
Create an in memory \textbf{raster} dataset to store the mask, using
\code{lc\_h17v03.tif} as a reference for geotransforms, array size and
projection.

\item {} 
Create an in memory \textbf{vector} dataset to hold the features that will
be reprojected

\item {} 
Open \code{world.shp} and apply an \code{AttributeFilter} to select a
country

\item {} 
Select a geometry from \code{world.shp}, project it and store it in the
destination in memory vector layer

\item {} 
Once this is done, use \code{gdal.RasterizeLayer} with both in-memory
raster and vector datasets

\item {} 
Read the in memory raster into an array

\end{enumerate}

This is a particularly good exercise that will stress all that we have
learned so far.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{osgeo} \PYG{k+kn}{import} \PYG{n}{ogr}\PYG{p}{,}\PYG{n}{osr}
\PYG{k+kn}{import} \PYG{n+nn}{gdal}

\PYG{n}{reference\PYGZus{}filename} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{lc\PYGZus{}h17v03.tif}\PYG{l+s}{\PYGZdq{}}
\PYG{n}{target\PYGZus{}vector\PYGZus{}file} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{world.shp}\PYG{l+s}{\PYGZdq{}}
\PYG{n}{attribute\PYGZus{}filter} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{NAME = }\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{IRELAND}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZdq{}}
\PYG{n}{burn\PYGZus{}value} \PYG{o}{=} \PYG{l+m+mi}{1}

\PYG{c}{\PYGZsh{} First, open the file that we\PYGZsq{}ll be taking as a reference}
\PYG{c}{\PYGZsh{} We will need to gleam the size in pixels, as well as projection}
\PYG{c}{\PYGZsh{} and geotransform.}

\PYG{n}{g} \PYG{o}{=} \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{Open}\PYG{p}{(} \PYG{n}{reference\PYGZus{}filename} \PYG{p}{)}

\PYG{c}{\PYGZsh{} We now create an in\PYGZhy{}memory raster, with the appropriate dimensions}
\PYG{n}{drv} \PYG{o}{=} \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{GetDriverByName}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MEM}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{target\PYGZus{}ds} \PYG{o}{=} \PYG{n}{drv}\PYG{o}{.}\PYG{n}{Create}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{g}\PYG{o}{.}\PYG{n}{RasterXSize}\PYG{p}{,} \PYG{n}{g}\PYG{o}{.}\PYG{n}{RasterXSize}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,}  \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{GDT\PYGZus{}Byte}\PYG{p}{)}
\PYG{n}{target\PYGZus{}ds}\PYG{o}{.}\PYG{n}{SetGeoTransform}\PYG{p}{(} \PYG{n}{g}\PYG{o}{.}\PYG{n}{GetGeoTransform}\PYG{p}{(}\PYG{p}{)} \PYG{p}{)}

\PYG{c}{\PYGZsh{} We set up a transform object as we saw in the previous notebook.}
\PYG{c}{\PYGZsh{} This goes from WGS84 to the projection in the reference datasets}

\PYG{n}{wgs84} \PYG{o}{=} \PYG{n}{osr}\PYG{o}{.}\PYG{n}{SpatialReference}\PYG{p}{(} \PYG{p}{)} \PYG{c}{\PYGZsh{} Define a SpatialReference object}
\PYG{n}{wgs84}\PYG{o}{.}\PYG{n}{ImportFromEPSG}\PYG{p}{(} \PYG{l+m+mi}{4326} \PYG{p}{)} \PYG{c}{\PYGZsh{} And set it to WGS84 using the EPSG code}

\PYG{c}{\PYGZsh{} Now for the target projection, Ordnance Survey\PYGZsq{}s British National Grid}
\PYG{n}{to\PYGZus{}proj} \PYG{o}{=} \PYG{n}{osr}\PYG{o}{.}\PYG{n}{SpatialReference}\PYG{p}{(}\PYG{p}{)} \PYG{c}{\PYGZsh{} define the SpatialReference object}
\PYG{c}{\PYGZsh{} In this case, we get the projection from a Proj4 string}

\PYG{c}{\PYGZsh{} or, if using the proj4 representation}
\PYG{n}{to\PYGZus{}proj}\PYG{o}{.}\PYG{n}{ImportFromWkt}\PYG{p}{(} \PYG{n}{g}\PYG{o}{.}\PYG{n}{GetProjectionRef}\PYG{p}{(}\PYG{p}{)} \PYG{p}{)}
\PYG{n}{target\PYGZus{}ds}\PYG{o}{.}\PYG{n}{SetProjection} \PYG{p}{(} \PYG{n}{to\PYGZus{}proj}\PYG{o}{.}\PYG{n}{ExportToWkt}\PYG{p}{(}\PYG{p}{)} \PYG{p}{)}
\PYG{c}{\PYGZsh{} Now, we define a coordinate transformtion object, *from* wgs84 *to* OSNG}
\PYG{n}{tx} \PYG{o}{=} \PYG{n}{osr}\PYG{o}{.}\PYG{n}{CoordinateTransformation}\PYG{p}{(} \PYG{n}{wgs84}\PYG{p}{,} \PYG{n}{to\PYGZus{}proj} \PYG{p}{)}

\PYG{c}{\PYGZsh{} We define an output in\PYGZhy{}memory OGR dataset}
\PYG{c}{\PYGZsh{} You could also do select a driver for an eg \PYGZdq{}ESRI Shapefile\PYGZdq{} here}
\PYG{c}{\PYGZsh{} and give it a sexier name than out!}

\PYG{n}{drv} \PYG{o}{=} \PYG{n}{ogr}\PYG{o}{.}\PYG{n}{GetDriverByName}\PYG{p}{(} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Memory}\PYG{l+s}{\PYGZsq{}} \PYG{p}{)}
\PYG{n}{dst\PYGZus{}ds} \PYG{o}{=} \PYG{n}{drv}\PYG{o}{.}\PYG{n}{CreateDataSource}\PYG{p}{(} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{out}\PYG{l+s}{\PYGZsq{}} \PYG{p}{)}
\PYG{c}{\PYGZsh{} This is a single layer dataset. The layer needs to be of polygons}
\PYG{c}{\PYGZsh{} and needs to have the target files\PYGZsq{} projection}
\PYG{n}{dst\PYGZus{}layer} \PYG{o}{=} \PYG{n}{dst\PYGZus{}ds}\PYG{o}{.}\PYG{n}{CreateLayer}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{srs} \PYG{o}{=} \PYG{n}{to\PYGZus{}proj}\PYG{p}{,} \PYG{n}{geom\PYGZus{}type}\PYG{o}{=}\PYG{n}{ogr}\PYG{o}{.}\PYG{n}{wkbPolygon} \PYG{p}{)}

\PYG{c}{\PYGZsh{} Open the original shapefile, get the first layer, and filter by attribute}
\PYG{n}{vector\PYGZus{}ds} \PYG{o}{=} \PYG{n}{ogr}\PYG{o}{.}\PYG{n}{Open}\PYG{p}{(} \PYG{n}{target\PYGZus{}vector\PYGZus{}file} \PYG{p}{)}
\PYG{n}{lyr} \PYG{o}{=} \PYG{n}{vector\PYGZus{}ds}\PYG{o}{.}\PYG{n}{GetLayer} \PYG{p}{(} \PYG{l+m+mi}{0} \PYG{p}{)}
\PYG{n}{lyr}\PYG{o}{.}\PYG{n}{SetAttributeFilter}\PYG{p}{(} \PYG{n}{attribute\PYGZus{}filter} \PYG{p}{)}


\PYG{c}{\PYGZsh{} Get a field definition from the original vector file.}
\PYG{c}{\PYGZsh{} We don\PYGZsq{}t need much more detail here}
\PYG{n}{feature} \PYG{o}{=} \PYG{n}{lyr}\PYG{o}{.}\PYG{n}{GetFeature}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{field} \PYG{o}{=} \PYG{n}{feature}\PYG{o}{.}\PYG{n}{GetFieldDefnRef}\PYG{p}{(} \PYG{l+m+mi}{0} \PYG{p}{)}
\PYG{c}{\PYGZsh{} Apply the field definition from the original to the output}
\PYG{n}{dst\PYGZus{}layer}\PYG{o}{.}\PYG{n}{CreateField}\PYG{p}{(} \PYG{n}{field} \PYG{p}{)}
\PYG{n}{feature\PYGZus{}defn} \PYG{o}{=} \PYG{n}{dst\PYGZus{}layer}\PYG{o}{.}\PYG{n}{GetLayerDefn}\PYG{p}{(}\PYG{p}{)}
\PYG{c}{\PYGZsh{} Reset the original layer so we can read all features}
\PYG{n}{lyr}\PYG{o}{.}\PYG{n}{ResetReading}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{feat} \PYG{o+ow}{in} \PYG{n}{lyr}\PYG{p}{:}
    \PYG{c}{\PYGZsh{} For each feature, get the geometry}
    \PYG{n}{geom} \PYG{o}{=} \PYG{n}{feat}\PYG{o}{.}\PYG{n}{GetGeometryRef}\PYG{p}{(}\PYG{p}{)}
    \PYG{c}{\PYGZsh{} transform it to the reference projection}
    \PYG{n}{geom}\PYG{o}{.}\PYG{n}{Transform} \PYG{p}{(} \PYG{n}{tx} \PYG{p}{)}
    \PYG{c}{\PYGZsh{} Create an output feature}
    \PYG{n}{out\PYGZus{}geom} \PYG{o}{=} \PYG{n}{ogr}\PYG{o}{.}\PYG{n}{Feature} \PYG{p}{(} \PYG{n}{feature\PYGZus{}defn} \PYG{p}{)}
    \PYG{c}{\PYGZsh{} Set the geometry to be the reprojected/transformed geometry}
    \PYG{n}{out\PYGZus{}geom}\PYG{o}{.}\PYG{n}{SetGeometry} \PYG{p}{(} \PYG{n}{geom} \PYG{p}{)}
    \PYG{c}{\PYGZsh{} Add the feature with its geometry to the output yaer}
    \PYG{n}{dst\PYGZus{}layer}\PYG{o}{.}\PYG{n}{CreateFeature}\PYG{p}{(}\PYG{n}{out\PYGZus{}geom} \PYG{p}{)}
    \PYG{c}{\PYGZsh{} Clear things up}
    \PYG{n}{out\PYGZus{}geom}\PYG{o}{.}\PYG{n}{Destroy}
    \PYG{n}{geom}\PYG{o}{.}\PYG{n}{Destroy}
\PYG{c}{\PYGZsh{} Done adding geometries}
\PYG{c}{\PYGZsh{} Reset the output layer to the 0th geometry}
\PYG{n}{dst\PYGZus{}layer}\PYG{o}{.}\PYG{n}{ResetReading}\PYG{p}{(}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Now, we rastertize the output vector in\PYGZhy{}memory file}
\PYG{c}{\PYGZsh{} into the in\PYGZhy{}memory output raster file}

\PYG{n}{err} \PYG{o}{=} \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{RasterizeLayer}\PYG{p}{(}\PYG{n}{target\PYGZus{}ds}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{dst\PYGZus{}layer}\PYG{p}{,}
            \PYG{n}{burn\PYGZus{}values}\PYG{o}{=}\PYG{p}{[}\PYG{n}{burn\PYGZus{}value}\PYG{p}{]}\PYG{p}{)}
\PYG{k}{if} \PYG{n}{err} \PYG{o}{!=} \PYG{l+m+mi}{0}\PYG{p}{:}
    \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{error:}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{err}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Read the data from the raster, this is your mask}
\PYG{n}{data} \PYG{o}{=} \PYG{n}{target\PYGZus{}ds}\PYG{o}{.}\PYG{n}{ReadAsArray}\PYG{p}{(}\PYG{p}{)}



\PYG{c}{\PYGZsh{} Plotting to see whether this makes sense.}

\PYG{n}{ndata} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{ReadAsArray}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow} \PYG{p}{(} \PYG{n}{ndata}\PYG{p}{,} \PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nearest}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{n}{plt}\PYG{o}{.}\PYG{n}{cm}\PYG{o}{.}\PYG{n}{gray}\PYG{p}{,} \PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{vmax}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{alpha}\PYG{o}{=}\PYG{l+m+mf}{0.3} \PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{hold} \PYG{p}{(} \PYG{n+nb+bp}{True} \PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow} \PYG{p}{(} \PYG{n}{data}\PYG{p}{,} \PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nearest}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{n}{plt}\PYG{o}{.}\PYG{n}{cm}\PYG{o}{.}\PYG{n}{gray}\PYG{p}{,} \PYG{n}{alpha}\PYG{o}{=}\PYG{l+m+mf}{0.7} \PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{grid} \PYG{p}{(} \PYG{n+nb+bp}{False} \PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\includegraphics{OGR_Python_28_0.png}


\section{Using matplotlib to plot geometries}
\label{Chapter4_GDAL/OGR_Python:using-matplotlib-to-plot-geometries}
Using matplotlib to plot geometries from OGR can be quite tedious.
Here's an example of plotting a map of Angola from the \code{world.shp}. In
the same vein of recommending Shapely and Fiona above for serious
geoprocessing of vector data, you are encouraged to use
\href{https://bitbucket.org/sgillies/descartes/}{descartes} for plotting
vector data!

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib.path} \PYG{k+kn}{as} \PYG{n+nn}{mpath}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib.patches} \PYG{k+kn}{as} \PYG{n+nn}{mpatches}


\PYG{c}{\PYGZsh{} Extract first layer of features from shapefile using OGR}
\PYG{n}{ds} \PYG{o}{=} \PYG{n}{ogr}\PYG{o}{.}\PYG{n}{Open}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{world.shp}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{lyr} \PYG{o}{=} \PYG{n}{ds}\PYG{o}{.}\PYG{n}{GetLayer}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}


\PYG{c}{\PYGZsh{} Prepare figure}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ioff}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplot}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{gca}\PYG{p}{(}\PYG{p}{)}


\PYG{n}{paths} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{lyr}\PYG{o}{.}\PYG{n}{ResetReading}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{lyr}\PYG{o}{.}\PYG{n}{SetAttributeFilter} \PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ NAME = }\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{ANGOLA}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlim}\PYG{p}{(}\PYG{l+m+mi}{11}\PYG{p}{,} \PYG{l+m+mf}{24.5} \PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylim}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{c}{\PYGZsh{} Read all features in layer and store as paths}

\PYG{k}{for} \PYG{n}{feat} \PYG{o+ow}{in} \PYG{n}{lyr}\PYG{p}{:}

    \PYG{k}{for} \PYG{n}{geom} \PYG{o+ow}{in} \PYG{n}{feat}\PYG{o}{.}\PYG{n}{GetGeometryRef}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{envelope} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(} \PYG{n}{geom}\PYG{o}{.}\PYG{n}{GetEnvelope}\PYG{p}{(}\PYG{p}{)} \PYG{p}{)}
        \PYG{c}{\PYGZsh{} check if geom is polygon}
        \PYG{k}{if} \PYG{n}{geom}\PYG{o}{.}\PYG{n}{GetGeometryType}\PYG{p}{(}\PYG{p}{)} \PYG{o}{==} \PYG{n}{ogr}\PYG{o}{.}\PYG{n}{wkbPolygon}\PYG{p}{:}
            \PYG{n}{codes} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
            \PYG{n}{all\PYGZus{}x} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
            \PYG{n}{all\PYGZus{}y} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
            \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{geom}\PYG{o}{.}\PYG{n}{GetGeometryCount}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                \PYG{c}{\PYGZsh{} Read ring geometry and create path}
                \PYG{n}{r} \PYG{o}{=} \PYG{n}{geom}\PYG{o}{.}\PYG{n}{GetGeometryRef}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}
                \PYG{n}{x} \PYG{o}{=} \PYG{p}{[}\PYG{n}{r}\PYG{o}{.}\PYG{n}{GetX}\PYG{p}{(}\PYG{n}{j}\PYG{p}{)} \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{r}\PYG{o}{.}\PYG{n}{GetPointCount}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{]}
                \PYG{n}{y} \PYG{o}{=} \PYG{p}{[}\PYG{n}{r}\PYG{o}{.}\PYG{n}{GetY}\PYG{p}{(}\PYG{n}{j}\PYG{p}{)} \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{r}\PYG{o}{.}\PYG{n}{GetPointCount}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{]}
                \PYG{c}{\PYGZsh{} skip boundary between individual rings}
                \PYG{n}{codes} \PYG{o}{+}\PYG{o}{=} \PYG{p}{[}\PYG{n}{mpath}\PYG{o}{.}\PYG{n}{Path}\PYG{o}{.}\PYG{n}{MOVETO}\PYG{p}{]} \PYG{o}{+} \PYGZbs{}
                             \PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{p}{[}\PYG{n}{mpath}\PYG{o}{.}\PYG{n}{Path}\PYG{o}{.}\PYG{n}{LINETO}\PYG{p}{]}
                \PYG{n}{all\PYGZus{}x} \PYG{o}{+}\PYG{o}{=} \PYG{n}{x}
                \PYG{n}{all\PYGZus{}y} \PYG{o}{+}\PYG{o}{=} \PYG{n}{y}
            \PYG{n}{path} \PYG{o}{=} \PYG{n}{mpath}\PYG{o}{.}\PYG{n}{Path}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{column\PYGZus{}stack}\PYG{p}{(}\PYG{p}{(}\PYG{n}{all\PYGZus{}x}\PYG{p}{,}\PYG{n}{all\PYGZus{}y}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{n}{codes}\PYG{p}{)}
            \PYG{n}{paths}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{path}\PYG{p}{)}
    \PYG{c}{\PYGZsh{} Add paths as patches to axes}
    \PYG{k}{for} \PYG{n}{path} \PYG{o+ow}{in} \PYG{n}{paths}\PYG{p}{:}
        \PYG{n}{patch} \PYG{o}{=} \PYG{n}{mpatches}\PYG{o}{.}\PYG{n}{PathPatch}\PYG{p}{(}\PYG{n}{path}\PYG{p}{,} \PYGZbs{}
                \PYG{n}{facecolor}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{0.8}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{edgecolor}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{black}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{ax}\PYG{o}{.}\PYG{n}{add\PYGZus{}patch}\PYG{p}{(}\PYG{n}{patch}\PYG{p}{)}



\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}aspect}\PYG{p}{(}\PYG{l+m+mf}{1.0}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\includegraphics{OGR_Python_31_0.png}


\chapter{A4.1. Getting MODIS URLs}
\label{Chapter4_GDAL/advanced:a4-1-getting-modis-urls}\label{Chapter4_GDAL/advanced::doc}
Access to MODIS data is now through \code{http}, which means that previous
methods using \code{ftp} no longer operate.

In some ways, this complicates automatic download (also, download seems
now to be throttled, which means it takes longer to access the data).

That said, you can of course still easily order data through NASA tools
such as \href{http://reverb.echo.nasa.gov}{reverb}.

Some tools have been developed to allow automated access to MODIS
products from Python, such as
\href{https://github.com/jgomezdans/get\_modis}{get\_modis}, but here, we
will demonstrate how you can do it yourself, semi-automatically.

We will see that a large part of the overhead and complexity is
negotiating the directory structure.

We have provided a shell programme \code{{}`zat} \textless{}files/python/zat\textgreater{}{}`\_\_ that
will produce a list of urls of the MODIS products on the USGS server
(use \code{zat \textgreater{}} \code{{}`urls.txt} \textless{}files/data/robot.txt\textgreater{}{}`\_\_), which you would
probably find more convenient than this section.

So, only go through section A1 if you are particularly intererested in
trawling directories with http ...

Once we have a full list of the urls of the hdf files that we want, life
is much simpler. Such a list of urls is \emph{exactly} what
\href{http://reverb.echo.nasa.gov}{reverb} supplies you with.


\section{A4.1.1 Identify the server and directory structure}
\label{Chapter4_GDAL/advanced:a4-1-1-identify-the-server-and-directory-structure}
First, you need to identify which datasets you want. You should explore
the data products e.g. through \href{http://reverb.echo.nasa.gov}{reverb}
to do this.

If you go through the ordering system for one tile of these products,
you can get the information you need for further data download. When you
come to order the data, it will give you a download file.

As an example:
\begin{itemize}
\item {} 
MODIS LAI/fAPAR for Trerra and Aqua 8 day composite for 17 Jan 2013
for tile h18v03
\begin{quote}

\href{http://e4ftl01.cr.usgs.gov/MODIS\_Composites/MOTA/MCD15A2.005/2013.01.17/MCD15A2.A2013017.h18v03.005.2013026065052.hdf}{http://e4ftl01.cr.usgs.gov/MODIS\_Composites/MOTA/MCD15A2.005/2013.01.17/MCD15A2.A2013017.h18v03.005.2013026065052.hdf}
\end{quote}

\end{itemize}

\href{http://e4ftl01.cr.usgs.gov/WORKING/BRWS/Browse.001/2013.01.26/BROWSE.MCD15A2.A2013017.h18v03.005.2013026065052.1.jpg}{http://e4ftl01.cr.usgs.gov/WORKING/BRWS/Browse.001/2013.01.26/BROWSE.MCD15A2.A2013017.h18v03.005.2013026065052.1.jpg}
\href{http://e4ftl01.cr.usgs.gov/WORKING/BRWS/Browse.001/2013.01.26/BROWSE.MCD15A2.A2013017.h18v03.005.2013026065052.2.jpg}{http://e4ftl01.cr.usgs.gov/WORKING/BRWS/Browse.001/2013.01.26/BROWSE.MCD15A2.A2013017.h18v03.005.2013026065052.2.jpg}
\href{http://e4ftl01.cr.usgs.gov/MODIS\_Composites/MOTA/MCD15A2.005/2013.01.17/MCD15A2.A2013017.h18v03.005.2013026065052.hdf.xml}{http://e4ftl01.cr.usgs.gov/MODIS\_Composites/MOTA/MCD15A2.005/2013.01.17/MCD15A2.A2013017.h18v03.005.2013026065052.hdf.xml}


\section{A4.1.2 Identify the available dates}
\label{Chapter4_GDAL/advanced:a4-1-2-identify-the-available-dates}
From this, we see that the server is \code{e4ftl01.cr.usgs.gov}, that the
\code{hdf} data (the spatial dataset we want) for the product \code{MCD15A2}
version \code{005} is in the directory
\code{MODIS\_Composites/MOTA/MCD15A2.005}.

Below that, we have the date and then the filename.

Let's use \code{urllib2} to explore this:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{urllib2}
\PYG{n}{url\PYGZus{}base} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005}\PYG{l+s}{\PYGZsq{}}
\PYG{n}{response} \PYG{o}{=} \PYG{n}{urllib2}\PYG{o}{.}\PYG{n}{urlopen}\PYG{p}{(}\PYG{n}{url\PYGZus{}base}\PYG{p}{)}
\PYG{n}{html} \PYG{o}{=} \PYG{n}{response}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} print the first 30 lines}
\PYG{n}{html}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{p}{:}\PYG{l+m+mi}{30}\PYG{p}{]}
\end{Verbatim}

This is an html directory listing. We can identify the directories as
lines that contain \code{{[}DIR{]}}.

We can use \code{find} to identify lines that have this field:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{dirs} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n}{html}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{line}\PYG{o}{.}\PYG{n}{find}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{[DIRS]}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{dirs}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{line}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} or more succinctly}
\PYG{n}{dirs} \PYG{o}{=} \PYG{p}{[}\PYG{n}{line} \PYG{k}{for} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n}{html}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)} \PYG{k}{if} \PYG{n}{line}\PYG{o}{.}\PYG{n}{find}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{[DIR]}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)} \PYG{o}{!=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{dirs}\PYG{p}{[}\PYG{p}{:}\PYG{l+m+mi}{3}\PYG{p}{]}
\end{Verbatim}

We notice that the first such line is the directory listing information,
so, what we really want is:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{dirs} \PYG{o}{=} \PYG{p}{[}\PYG{n}{line} \PYG{k}{for} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n}{html}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)} \PYG{k}{if} \PYG{n}{line}\PYG{o}{.}\PYG{n}{find}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{[DIR]}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)} \PYG{o}{!=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{dirs}\PYG{p}{[}\PYG{p}{:}\PYG{l+m+mi}{3}\PYG{p}{]}
\end{Verbatim}

The subdirectory name is jusr after the field \code{href="}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{n}{dirs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{n}{dirs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{href=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{n}{dirs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{href=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZgt{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\end{Verbatim}

So, in this case, we can get the subdirectory names with:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{dirs} \PYG{o}{=} \PYG{p}{[}\PYG{n}{line}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{href=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZgt{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{k}{for} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n}{html}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)} \PYG{k}{if} \PYG{n}{line}\PYG{o}{.}\PYG{n}{find}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{[DIR]}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)} \PYG{o}{!=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} print the first 10}
\PYG{n}{dirs}\PYG{p}{[}\PYG{p}{:}\PYG{l+m+mi}{10}\PYG{p}{]}
\end{Verbatim}

The pattern is \code{YYYY.MM.DD}. So we could split these as we go along.
It would be convenient to have this as a numpy array:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{dirs} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{n}{line}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{href=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZgt{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{.}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)} \PYGZbs{}
                 \PYG{k}{for} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n}{html}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)} \PYG{k}{if} \PYG{n}{line}\PYG{o}{.}\PYG{n}{find}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{[DIR]}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)} \PYG{o}{!=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{dirs}\PYG{p}{[}\PYG{p}{:}\PYG{l+m+mi}{10}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{all\PYGZus{}years} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sort}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{unique}\PYG{p}{(}\PYG{n}{dirs}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{all\PYGZus{}months} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sort}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{unique}\PYG{p}{(}\PYG{n}{dirs}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{all\PYGZus{}doys} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sort}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{unique}\PYG{p}{(}\PYG{n}{dirs}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{years}\PYG{p}{,}\PYG{n}{months}\PYG{p}{,}\PYG{n}{doys}
\end{Verbatim}


\section{A4.1.3 Identify the datasets}
\label{Chapter4_GDAL/advanced:a4-1-3-identify-the-datasets}
We know the full url is of the form:

\code{http://e4ftl01.cr.usgs.gov/MODIS\_Composites/MOTA/MCD15A2.005/2013.01.17/MCD15A2.A2013017.h18v03.005.2013026065052.hdf}

Simplifying what we did above:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{urllib2}
\PYG{n}{url\PYGZus{}base} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005}\PYG{l+s}{\PYGZsq{}}
\PYG{n}{response} \PYG{o}{=} \PYG{n}{urllib2}\PYG{o}{.}\PYG{n}{urlopen}\PYG{p}{(}\PYG{n}{url\PYGZus{}base}\PYG{p}{)}
\PYG{n}{dirs} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{n}{line}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{href=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZgt{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{k}{for} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n}{html}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)} \PYG{k}{if} \PYG{n}{line}\PYG{o}{.}\PYG{n}{find}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{[DIR]}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)} \PYG{o}{!=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{years} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{n}{i}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{.}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{dirs}\PYG{p}{]}\PYG{p}{)}
\PYG{c}{\PYGZsh{} year mask}
\PYG{n}{year} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{2012}\PYG{l+s}{\PYGZsq{}}
\PYG{n}{mask} \PYG{o}{=} \PYG{p}{(}\PYG{n}{year} \PYG{o}{==} \PYG{n}{years}\PYG{p}{)}
\PYG{n}{sub\PYGZus{}dirs} \PYG{o}{=} \PYG{n}{dirs}\PYG{p}{[}\PYG{n}{mask}\PYG{p}{]}
\PYG{k}{print} \PYG{n}{sub\PYGZus{}dirs}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} test with first one}
\PYG{n}{this\PYGZus{}date} \PYG{o}{=} \PYG{n}{sub\PYGZus{}dirs}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}

\PYG{n}{url\PYGZus{}date} \PYG{o}{=} \PYG{n}{url\PYGZus{}base} \PYG{o}{+} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/}\PYG{l+s}{\PYGZsq{}} \PYG{o}{+} \PYG{n}{this\PYGZus{}date}
\PYG{k}{print} \PYG{n}{url\PYGZus{}date}
\PYG{n}{response1} \PYG{o}{=} \PYG{n}{urllib2}\PYG{o}{.}\PYG{n}{urlopen}\PYG{p}{(}\PYG{n}{url\PYGZus{}date}\PYG{p}{)}
\PYG{n}{html1} \PYG{o}{=} \PYG{n}{response1}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} print the first 21 lines}
\PYG{n}{html1}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{p}{:}\PYG{l+m+mi}{21}\PYG{p}{]}
\end{Verbatim}

We note that the directory contains data for all tiles.

Lets filter only lines that have the tile we want in:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{tile} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{h18v03}\PYG{l+s}{\PYGZsq{}}
\PYG{n}{lines} \PYG{o}{=} \PYG{p}{[}\PYG{n}{line} \PYG{k}{for} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n}{html1}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)} \PYG{k}{if} \PYG{n}{line}\PYG{o}{.}\PYG{n}{find}\PYG{p}{(}\PYG{n}{tile}\PYG{p}{)} \PYG{o}{!=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{lines}
\end{Verbatim}

We want the \code{.hdf} file, so refine the filter:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{tile} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{h18v03}\PYG{l+s}{\PYGZsq{}}
\PYG{n}{hdf\PYGZus{}lines} \PYG{o}{=} \PYG{p}{[}\PYG{n}{i} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{p}{[}\PYG{n}{line} \PYG{k}{for} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n}{html1}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)} \PYGZbs{}
                         \PYG{k}{if} \PYG{n}{line}\PYG{o}{.}\PYG{n}{find}\PYG{p}{(}\PYG{n}{tile}\PYG{p}{)} \PYG{o}{!=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{k}{if} \PYG{n}{i}\PYG{o}{.}\PYG{n}{find}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{.hdf}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)} \PYG{o}{!=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{hdf\PYGZus{}lines}
\end{Verbatim}

Now split this to get the filename we want:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{hdf\PYGZus{}lines}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZlt{}a href=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{hdf\PYGZus{}lines}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZlt{}a href=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZgt{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\end{Verbatim}

So, putting all of that together:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{tile} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{h18v03}\PYG{l+s}{\PYGZsq{}}
\PYG{n}{hdf\PYGZus{}lines} \PYG{o}{=} \PYG{p}{[}\PYG{n}{i} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{p}{[}\PYG{n}{line} \PYG{k}{for} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n}{html1}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)} \PYGZbs{}
                         \PYG{k}{if} \PYG{n}{line}\PYG{o}{.}\PYG{n}{find}\PYG{p}{(}\PYG{n}{tile}\PYG{p}{)} \PYG{o}{!=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{k}{if} \PYG{n}{i}\PYG{o}{.}\PYG{n}{find}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{.hdf}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)} \PYG{o}{!=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{hdf\PYGZus{}file} \PYG{o}{=} \PYG{n}{hdf\PYGZus{}lines}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZlt{}a href=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZgt{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\end{Verbatim}


\section{A4.1.4 Some code for MODIS LAI filenames for a year}
\label{Chapter4_GDAL/advanced:a4-1-4-some-code-for-modis-lai-filenames-for-a-year}
The http access is quite slow, so this may take some minutes to run.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{year} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{2012}\PYG{l+s}{\PYGZsq{}}
\PYG{n}{tile} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{h17v03}\PYG{l+s}{\PYGZsq{}}


\PYG{n}{hdf\PYGZus{}files} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}

\PYG{k+kn}{import} \PYG{n+nn}{urllib2}

\PYG{c}{\PYGZsh{} base URL for the product}
\PYG{n}{url\PYGZus{}base} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005}\PYG{l+s}{\PYGZsq{}}

\PYG{n}{response} \PYG{o}{=} \PYG{n}{urllib2}\PYG{o}{.}\PYG{n}{urlopen}\PYG{p}{(}\PYG{n}{url\PYGZus{}base}\PYG{p}{)}
\PYG{n}{html} \PYG{o}{=} \PYG{n}{response}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{dirs} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{n}{line}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{href=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZgt{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{k}{for} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n}{html}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)} \PYG{k}{if} \PYG{n}{line}\PYG{o}{.}\PYG{n}{find}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{[DIR]}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)} \PYG{o}{!=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{p}{]}\PYG{p}{)}

\PYG{c}{\PYGZsh{} identify years}
\PYG{n}{years} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{n}{i}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{.}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{dirs}\PYG{p}{]}\PYG{p}{)}
\PYG{c}{\PYGZsh{} year mask}
\PYG{n}{mask} \PYG{o}{=} \PYG{p}{(}\PYG{n}{year} \PYG{o}{==} \PYG{n}{years}\PYG{p}{)}
\PYG{n}{sub\PYGZus{}dirs} \PYG{o}{=} \PYG{n}{dirs}\PYG{p}{[}\PYG{n}{mask}\PYG{p}{]}

\PYG{k}{for} \PYG{n}{this\PYGZus{}date} \PYG{o+ow}{in} \PYG{n}{sub\PYGZus{}dirs}\PYG{p}{:}
    \PYG{n}{url\PYGZus{}date} \PYG{o}{=} \PYG{n}{url\PYGZus{}base} \PYG{o}{+} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/}\PYG{l+s}{\PYGZsq{}} \PYG{o}{+} \PYG{n}{this\PYGZus{}date}
    \PYG{k}{print} \PYG{n}{url\PYGZus{}date}
    \PYG{n}{response1} \PYG{o}{=} \PYG{n}{urllib2}\PYG{o}{.}\PYG{n}{urlopen}\PYG{p}{(}\PYG{n}{url\PYGZus{}date}\PYG{p}{)}
    \PYG{n}{html1} \PYG{o}{=} \PYG{n}{response1}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{hdf\PYGZus{}lines} \PYG{o}{=} \PYG{p}{[}\PYG{n}{i} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{p}{[}\PYG{n}{line} \PYG{k}{for} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n}{html1}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)} \PYGZbs{}
                             \PYG{k}{if} \PYG{n}{line}\PYG{o}{.}\PYG{n}{find}\PYG{p}{(}\PYG{n}{tile}\PYG{p}{)} \PYG{o}{!=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{k}{if} \PYG{n}{i}\PYG{o}{.}\PYG{n}{find}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{.hdf}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)} \PYG{o}{!=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
    \PYG{n}{hdf\PYGZus{}file} \PYG{o}{=} \PYG{n}{url\PYGZus{}date} \PYG{o}{+} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/}\PYG{l+s}{\PYGZsq{}} \PYG{o}{+} \PYG{n}{hdf\PYGZus{}lines}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZlt{}a href=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZgt{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
    \PYG{n}{hdf\PYGZus{}files}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{hdf\PYGZus{}file}\PYG{o}{+}\PYG{l+s}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.01.01
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.01.09
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.01.17
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.01.25
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.02.02
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.02.10
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.02.18
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.02.26
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.03.05
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.03.13
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.03.21
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.03.29
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.04.06
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.04.14
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.04.22
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.04.30
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.05.08
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.05.16
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.05.24
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.06.01
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.06.09
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.06.17
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.06.25
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.07.03
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.07.11
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.07.19
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.07.27
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.08.04
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.08.12
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.08.20
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.08.28
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.09.05
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.09.13
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.09.21
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.09.29
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.10.07
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.10.15
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.10.23
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.10.31
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.11.08
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.11.16
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.11.24
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.12.02
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.12.10
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.12.18
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.12.26
\end{Verbatim}

In case download fails later, lets save this list \code{hdf\_files}.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{f} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/lai\PYGZus{}list.txt}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{w}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{f}\PYG{o}{.}\PYG{n}{writelines}\PYG{p}{(}\PYG{n}{hdf\PYGZus{}files}\PYG{p}{)}
\PYG{n}{f}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}


\section{A4.1.5 Pull Data from url}
\label{Chapter4_GDAL/advanced:a4-1-5-pull-data-from-url}
This part is actually faster than doing all of that messing around with
directories.

You don't really want to have to do too much of the directory
exploration, so it is \emph{probably} a good idea to just periodically scan
the whole structure and store that in a local file. You can then parse
the local file much more easily (that is what we do in the main part of
the class).

This is achieved for instance with the shell
\code{{}`zat} \textless{}files/python/zat\textgreater{}{}`\_\_ (use \code{zat \textgreater{}}
\code{{}`urls.txt} \textless{}files/data/robot.txt\textgreater{}{}`\_\_) if you want to do an update, or
just use the existing url file.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{urllib2}

\PYG{n}{f} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/lai\PYGZus{}list.txt}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{hdf\PYGZus{}files} \PYG{o}{=} \PYG{n}{f}\PYG{o}{.}\PYG{n}{readlines}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{f}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{url} \PYG{o+ow}{in} \PYG{n}{hdf\PYGZus{}files}\PYG{p}{:}
    \PYG{n}{url} \PYG{o}{=} \PYG{n}{url}\PYG{o}{.}\PYG{n}{strip}\PYG{p}{(}\PYG{p}{)}
    \PYG{k}{print} \PYG{n}{url}
    \PYG{n}{response} \PYG{o}{=} \PYG{n}{urllib2}\PYG{o}{.}\PYG{n}{urlopen}\PYG{p}{(}\PYG{n}{url}\PYG{o}{.}\PYG{n}{strip}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{ofile} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/}\PYG{l+s}{\PYGZsq{}} \PYG{o}{+} \PYG{n}{url}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
    \PYG{n}{f} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{ofile}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{w}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{f}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n}{response}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{f}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.01.01/MCD15A2.A2012001.h17v03.005.2012017211237.hdf
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.01.09/MCD15A2.A2012009.h17v03.005.2012019044037.hdf
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.01.17/MCD15A2.A2012017.h17v03.005.2012026072526.hdf
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.01.25/MCD15A2.A2012025.h17v03.005.2012052124839.hdf
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.02.02/MCD15A2.A2012033.h17v03.005.2012042060649.hdf
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.02.10/MCD15A2.A2012041.h17v03.005.2012050092057.hdf
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.02.18/MCD15A2.A2012049.h17v03.005.2012068144447.hdf
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.02.26/MCD15A2.A2012057.h17v03.005.2012068140544.hdf
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.03.05/MCD15A2.A2012065.h17v03.005.2012075021749.hdf
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.03.13/MCD15A2.A2012073.h17v03.005.2012083010304.hdf
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.03.21/MCD15A2.A2012081.h17v03.005.2012090131602.hdf
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.03.29/MCD15A2.A2012089.h17v03.005.2012107201245.hdf
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.04.06/MCD15A2.A2012097.h17v03.005.2012108125047.hdf
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.04.14/MCD15A2.A2012105.h17v03.005.2012116125519.hdf
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.04.22/MCD15A2.A2012113.h17v03.005.2012122072153.hdf
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.04.30/MCD15A2.A2012121.h17v03.005.2012137221611.hdf
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.05.08/MCD15A2.A2012129.h17v03.005.2012142001241.hdf
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.05.16/MCD15A2.A2012137.h17v03.005.2012153021910.hdf
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.05.24/MCD15A2.A2012145.h17v03.005.2012160130927.hdf
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.06.01/MCD15A2.A2012153.h17v03.005.2012166161748.hdf
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.06.09/MCD15A2.A2012161.h17v03.005.2012170080216.hdf
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.06.17/MCD15A2.A2012169.h17v03.005.2012181134242.hdf
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.06.25/MCD15A2.A2012177.h17v03.005.2012188150145.hdf
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.07.03/MCD15A2.A2012185.h17v03.005.2012208181105.hdf
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.07.11/MCD15A2.A2012193.h17v03.005.2012202144013.hdf
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.07.19/MCD15A2.A2012201.h17v03.005.2012215131931.hdf
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.07.27/MCD15A2.A2012209.h17v03.005.2012219144450.hdf
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.08.04/MCD15A2.A2012217.h17v03.005.2012228215213.hdf
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.08.12/MCD15A2.A2012225.h17v03.005.2012234105932.hdf
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.08.20/MCD15A2.A2012233.h17v03.005.2012242093511.hdf
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.08.28/MCD15A2.A2012241.h17v03.005.2012250182515.hdf
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.09.05/MCD15A2.A2012249.h17v03.005.2012261231425.hdf
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.09.13/MCD15A2.A2012257.h17v03.005.2012270114223.hdf
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.09.21/MCD15A2.A2012265.h17v03.005.2012276134731.hdf
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.09.29/MCD15A2.A2012273.h17v03.005.2012297134400.hdf
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.10.07/MCD15A2.A2012281.h17v03.005.2012297135831.hdf
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.10.15/MCD15A2.A2012289.h17v03.005.2012299194634.hdf
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.10.23/MCD15A2.A2012297.h17v03.005.2012306163257.hdf
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.10.31/MCD15A2.A2012305.h17v03.005.2012314140451.hdf
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.11.08/MCD15A2.A2012313.h17v03.005.2012322095802.hdf
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.11.16/MCD15A2.A2012321.h17v03.005.2012335133638.hdf
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.11.24/MCD15A2.A2012329.h17v03.005.2012340181739.hdf
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.12.02/MCD15A2.A2012337.h17v03.005.2012346165133.hdf
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.12.10/MCD15A2.A2012345.h17v03.005.2012356133200.hdf
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.12.18/MCD15A2.A2012353.h17v03.005.2012363125132.hdf
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2012.12.26/MCD15A2.A2012361.h17v03.005.2013007202756.hdf
\end{Verbatim}


\chapter{A4.2 GDAL tools and HDF format}
\label{Chapter4_GDAL/advanced:a4-2-gdal-tools-and-hdf-format}
\href{http://www.hdfgroup.org/HDF-FAQ.html}{HDF}(Hierarchical Data
Format) and \href{http://hdfeos.org/}{HDF-EOS} are common formats for EO
data so you need to have some idea how to use and manipulate them.

A hierarchical data format is essentially a format that packs together
various aspects of a dataset (metadata, raster data etc.) into a binary
file. There are many tools for manipulating and reading HDF in python,
but we will use one of the more generic tools,
\href{http://gdal.org}{gdal} here.

When using HDF files, we need to have some idea of the stucture of the
contents, although you can clearly explore that yourself in an
interactive session. MODIS products have extensive information available
to help you interpret the datasets, for example the MODIS LAI/fAPAR
product
\href{https://lpdaac.usgs.gov/products/modis\_products\_table/leaf\_area\_index\_fraction\_of\_photosynthetically\_active\_radiation/8\_day\_l4\_global\_1km/mod15a2}{MOD15A2}.
We will use this as an example to explore a dataset.

You will need access to the file
\code{{}`files/data/MCD15A2.A2011185.h09v05.005.2011213154534.hdf} \textless{}files/data/MCD15A2.A2011185.h09v05.005.2011213154534.hdf\textgreater{}{}`\_\_,
which you might access from the \href{https://lpdaac.usgs.gov/}{MODIS Land Products
site}

Before going into the Python coding for GDAL, it is worthwhile looking
over some of the tools that are provided with GDAL and that can be run
from the shell. In particular, we can use the \code{gdalinfo} program, that
takes a filename and will output a copious description of the data,
including metadata, but also geogrpahic projection, size, number of
bands, etc.

Here, we will look at the first 20 lines that come out of \code{gdalinfo}:

\begin{Verbatim}[commandchars=\\\{\}]
!gdalinfo files/data/MCD15A2.A2011185.h09v05.005.2011213154534.hdf \textbar{} head \PYGZhy{}20
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
Driver: HDF4/Hierarchical Data Format Release 4
Files: files/data/MCD15A2.A2011185.h09v05.005.2011213154534.hdf
Size is 512, 512
Coordinate System is {}`\PYGZsq{}
Metadata:
  ALGORITHMPACKAGEACCEPTANCEDATE=10\PYGZhy{}01\PYGZhy{}2004
  ALGORITHMPACKAGEMATURITYCODE=Normal
  ALGORITHMPACKAGENAME=MCDPR\PYGZus{}15A2
  ALGORITHMPACKAGEVERSION=5
  ASSOCIATEDINSTRUMENTSHORTNAME=MODIS
  ASSOCIATEDINSTRUMENTSHORTNAME=MODIS
  ASSOCIATEDPLATFORMSHORTNAME=Aqua
  ASSOCIATEDPLATFORMSHORTNAME=Terra
  ASSOCIATEDSENSORSHORTNAME=MODIS
  ASSOCIATEDSENSORSHORTNAME=MODIS
  AUTOMATICQUALITYFLAG=Passed
  AUTOMATICQUALITYFLAGEXPLANATION=No automatic quality assessment is performed in the PGE
  CHARACTERISTICBINANGULARSIZE=30.0
  CHARACTERISTICBINSIZE=926.625433055556
  DATACOLUMNS=1200
\end{Verbatim}

We can use standard unix filters (e.g. \code{grep}) to look at particular
fields:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{} Filter lines that do not have BOUNDINGCOORDINATE in them
file=files/data/MCD15A2.A2011185.h09v05.005.2011213154534.hdf
gdalinfo \PYGZdl{}file \textbar{} grep BOUNDINGCOORDINATE
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{EASTBOUNDINGCOORDINATE}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{92.3664205550513}
\PYG{n}{NORTHBOUNDINGCOORDINATE}\PYG{o}{=}\PYG{l+m+mf}{39.9999999964079}
\PYG{n}{SOUTHBOUNDINGCOORDINATE}\PYG{o}{=}\PYG{l+m+mf}{29.9999999973059}
\PYG{n}{WESTBOUNDINGCOORDINATE}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{117.486656023174}
\end{Verbatim}

We can check this against e.g. the \href{http://remotesensing.unh.edu/modis/modis.shtml}{UNH MODIS tile
calculator}, just to
confirm that we have interpreted the coordinates correctly.

We can apply other shell GDAL tools, e.g. to perform a reprojection from
the native \href{http://modis-land.gsfc.nasa.gov/MODLAND\_grid.html}{MODIS
sinusoidal}
projection, to the \href{http://spatialreference.org/ref/sr-org/7271/}{Contiguous United States NAD27 Albers Equal
Area}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{} a bash script

\PYGZsh{} set the variables file to be the filename for convenience
file=files/data/MCD15A2.A2011185.h09v05.005.2011213154534.hdf

\PYGZsh{} dselete the output file if it exists
rm \PYGZhy{}f files/data/output\PYGZus{}file.tif

\PYGZsh{} reproject the data
gdalwarp \PYGZhy{}of GTiff \PYGZbs{}
    \PYGZhy{}t\PYGZus{}srs \PYGZsq{}+proj=aea +lat\PYGZus{}1=29.5 +lat\PYGZus{}2=45.5 +lat\PYGZus{}0=23 +lon\PYGZus{}0=\PYGZhy{}96 +x\PYGZus{}0=0 \PYGZbs{}
    +y\PYGZus{}0=0 +ellps=clrk66 +units=m +no\PYGZus{}defs\PYGZsq{} \PYGZhy{}tr 1000 1000 \PYGZbs{}
    \PYGZsq{}HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:\PYGZsq{}\PYGZdl{}\PYGZob{}file\PYGZcb{}\PYGZsq{}:MOD\PYGZus{}Grid\PYGZus{}MOD15A2:Lai\PYGZus{}1km\PYGZsq{} files/data/output\PYGZus{}file.tif

\PYGZsh{} convert to gif for viewing
gdal\PYGZus{}translate \PYGZhy{}outsize 30\PYGZpc{} 30\PYGZpc{} \PYGZhy{}of gif \PYGZbs{}
    files/data/output\PYGZus{}file.tif files/data/output\PYGZus{}file.gif
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
Creating output file that is 2152P x 1323L.
Processing input file HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:files/data/MCD15A2.A2011185.h09v05.005.2011213154534.hdf:MOD\PYGZus{}Grid\PYGZus{}MOD15A2:Lai\PYGZus{}1km.
Using internal nodata values (eg. 255) for image HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:files/data/MCD15A2.A2011185.h09v05.005.2011213154534.hdf:MOD\PYGZus{}Grid\PYGZus{}MOD15A2:Lai\PYGZus{}1km.
0...10...20...30...40...50...60...70...80...90...100 \PYGZhy{} done.
Input file size is 2152, 1323
0...10...20...30...40...50...60...70...80...90...100 \PYGZhy{} done.
\end{Verbatim}
\begin{figure}[htbp]
\centering

\includegraphics{Chapter4_GDAL/files/data/output_file.gif}
\end{figure}

where \code{MCD15A2.A2011185.h09v05.005.2011213154534.hdf} is the name of
the input HDF file, \code{MOD\_Grid\_MOD15A2:Lai\_1km} is the data product we
want, and the rather menacing string
\code{+proj=aea +lat\_1=29.5 +lat\_2=45.5 +lat\_0=23 +lon\_0=-96 +x\_0=0 +y\_0=0 +ellps=clrk66 +units=m +no\_defs}
specifies the projection in Proj4 format. You can typically find the
projection you want on
\href{http://spatialreference.org}{spatialreference.org}, and just copy
and paste the contents of \href{http://spatialreference.org/ref/sr-org/7271/proj4/}{Proj4
definition}
(remember to surround it by quotes). The option \code{-tr xres yres}
specifies the desired resolution of the output dataset (1000 by 1000 m
in the case above). \code{-of GTiff} specifies the GeoTiff format to be
used as as output.


\chapter{A4.3 Further Geospatial Notes}
\label{Chapter4_GDAL/advanced:a4-3-further-geospatial-notes}
There are additonal notes that go into the details of \code{gdal} and
vectors processing tools.

Follow these on:
\begin{itemize}
\item {} 
gdal

\item {} 
ogr

\end{itemize}

There are no explicit advanced exercises this week. Instead, you should
eplore these notes and see if you can apply the concepts to your own
datasets.


\chapter{Exercise 4.1}
\label{Chapter4_GDAL/answers::doc}\label{Chapter4_GDAL/answers:exercise-4-1}
You are given the MODIS LAI data files for the year 2012 in the
directory \code{files/data} for the UK (MODIS tile .

Read the LAI datasets into a masked array, using QA bit 0 to mask the
data (i.e. good quality data only) and generate a movie of LAI.


\section{Answer 4.1}
\label{Chapter4_GDAL/answers:answer-4-1}
You ought be getting familiar with this sort of problem, as it is very
common.

Since we have the code in the main notes to read a single data dataset:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{gdal} \PYG{c}{\PYGZsh{} Import GDAL library bindings}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}

\PYG{c}{\PYGZsh{} The file that we shall be using}
\PYG{c}{\PYGZsh{} Needs to be on current directory}
\PYG{n}{filename} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MCD15A2.A2011185.h09v05.005.2011213154534.hdf}\PYG{l+s}{\PYGZsq{}}

\PYG{n}{g} \PYG{o}{=} \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{Open}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{)}
\PYG{c}{\PYGZsh{} g should now be a GDAL dataset, but if the file isn\PYGZsq{}t found}
\PYG{c}{\PYGZsh{} g will be none. Let\PYGZsq{}s test this:}
\PYG{k}{if} \PYG{n}{g} \PYG{o+ow}{is} \PYG{n+nb+bp}{None}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Problem opening file }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{!}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n}{filename}
\PYG{k}{else}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{File }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{ opened fine}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n}{filename}


\PYG{n}{subdatasets} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{GetSubDatasets}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{fname}\PYG{p}{,} \PYG{n}{name} \PYG{o+ow}{in} \PYG{n}{subdatasets}\PYG{p}{:}
    \PYG{k}{print} \PYG{n}{name}
    \PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{fname}

\PYG{c}{\PYGZsh{} Let\PYGZsq{}s create a list with the selected layer names}
\PYG{n}{selected\PYGZus{}layers} \PYG{o}{=} \PYG{p}{[}  \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{FparLai\PYGZus{}QC}\PYG{l+s}{\PYGZdq{}} \PYG{p}{]}
\PYG{c}{\PYGZsh{} We will store the data in a dictionary}
\PYG{c}{\PYGZsh{} Initialise an empty dictionary}
\PYG{n}{data} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{c}{\PYGZsh{} for convenience, we will use string substitution to create a}
\PYG{c}{\PYGZsh{} template for GDAL filenames, which we\PYGZsq{}ll substitute on the fly:}
\PYG{n}{file\PYGZus{}template} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{:MOD\PYGZus{}Grid\PYGZus{}MOD15A2:}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZsq{}}
\PYG{k}{for} \PYG{n}{i}\PYG{p}{,} \PYG{n}{layer} \PYG{o+ow}{in} \PYG{n+nb}{enumerate} \PYG{p}{(} \PYG{n}{selected\PYGZus{}layers} \PYG{p}{)}\PYG{p}{:}
    \PYG{n}{this\PYGZus{}file} \PYG{o}{=} \PYG{n}{file\PYGZus{}template} \PYG{o}{\PYGZpc{}} \PYG{p}{(} \PYG{n}{filename}\PYG{p}{,} \PYG{n}{layer} \PYG{p}{)}
    \PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Opening Layer }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{: }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{this\PYGZus{}file} \PYG{p}{)}
    \PYG{n}{g} \PYG{o}{=} \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{Open} \PYG{p}{(} \PYG{n}{this\PYGZus{}file} \PYG{p}{)}

    \PYG{k}{if} \PYG{n}{g} \PYG{o+ow}{is} \PYG{n+nb+bp}{None}\PYG{p}{:}
        \PYG{k}{raise} \PYG{n+ne}{IOError}
    \PYG{n}{data}\PYG{p}{[}\PYG{n}{layer}\PYG{p}{]} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{ReadAsArray}\PYG{p}{(}\PYG{p}{)}
    \PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZgt{}\PYGZgt{}\PYGZgt{} Read }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{!}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n}{layer}

\PYG{c}{\PYGZsh{} scale the LAI}
\PYG{n}{lai} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{*} \PYG{l+m+mf}{0.1}

\PYG{c}{\PYGZsh{} pull out the QC}
\PYG{n}{qc} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{FparLai\PYGZus{}QC}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\PYG{c}{\PYGZsh{} find bit 0}
\PYG{n}{qc} \PYG{o}{=} \PYG{n}{qc} \PYG{o}{\PYGZam{}} \PYG{l+m+mi}{1}

\PYG{c}{\PYGZsh{} generate the masked array}
\PYG{n}{laim} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ma}\PYG{o}{.}\PYG{n}{array} \PYG{p}{(} \PYG{n}{lai}\PYG{p}{,} \PYG{n}{mask}\PYG{o}{=}\PYG{n}{qc} \PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
File files/data/MCD15A2.A2011185.h09v05.005.2011213154534.hdf opened fine
[1200x1200] Fpar\PYGZus{}1km MOD\PYGZus{}Grid\PYGZus{}MOD15A2 (8\PYGZhy{}bit unsigned integer)
    HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:\PYGZdq{}files/data/MCD15A2.A2011185.h09v05.005.2011213154534.hdf\PYGZdq{}:MOD\PYGZus{}Grid\PYGZus{}MOD15A2:Fpar\PYGZus{}1km
[1200x1200] Lai\PYGZus{}1km MOD\PYGZus{}Grid\PYGZus{}MOD15A2 (8\PYGZhy{}bit unsigned integer)
    HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:\PYGZdq{}files/data/MCD15A2.A2011185.h09v05.005.2011213154534.hdf\PYGZdq{}:MOD\PYGZus{}Grid\PYGZus{}MOD15A2:Lai\PYGZus{}1km
[1200x1200] FparLai\PYGZus{}QC MOD\PYGZus{}Grid\PYGZus{}MOD15A2 (8\PYGZhy{}bit unsigned integer)
    HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:\PYGZdq{}files/data/MCD15A2.A2011185.h09v05.005.2011213154534.hdf\PYGZdq{}:MOD\PYGZus{}Grid\PYGZus{}MOD15A2:FparLai\PYGZus{}QC
[1200x1200] FparExtra\PYGZus{}QC MOD\PYGZus{}Grid\PYGZus{}MOD15A2 (8\PYGZhy{}bit unsigned integer)
    HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:\PYGZdq{}files/data/MCD15A2.A2011185.h09v05.005.2011213154534.hdf\PYGZdq{}:MOD\PYGZus{}Grid\PYGZus{}MOD15A2:FparExtra\PYGZus{}QC
[1200x1200] FparStdDev\PYGZus{}1km MOD\PYGZus{}Grid\PYGZus{}MOD15A2 (8\PYGZhy{}bit unsigned integer)
    HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:\PYGZdq{}files/data/MCD15A2.A2011185.h09v05.005.2011213154534.hdf\PYGZdq{}:MOD\PYGZus{}Grid\PYGZus{}MOD15A2:FparStdDev\PYGZus{}1km
[1200x1200] LaiStdDev\PYGZus{}1km MOD\PYGZus{}Grid\PYGZus{}MOD15A2 (8\PYGZhy{}bit unsigned integer)
    HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:\PYGZdq{}files/data/MCD15A2.A2011185.h09v05.005.2011213154534.hdf\PYGZdq{}:MOD\PYGZus{}Grid\PYGZus{}MOD15A2:LaiStdDev\PYGZus{}1km
Opening Layer 1: HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:\PYGZdq{}files/data/MCD15A2.A2011185.h09v05.005.2011213154534.hdf\PYGZdq{}:MOD\PYGZus{}Grid\PYGZus{}MOD15A2:Lai\PYGZus{}1km
    \PYGZgt{}\PYGZgt{}\PYGZgt{} Read Lai\PYGZus{}1km!
Opening Layer 2: HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:\PYGZdq{}files/data/MCD15A2.A2011185.h09v05.005.2011213154534.hdf\PYGZdq{}:MOD\PYGZus{}Grid\PYGZus{}MOD15A2:FparLai\PYGZus{}QC
    \PYGZgt{}\PYGZgt{}\PYGZgt{} Read FparLai\PYGZus{}QC!
\end{Verbatim}

We can use this as a function that reads a single dataset:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{read\PYGZus{}modis\PYGZus{}lai}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}  Read MODIS LAI data from filename}
\PYG{l+s+sd}{         and return masked array}
\PYG{l+s+sd}{    \PYGZsq{}\PYGZsq{}\PYGZsq{}}

    \PYG{n}{g} \PYG{o}{=} \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{Open}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{)}
    \PYG{c}{\PYGZsh{} g should now be a GDAL dataset, but if the file isn\PYGZsq{}t found}
    \PYG{c}{\PYGZsh{} g will be none. Let\PYGZsq{}s test this:}
    \PYG{k}{if} \PYG{n}{g} \PYG{o+ow}{is} \PYG{n+nb+bp}{None}\PYG{p}{:}
        \PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Problem opening file }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{!}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n}{filename}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{File }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{ opened fine}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n}{filename}


    \PYG{n}{subdatasets} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{GetSubDatasets}\PYG{p}{(}\PYG{p}{)}
    \PYG{c}{\PYGZsh{}for fname, name in subdatasets:}
        \PYG{c}{\PYGZsh{}print name}
        \PYG{c}{\PYGZsh{}print \PYGZdq{}\PYGZbs{}t\PYGZdq{}, fname}

    \PYG{c}{\PYGZsh{} Let\PYGZsq{}s create a list with the selected layer names}
    \PYG{n}{selected\PYGZus{}layers} \PYG{o}{=} \PYG{p}{[}  \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{FparLai\PYGZus{}QC}\PYG{l+s}{\PYGZdq{}} \PYG{p}{]}
    \PYG{c}{\PYGZsh{} We will store the data in a dictionary}
    \PYG{c}{\PYGZsh{} Initialise an empty dictionary}
    \PYG{n}{data} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
    \PYG{c}{\PYGZsh{} for convenience, we will use string substitution to create a}
    \PYG{c}{\PYGZsh{} template for GDAL filenames, which we\PYGZsq{}ll substitute on the fly:}
    \PYG{n}{file\PYGZus{}template} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{:MOD\PYGZus{}Grid\PYGZus{}MOD15A2:}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZsq{}}
    \PYG{k}{for} \PYG{n}{i}\PYG{p}{,} \PYG{n}{layer} \PYG{o+ow}{in} \PYG{n+nb}{enumerate} \PYG{p}{(} \PYG{n}{selected\PYGZus{}layers} \PYG{p}{)}\PYG{p}{:}
        \PYG{n}{this\PYGZus{}file} \PYG{o}{=} \PYG{n}{file\PYGZus{}template} \PYG{o}{\PYGZpc{}} \PYG{p}{(} \PYG{n}{filename}\PYG{p}{,} \PYG{n}{layer} \PYG{p}{)}
        \PYG{c}{\PYGZsh{}print \PYGZdq{}Opening Layer \PYGZpc{}d: \PYGZpc{}s\PYGZdq{} \PYGZpc{} (i+1, this\PYGZus{}file )}
        \PYG{n}{g} \PYG{o}{=} \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{Open} \PYG{p}{(} \PYG{n}{this\PYGZus{}file} \PYG{p}{)}

        \PYG{k}{if} \PYG{n}{g} \PYG{o+ow}{is} \PYG{n+nb+bp}{None}\PYG{p}{:}
            \PYG{k}{raise} \PYG{n+ne}{IOError}
        \PYG{n}{data}\PYG{p}{[}\PYG{n}{layer}\PYG{p}{]} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{ReadAsArray}\PYG{p}{(}\PYG{p}{)}
        \PYG{c}{\PYGZsh{}print \PYGZdq{}\PYGZbs{}t\PYGZgt{}\PYGZgt{}\PYGZgt{} Read \PYGZpc{}s!\PYGZdq{} \PYGZpc{} layer}

    \PYG{c}{\PYGZsh{} scale the LAI}
    \PYG{n}{lai} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{*} \PYG{l+m+mf}{0.1}

    \PYG{c}{\PYGZsh{} pull out the QC}
    \PYG{n}{qc} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{FparLai\PYGZus{}QC}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
    \PYG{c}{\PYGZsh{} find bit 0}
    \PYG{n}{qc} \PYG{o}{=} \PYG{n}{qc} \PYG{o}{\PYGZam{}} \PYG{l+m+mi}{1}

    \PYG{c}{\PYGZsh{} generate the masked array}
    \PYG{n}{laim} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ma}\PYG{o}{.}\PYG{n}{array} \PYG{p}{(} \PYG{n}{lai}\PYG{p}{,} \PYG{n}{mask}\PYG{o}{=}\PYG{n}{qc} \PYG{p}{)}

    \PYG{k}{return} \PYG{n}{laim}
\end{Verbatim}

and then loop:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{glob}

\PYG{n}{year} \PYG{o}{=} \PYG{l+m+mi}{2012}
\PYG{n}{tile} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{h17v03}\PYG{l+s}{\PYGZsq{}}
\PYG{n}{files} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sort}\PYG{p}{(}\PYG{n}{glob}\PYG{o}{.}\PYG{n}{glob}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MCD15A2.A}\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{*.}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{.*.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{year}\PYG{p}{,}\PYG{n}{tile}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{lai} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{f} \PYG{o+ow}{in} \PYG{n}{files}\PYG{p}{:}
    \PYG{n}{lai}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{read\PYGZus{}modis\PYGZus{}lai}\PYG{p}{(}\PYG{n}{f}\PYG{p}{)}\PYG{p}{)}

\PYG{c}{\PYGZsh{} force it to be a masked array}
\PYG{n}{lai} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ma}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{lai}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
File files/data/MCD15A2.A2012017.h17v03.005.2012026072526.hdf opened fine
File files/data/MCD15A2.A2012025.h17v03.005.2012052124839.hdf opened fine
File files/data/MCD15A2.A2012033.h17v03.005.2012042060649.hdf opened fine
File files/data/MCD15A2.A2012041.h17v03.005.2012050092057.hdf opened fine
File files/data/MCD15A2.A2012049.h17v03.005.2012068144447.hdf opened fine
File files/data/MCD15A2.A2012057.h17v03.005.2012068140544.hdf opened fine
File files/data/MCD15A2.A2012065.h17v03.005.2012075021749.hdf opened fine
File files/data/MCD15A2.A2012073.h17v03.005.2012083010304.hdf opened fine
File files/data/MCD15A2.A2012081.h17v03.005.2012090131602.hdf opened fine
File files/data/MCD15A2.A2012089.h17v03.005.2012107201245.hdf opened fine
File files/data/MCD15A2.A2012097.h17v03.005.2012108125047.hdf opened fine
File files/data/MCD15A2.A2012105.h17v03.005.2012116125519.hdf opened fine
File files/data/MCD15A2.A2012113.h17v03.005.2012122072153.hdf opened fine
File files/data/MCD15A2.A2012121.h17v03.005.2012137221611.hdf opened fine
File files/data/MCD15A2.A2012129.h17v03.005.2012142001241.hdf opened fine
File files/data/MCD15A2.A2012137.h17v03.005.2012153021910.hdf opened fine
File files/data/MCD15A2.A2012145.h17v03.005.2012160130927.hdf opened fine
File files/data/MCD15A2.A2012153.h17v03.005.2012166161748.hdf opened fine
File files/data/MCD15A2.A2012161.h17v03.005.2012170080216.hdf opened fine
File files/data/MCD15A2.A2012169.h17v03.005.2012181134242.hdf opened fine
File files/data/MCD15A2.A2012177.h17v03.005.2012188150145.hdf opened fine
File files/data/MCD15A2.A2012185.h17v03.005.2012208181105.hdf opened fine
File files/data/MCD15A2.A2012193.h17v03.005.2012202144013.hdf opened fine
File files/data/MCD15A2.A2012201.h17v03.005.2012215131931.hdf opened fine
File files/data/MCD15A2.A2012209.h17v03.005.2012219144450.hdf opened fine
File files/data/MCD15A2.A2012217.h17v03.005.2012228215213.hdf opened fine
File files/data/MCD15A2.A2012225.h17v03.005.2012234105932.hdf opened fine
File files/data/MCD15A2.A2012233.h17v03.005.2012242093511.hdf opened fine
File files/data/MCD15A2.A2012241.h17v03.005.2012250182515.hdf opened fine
File files/data/MCD15A2.A2012249.h17v03.005.2012261231425.hdf opened fine
File files/data/MCD15A2.A2012257.h17v03.005.2012270114223.hdf opened fine
File files/data/MCD15A2.A2012265.h17v03.005.2012276134731.hdf opened fine
File files/data/MCD15A2.A2012273.h17v03.005.2012297134400.hdf opened fine
File files/data/MCD15A2.A2012281.h17v03.005.2012297135831.hdf opened fine
File files/data/MCD15A2.A2012289.h17v03.005.2012299194634.hdf opened fine
File files/data/MCD15A2.A2012297.h17v03.005.2012306163257.hdf opened fine
File files/data/MCD15A2.A2012305.h17v03.005.2012314140451.hdf opened fine
File files/data/MCD15A2.A2012313.h17v03.005.2012322095802.hdf opened fine
File files/data/MCD15A2.A2012321.h17v03.005.2012335133638.hdf opened fine
File files/data/MCD15A2.A2012329.h17v03.005.2012340181739.hdf opened fine
File files/data/MCD15A2.A2012337.h17v03.005.2012346165133.hdf opened fine
File files/data/MCD15A2.A2012345.h17v03.005.2012356133200.hdf opened fine
File files/data/MCD15A2.A2012353.h17v03.005.2012363125132.hdf opened fine
File files/data/MCD15A2.A2012361.h17v03.005.2013007202756.hdf opened fine
File files/data/MCD15A2.A2012001.h17v03.005.2012017211237.hdf opened fine
File files/data/MCD15A2.A2012009.h17v03.005.2012019044037.hdf opened fine
File files/data/MCD15A2.A2012017.h17v03.005.2012026072526.hdf opened fine
File files/data/MCD15A2.A2012025.h17v03.005.2012052124839.hdf opened fine
File files/data/MCD15A2.A2012033.h17v03.005.2012042060649.hdf opened fine
File files/data/MCD15A2.A2012041.h17v03.005.2012050092057.hdf opened fine
File files/data/MCD15A2.A2012049.h17v03.005.2012068144447.hdf opened fine
File files/data/MCD15A2.A2012057.h17v03.005.2012068140544.hdf opened fine
File files/data/MCD15A2.A2012065.h17v03.005.2012075021749.hdf opened fine
File files/data/MCD15A2.A2012073.h17v03.005.2012083010304.hdf opened fine
File files/data/MCD15A2.A2012081.h17v03.005.2012090131602.hdf opened fine
File files/data/MCD15A2.A2012089.h17v03.005.2012107201245.hdf opened fine
File files/data/MCD15A2.A2012097.h17v03.005.2012108125047.hdf opened fine
File files/data/MCD15A2.A2012105.h17v03.005.2012116125519.hdf opened fine
File files/data/MCD15A2.A2012113.h17v03.005.2012122072153.hdf opened fine
File files/data/MCD15A2.A2012121.h17v03.005.2012137221611.hdf opened fine
File files/data/MCD15A2.A2012129.h17v03.005.2012142001241.hdf opened fine
File files/data/MCD15A2.A2012137.h17v03.005.2012153021910.hdf opened fine
File files/data/MCD15A2.A2012145.h17v03.005.2012160130927.hdf opened fine
File files/data/MCD15A2.A2012153.h17v03.005.2012166161748.hdf opened fine
File files/data/MCD15A2.A2012161.h17v03.005.2012170080216.hdf opened fine
File files/data/MCD15A2.A2012169.h17v03.005.2012181134242.hdf opened fine
File files/data/MCD15A2.A2012177.h17v03.005.2012188150145.hdf opened fine
File files/data/MCD15A2.A2012185.h17v03.005.2012208181105.hdf opened fine
File files/data/MCD15A2.A2012193.h17v03.005.2012202144013.hdf opened fine
File files/data/MCD15A2.A2012201.h17v03.005.2012215131931.hdf opened fine
File files/data/MCD15A2.A2012209.h17v03.005.2012219144450.hdf opened fine
File files/data/MCD15A2.A2012217.h17v03.005.2012228215213.hdf opened fine
File files/data/MCD15A2.A2012225.h17v03.005.2012234105932.hdf opened fine
File files/data/MCD15A2.A2012233.h17v03.005.2012242093511.hdf opened fine
File files/data/MCD15A2.A2012241.h17v03.005.2012250182515.hdf opened fine
File files/data/MCD15A2.A2012249.h17v03.005.2012261231425.hdf opened fine
File files/data/MCD15A2.A2012257.h17v03.005.2012270114223.hdf opened fine
File files/data/MCD15A2.A2012265.h17v03.005.2012276134731.hdf opened fine
File files/data/MCD15A2.A2012273.h17v03.005.2012297134400.hdf opened fine
File files/data/MCD15A2.A2012281.h17v03.005.2012297135831.hdf opened fine
File files/data/MCD15A2.A2012289.h17v03.005.2012299194634.hdf opened fine
File files/data/MCD15A2.A2012297.h17v03.005.2012306163257.hdf opened fine
File files/data/MCD15A2.A2012305.h17v03.005.2012314140451.hdf opened fine
File files/data/MCD15A2.A2012313.h17v03.005.2012322095802.hdf opened fine
File files/data/MCD15A2.A2012321.h17v03.005.2012335133638.hdf opened fine
File files/data/MCD15A2.A2012329.h17v03.005.2012340181739.hdf opened fine
File files/data/MCD15A2.A2012337.h17v03.005.2012346165133.hdf opened fine
File files/data/MCD15A2.A2012345.h17v03.005.2012356133200.hdf opened fine
File files/data/MCD15A2.A2012353.h17v03.005.2012363125132.hdf opened fine
File files/data/MCD15A2.A2012361.h17v03.005.2013007202756.hdf opened fine
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} plot the data}
\PYG{k+kn}{import} \PYG{n+nn}{pylab} \PYG{k+kn}{as} \PYG{n+nn}{plt}

\PYG{c}{\PYGZsh{} work out a consistent scaling}
\PYG{n}{lai\PYGZus{}max} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{n}{lai}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{i}\PYG{p}{,}\PYG{n}{f} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{files}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{fig} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{lai}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{n}{vmax}\PYG{o}{=}\PYG{n}{lai\PYGZus{}max}\PYG{o}{*}\PYG{l+m+mf}{0.75}\PYG{p}{)}
    \PYG{c}{\PYGZsh{} remember filenames of the form}
    \PYG{c}{\PYGZsh{} files/data/MCD15A2.A2011185.h09v05.005.2011213154534.hdf\PYGZsq{}}
    \PYG{n}{file\PYGZus{}id} \PYG{o}{=} \PYG{n}{f}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{.}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{p}{]}
    \PYG{k}{print} \PYG{n}{file\PYGZus{}id}
    \PYG{c}{\PYGZsh{} plot a jpg}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{n}{file\PYGZus{}id}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/images/lai\PYGZus{}uk\PYGZus{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{.jpg}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{n}{file\PYGZus{}id}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{n}{fig}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{2012001}
\PYG{l+m+mi}{2012009}
\PYG{l+m+mi}{2012017}
\PYG{l+m+mi}{2012025}
\PYG{l+m+mi}{2012033}
\PYG{l+m+mi}{2012041}
\PYG{l+m+mi}{2012049}
\PYG{l+m+mi}{2012057}
\PYG{l+m+mi}{2012065}
\PYG{l+m+mi}{2012073}
\PYG{l+m+mi}{2012081}
\PYG{l+m+mi}{2012089}
\PYG{l+m+mi}{2012097}
\PYG{l+m+mi}{2012105}
\PYG{l+m+mi}{2012113}
\PYG{l+m+mi}{2012121}
\PYG{l+m+mi}{2012129}
\PYG{l+m+mi}{2012137}
\PYG{l+m+mi}{2012145}
\PYG{l+m+mi}{2012153}
\PYG{l+m+mi}{2012161}
\PYG{l+m+mi}{2012169}
\PYG{l+m+mi}{2012177}
\PYG{l+m+mi}{2012185}
\PYG{l+m+mi}{2012193}
\PYG{l+m+mi}{2012201}
\PYG{l+m+mi}{2012209}
\PYG{l+m+mi}{2012217}
\PYG{l+m+mi}{2012225}
\PYG{l+m+mi}{2012233}
\PYG{l+m+mi}{2012241}
\PYG{l+m+mi}{2012249}
\PYG{l+m+mi}{2012257}
\PYG{l+m+mi}{2012265}
\PYG{l+m+mi}{2012273}
\PYG{l+m+mi}{2012281}
\PYG{l+m+mi}{2012289}
\PYG{l+m+mi}{2012297}
\PYG{l+m+mi}{2012305}
\PYG{l+m+mi}{2012313}
\PYG{l+m+mi}{2012321}
\PYG{l+m+mi}{2012329}
\PYG{l+m+mi}{2012337}
\PYG{l+m+mi}{2012345}
\PYG{l+m+mi}{2012353}
\PYG{l+m+mi}{2012361}
\PYG{l+m+mi}{2012001}
\PYG{l+m+mi}{2012009}
\PYG{l+m+mi}{2012017}
\PYG{l+m+mi}{2012025}
\PYG{l+m+mi}{2012033}
\PYG{l+m+mi}{2012041}
\PYG{l+m+mi}{2012049}
\PYG{l+m+mi}{2012057}
\PYG{l+m+mi}{2012065}
\PYG{l+m+mi}{2012073}
\PYG{l+m+mi}{2012081}
\PYG{l+m+mi}{2012089}
\PYG{l+m+mi}{2012097}
\PYG{l+m+mi}{2012105}
\PYG{l+m+mi}{2012113}
\PYG{l+m+mi}{2012121}
\PYG{l+m+mi}{2012129}
\PYG{l+m+mi}{2012137}
\PYG{l+m+mi}{2012145}
\PYG{l+m+mi}{2012153}
\PYG{l+m+mi}{2012161}
\PYG{l+m+mi}{2012169}
\PYG{l+m+mi}{2012177}
\PYG{l+m+mi}{2012185}
\PYG{l+m+mi}{2012193}
\PYG{l+m+mi}{2012201}
\PYG{l+m+mi}{2012209}
\PYG{l+m+mi}{2012217}
\PYG{l+m+mi}{2012225}
\PYG{l+m+mi}{2012233}
\PYG{l+m+mi}{2012241}
\PYG{l+m+mi}{2012249}
\PYG{l+m+mi}{2012257}
\PYG{l+m+mi}{2012265}
\PYG{l+m+mi}{2012273}
\PYG{l+m+mi}{2012281}
\PYG{l+m+mi}{2012289}
\PYG{l+m+mi}{2012297}
\PYG{l+m+mi}{2012305}
\PYG{l+m+mi}{2012313}
\PYG{l+m+mi}{2012321}
\PYG{l+m+mi}{2012329}
\PYG{l+m+mi}{2012337}
\PYG{l+m+mi}{2012345}
\PYG{l+m+mi}{2012353}
\PYG{l+m+mi}{2012361}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} now make a movie ...}

\PYG{k+kn}{import} \PYG{n+nn}{os}

\PYG{n}{cmd} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{convert \PYGZhy{}delay 100 \PYGZhy{}loop 0 files/images/lai\PYGZus{}uk\PYGZus{}*.jpg files/images/lai\PYGZus{}uk2.gif}\PYG{l+s}{\PYGZsq{}}
\PYG{n}{os}\PYG{o}{.}\PYG{n}{system}\PYG{p}{(}\PYG{n}{cmd}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{0}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{0}
\end{Verbatim}
\begin{figure}[htbp]
\centering

\includegraphics{Chapter4_GDAL/files/images/lai_uk02.gif}
\end{figure}


\chapter{Exercise 4.2: A Different Dataset}
\label{Chapter4_GDAL/answers:exercise-4-2-a-different-dataset}
We have now dowloaded a different dataset, the \href{http://www.icess.ucsb.edu/modis/SnowUsrGuide/usrguide\_1dtil.html}{MOD10A
product},
which is the 500 m MODIS daily snow cover product, over the UK.

This is a good opportunity to see if you can apply what was learned
above about interpreting QC information and using \code{gdal} to examine a
dataset.

If you examine the \href{http://nsidc.org/data/docs/daac/modis\_v5/mod10a1\_modis\_terra\_snow\_daily\_global\_500m\_grid.gd.html}{data description
page},
you will see that the data are in HDF EOS format (the same as the LAI
product).


\section{E4.2.1 Download}
\label{Chapter4_GDAL/answers:e4-2-1-download}
\begin{Verbatim}[commandchars=\\\{\}]
tile=h17v03
year=2012
type=MOST
month=02

file=robot\PYGZus{}snow.\PYGZdl{}\PYGZob{}year\PYGZcb{}\PYGZus{}\PYGZdl{}\PYGZob{}type\PYGZcb{}\PYGZus{}\PYGZdl{}\PYGZob{}tile\PYGZcb{}\PYGZus{}\PYGZdl{}\PYGZob{}month\PYGZcb{}.txt

grep \PYGZdl{}tile \PYGZlt{} files/data/robot\PYGZus{}snow.\PYGZdl{}year.txt \textbar{} grep \PYGZdl{}type \textbar{} grep \PYGZdq{}\PYGZdl{}\PYGZob{}year\PYGZcb{}\PYGZbs{}.\PYGZdl{}\PYGZob{}month\PYGZcb{}\PYGZdq{} \PYGZgt{} files/data/\PYGZdl{}file

wc \PYGZhy{}l files/data/\PYGZdl{}file

\PYGZsh{} cd temporarily to the local directory
pushd files/data
\PYGZsh{} \PYGZhy{}nc : no clobber : dont download if its there already
\PYGZsh{} \PYGZhy{}nH \PYGZhy{}\PYGZhy{}cut\PYGZhy{}dirs=3 : ignore the directories
wget \PYGZhy{}nc \PYGZhy{}i \PYGZdl{}file \PYGZhy{}nH \PYGZhy{}\PYGZhy{}cut\PYGZhy{}dirs=3
\PYGZsh{} cd back again
popd
echo \PYGZdl{}file
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
29 files/data/robot\PYGZus{}snow.2012\PYGZus{}MOST\PYGZus{}h17v03\PYGZus{}02.txt
\PYGZti{}/p/geogg122\PYGZus{}local/geogg122/Chapter4\PYGZus{}GDAL/files/data \PYGZti{}/p/geogg122\PYGZus{}local/geogg122/Chapter4\PYGZus{}GDAL
\PYGZti{}/p/geogg122\PYGZus{}local/geogg122/Chapter4\PYGZus{}GDAL
robot\PYGZus{}snow.2012\PYGZus{}MOST\PYGZus{}h17v03\PYGZus{}02.txt
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
Exception in thread Thread\PYGZhy{}2:
Traceback (most recent call last):
  File \PYGZdq{}/opt/anaconda/lib/python2.7/threading.py\PYGZdq{}, line 808, in \PYGZus{}\PYGZus{}bootstrap\PYGZus{}inner
    self.run()
  File \PYGZdq{}/opt/anaconda/lib/python2.7/site\PYGZhy{}packages/IPython/kernel/zmq/heartbeat.py\PYGZdq{}, line 55, in run
    zmq.device(zmq.FORWARDER, self.socket, self.socket)
  File \PYGZdq{}device.pyx\PYGZdq{}, line 55, in zmq.core.device.device (zmq/core/device.c:854)
ZMQError: Interrupted system call

File {}`MOD10A1.A2012032.h17v03.005.2012046141710.hdf\PYGZsq{} already there; not retrieving.
File {}`MOD10A1.A2012033.h17v03.005.2012035071148.hdf\PYGZsq{} already there; not retrieving.
File {}`MOD10A1.A2012034.h17v03.005.2012036060335.hdf\PYGZsq{} already there; not retrieving.
File {}`MOD10A1.A2012035.h17v03.005.2012037061127.hdf\PYGZsq{} already there; not retrieving.
File {}`MOD10A1.A2012036.h17v03.005.2012038044224.hdf\PYGZsq{} already there; not retrieving.
File {}`MOD10A1.A2012037.h17v03.005.2012039055929.hdf\PYGZsq{} already there; not retrieving.
File {}`MOD10A1.A2012038.h17v03.005.2012040045622.hdf\PYGZsq{} already there; not retrieving.
File {}`MOD10A1.A2012039.h17v03.005.2012041055153.hdf\PYGZsq{} already there; not retrieving.
File {}`MOD10A1.A2012040.h17v03.005.2012042055706.hdf\PYGZsq{} already there; not retrieving.
File {}`MOD10A1.A2012041.h17v03.005.2012045014038.hdf\PYGZsq{} already there; not retrieving.
File {}`MOD10A1.A2012042.h17v03.005.2012045024036.hdf\PYGZsq{} already there; not retrieving.
File {}`MOD10A1.A2012043.h17v03.005.2012045091534.hdf\PYGZsq{} already there; not retrieving.
File {}`MOD10A1.A2012044.h17v03.005.2012046060303.hdf\PYGZsq{} already there; not retrieving.
File {}`MOD10A1.A2012045.h17v03.005.2012047061553.hdf\PYGZsq{} already there; not retrieving.
File {}`MOD10A1.A2012046.h17v03.005.2012048071318.hdf\PYGZsq{} already there; not retrieving.
File {}`MOD10A1.A2012047.h17v03.005.2012049053946.hdf\PYGZsq{} already there; not retrieving.
File {}`MOD10A1.A2012048.h17v03.005.2012050063219.hdf\PYGZsq{} already there; not retrieving.
File {}`MOD10A1.A2012049.h17v03.005.2012051070019.hdf\PYGZsq{} already there; not retrieving.
File {}`MOD10A1.A2012050.h17v03.005.2012052062212.hdf\PYGZsq{} already there; not retrieving.
File {}`MOD10A1.A2012051.h17v03.005.2012053064001.hdf\PYGZsq{} already there; not retrieving.
File {}`MOD10A1.A2012052.h17v03.005.2012054062116.hdf\PYGZsq{} already there; not retrieving.
File {}`MOD10A1.A2012053.h17v03.005.2012056015333.hdf\PYGZsq{} already there; not retrieving.
File {}`MOD10A1.A2012054.h17v03.005.2012062191100.hdf\PYGZsq{} already there; not retrieving.
File {}`MOD10A1.A2012055.h17v03.005.2012057063901.hdf\PYGZsq{} already there; not retrieving.
File {}`MOD10A1.A2012056.h17v03.005.2012058061115.hdf\PYGZsq{} already there; not retrieving.
File {}`MOD10A1.A2012057.h17v03.005.2012059062619.hdf\PYGZsq{} already there; not retrieving.
File {}`MOD10A1.A2012058.h17v03.005.2012060061357.hdf\PYGZsq{} already there; not retrieving.
File {}`MOD10A1.A2012059.h17v03.005.2012061063515.hdf\PYGZsq{} already there; not retrieving.
File {}`MOD10A1.A2012060.h17v03.005.2012062064750.hdf\PYGZsq{} already there; not retrieving.
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
29 files/data/robot\PYGZus{}snow.2012\PYGZus{}MOST\PYGZus{}h17v03\PYGZus{}02.txt
\PYGZti{}/p/geogg122\PYGZus{}local/geogg122/Chapter4\PYGZus{}GDAL/files/data \PYGZti{}/p/geogg122\PYGZus{}local/geogg122/Chapter4\PYGZus{}GDAL
\PYGZti{}/p/geogg122\PYGZus{}local/geogg122/Chapter4\PYGZus{}GDAL
robot\PYGZus{}snow.2012\PYGZus{}MOST\PYGZus{}h17v03\PYGZus{}02.txt
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
File {}`MOD10A1.A2012032.h17v03.005.2012046141710.hdf\PYGZsq{} already there; not retrieving.
File {}`MOD10A1.A2012033.h17v03.005.2012035071148.hdf\PYGZsq{} already there; not retrieving.
File {}`MOD10A1.A2012034.h17v03.005.2012036060335.hdf\PYGZsq{} already there; not retrieving.
File {}`MOD10A1.A2012035.h17v03.005.2012037061127.hdf\PYGZsq{} already there; not retrieving.
File {}`MOD10A1.A2012036.h17v03.005.2012038044224.hdf\PYGZsq{} already there; not retrieving.
File {}`MOD10A1.A2012037.h17v03.005.2012039055929.hdf\PYGZsq{} already there; not retrieving.
File {}`MOD10A1.A2012038.h17v03.005.2012040045622.hdf\PYGZsq{} already there; not retrieving.
File {}`MOD10A1.A2012039.h17v03.005.2012041055153.hdf\PYGZsq{} already there; not retrieving.
File {}`MOD10A1.A2012040.h17v03.005.2012042055706.hdf\PYGZsq{} already there; not retrieving.
File {}`MOD10A1.A2012041.h17v03.005.2012045014038.hdf\PYGZsq{} already there; not retrieving.
File {}`MOD10A1.A2012042.h17v03.005.2012045024036.hdf\PYGZsq{} already there; not retrieving.
File {}`MOD10A1.A2012043.h17v03.005.2012045091534.hdf\PYGZsq{} already there; not retrieving.
File {}`MOD10A1.A2012044.h17v03.005.2012046060303.hdf\PYGZsq{} already there; not retrieving.
File {}`MOD10A1.A2012045.h17v03.005.2012047061553.hdf\PYGZsq{} already there; not retrieving.
File {}`MOD10A1.A2012046.h17v03.005.2012048071318.hdf\PYGZsq{} already there; not retrieving.
File {}`MOD10A1.A2012047.h17v03.005.2012049053946.hdf\PYGZsq{} already there; not retrieving.
File {}`MOD10A1.A2012048.h17v03.005.2012050063219.hdf\PYGZsq{} already there; not retrieving.
File {}`MOD10A1.A2012049.h17v03.005.2012051070019.hdf\PYGZsq{} already there; not retrieving.
File {}`MOD10A1.A2012050.h17v03.005.2012052062212.hdf\PYGZsq{} already there; not retrieving.
File {}`MOD10A1.A2012051.h17v03.005.2012053064001.hdf\PYGZsq{} already there; not retrieving.
File {}`MOD10A1.A2012052.h17v03.005.2012054062116.hdf\PYGZsq{} already there; not retrieving.
File {}`MOD10A1.A2012053.h17v03.005.2012056015333.hdf\PYGZsq{} already there; not retrieving.
File {}`MOD10A1.A2012054.h17v03.005.2012062191100.hdf\PYGZsq{} already there; not retrieving.
File {}`MOD10A1.A2012055.h17v03.005.2012057063901.hdf\PYGZsq{} already there; not retrieving.
File {}`MOD10A1.A2012056.h17v03.005.2012058061115.hdf\PYGZsq{} already there; not retrieving.
File {}`MOD10A1.A2012057.h17v03.005.2012059062619.hdf\PYGZsq{} already there; not retrieving.
File {}`MOD10A1.A2012058.h17v03.005.2012060061357.hdf\PYGZsq{} already there; not retrieving.
File {}`MOD10A1.A2012059.h17v03.005.2012061063515.hdf\PYGZsq{} already there; not retrieving.
File {}`MOD10A1.A2012060.h17v03.005.2012062064750.hdf\PYGZsq{} already there; not retrieving.
\end{Verbatim}


\section{E4.2.2 Explore}
\label{Chapter4_GDAL/answers:e4-2-2-explore}
We explore the dataset in the same way as above:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} how to find out which datasets are in the file}

\PYG{k+kn}{import} \PYG{n+nn}{gdal} \PYG{c}{\PYGZsh{} Import GDAL library bindings}

\PYG{c}{\PYGZsh{} The file that we shall be using}
\PYG{c}{\PYGZsh{} Needs to be on current directory}
\PYG{n}{filename} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012060.h17v03.005.2012062064750.hdf}\PYG{l+s}{\PYGZsq{}}

\PYG{n}{g} \PYG{o}{=} \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{Open}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{)}
\PYG{c}{\PYGZsh{} g should now be a GDAL dataset, but if the file isn\PYGZsq{}t found}
\PYG{c}{\PYGZsh{} g will be none. Let\PYGZsq{}s test this:}
\PYG{k}{if} \PYG{n}{g} \PYG{o+ow}{is} \PYG{n+nb+bp}{None}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Problem opening file }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{!}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n}{filename}
\PYG{k}{else}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{File }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{ opened fine}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n}{filename}


\PYG{n}{subdatasets} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{GetSubDatasets}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{fname}\PYG{p}{,} \PYG{n}{name} \PYG{o+ow}{in} \PYG{n}{subdatasets}\PYG{p}{:}
    \PYG{k}{print} \PYG{n}{name}
    \PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{fname}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
File files/data/MOD10A1.A2012060.h17v03.005.2012062064750.hdf opened fine
[2400x2400] Snow\PYGZus{}Cover\PYGZus{}Daily\PYGZus{}Tile MOD\PYGZus{}Grid\PYGZus{}Snow\PYGZus{}500m (8\PYGZhy{}bit unsigned integer)
    HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:\PYGZdq{}files/data/MOD10A1.A2012060.h17v03.005.2012062064750.hdf\PYGZdq{}:MOD\PYGZus{}Grid\PYGZus{}Snow\PYGZus{}500m:Snow\PYGZus{}Cover\PYGZus{}Daily\PYGZus{}Tile
[2400x2400] Snow\PYGZus{}Spatial\PYGZus{}QA MOD\PYGZus{}Grid\PYGZus{}Snow\PYGZus{}500m (8\PYGZhy{}bit unsigned integer)
    HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:\PYGZdq{}files/data/MOD10A1.A2012060.h17v03.005.2012062064750.hdf\PYGZdq{}:MOD\PYGZus{}Grid\PYGZus{}Snow\PYGZus{}500m:Snow\PYGZus{}Spatial\PYGZus{}QA
[2400x2400] Snow\PYGZus{}Albedo\PYGZus{}Daily\PYGZus{}Tile MOD\PYGZus{}Grid\PYGZus{}Snow\PYGZus{}500m (8\PYGZhy{}bit unsigned integer)
    HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:\PYGZdq{}files/data/MOD10A1.A2012060.h17v03.005.2012062064750.hdf\PYGZdq{}:MOD\PYGZus{}Grid\PYGZus{}Snow\PYGZus{}500m:Snow\PYGZus{}Albedo\PYGZus{}Daily\PYGZus{}Tile
[2400x2400] Fractional\PYGZus{}Snow\PYGZus{}Cover MOD\PYGZus{}Grid\PYGZus{}Snow\PYGZus{}500m (8\PYGZhy{}bit unsigned integer)
    HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:\PYGZdq{}files/data/MOD10A1.A2012060.h17v03.005.2012062064750.hdf\PYGZdq{}:MOD\PYGZus{}Grid\PYGZus{}Snow\PYGZus{}500m:Fractional\PYGZus{}Snow\PYGZus{}Cover
File files/data/MOD10A1.A2012060.h17v03.005.2012062064750.hdf opened fine
[2400x2400] Snow\PYGZus{}Cover\PYGZus{}Daily\PYGZus{}Tile MOD\PYGZus{}Grid\PYGZus{}Snow\PYGZus{}500m (8\PYGZhy{}bit unsigned integer)
    HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:\PYGZdq{}files/data/MOD10A1.A2012060.h17v03.005.2012062064750.hdf\PYGZdq{}:MOD\PYGZus{}Grid\PYGZus{}Snow\PYGZus{}500m:Snow\PYGZus{}Cover\PYGZus{}Daily\PYGZus{}Tile
[2400x2400] Snow\PYGZus{}Spatial\PYGZus{}QA MOD\PYGZus{}Grid\PYGZus{}Snow\PYGZus{}500m (8\PYGZhy{}bit unsigned integer)
    HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:\PYGZdq{}files/data/MOD10A1.A2012060.h17v03.005.2012062064750.hdf\PYGZdq{}:MOD\PYGZus{}Grid\PYGZus{}Snow\PYGZus{}500m:Snow\PYGZus{}Spatial\PYGZus{}QA
[2400x2400] Snow\PYGZus{}Albedo\PYGZus{}Daily\PYGZus{}Tile MOD\PYGZus{}Grid\PYGZus{}Snow\PYGZus{}500m (8\PYGZhy{}bit unsigned integer)
    HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:\PYGZdq{}files/data/MOD10A1.A2012060.h17v03.005.2012062064750.hdf\PYGZdq{}:MOD\PYGZus{}Grid\PYGZus{}Snow\PYGZus{}500m:Snow\PYGZus{}Albedo\PYGZus{}Daily\PYGZus{}Tile
[2400x2400] Fractional\PYGZus{}Snow\PYGZus{}Cover MOD\PYGZus{}Grid\PYGZus{}Snow\PYGZus{}500m (8\PYGZhy{}bit unsigned integer)
    HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:\PYGZdq{}files/data/MOD10A1.A2012060.h17v03.005.2012062064750.hdf\PYGZdq{}:MOD\PYGZus{}Grid\PYGZus{}Snow\PYGZus{}500m:Fractional\PYGZus{}Snow\PYGZus{}Cover
\end{Verbatim}


\section{E4.3.3 Read a dataset}
\label{Chapter4_GDAL/answers:e4-3-3-read-a-dataset}
This is very nearly the same as the LAI dataset reading.

We need obviously to select a different layer name.

We should also notice that the \code{file\_template} will be slightly
different (look at the list of subsets above).

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} How to access specific datasets in gdal}

\PYG{c}{\PYGZsh{} Let\PYGZsq{}s create a list with the selected layer names}
\PYG{n}{selected\PYGZus{}layers} \PYG{o}{=} \PYG{p}{[}  \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Fractional\PYGZus{}Snow\PYGZus{}Cover}\PYG{l+s}{\PYGZdq{}} \PYG{p}{]}

\PYG{c}{\PYGZsh{} We will store the data in a dictionary}
\PYG{c}{\PYGZsh{} Initialise an empty dictionary}
\PYG{n}{data} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}

\PYG{c}{\PYGZsh{} for convenience, we will use string substitution to create a}
\PYG{c}{\PYGZsh{} template for GDAL filenames, which we\PYGZsq{}ll substitute on the fly:}
\PYG{n}{file\PYGZus{}template} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{:MOD\PYGZus{}Grid\PYGZus{}Snow\PYGZus{}500m:}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZsq{}}
\PYG{c}{\PYGZsh{} This has two substitutions (the \PYGZpc{}s parts) which will refer to:}
\PYG{c}{\PYGZsh{} \PYGZhy{} the filename}
\PYG{c}{\PYGZsh{} \PYGZhy{} the data layer}

\PYG{k}{for} \PYG{n}{i}\PYG{p}{,} \PYG{n}{layer} \PYG{o+ow}{in} \PYG{n+nb}{enumerate} \PYG{p}{(} \PYG{n}{selected\PYGZus{}layers} \PYG{p}{)}\PYG{p}{:}
    \PYG{n}{this\PYGZus{}file} \PYG{o}{=} \PYG{n}{file\PYGZus{}template} \PYG{o}{\PYGZpc{}} \PYG{p}{(} \PYG{n}{filename}\PYG{p}{,} \PYG{n}{layer} \PYG{p}{)}
    \PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Opening Layer }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{: }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{this\PYGZus{}file} \PYG{p}{)}
    \PYG{n}{g} \PYG{o}{=} \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{Open} \PYG{p}{(} \PYG{n}{this\PYGZus{}file} \PYG{p}{)}

    \PYG{k}{if} \PYG{n}{g} \PYG{o+ow}{is} \PYG{n+nb+bp}{None}\PYG{p}{:}
        \PYG{k}{raise} \PYG{n+ne}{IOError}
    \PYG{n}{data}\PYG{p}{[}\PYG{n}{layer}\PYG{p}{]} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{ReadAsArray}\PYG{p}{(}\PYG{p}{)}
    \PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZgt{}\PYGZgt{}\PYGZgt{} Read }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{!}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n}{layer}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
Opening Layer 1: HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:\PYGZdq{}files/data/MOD10A1.A2012060.h17v03.005.2012062064750.hdf\PYGZdq{}:MOD\PYGZus{}Grid\PYGZus{}Snow\PYGZus{}500m:Fractional\PYGZus{}Snow\PYGZus{}Cover
    \PYGZgt{}\PYGZgt{}\PYGZgt{} Read Fractional\PYGZus{}Snow\PYGZus{}Cover!
Opening Layer 1: HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:\PYGZdq{}files/data/MOD10A1.A2012060.h17v03.005.2012062064750.hdf\PYGZdq{}:MOD\PYGZus{}Grid\PYGZus{}Snow\PYGZus{}500m:Fractional\PYGZus{}Snow\PYGZus{}Cover
    \PYGZgt{}\PYGZgt{}\PYGZgt{} Read Fractional\PYGZus{}Snow\PYGZus{}Cover!
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Fractional\PYGZus{}Snow\PYGZus{}Cover}\PYG{l+s}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s+si}{\PYGZpc{} s}\PYG{l+s}{now cover}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.text.Text at 0x5419ca90\PYGZgt{}
\end{Verbatim}

\includegraphics{answers_22_1.png}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.text.Text at 0x5c29a310\PYGZgt{}
\end{Verbatim}

\includegraphics{answers_22_3.png}


\section{E4.3.4 Water mask}
\label{Chapter4_GDAL/answers:e4-3-4-water-mask}
The data description page tells us that values of 237 239 will indicate
whether the data are ocean or inland water bodies. These are what you
should use to build the water mask.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{snow} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Fractional\PYGZus{}Snow\PYGZus{}Cover}\PYG{l+s}{\PYGZdq{}}\PYG{p}{]}

\PYG{n}{water} \PYG{o}{=}  \PYG{p}{(}\PYG{n}{snow} \PYG{o}{==} \PYG{l+m+mi}{239}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{water}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{water mask}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.text.Text at 0x4eb36890\PYGZgt{}
\end{Verbatim}

\includegraphics{answers_26_1.png}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.text.Text at 0x58256990\PYGZgt{}
\end{Verbatim}

\includegraphics{answers_26_3.png}


\section{E4.3.5 Valid pixel mask}
\label{Chapter4_GDAL/answers:e4-3-5-valid-pixel-mask}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{snow} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Fractional\PYGZus{}Snow\PYGZus{}Cover}\PYG{l+s}{\PYGZdq{}}\PYG{p}{]}

\PYG{n}{valid\PYGZus{}mask} \PYG{o}{=} \PYG{p}{(}\PYG{n}{snow} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{100}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{valid\PYGZus{}mask}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{valid mask}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.text.Text at 0x1c8f0e10\PYGZgt{}
\end{Verbatim}

\includegraphics{answers_29_1.png}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.text.Text at 0x5ad9cb50\PYGZgt{}
\end{Verbatim}

\includegraphics{answers_29_3.png}


\section{E4.3.6 3D dataset}
\label{Chapter4_GDAL/answers:e4-3-6-3d-dataset}
You should be used to this sort of thing by now.

First, lets sort the filenames:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} filenames from the file}
\PYG{n}{url\PYGZus{}file} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/robot\PYGZus{}snow.2012\PYGZus{}MOST\PYGZus{}h17v03\PYGZus{}02.txt}\PYG{l+s}{\PYGZsq{}}

\PYG{c}{\PYGZsh{} open the file for read}
\PYG{n}{fp} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{url\PYGZus{}file}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{c}{\PYGZsh{} the strip is to get rid of the \PYGZbs{}n character}
\PYG{n}{filenames} \PYG{o}{=} \PYG{p}{[}\PYG{n}{f}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{strip}\PYG{p}{(}\PYG{p}{)} \PYG{k}{for} \PYG{n}{f} \PYG{o+ow}{in} \PYG{n}{fp}\PYG{o}{.}\PYG{n}{readlines}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}

\PYG{c}{\PYGZsh{} close the file}
\PYG{n}{fp}\PYG{o}{.}\PYG{n}{close}

\PYG{c}{\PYGZsh{} lets see what we got}
\PYG{k}{print} \PYG{n}{filenames}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MOD10A1.A2012032.h17v03.005.2012046141710.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MOD10A1.A2012033.h17v03.005.2012035071148.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MOD10A1.A2012034.h17v03.005.2012036060335.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MOD10A1.A2012035.h17v03.005.2012037061127.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MOD10A1.A2012036.h17v03.005.2012038044224.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MOD10A1.A2012037.h17v03.005.2012039055929.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MOD10A1.A2012038.h17v03.005.2012040045622.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MOD10A1.A2012039.h17v03.005.2012041055153.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MOD10A1.A2012040.h17v03.005.2012042055706.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MOD10A1.A2012041.h17v03.005.2012045014038.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MOD10A1.A2012042.h17v03.005.2012045024036.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MOD10A1.A2012043.h17v03.005.2012045091534.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MOD10A1.A2012044.h17v03.005.2012046060303.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MOD10A1.A2012045.h17v03.005.2012047061553.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MOD10A1.A2012046.h17v03.005.2012048071318.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MOD10A1.A2012047.h17v03.005.2012049053946.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MOD10A1.A2012048.h17v03.005.2012050063219.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MOD10A1.A2012049.h17v03.005.2012051070019.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MOD10A1.A2012050.h17v03.005.2012052062212.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MOD10A1.A2012051.h17v03.005.2012053064001.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MOD10A1.A2012052.h17v03.005.2012054062116.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MOD10A1.A2012053.h17v03.005.2012056015333.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MOD10A1.A2012054.h17v03.005.2012062191100.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MOD10A1.A2012055.h17v03.005.2012057063901.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MOD10A1.A2012056.h17v03.005.2012058061115.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MOD10A1.A2012057.h17v03.005.2012059062619.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MOD10A1.A2012058.h17v03.005.2012060061357.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MOD10A1.A2012059.h17v03.005.2012061063515.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MOD10A1.A2012060.h17v03.005.2012062064750.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MOD10A1.A2012032.h17v03.005.2012046141710.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MOD10A1.A2012033.h17v03.005.2012035071148.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MOD10A1.A2012034.h17v03.005.2012036060335.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MOD10A1.A2012035.h17v03.005.2012037061127.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MOD10A1.A2012036.h17v03.005.2012038044224.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MOD10A1.A2012037.h17v03.005.2012039055929.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MOD10A1.A2012038.h17v03.005.2012040045622.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MOD10A1.A2012039.h17v03.005.2012041055153.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MOD10A1.A2012040.h17v03.005.2012042055706.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MOD10A1.A2012041.h17v03.005.2012045014038.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MOD10A1.A2012042.h17v03.005.2012045024036.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MOD10A1.A2012043.h17v03.005.2012045091534.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MOD10A1.A2012044.h17v03.005.2012046060303.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MOD10A1.A2012045.h17v03.005.2012047061553.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MOD10A1.A2012046.h17v03.005.2012048071318.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MOD10A1.A2012047.h17v03.005.2012049053946.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MOD10A1.A2012048.h17v03.005.2012050063219.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MOD10A1.A2012049.h17v03.005.2012051070019.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MOD10A1.A2012050.h17v03.005.2012052062212.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MOD10A1.A2012051.h17v03.005.2012053064001.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MOD10A1.A2012052.h17v03.005.2012054062116.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MOD10A1.A2012053.h17v03.005.2012056015333.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MOD10A1.A2012054.h17v03.005.2012062191100.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MOD10A1.A2012055.h17v03.005.2012057063901.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MOD10A1.A2012056.h17v03.005.2012058061115.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MOD10A1.A2012057.h17v03.005.2012059062619.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MOD10A1.A2012058.h17v03.005.2012060061357.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MOD10A1.A2012059.h17v03.005.2012061063515.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MOD10A1.A2012060.h17v03.005.2012062064750.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\end{Verbatim}

Using \code{glob} you might try:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} using glob}
\PYG{k+kn}{from} \PYG{n+nn}{glob} \PYG{k+kn}{import} \PYG{n}{glob}

\PYG{n}{filenames} \PYG{o}{=} \PYG{n}{glob}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012*.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{filenames}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012301.h17v03.005.2012303060756.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012022.h17v03.005.2012024065639.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012035.h17v03.005.2012037061127.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012099.h17v03.005.2012101130724.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012045.h17v03.005.2012047061553.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012026.h17v03.005.2012028061520.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012052.h17v03.005.2012054062116.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012300.h17v03.005.2012302074825.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012302.h17v03.005.2012305001707.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012101.h17v03.005.2012103060602.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012027.h17v03.005.2012029055452.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012033.h17v03.005.2012035071148.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012006.h17v03.005.2012008070328.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012034.h17v03.005.2012036060335.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012019.h17v03.005.2012021060039.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012011.h17v03.005.2012013083450.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012049.h17v03.005.2012051070019.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012021.h17v03.005.2012023061925.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012201.h17v03.005.2012203062815.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012102.h17v03.005.2012104064623.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012032.h17v03.005.2012046141710.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012056.h17v03.005.2012058061115.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012029.h17v03.005.2012031061407.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012100.h17v03.005.2012102064522.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012058.h17v03.005.2012060061357.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012047.h17v03.005.2012049053946.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012043.h17v03.005.2012045091534.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012051.h17v03.005.2012053064001.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012060.h17v03.005.2012062064750.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012001.h17v03.005.2012003054416.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012023.h17v03.005.2012025071134.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012010.h17v03.005.2012012062821.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012015.h17v03.005.2012018205153.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012025.h17v03.005.2012027050342.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012044.h17v03.005.2012046060303.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012017.h17v03.005.2012019073727.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012036.h17v03.005.2012038044224.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012018.h17v03.005.2012020053540.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012002.h17v03.005.2012004061011.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012048.h17v03.005.2012050063219.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012199.h17v03.005.2012201105729.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012008.h17v03.005.2012011154609.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012020.h17v03.005.2012022061254.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012009.h17v03.005.2012011222125.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012202.h17v03.005.2012204070422.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012097.h17v03.005.2012101074931.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012016.h17v03.005.2012019043022.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012024.h17v03.005.2012026061856.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012003.h17v03.005.2012005061244.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012030.h17v03.005.2012032062230.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012050.h17v03.005.2012052062212.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012040.h17v03.005.2012042055706.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012004.h17v03.005.2012006054639.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012039.h17v03.005.2012041055153.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012057.h17v03.005.2012059062619.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012041.h17v03.005.2012045014038.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012014.h17v03.005.2012017164755.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012038.h17v03.005.2012040045622.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012046.h17v03.005.2012048071318.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012054.h17v03.005.2012062191100.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012042.h17v03.005.2012045024036.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012299.h17v03.005.2012301062059.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012012.h17v03.005.2012014055337.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012098.h17v03.005.2012101093641.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012031.h17v03.005.2012033182451.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012059.h17v03.005.2012061063515.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012053.h17v03.005.2012056015333.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012013.h17v03.005.2012017195109.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012005.h17v03.005.2012007052708.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012028.h17v03.005.2012030055354.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012037.h17v03.005.2012039055929.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012055.h17v03.005.2012057063901.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012200.h17v03.005.2012202133641.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012007.h17v03.005.2012011144012.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012301.h17v03.005.2012303060756.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012022.h17v03.005.2012024065639.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012035.h17v03.005.2012037061127.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012099.h17v03.005.2012101130724.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012045.h17v03.005.2012047061553.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012026.h17v03.005.2012028061520.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012052.h17v03.005.2012054062116.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012300.h17v03.005.2012302074825.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012302.h17v03.005.2012305001707.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012101.h17v03.005.2012103060602.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012027.h17v03.005.2012029055452.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012033.h17v03.005.2012035071148.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012006.h17v03.005.2012008070328.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012034.h17v03.005.2012036060335.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012019.h17v03.005.2012021060039.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012011.h17v03.005.2012013083450.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012049.h17v03.005.2012051070019.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012021.h17v03.005.2012023061925.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012201.h17v03.005.2012203062815.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012102.h17v03.005.2012104064623.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012032.h17v03.005.2012046141710.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012056.h17v03.005.2012058061115.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012029.h17v03.005.2012031061407.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012100.h17v03.005.2012102064522.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012058.h17v03.005.2012060061357.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012047.h17v03.005.2012049053946.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012043.h17v03.005.2012045091534.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012051.h17v03.005.2012053064001.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012060.h17v03.005.2012062064750.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012001.h17v03.005.2012003054416.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012023.h17v03.005.2012025071134.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012010.h17v03.005.2012012062821.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012015.h17v03.005.2012018205153.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012025.h17v03.005.2012027050342.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012044.h17v03.005.2012046060303.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012017.h17v03.005.2012019073727.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012036.h17v03.005.2012038044224.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012018.h17v03.005.2012020053540.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012002.h17v03.005.2012004061011.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012048.h17v03.005.2012050063219.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012199.h17v03.005.2012201105729.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012008.h17v03.005.2012011154609.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012020.h17v03.005.2012022061254.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012009.h17v03.005.2012011222125.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012202.h17v03.005.2012204070422.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012097.h17v03.005.2012101074931.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012016.h17v03.005.2012019043022.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012024.h17v03.005.2012026061856.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012003.h17v03.005.2012005061244.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012030.h17v03.005.2012032062230.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012050.h17v03.005.2012052062212.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012040.h17v03.005.2012042055706.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012004.h17v03.005.2012006054639.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012039.h17v03.005.2012041055153.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012057.h17v03.005.2012059062619.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012041.h17v03.005.2012045014038.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012014.h17v03.005.2012017164755.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012038.h17v03.005.2012040045622.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012046.h17v03.005.2012048071318.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012054.h17v03.005.2012062191100.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012042.h17v03.005.2012045024036.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012299.h17v03.005.2012301062059.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012012.h17v03.005.2012014055337.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012098.h17v03.005.2012101093641.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012031.h17v03.005.2012033182451.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012059.h17v03.005.2012061063515.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012053.h17v03.005.2012056015333.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012013.h17v03.005.2012017195109.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012005.h17v03.005.2012007052708.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012028.h17v03.005.2012030055354.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012037.h17v03.005.2012039055929.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012055.h17v03.005.2012057063901.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012200.h17v03.005.2012202133641.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012007.h17v03.005.2012011144012.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\end{Verbatim}

But that isn't refined enough (i.e. it won't only pull files for
February if there are more).

So, we need to pull files from doy 32 to 60 inclusive ... which is a lot
more tricky ...

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} using glob}
\PYG{k+kn}{from} \PYG{n+nn}{glob} \PYG{k+kn}{import} \PYG{n}{glob}

\PYG{n}{filenames} \PYG{o}{=} \PYG{n}{glob}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A201203[2\PYGZhy{}9].*.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)} \PYG{o}{+}\PYGZbs{}
            \PYG{n}{glob}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A201204?.*.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)} \PYG{o}{+}\PYGZbs{}
            \PYG{n}{glob}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A201205?.*.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)} \PYG{o}{+}\PYGZbs{}
            \PYG{n}{glob}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012060.*.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{filenames}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012035.h17v03.005.2012037061127.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012033.h17v03.005.2012035071148.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012034.h17v03.005.2012036060335.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012032.h17v03.005.2012046141710.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012036.h17v03.005.2012038044224.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012039.h17v03.005.2012041055153.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012038.h17v03.005.2012040045622.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012037.h17v03.005.2012039055929.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012045.h17v03.005.2012047061553.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012049.h17v03.005.2012051070019.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012047.h17v03.005.2012049053946.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012043.h17v03.005.2012045091534.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012044.h17v03.005.2012046060303.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012048.h17v03.005.2012050063219.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012040.h17v03.005.2012042055706.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012041.h17v03.005.2012045014038.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012046.h17v03.005.2012048071318.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012042.h17v03.005.2012045024036.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012052.h17v03.005.2012054062116.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012056.h17v03.005.2012058061115.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012058.h17v03.005.2012060061357.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012051.h17v03.005.2012053064001.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012050.h17v03.005.2012052062212.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012057.h17v03.005.2012059062619.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012054.h17v03.005.2012062191100.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012059.h17v03.005.2012061063515.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012053.h17v03.005.2012056015333.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012055.h17v03.005.2012057063901.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012060.h17v03.005.2012062064750.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012035.h17v03.005.2012037061127.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012033.h17v03.005.2012035071148.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012034.h17v03.005.2012036060335.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012032.h17v03.005.2012046141710.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012036.h17v03.005.2012038044224.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012039.h17v03.005.2012041055153.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012038.h17v03.005.2012040045622.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012037.h17v03.005.2012039055929.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012045.h17v03.005.2012047061553.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012049.h17v03.005.2012051070019.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012047.h17v03.005.2012049053946.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012043.h17v03.005.2012045091534.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012044.h17v03.005.2012046060303.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012048.h17v03.005.2012050063219.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012040.h17v03.005.2012042055706.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012041.h17v03.005.2012045014038.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012046.h17v03.005.2012048071318.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012042.h17v03.005.2012045024036.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012052.h17v03.005.2012054062116.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012056.h17v03.005.2012058061115.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012058.h17v03.005.2012060061357.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012051.h17v03.005.2012053064001.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012050.h17v03.005.2012052062212.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012057.h17v03.005.2012059062619.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012054.h17v03.005.2012062191100.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012059.h17v03.005.2012061063515.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012053.h17v03.005.2012056015333.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012055.h17v03.005.2012057063901.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MOD10A1.A2012060.h17v03.005.2012062064750.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\end{Verbatim}

Practically, you might be better off reading an interpreting the url
file as above, or alternatively, put all of the February files in a
different directory and \code{glob} that ...

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} in any case, we should sort the filenames}
\PYG{n}{filenames} \PYG{o}{=} \PYG{n}{sort}\PYG{p}{(}\PYG{n}{filenames}\PYG{p}{)}
\end{Verbatim}

Next, let's define a function to read a single file into a numpy array
(and simplify what we have above a bit):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy.ma} \PYG{k+kn}{as} \PYG{n+nn}{ma}

\PYG{k}{def} \PYG{n+nf}{read\PYGZus{}snow}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{)}\PYG{p}{:}

    \PYG{n}{layers} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Fractional\PYGZus{}Snow\PYGZus{}Cover}\PYG{l+s}{\PYGZdq{}}

    \PYG{c}{\PYGZsh{} for convenience, we will use string substitution to create a}
    \PYG{c}{\PYGZsh{} template for GDAL filenames, which we\PYGZsq{}ll substitute on the fly:}
    \PYG{n}{file\PYGZus{}template} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{:MOD\PYGZus{}Grid\PYGZus{}Snow\PYGZus{}500m:}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZsq{}}
    \PYG{c}{\PYGZsh{} This has two substitutions (the \PYGZpc{}s parts) which will refer to:}
    \PYG{c}{\PYGZsh{} \PYGZhy{} the filename}
    \PYG{c}{\PYGZsh{} \PYGZhy{} the data layer}

    \PYG{n}{this\PYGZus{}file} \PYG{o}{=} \PYG{n}{file\PYGZus{}template} \PYG{o}{\PYGZpc{}} \PYG{p}{(} \PYG{n}{filename}\PYG{p}{,} \PYG{n}{layer} \PYG{p}{)}
    \PYG{n}{g} \PYG{o}{=} \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{Open} \PYG{p}{(} \PYG{n}{this\PYGZus{}file} \PYG{p}{)}

    \PYG{k}{if} \PYG{n}{g} \PYG{o+ow}{is} \PYG{n+nb+bp}{None}\PYG{p}{:}
        \PYG{k}{raise} \PYG{n+ne}{IOError}
    \PYG{n}{snow} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{ReadAsArray}\PYG{p}{(}\PYG{p}{)}

    \PYG{c}{\PYGZsh{} dont use this here, but just in case useful}
    \PYG{c}{\PYGZsh{}water = (snow == 239)}

    \PYG{n}{valid\PYGZus{}mask} \PYG{o}{=} \PYG{p}{(}\PYG{n}{snow} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{100}\PYG{p}{)}

    \PYG{k}{return} \PYG{n}{ma}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{snow}\PYG{p}{,}\PYG{n}{mask}\PYG{o}{=}\PYG{n}{valid\PYGZus{}mask}\PYG{p}{)}
\end{Verbatim}

Now, test it:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{snow} \PYG{o}{=} \PYG{n}{read\PYGZus{}snow}\PYG{p}{(}\PYG{n}{filenames}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{snow}\PYG{p}{,}\PYG{n}{vmax}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{n}{filenames}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.text.Text at 0x51650d50\PYGZgt{}
\end{Verbatim}

\includegraphics{answers_42_1.png}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.text.Text at 0x55663490\PYGZgt{}
\end{Verbatim}

\includegraphics{answers_42_3.png}

Now its just a loop as in several previous examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{snow} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{f} \PYG{o+ow}{in} \PYG{n}{filenames}\PYG{p}{:}
    \PYG{n}{snow}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{read\PYGZus{}snow}\PYG{p}{(}\PYG{n}{f}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{snow} \PYG{o}{=} \PYG{n}{ma}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{snow}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} or neater ...}

\PYG{n}{snow} \PYG{o}{=} \PYG{n}{ma}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{n}{read\PYGZus{}snow}\PYG{p}{(}\PYG{n}{f}\PYG{p}{)} \PYG{k}{for} \PYG{n}{f} \PYG{o+ow}{in} \PYG{n}{filenames}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{n}{snow}\PYG{o}{.}\PYG{n}{shape}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{l+m+mi}{29}\PYG{p}{,} \PYG{l+m+mi}{2400}\PYG{p}{,} \PYG{l+m+mi}{2400}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} now plot and save images}
\PYG{c}{\PYGZsh{} plot the data}
\PYG{k+kn}{import} \PYG{n+nn}{pylab} \PYG{k+kn}{as} \PYG{n+nn}{plt}

\PYG{n}{cmap} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{cm}\PYG{o}{.}\PYG{n}{PuBu}

\PYG{k}{for} \PYG{n}{i}\PYG{p}{,}\PYG{n}{f} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{filenames}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{snow}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,}\PYG{n}{cmap}\PYG{o}{=}\PYG{n}{cmap}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{n}{vmax}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{)}
    \PYG{c}{\PYGZsh{} remember filenames of the form}
    \PYG{c}{\PYGZsh{} files/data/MCD15A2.A2011185.h09v05.005.2011213154534.hdf\PYGZsq{}}
    \PYG{n}{file\PYGZus{}id} \PYG{o}{=} \PYG{n}{f}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{.}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{p}{]}
    \PYG{k}{print} \PYG{n}{file\PYGZus{}id}
    \PYG{c}{\PYGZsh{} plot a jpg}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{n}{file\PYGZus{}id}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/images/snow\PYGZus{}uk\PYGZus{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{.jpg}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{n}{file\PYGZus{}id}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{2012032}
\PYG{l+m+mi}{2012033}
\PYG{l+m+mi}{2012034}
\PYG{l+m+mi}{2012035}
\PYG{l+m+mi}{2012036}
\PYG{l+m+mi}{2012037}
\PYG{l+m+mi}{2012038}
\PYG{l+m+mi}{2012039}
\PYG{l+m+mi}{2012040}
\PYG{l+m+mi}{2012041}
\PYG{l+m+mi}{2012042}
\PYG{l+m+mi}{2012043}
\PYG{l+m+mi}{2012044}
\PYG{l+m+mi}{2012045}
\PYG{l+m+mi}{2012046}
\PYG{l+m+mi}{2012047}
\PYG{l+m+mi}{2012048}
\PYG{l+m+mi}{2012049}
\PYG{l+m+mi}{2012050}
\PYG{l+m+mi}{2012051}
\PYG{l+m+mi}{2012052}
\PYG{l+m+mi}{2012053}
\PYG{l+m+mi}{2012054}
\PYG{l+m+mi}{2012055}
\PYG{l+m+mi}{2012056}
\PYG{l+m+mi}{2012057}
\PYG{l+m+mi}{2012058}
\PYG{l+m+mi}{2012059}
\PYG{l+m+mi}{2012060}
\end{Verbatim}
\begin{alltt}
/opt/anaconda/lib/python2.7/site-packages/matplotlib/pyplot.py:412: RuntimeWarning: More than 20 figures have been opened. Figures created through the pyplot interface (\emph{matplotlib.pyplot.figure}) are retained until explicitly closed and may consume too much memory. (To control this warning, see the rcParam \emph{figure.max\_num\_figures}).
  max\_open\_warning, RuntimeWarning)
\end{alltt}

\includegraphics{answers_47_2.png}

\includegraphics{answers_47_3.png}

\includegraphics{answers_47_4.png}

\includegraphics{answers_47_5.png}

\includegraphics{answers_47_6.png}

\includegraphics{answers_47_7.png}

\includegraphics{answers_47_8.png}

\includegraphics{answers_47_9.png}

\includegraphics{answers_47_10.png}

\includegraphics{answers_47_11.png}

\includegraphics{answers_47_12.png}

\includegraphics{answers_47_13.png}

\includegraphics{answers_47_14.png}

\includegraphics{answers_47_15.png}

\includegraphics{answers_47_16.png}

\includegraphics{answers_47_17.png}

\includegraphics{answers_47_18.png}

\includegraphics{answers_47_19.png}

\includegraphics{answers_47_20.png}

\includegraphics{answers_47_21.png}

\includegraphics{answers_47_22.png}

\includegraphics{answers_47_23.png}

\includegraphics{answers_47_24.png}

\includegraphics{answers_47_25.png}

\includegraphics{answers_47_26.png}

\includegraphics{answers_47_27.png}

\includegraphics{answers_47_28.png}

\includegraphics{answers_47_29.png}

\includegraphics{answers_47_30.png}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} now make a movie ...}

\PYG{k+kn}{import} \PYG{n+nn}{os}

\PYG{n}{cmd} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{convert \PYGZhy{}delay 100 \PYGZhy{}loop 0 files/images/snow\PYGZus{}uk\PYGZus{}*.jpg files/images/snow\PYGZus{}uk2.gif}\PYG{l+s}{\PYGZsq{}}
\PYG{n}{os}\PYG{o}{.}\PYG{n}{system}\PYG{p}{(}\PYG{n}{cmd}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{0}
\end{Verbatim}
\begin{figure}[htbp]
\centering

\includegraphics{Chapter4_GDAL/files/images/snow_uk2.gif}
\end{figure}


\section{Exercise 4.3}
\label{Chapter4_GDAL/answers:exercise-4-3}
Again, you should be used to this sort of thing by now.

We have the following code to base this on:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{n}{sys}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/python}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{k+kn}{from} \PYG{n+nn}{raster\PYGZus{}mask} \PYG{k+kn}{import} \PYG{n}{raster\PYGZus{}mask}\PYG{p}{,} \PYG{n}{getLAI}

\PYG{c}{\PYGZsh{} test this on an LAI file}

\PYG{c}{\PYGZsh{} the data file name}
\PYG{n}{filename} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MCD15A2.A2012273.h17v03.005.2012297134400.hdf}\PYG{l+s}{\PYGZsq{}}

\PYG{c}{\PYGZsh{} a layer (doesn\PYGZsq{}t matter so much which: use for geometry info)}
\PYG{n}{layer} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}
\PYG{c}{\PYGZsh{} the full dataset specification}
\PYG{n}{file\PYGZus{}template} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{:MOD\PYGZus{}Grid\PYGZus{}MOD15A2:}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZsq{}}
\PYG{n}{file\PYGZus{}spec} \PYG{o}{=} \PYG{n}{file\PYGZus{}template}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{,}\PYG{n}{layer}\PYG{p}{)}

\PYG{c}{\PYGZsh{} make a raster mask}
\PYG{c}{\PYGZsh{} from the layer IRELAND in world.shp}
\PYG{n}{mask} \PYG{o}{=} \PYG{n}{raster\PYGZus{}mask}\PYG{p}{(}\PYG{n}{file\PYGZus{}spec}\PYG{p}{,}\PYGZbs{}
                   \PYG{n}{target\PYGZus{}vector\PYGZus{}file} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{files/data/world.shp}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYGZbs{}
                   \PYG{n}{attribute\PYGZus{}filter} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{NAME = }\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{IRELAND}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}

\PYG{c}{\PYGZsh{} get the LAI data}
\PYG{n}{data} \PYG{o}{=} \PYG{n}{getLAI}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{)}

\PYG{c}{\PYGZsh{} reset the data mask}
\PYG{c}{\PYGZsh{} \PYGZsq{}mask\PYGZsq{} is True for Ireland}
\PYG{c}{\PYGZsh{} so take the opposite}
\PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{ma}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{mask}\PYG{o}{=}\PYG{n}{mask}\PYG{p}{)}
\PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{LaiStdDev\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{ma}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{mask}\PYG{o}{=}\PYG{n}{mask}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{LAI for Eire: 2012273}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{vmax}\PYG{o}{=}\PYG{l+m+mi}{6}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.colorbar.Colorbar instance at 0x47fc61b8\PYGZgt{}
\end{Verbatim}

\includegraphics{answers_52_1.png}

Obviously, we will need to specify a set of filenames again.

These have a simple filename pattern, so \code{glob} would be appropriate
(don't forget to \code{sort}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{glob} \PYG{k+kn}{import} \PYG{n}{glob}

\PYG{n}{filenames} \PYG{o}{=} \PYG{n}{sort}\PYG{p}{(}\PYG{n}{glob}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MCD15A2.A2012???.h17v03.005.*.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}

\PYG{k}{print} \PYG{n}{filenames}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MCD15A2.A2012001.h17v03.005.2012017211237.hdf}\PYG{l+s}{\PYGZsq{}}
 \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MCD15A2.A2012009.h17v03.005.2012019044037.hdf}\PYG{l+s}{\PYGZsq{}}
 \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MCD15A2.A2012017.h17v03.005.2012026072526.hdf}\PYG{l+s}{\PYGZsq{}}
 \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MCD15A2.A2012025.h17v03.005.2012052124839.hdf}\PYG{l+s}{\PYGZsq{}}
 \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MCD15A2.A2012033.h17v03.005.2012042060649.hdf}\PYG{l+s}{\PYGZsq{}}
 \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MCD15A2.A2012041.h17v03.005.2012050092057.hdf}\PYG{l+s}{\PYGZsq{}}
 \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MCD15A2.A2012049.h17v03.005.2012068144447.hdf}\PYG{l+s}{\PYGZsq{}}
 \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MCD15A2.A2012057.h17v03.005.2012068140544.hdf}\PYG{l+s}{\PYGZsq{}}
 \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MCD15A2.A2012065.h17v03.005.2012075021749.hdf}\PYG{l+s}{\PYGZsq{}}
 \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MCD15A2.A2012073.h17v03.005.2012083010304.hdf}\PYG{l+s}{\PYGZsq{}}
 \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MCD15A2.A2012081.h17v03.005.2012090131602.hdf}\PYG{l+s}{\PYGZsq{}}
 \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MCD15A2.A2012089.h17v03.005.2012107201245.hdf}\PYG{l+s}{\PYGZsq{}}
 \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MCD15A2.A2012097.h17v03.005.2012108125047.hdf}\PYG{l+s}{\PYGZsq{}}
 \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MCD15A2.A2012105.h17v03.005.2012116125519.hdf}\PYG{l+s}{\PYGZsq{}}
 \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MCD15A2.A2012113.h17v03.005.2012122072153.hdf}\PYG{l+s}{\PYGZsq{}}
 \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MCD15A2.A2012121.h17v03.005.2012137221611.hdf}\PYG{l+s}{\PYGZsq{}}
 \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MCD15A2.A2012129.h17v03.005.2012142001241.hdf}\PYG{l+s}{\PYGZsq{}}
 \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MCD15A2.A2012137.h17v03.005.2012153021910.hdf}\PYG{l+s}{\PYGZsq{}}
 \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MCD15A2.A2012145.h17v03.005.2012160130927.hdf}\PYG{l+s}{\PYGZsq{}}
 \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MCD15A2.A2012153.h17v03.005.2012166161748.hdf}\PYG{l+s}{\PYGZsq{}}
 \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MCD15A2.A2012161.h17v03.005.2012170080216.hdf}\PYG{l+s}{\PYGZsq{}}
 \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MCD15A2.A2012169.h17v03.005.2012181134242.hdf}\PYG{l+s}{\PYGZsq{}}
 \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MCD15A2.A2012177.h17v03.005.2012188150145.hdf}\PYG{l+s}{\PYGZsq{}}
 \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MCD15A2.A2012185.h17v03.005.2012208181105.hdf}\PYG{l+s}{\PYGZsq{}}
 \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MCD15A2.A2012193.h17v03.005.2012202144013.hdf}\PYG{l+s}{\PYGZsq{}}
 \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MCD15A2.A2012201.h17v03.005.2012215131931.hdf}\PYG{l+s}{\PYGZsq{}}
 \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MCD15A2.A2012209.h17v03.005.2012219144450.hdf}\PYG{l+s}{\PYGZsq{}}
 \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MCD15A2.A2012217.h17v03.005.2012228215213.hdf}\PYG{l+s}{\PYGZsq{}}
 \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MCD15A2.A2012225.h17v03.005.2012234105932.hdf}\PYG{l+s}{\PYGZsq{}}
 \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MCD15A2.A2012233.h17v03.005.2012242093511.hdf}\PYG{l+s}{\PYGZsq{}}
 \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MCD15A2.A2012241.h17v03.005.2012250182515.hdf}\PYG{l+s}{\PYGZsq{}}
 \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MCD15A2.A2012249.h17v03.005.2012261231425.hdf}\PYG{l+s}{\PYGZsq{}}
 \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MCD15A2.A2012257.h17v03.005.2012270114223.hdf}\PYG{l+s}{\PYGZsq{}}
 \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MCD15A2.A2012265.h17v03.005.2012276134731.hdf}\PYG{l+s}{\PYGZsq{}}
 \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MCD15A2.A2012273.h17v03.005.2012297134400.hdf}\PYG{l+s}{\PYGZsq{}}
 \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MCD15A2.A2012281.h17v03.005.2012297135831.hdf}\PYG{l+s}{\PYGZsq{}}
 \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MCD15A2.A2012289.h17v03.005.2012299194634.hdf}\PYG{l+s}{\PYGZsq{}}
 \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MCD15A2.A2012297.h17v03.005.2012306163257.hdf}\PYG{l+s}{\PYGZsq{}}
 \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MCD15A2.A2012305.h17v03.005.2012314140451.hdf}\PYG{l+s}{\PYGZsq{}}
 \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MCD15A2.A2012313.h17v03.005.2012322095802.hdf}\PYG{l+s}{\PYGZsq{}}
 \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MCD15A2.A2012321.h17v03.005.2012335133638.hdf}\PYG{l+s}{\PYGZsq{}}
 \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MCD15A2.A2012329.h17v03.005.2012340181739.hdf}\PYG{l+s}{\PYGZsq{}}
 \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MCD15A2.A2012337.h17v03.005.2012346165133.hdf}\PYG{l+s}{\PYGZsq{}}
 \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MCD15A2.A2012345.h17v03.005.2012356133200.hdf}\PYG{l+s}{\PYGZsq{}}
 \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MCD15A2.A2012353.h17v03.005.2012363125132.hdf}\PYG{l+s}{\PYGZsq{}}
 \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MCD15A2.A2012361.h17v03.005.2013007202756.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\end{Verbatim}

Now we just build a loop around that:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{n}{sys}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/python}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{k+kn}{from} \PYG{n+nn}{raster\PYGZus{}mask} \PYG{k+kn}{import} \PYG{n}{raster\PYGZus{}mask}\PYG{p}{,} \PYG{n}{getLAI}
\PYG{k+kn}{from} \PYG{n+nn}{glob} \PYG{k+kn}{import} \PYG{n}{glob}

\PYG{c}{\PYGZsh{} a layer (doesn\PYGZsq{}t matter so much which: use for geometry info)}
\PYG{n}{layer} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}
\PYG{c}{\PYGZsh{} the full dataset specification}

\PYG{n}{file\PYGZus{}template} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{:MOD\PYGZus{}Grid\PYGZus{}MOD15A2:}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZsq{}}

\PYG{c}{\PYGZsh{} list of filenames}
\PYG{n}{filenames} \PYG{o}{=} \PYG{n}{sort}\PYG{p}{(}\PYG{n}{glob}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MCD15A2.A2012???.h17v03.005.*.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}

\PYG{c}{\PYGZsh{} build a mask: use filenames[0] for geometry}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{building mask ...}\PYG{l+s}{\PYGZsq{}}
\PYG{n}{mask} \PYG{o}{=} \PYG{n}{raster\PYGZus{}mask}\PYG{p}{(}\PYG{n}{file\PYGZus{}template}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{filenames}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{layer}\PYG{p}{)}\PYG{p}{,}\PYGZbs{}
                       \PYG{n}{target\PYGZus{}vector\PYGZus{}file} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{files/data/world.shp}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYGZbs{}
                       \PYG{n}{attribute\PYGZus{}filter} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{NAME = }\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{IRELAND}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}

\PYG{n}{lai} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{looping over files...}\PYG{l+s}{\PYGZsq{}}
\PYG{k}{for} \PYG{n}{filename} \PYG{o+ow}{in} \PYG{n}{filenames}\PYG{p}{:}
    \PYG{c}{\PYGZsh{} get the LAI data}
    \PYG{k}{print} \PYG{n}{filename}
    \PYG{n}{data} \PYG{o}{=} \PYG{n}{getLAI}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{)}

    \PYG{c}{\PYGZsh{} reset the data mask}
    \PYG{n}{lai}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{ma}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{mask}\PYG{o}{=}\PYG{n}{mask}\PYG{p}{)}\PYG{p}{)}

\PYG{c}{\PYGZsh{} convert to masked array}
\PYG{n}{lai} \PYG{o}{=} \PYG{n}{ma}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{lai}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
building mask ...
looping over files...
files/data/MCD15A2.A2012001.h17v03.005.2012017211237.hdf
files/data/MCD15A2.A2012009.h17v03.005.2012019044037.hdf
files/data/MCD15A2.A2012017.h17v03.005.2012026072526.hdf
files/data/MCD15A2.A2012025.h17v03.005.2012052124839.hdf
files/data/MCD15A2.A2012033.h17v03.005.2012042060649.hdf
files/data/MCD15A2.A2012041.h17v03.005.2012050092057.hdf
files/data/MCD15A2.A2012049.h17v03.005.2012068144447.hdf
files/data/MCD15A2.A2012057.h17v03.005.2012068140544.hdf
files/data/MCD15A2.A2012065.h17v03.005.2012075021749.hdf
files/data/MCD15A2.A2012073.h17v03.005.2012083010304.hdf
files/data/MCD15A2.A2012081.h17v03.005.2012090131602.hdf
files/data/MCD15A2.A2012089.h17v03.005.2012107201245.hdf
files/data/MCD15A2.A2012097.h17v03.005.2012108125047.hdf
files/data/MCD15A2.A2012105.h17v03.005.2012116125519.hdf
files/data/MCD15A2.A2012113.h17v03.005.2012122072153.hdf
files/data/MCD15A2.A2012121.h17v03.005.2012137221611.hdf
files/data/MCD15A2.A2012129.h17v03.005.2012142001241.hdf
files/data/MCD15A2.A2012137.h17v03.005.2012153021910.hdf
files/data/MCD15A2.A2012145.h17v03.005.2012160130927.hdf
files/data/MCD15A2.A2012153.h17v03.005.2012166161748.hdf
files/data/MCD15A2.A2012161.h17v03.005.2012170080216.hdf
files/data/MCD15A2.A2012169.h17v03.005.2012181134242.hdf
files/data/MCD15A2.A2012177.h17v03.005.2012188150145.hdf
files/data/MCD15A2.A2012185.h17v03.005.2012208181105.hdf
files/data/MCD15A2.A2012193.h17v03.005.2012202144013.hdf
files/data/MCD15A2.A2012201.h17v03.005.2012215131931.hdf
files/data/MCD15A2.A2012209.h17v03.005.2012219144450.hdf
files/data/MCD15A2.A2012217.h17v03.005.2012228215213.hdf
files/data/MCD15A2.A2012225.h17v03.005.2012234105932.hdf
files/data/MCD15A2.A2012233.h17v03.005.2012242093511.hdf
files/data/MCD15A2.A2012241.h17v03.005.2012250182515.hdf
files/data/MCD15A2.A2012249.h17v03.005.2012261231425.hdf
files/data/MCD15A2.A2012257.h17v03.005.2012270114223.hdf
files/data/MCD15A2.A2012265.h17v03.005.2012276134731.hdf
files/data/MCD15A2.A2012273.h17v03.005.2012297134400.hdf
files/data/MCD15A2.A2012281.h17v03.005.2012297135831.hdf
files/data/MCD15A2.A2012289.h17v03.005.2012299194634.hdf
files/data/MCD15A2.A2012297.h17v03.005.2012306163257.hdf
files/data/MCD15A2.A2012305.h17v03.005.2012314140451.hdf
files/data/MCD15A2.A2012313.h17v03.005.2012322095802.hdf
files/data/MCD15A2.A2012321.h17v03.005.2012335133638.hdf
files/data/MCD15A2.A2012329.h17v03.005.2012340181739.hdf
files/data/MCD15A2.A2012337.h17v03.005.2012346165133.hdf
files/data/MCD15A2.A2012345.h17v03.005.2012356133200.hdf
files/data/MCD15A2.A2012353.h17v03.005.2012363125132.hdf
files/data/MCD15A2.A2012361.h17v03.005.2013007202756.hdf
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} make sure we can load it, then plot it}
\PYG{k+kn}{import} \PYG{n+nn}{numpy.ma} \PYG{k+kn}{as} \PYG{n+nn}{ma}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}


\PYG{c}{\PYGZsh{} now plot and save images}
\PYG{c}{\PYGZsh{} plot the data}
\PYG{k+kn}{import} \PYG{n+nn}{pylab} \PYG{k+kn}{as} \PYG{n+nn}{plt}

\PYG{n}{cmap} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{cm}\PYG{o}{.}\PYG{n}{Greens}
\PYG{c}{\PYGZsh{}plt.ioff()}

\PYG{k}{for} \PYG{n}{i}\PYG{p}{,}\PYG{n}{f} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{filenames}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{fig} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{lai}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,}\PYG{n}{cmap}\PYG{o}{=}\PYG{n}{cmap}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{n}{vmax}\PYG{o}{=}\PYG{l+m+mf}{6.}\PYG{p}{)}
    \PYG{c}{\PYGZsh{} remember filenames of the form}
    \PYG{c}{\PYGZsh{} files/data/MCD15A2.A2011185.h09v05.005.2011213154534.hdf\PYGZsq{}}
    \PYG{n}{file\PYGZus{}id} \PYG{o}{=} \PYG{n}{f}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{.}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{p}{]}
    \PYG{k}{print} \PYG{n}{file\PYGZus{}id}
    \PYG{c}{\PYGZsh{} plot a jpg}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{n}{file\PYGZus{}id}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/images/lai\PYGZus{}eire\PYGZus{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{.jpg}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{n}{file\PYGZus{}id}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{n}{fig}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{2012001}
\PYG{l+m+mi}{2012009}
\PYG{l+m+mi}{2012017}
\PYG{l+m+mi}{2012025}
\PYG{l+m+mi}{2012033}
\PYG{l+m+mi}{2012041}
\PYG{l+m+mi}{2012049}
\PYG{l+m+mi}{2012057}
\PYG{l+m+mi}{2012065}
\PYG{l+m+mi}{2012073}
\PYG{l+m+mi}{2012081}
\PYG{l+m+mi}{2012089}
\PYG{l+m+mi}{2012097}
\PYG{l+m+mi}{2012105}
\PYG{l+m+mi}{2012113}
\PYG{l+m+mi}{2012121}
\PYG{l+m+mi}{2012129}
\PYG{l+m+mi}{2012137}
\PYG{l+m+mi}{2012145}
\PYG{l+m+mi}{2012153}
\PYG{l+m+mi}{2012161}
\PYG{l+m+mi}{2012169}
\PYG{l+m+mi}{2012177}
\PYG{l+m+mi}{2012185}
\PYG{l+m+mi}{2012193}
\PYG{l+m+mi}{2012201}
\PYG{l+m+mi}{2012209}
\PYG{l+m+mi}{2012217}
\PYG{l+m+mi}{2012225}
\PYG{l+m+mi}{2012233}
\PYG{l+m+mi}{2012241}
\PYG{l+m+mi}{2012249}
\PYG{l+m+mi}{2012257}
\PYG{l+m+mi}{2012265}
\PYG{l+m+mi}{2012273}
\PYG{l+m+mi}{2012281}
\PYG{l+m+mi}{2012289}
\PYG{l+m+mi}{2012297}
\PYG{l+m+mi}{2012305}
\PYG{l+m+mi}{2012313}
\PYG{l+m+mi}{2012321}
\PYG{l+m+mi}{2012329}
\PYG{l+m+mi}{2012337}
\PYG{l+m+mi}{2012345}
\PYG{l+m+mi}{2012353}
\PYG{l+m+mi}{2012361}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} now make a movie ...}

\PYG{k+kn}{import} \PYG{n+nn}{os}

\PYG{n}{cmd} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{convert \PYGZhy{}delay 100 \PYGZhy{}loop 0 files/images/lai\PYGZus{}eire\PYGZus{}*.jpg files/images/lai\PYGZus{}eire.gif}\PYG{l+s}{\PYGZsq{}}
\PYG{n}{os}\PYG{o}{.}\PYG{n}{system}\PYG{p}{(}\PYG{n}{cmd}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{0}
\end{Verbatim}
\begin{figure}[htbp]
\centering

\includegraphics{Chapter4_GDAL/files/images/lai_eire.gif}
\end{figure}

It should be obvious how to adapt this to generate a similar LAI Std Dev
dataset.

An average is simply obtained:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{try}\PYG{p}{:}
    \PYG{n}{lai\PYGZus{}mean} \PYG{o}{=} \PYG{n}{lai}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{n}{axis}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{except}\PYG{p}{:}
    \PYG{k}{pass}
\end{Verbatim}

Though in older versions of numpy, you have to do each axis separately:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{lai}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{array}\PYG{p}{(}\PYG{p}{[} \PYG{l+m+mf}{0.}        \PYG{p}{,}  \PYG{l+m+mf}{0.}        \PYG{p}{,}  \PYG{l+m+mf}{0.}        \PYG{p}{,}  \PYG{l+m+mf}{1.13194208}\PYG{p}{,}  \PYG{l+m+mf}{0.8385127} \PYG{p}{,}
        \PYG{l+m+mf}{0.7581951} \PYG{p}{,}  \PYG{l+m+mf}{1.62490352}\PYG{p}{,}  \PYG{l+m+mf}{1.77427215}\PYG{p}{,}  \PYG{l+m+mf}{1.68431605}\PYG{p}{,}  \PYG{l+m+mf}{1.53881657}\PYG{p}{,}
        \PYG{l+m+mf}{2.46867764}\PYG{p}{,}  \PYG{l+m+mf}{2.22713124}\PYG{p}{,}  \PYG{l+m+mf}{1.97079892}\PYG{p}{,}  \PYG{l+m+mf}{2.19423149}\PYG{p}{,}  \PYG{l+m+mf}{1.83186409}\PYG{p}{,}
        \PYG{l+m+mf}{1.68775959}\PYG{p}{,}  \PYG{l+m+mf}{2.5530641} \PYG{p}{,}  \PYG{l+m+mf}{1.82426569}\PYG{p}{,}  \PYG{l+m+mf}{3.350427}  \PYG{p}{,}  \PYG{l+m+mf}{1.79795768}\PYG{p}{,}
        \PYG{l+m+mf}{2.29830478}\PYG{p}{,}  \PYG{l+m+mf}{2.30001168}\PYG{p}{,}  \PYG{l+m+mf}{1.86932879}\PYG{p}{,}  \PYG{l+m+mf}{1.74646726}\PYG{p}{,}  \PYG{l+m+mf}{2.21955}   \PYG{p}{,}
        \PYG{l+m+mf}{2.02689304}\PYG{p}{,}  \PYG{l+m+mf}{2.61823983}\PYG{p}{,}  \PYG{l+m+mf}{2.63460711}\PYG{p}{,}  \PYG{l+m+mf}{2.18868341}\PYG{p}{,}  \PYG{l+m+mf}{2.2350088} \PYG{p}{,}
        \PYG{l+m+mf}{2.10244737}\PYG{p}{,}  \PYG{l+m+mf}{2.64785816}\PYG{p}{,}  \PYG{l+m+mf}{2.38064128}\PYG{p}{,}  \PYG{l+m+mf}{1.93491947}\PYG{p}{,}  \PYG{l+m+mf}{2.01097991}\PYG{p}{,}
        \PYG{l+m+mf}{1.92061334}\PYG{p}{,}  \PYG{l+m+mf}{1.6725845} \PYG{p}{,}  \PYG{l+m+mf}{1.83265805}\PYG{p}{,}  \PYG{l+m+mf}{1.70210771}\PYG{p}{,}  \PYG{l+m+mf}{0.99212715}\PYG{p}{,}
        \PYG{l+m+mf}{0.}        \PYG{p}{,}  \PYG{l+m+mf}{0.}        \PYG{p}{,}  \PYG{l+m+mf}{0.}        \PYG{p}{,}  \PYG{l+m+mf}{0.}        \PYG{p}{,}  \PYG{l+m+mf}{0.}        \PYG{p}{,}  \PYG{l+m+mf}{0.}        \PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

There is plenty to criticise with such an average though: it takes no
account of the uncertainty in each data value (that is known), and it
takes no account of data gaps.

We will return to these issues next week.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{n}{lai}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{lai}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{mean LAI over Eire}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{ index}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{LAI}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.text.Text at 0x6fa33490\PYGZgt{}
\end{Verbatim}

\includegraphics{answers_65_1.png}


\chapter{5. Function fitting and Interpolation}
\label{Chapter5_Interpolation/Interpolation:function-fitting-and-interpolation}\label{Chapter5_Interpolation/Interpolation::doc}
In today's session, we will be using some of the LAI datasets we
examined last week (masked by national boundaries) and doing some
analysis on them.
\begin{itemize}
\item {} 
{\hyperref[Chapter5_Interpolation/Interpolation:5.1-Making-3D-datasets-and-Movies]{5.1 Making 3D datasets and
Movies}} First, we will examine
how to improve our data reading function by extracting only the area
we are interested in. This involves querying the `country' mask to
find its limits and passing this information through to the reader.

\item {} 
{\hyperref[Chapter5_Interpolation/Interpolation:5.2-Interpolation]{5.2 Interpolation}} Then we will look at
methods to interpolate and smooth over gaps in datasets using various
methods.

\item {} 
{\hyperref[Chapter5_Interpolation/Interpolation:5.3-Function-fitting]{5.3 Function Fitting}} Finally, we will
look at fitting models to datasets, in this case a model describing
LAI phenology.

\end{itemize}


\section{5.1 Making 3D datasets and Movies}
\label{Chapter5_Interpolation/Interpolation:making-3d-datasets-and-movies}
First though, we will briefly go over once more the work we did on
downloading data (ussssing \code{wget}), generating 3D masked datasets, and
making movies.

This time, we will concentrate more on generating functions that we can
re-use for other purposes.


\subsection{5.1.1 Downloading data}
\label{Chapter5_Interpolation/Interpolation:downloading-data}
We start by filtering the file \code{files/data/robot.txt} to get only
lines (containing urls) for a particular tile and year.

We might easily do this in unix:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{} filter LAI MODIS files for this year and tile (in bash)
tile=\PYGZsq{}h17v03\PYGZsq{}
year=\PYGZsq{}2005\PYGZsq{}
ofile=files/data/modis\PYGZus{}lai\PYGZus{}\PYGZdl{}\PYGZob{}tile\PYGZcb{}\PYGZus{}\PYGZdl{}\PYGZob{}year\PYGZcb{}.txt

grep \PYGZdl{}tile \PYGZlt{} files/data/robot.txt \textbar{} grep \PYGZbs{}/\PYGZdl{}year \PYGZgt{} \PYGZdl{}ofile

\PYGZsh{} have a look at the first few
head \PYGZhy{}4 \PYGZlt{} \PYGZdl{}ofile
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2005.01.01/MCD15A2.A2005001.h17v03.005.2007350235547.hdf
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2005.01.09/MCD15A2.A2005009.h17v03.005.2007351235445.hdf
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2005.01.17/MCD15A2.A2005017.h17v03.005.2007352033411.hdf
http://e4ftl01.cr.usgs.gov/MODIS\PYGZus{}Composites/MOTA/MCD15A2.005/2005.01.25/MCD15A2.A2005025.h17v03.005.2007353055037.hdf
\end{Verbatim}

Now download the datasets:

\begin{Verbatim}[commandchars=\\\{\}]
tile=\PYGZsq{}h17v03\PYGZsq{}
year=\PYGZsq{}2005\PYGZsq{}
ofile=files/data/modis\PYGZus{}lai\PYGZus{}\PYGZdl{}\PYGZob{}tile\PYGZcb{}\PYGZus{}\PYGZdl{}\PYGZob{}year\PYGZcb{}.txt

\PYGZsh{} go into the directory we want the data
pushd files/data
\PYGZsh{} get the urls from the file
\PYGZsh{} \PYGZhy{}\PYGZhy{}cut\PYGZhy{}dirs=4 this time as there are 4 laters of directory we
\PYGZsh{} wish to ignore with this dataset
wget \PYGZhy{}\PYGZhy{}quiet \PYGZhy{}nc \PYGZhy{}nH \PYGZhy{}\PYGZhy{}cut\PYGZhy{}dirs=4 \PYGZhy{}i ../\PYGZdl{}ofile
\PYGZsh{} go back to where we were
popd
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
/archive/rsu\PYGZus{}raid\PYGZus{}0/plewis/public\PYGZus{}html/geogg122\PYGZus{}local/geogg122/Chapter5\PYGZus{}Interpolation/files/data /archive/rsu\PYGZus{}raid\PYGZus{}0/plewis/public\PYGZus{}html/geogg122\PYGZus{}local/geogg122/Chapter5\PYGZus{}Interpolation
/archive/rsu\PYGZus{}raid\PYGZus{}0/plewis/public\PYGZus{}html/geogg122\PYGZus{}local/geogg122/Chapter5\PYGZus{}Interpolation
\end{Verbatim}


\subsection{5.1.2 Read from an ASCII file}
\label{Chapter5_Interpolation/Interpolation:read-from-an-ascii-file}
The ASCII file \code{files/data/modis\_lai\_\$\{tile\}\_\$\{year\}.txt} contains
lines of urls.

Each line (each url) is a string such as:

\code{http://e4ftl01.cr.usgs.gov/MODIS\_Composites/MOTA/MCD15A2.005/2005.01.25/MCD15A2.A2005025.h17v03.005.2007353055037.hdf}

The \emph{filename} here is
\code{MCD15A2.A2005025.h17v03.005.2007353055037.hdf}, so we can split the
url on the field \code{/} to get this:

Let's read the filenames from the text file that has the urls in it and
load it into a list that we will call \code{filelist}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}

\PYG{n}{tile} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{h17v03}\PYG{l+s}{\PYGZsq{}}
\PYG{n}{year} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{2005}\PYG{l+s}{\PYGZsq{}}

\PYG{c}{\PYGZsh{} specify the file with the urls in}
\PYG{n}{ifile}\PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/modis\PYGZus{}lai\PYGZus{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZus{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{.txt}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{tile}\PYG{p}{,}\PYG{n}{year}\PYG{p}{)}

\PYG{c}{\PYGZsh{} one way to read the data from the file}
\PYG{n}{fp} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{ifile}\PYG{p}{)}
\PYG{n}{lines} \PYG{o}{=} \PYG{n}{fp}\PYG{o}{.}\PYG{n}{readlines}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{filelist} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{url} \PYG{o+ow}{in} \PYG{n}{lines}\PYG{p}{:}
    \PYG{n}{filename} \PYG{o}{=} \PYG{n}{url}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{strip}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{filelist}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{)}
\PYG{n}{fp}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}

\PYG{c}{\PYGZsh{} show the first few}
\PYG{k}{print} \PYG{n}{filelist}\PYG{p}{[}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MCD15A2.A2005001.h17v03.005.2007350235547.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MCD15A2.A2005009.h17v03.005.2007351235445.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MCD15A2.A2005017.h17v03.005.2007352033411.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MCD15A2.A2005025.h17v03.005.2007353055037.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MCD15A2.A2005033.h17v03.005.2007355050158.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} a neater way:}
\PYG{n}{fp} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{ifile}\PYG{p}{)}
\PYG{n}{filelist} \PYG{o}{=} \PYG{p}{[}\PYG{n}{url}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{strip}\PYG{p}{(}\PYG{p}{)} \PYG{k}{for} \PYG{n}{url} \PYG{o+ow}{in} \PYG{n}{fp}\PYG{o}{.}\PYG{n}{readlines}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}
\PYG{n}{fp}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}

\PYG{c}{\PYGZsh{} show the first few}
\PYG{k}{print} \PYG{n}{filelist}\PYG{p}{[}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MCD15A2.A2005001.h17v03.005.2007350235547.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MCD15A2.A2005009.h17v03.005.2007351235445.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MCD15A2.A2005017.h17v03.005.2007352033411.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MCD15A2.A2005025.h17v03.005.2007353055037.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MCD15A2.A2005033.h17v03.005.2007355050158.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} an even neater way using np.loadtxt}
\PYG{c}{\PYGZsh{} But don\PYGZsq{}t worry if you don\PYGZsq{}t quite get this one yet!}

\PYG{c}{\PYGZsh{} define a function get\PYGZus{}filename(f)}
\PYG{c}{\PYGZsh{} When a function is \PYGZsq{}small\PYGZsq{} its easier to use a lambda definition!}
\PYG{n}{get\PYGZus{}filename} \PYG{o}{=} \PYG{k}{lambda} \PYG{n}{f}\PYG{p}{:} \PYG{n}{f}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{filelist} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{loadtxt}\PYG{p}{(}\PYG{n}{ifile}\PYG{p}{,}\PYG{n}{dtype}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{str}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{converters}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{n}{get\PYGZus{}filename}\PYG{p}{\PYGZcb{}}\PYG{p}{)}

\PYG{k}{print} \PYG{n}{filelist}\PYG{p}{[}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MCD15A2.A2005001.h17v03.005.2007350235547.hdf}\PYG{l+s}{\PYGZsq{}}
 \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MCD15A2.A2005009.h17v03.005.2007351235445.hdf}\PYG{l+s}{\PYGZsq{}}
 \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MCD15A2.A2005017.h17v03.005.2007352033411.hdf}\PYG{l+s}{\PYGZsq{}}
 \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MCD15A2.A2005025.h17v03.005.2007353055037.hdf}\PYG{l+s}{\PYGZsq{}}
 \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MCD15A2.A2005033.h17v03.005.2007355050158.hdf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\end{Verbatim}


\subsection{5.1.3 Read Just The Data We Want}
\label{Chapter5_Interpolation/Interpolation:read-just-the-data-we-want}
Last time, we generated a function to read MODIS LAI data.

We have now included such a function in the directory
\code{{}`files/python} \textless{}files/python\textgreater{}{}`\_\_ called
\code{{}`get\_lai.py} \textless{}files/python/get\_lai.py\textgreater{}{}`\_\_.

The only added sophistication is that when we call \code{ReadAsArray}, we
give it the starting cols, rows, and number of cols and rows to read
(e.g. \code{xsize=600,yoff=300,xoff=300,ysize=600}):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} Now we have a list of filenames}
\PYG{c}{\PYGZsh{} load read\PYGZus{}lai}
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{n}{sys}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/python}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{k+kn}{from} \PYG{n+nn}{get\PYGZus{}lai} \PYG{k+kn}{import} \PYG{n}{get\PYGZus{}lai}

\PYG{n}{help}\PYG{p}{(}\PYG{n}{get\PYGZus{}lai}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
Help on function get\PYGZus{}lai in module get\PYGZus{}lai:

get\PYGZus{}lai(filename, qc\PYGZus{}layer=\PYGZsq{}FparLai\PYGZus{}QC\PYGZsq{}, scale=[0.1, 0.1], mincol=0, minrow=0, ncol=None, nrow=None, selected\PYGZus{}layers=[\PYGZsq{}Lai\PYGZus{}1km\PYGZsq{}, \PYGZsq{}LaiStdDev\PYGZus{}1km\PYGZsq{}])
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} e.g. for reading a single file:}

\PYG{n}{lai\PYGZus{}file0} \PYG{o}{=} \PYG{n}{get\PYGZus{}lai}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{n}{filelist}\PYG{p}{[}\PYG{l+m+mi}{20}\PYG{p}{]}\PYG{p}{,}\PYG{n}{ncol}\PYG{o}{=}\PYG{l+m+mi}{600}\PYG{p}{,}\PYG{n}{mincol}\PYG{o}{=}\PYG{l+m+mi}{300}\PYG{p}{,}\PYG{n}{minrow}\PYG{o}{=}\PYG{l+m+mi}{400}\PYG{p}{,}\PYG{n}{nrow}\PYG{o}{=}\PYG{l+m+mi}{800}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{lai\PYGZus{}file0}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.image.AxesImage at 0x10342b50\PYGZgt{}
\end{Verbatim}

\includegraphics{Interpolation_13_1.png}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{lai\PYGZus{}file0}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{lai\PYGZus{}file0}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}type \PYGZsq{}dict\PYGZsq{}\PYGZgt{}
[\PYGZsq{}Lai\PYGZus{}1km\PYGZsq{}, \PYGZsq{}LaiStdDev\PYGZus{}1km\PYGZsq{}]
\end{Verbatim}

The function returns a dictionary with has keys
\code{{[}'Lai\_1km', 'LaiStdDev\_1km', 'FparLai\_QC'{]}}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{n}{lai\PYGZus{}file0}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{shape}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{l+m+mi}{800}\PYG{p}{,} \PYG{l+m+mi}{600}\PYG{p}{)}
\end{Verbatim}

Each of these datasets is of shape \code{(1200, 1200)}, but we have read
only 600 (columns) and 800 (rows) in this case. Note that the numpy
indexing is \code{(rows,cols)}.

We know how to create a mask from a vector dataset from thelast session:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{raster\PYGZus{}mask} \PYG{k+kn}{import} \PYG{n}{raster\PYGZus{}mask}

\PYG{c}{\PYGZsh{} make a raster mask}
\PYG{c}{\PYGZsh{} from the layer IRELAND in world.shp}
\PYG{n}{filename} \PYG{o}{=} \PYG{n}{filelist}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{file\PYGZus{}template} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{:MOD\PYGZus{}Grid\PYGZus{}MOD15A2:}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZsq{}}
\PYG{n}{file\PYGZus{}spec} \PYG{o}{=} \PYG{n}{file\PYGZus{}template}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{n}{filename}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{mask} \PYG{o}{=} \PYG{n}{raster\PYGZus{}mask}\PYG{p}{(}\PYG{n}{file\PYGZus{}spec}\PYG{p}{,}\PYGZbs{}
                   \PYG{n}{target\PYGZus{}vector\PYGZus{}file} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{files/data/world.shp}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYGZbs{}
                   \PYG{n}{attribute\PYGZus{}filter} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{NAME = }\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{IRELAND}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}


\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{mask}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.colorbar.Colorbar instance at 0x10ae5bd8\PYGZgt{}
\end{Verbatim}

\includegraphics{Interpolation_18_1.png}

In this case, the data we want is only a small section of the whole
spatial dataset.

It would be convenient to extract \emph{only} the part we want.

We can use \code{numpy.where()} to help with this:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} The mask is False for the area we want}
\PYG{n}{rowpix}\PYG{p}{,}\PYG{n}{colpix} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{where}\PYG{p}{(}\PYG{n}{mask} \PYG{o}{==} \PYG{n+nb+bp}{False}\PYG{p}{)}

\PYG{k}{print} \PYG{n}{rowpix}\PYG{p}{,}\PYG{n}{colpix}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
[ 548  548  548 ..., 1024 1025 1025] [693 694 695 ..., 476 473 474]
\end{Verbatim}

\code{rowpix} and \code{colpix} are lists of pixel coordinates where the
condition we specified is \code{True} (i.e. where \code{mask} is \code{False}).

If we wanted to find the bounds of this area, we simply need to know the
minimum and maximum column and row in these lists:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{mincol}\PYG{p}{,}\PYG{n}{maxcol} \PYG{o}{=} \PYG{n+nb}{min}\PYG{p}{(}\PYG{n}{colpix}\PYG{p}{)}\PYG{p}{,}\PYG{n+nb}{max}\PYG{p}{(}\PYG{n}{colpix}\PYG{p}{)}
\PYG{n}{minrow}\PYG{p}{,}\PYG{n}{maxrow} \PYG{o}{=} \PYG{n+nb}{min}\PYG{p}{(}\PYG{n}{rowpix}\PYG{p}{)}\PYG{p}{,}\PYG{n+nb}{max}\PYG{p}{(}\PYG{n}{rowpix}\PYG{p}{)}

\PYG{c}{\PYGZsh{} think about why the + 1 here!!!}
\PYG{c}{\PYGZsh{} what if maxcol and mincol were the same?}
\PYG{n}{ncol} \PYG{o}{=} \PYG{n}{maxcol} \PYG{o}{\PYGZhy{}} \PYG{n}{mincol} \PYG{o}{+} \PYG{l+m+mi}{1}
\PYG{n}{nrow} \PYG{o}{=} \PYG{n}{maxrow} \PYG{o}{\PYGZhy{}} \PYG{n}{minrow} \PYG{o}{+} \PYG{l+m+mi}{1}

\PYG{k}{print} \PYG{n}{minrow}\PYG{p}{,}\PYG{n}{mincol}\PYG{p}{,}\PYG{n}{nrow}\PYG{p}{,}\PYG{n}{ncol}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
548 422 478 348
\end{Verbatim}

We could use this information to extract \emph{only} the area we want when we
read the data:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{lai\PYGZus{}file0} \PYG{o}{=} \PYG{n}{get\PYGZus{}lai}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{n}{filelist}\PYG{p}{[}\PYG{l+m+mi}{20}\PYG{p}{]}\PYG{p}{,}\PYGZbs{}
                    \PYG{n}{ncol}\PYG{o}{=}\PYG{n}{ncol}\PYG{p}{,}\PYG{n}{nrow}\PYG{o}{=}\PYG{n}{nrow}\PYG{p}{,}\PYG{n}{mincol}\PYG{o}{=}\PYG{n}{mincol}\PYG{p}{,}\PYG{n}{minrow}\PYG{o}{=}\PYG{n}{minrow}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{lai\PYGZus{}file0}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.image.AxesImage at 0x10ddc2d0\PYGZgt{}
\end{Verbatim}

\includegraphics{Interpolation_24_1.png}

Now, lets extract this portion of the mask:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{small\PYGZus{}mask} \PYG{o}{=} \PYG{n}{mask}\PYG{p}{[}\PYG{n}{minrow}\PYG{p}{:}\PYG{n}{minrow}\PYG{o}{+}\PYG{n}{nrow}\PYG{p}{,}\PYG{n}{mincol}\PYG{p}{:}\PYG{n}{mincol}\PYG{o}{+}\PYG{n}{ncol}\PYG{p}{]}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{small\PYGZus{}mask}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.image.AxesImage at 0x2ae9e41a3750\PYGZgt{}
\end{Verbatim}

\includegraphics{Interpolation_26_1.png}

And combine the country mask with the small dataset:

As a recap, we can use the function \code{raster\_mask} that we gave you
last time to develop a raster mask (!) from an ESRI shapefile
(\code{files/data/world.shp} here).

We can then combine this mask with the QC-derived mask in the LAI
dataset.

The LAI mask (that will be \code{lai.mask} in the code below) is \code{False}
for good data, as is the coutry mask.

To combine them, we want some operator \code{X} for which:

\begin{DUlineblock}{0em}
\item[] \code{True  X True  == True}
\item[] \code{True  X False == True}
\item[] \code{False X True  == True}
\item[] \code{False X False == False}
\end{DUlineblock}

The operator to use then is an \emph{or}, here, a bitwise or, \code{\textbar{}}.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{lai\PYGZus{}file0} \PYG{o}{=} \PYG{n}{get\PYGZus{}lai}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{n}{filelist}\PYG{p}{[}\PYG{l+m+mi}{20}\PYG{p}{]}\PYG{p}{,}\PYGZbs{}
                    \PYG{n}{ncol}\PYG{o}{=}\PYG{n}{ncol}\PYG{p}{,}\PYG{n}{nrow}\PYG{o}{=}\PYG{n}{nrow}\PYG{p}{,}\PYG{n}{mincol}\PYG{o}{=}\PYG{n}{mincol}\PYG{p}{,}\PYG{n}{minrow}\PYG{o}{=}\PYG{n}{minrow}\PYG{p}{)}

\PYG{n}{layer} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}
\PYG{n}{lai} \PYG{o}{=} \PYG{n}{lai\PYGZus{}file0}\PYG{p}{[}\PYG{n}{layer}\PYG{p}{]}
\PYG{n}{small\PYGZus{}mask} \PYG{o}{=} \PYG{n}{mask}\PYG{p}{[}\PYG{n}{minrow}\PYG{p}{:}\PYG{n}{minrow}\PYG{o}{+}\PYG{n}{nrow}\PYG{p}{,}\PYG{n}{mincol}\PYG{p}{:}\PYG{n}{mincol}\PYG{o}{+}\PYG{n}{ncol}\PYG{p}{]}

\PYG{c}{\PYGZsh{} combined mask}
\PYG{n}{new\PYGZus{}mask} \PYG{o}{=} \PYG{n}{small\PYGZus{}mask} \PYG{o}{\textbar{}} \PYG{n}{lai}\PYG{o}{.}\PYG{n}{mask}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{new\PYGZus{}mask}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{lai} \PYG{o}{=} \PYG{n}{ma}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{lai}\PYG{p}{,}\PYG{n}{mask}\PYG{o}{=}\PYG{n}{new\PYGZus{}mask}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{lai}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.image.AxesImage at 0x2ae9e4275f50\PYGZgt{}
\end{Verbatim}

\includegraphics{Interpolation_29_1.png}

\includegraphics{Interpolation_29_2.png}

We should be used to writing loops around such functions.

In this case, we read \emph{all} of the files in \code{filelist} and put the
data into the dictionary called \code{lai} here.

Because there are multiple layers in the datasets, we loop over layer
and append to each list indiviually:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} load \PYGZsq{}em all ...}

\PYG{c}{\PYGZsh{} for United Kingdom here}

\PYG{k+kn}{import} \PYG{n+nn}{numpy.ma} \PYG{k+kn}{as} \PYG{n+nn}{ma}
\PYG{k+kn}{from} \PYG{n+nn}{raster\PYGZus{}mask} \PYG{k+kn}{import} \PYG{n}{raster\PYGZus{}mask}

\PYG{n}{country} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{UNITED KINGDOM}\PYG{l+s}{\PYGZsq{}}

\PYG{c}{\PYGZsh{} make a raster mask}
\PYG{c}{\PYGZsh{} from the layer UNITED KINGDOM in world.shp}
\PYG{n}{filename} \PYG{o}{=} \PYG{n}{filelist}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{file\PYGZus{}template} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{:MOD\PYGZus{}Grid\PYGZus{}MOD15A2:}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZsq{}}
\PYG{n}{file\PYGZus{}spec} \PYG{o}{=} \PYG{n}{file\PYGZus{}template}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{n}{filename}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{mask} \PYG{o}{=} \PYG{n}{raster\PYGZus{}mask}\PYG{p}{(}\PYG{n}{file\PYGZus{}spec}\PYG{p}{,}\PYGZbs{}
                   \PYG{n}{target\PYGZus{}vector\PYGZus{}file} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{files/data/world.shp}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYGZbs{}
                   \PYG{n}{attribute\PYGZus{}filter} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{NAME = }\PYG{l+s}{\PYGZsq{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZpc{}}\PYG{n}{country}\PYG{p}{)}
\PYG{c}{\PYGZsh{} extract just the area we want}
\PYG{c}{\PYGZsh{} by getting the min/max rows/cols}
\PYG{c}{\PYGZsh{} of the data mask}
\PYG{c}{\PYGZsh{} The mask is False for the area we want}
\PYG{n}{rowpix}\PYG{p}{,}\PYG{n}{colpix} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{where}\PYG{p}{(}\PYG{n}{mask} \PYG{o}{==} \PYG{n+nb+bp}{False}\PYG{p}{)}
\PYG{n}{mincol}\PYG{p}{,}\PYG{n}{maxcol} \PYG{o}{=} \PYG{n+nb}{min}\PYG{p}{(}\PYG{n}{colpix}\PYG{p}{)}\PYG{p}{,}\PYG{n+nb}{max}\PYG{p}{(}\PYG{n}{colpix}\PYG{p}{)}
\PYG{n}{minrow}\PYG{p}{,}\PYG{n}{maxrow} \PYG{o}{=} \PYG{n+nb}{min}\PYG{p}{(}\PYG{n}{rowpix}\PYG{p}{)}\PYG{p}{,}\PYG{n+nb}{max}\PYG{p}{(}\PYG{n}{rowpix}\PYG{p}{)}
\PYG{n}{ncol} \PYG{o}{=} \PYG{n}{maxcol} \PYG{o}{\PYGZhy{}} \PYG{n}{mincol} \PYG{o}{+} \PYG{l+m+mi}{1}
\PYG{n}{nrow} \PYG{o}{=} \PYG{n}{maxrow} \PYG{o}{\PYGZhy{}} \PYG{n}{minrow} \PYG{o}{+} \PYG{l+m+mi}{1}
\PYG{c}{\PYGZsh{} and make a small mask}
\PYG{n}{small\PYGZus{}mask} \PYG{o}{=} \PYG{n}{mask}\PYG{p}{[}\PYG{n}{minrow}\PYG{p}{:}\PYG{n}{minrow}\PYG{o}{+}\PYG{n}{nrow}\PYG{p}{,}\PYG{n}{mincol}\PYG{p}{:}\PYG{n}{mincol}\PYG{o}{+}\PYG{n}{ncol}\PYG{p}{]}


\PYG{c}{\PYGZsh{} data\PYGZus{}fields with empty lists}
\PYG{n}{data\PYGZus{}fields} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{LaiStdDev\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{p}{[}\PYG{p}{]}\PYG{p}{\PYGZcb{}}

\PYG{c}{\PYGZsh{} make a dictionary and put the filenames in it}
\PYG{c}{\PYGZsh{} along with the mask and min/max info}
\PYG{n}{lai} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{filenames}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{n}{np}\PYG{o}{.}\PYG{n}{sort}\PYG{p}{(}\PYG{n}{filelist}\PYG{p}{)}\PYG{p}{,}\PYGZbs{}
       \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{minrow}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{n}{minrow}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{mincol}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{n}{mincol}\PYG{p}{,}\PYGZbs{}
       \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{mask}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{n}{small\PYGZus{}mask}\PYG{p}{\PYGZcb{}}

\PYG{c}{\PYGZsh{} combine the dictionaries}
\PYG{n}{lai}\PYG{o}{.}\PYG{n}{update}\PYG{p}{(}\PYG{n}{data\PYGZus{}fields}\PYG{p}{)}

\PYG{c}{\PYGZsh{} loop over each filename}
\PYG{k}{for} \PYG{n}{f} \PYG{o+ow}{in} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sort}\PYG{p}{(}\PYG{n}{lai}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{filenames}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{this\PYGZus{}lai} \PYG{o}{=} \PYG{n}{get\PYGZus{}lai}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{n}{f}\PYG{p}{,}\PYGZbs{}
                       \PYG{n}{mincol}\PYG{o}{=}\PYG{n}{mincol}\PYG{p}{,}\PYG{n}{ncol}\PYG{o}{=}\PYG{n}{ncol}\PYG{p}{,}\PYGZbs{}
                       \PYG{n}{minrow}\PYG{o}{=}\PYG{n}{minrow}\PYG{p}{,}\PYG{n}{nrow}\PYG{o}{=}\PYG{n}{nrow}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{layer} \PYG{o+ow}{in} \PYG{n}{data\PYGZus{}fields}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
        \PYG{c}{\PYGZsh{} apply the mask}
        \PYG{n}{new\PYGZus{}mask} \PYG{o}{=} \PYG{n}{this\PYGZus{}lai}\PYG{p}{[}\PYG{n}{layer}\PYG{p}{]}\PYG{o}{.}\PYG{n}{mask} \PYG{o}{\textbar{}} \PYG{n}{small\PYGZus{}mask}
        \PYG{n}{this\PYGZus{}lai}\PYG{p}{[}\PYG{n}{layer}\PYG{p}{]} \PYG{o}{=} \PYG{n}{ma}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{this\PYGZus{}lai}\PYG{p}{[}\PYG{n}{layer}\PYG{p}{]}\PYG{p}{,}\PYG{n}{mask}\PYG{o}{=}\PYG{n}{new\PYGZus{}mask}\PYG{p}{)}
        \PYG{n}{lai}\PYG{p}{[}\PYG{n}{layer}\PYG{p}{]}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{this\PYGZus{}lai}\PYG{p}{[}\PYG{n}{layer}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} have a look at one of these}

\PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{20}

\PYG{k+kn}{import} \PYG{n+nn}{pylab} \PYG{k+kn}{as} \PYG{n+nn}{plt}

\PYG{c}{\PYGZsh{} just see what the shape is ...}
\PYG{k}{print} \PYG{n}{lai}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{.}\PYG{n}{shape}

\PYG{n}{root} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/images/lai\PYGZus{}uk}\PYG{l+s}{\PYGZsq{}}

\PYG{n}{cmap} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{cm}\PYG{o}{.}\PYG{n}{Greens}

\PYG{n}{f} \PYG{o}{=} \PYG{n}{lai}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{filenames}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
\PYG{n}{fig} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{)}\PYG{p}{)}
\PYG{c}{\PYGZsh{} get some info from filename}
\PYG{n}{file\PYGZus{}id} \PYG{o}{=} \PYG{n}{f}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{.}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{p}{]}
\PYG{k}{print} \PYG{n}{file\PYGZus{}id}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{lai}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,}\PYG{n}{cmap}\PYG{o}{=}\PYG{n}{cmap}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{vmax}\PYG{o}{=}\PYG{l+m+mf}{4.}\PYG{p}{,}\PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mf}{0.0}\PYG{p}{)}
\PYG{c}{\PYGZsh{} plot a jpg}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{n}{file\PYGZus{}id}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/images/lai\PYGZus{}uk\PYGZus{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{.jpg}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{n}{file\PYGZus{}id}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{l+m+mi}{1200}\PYG{p}{,} \PYG{l+m+mi}{566}\PYG{p}{)}
\PYG{l+m+mi}{2005161}
\end{Verbatim}

\includegraphics{Interpolation_32_1.png}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} thats quite good, so put as a function:}
\PYG{k+kn}{import} \PYG{n+nn}{numpy.ma} \PYG{k+kn}{as} \PYG{n+nn}{ma}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{n}{sys}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/python}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{k+kn}{from} \PYG{n+nn}{get\PYGZus{}lai} \PYG{k+kn}{import} \PYG{n}{get\PYGZus{}lai}
\PYG{k+kn}{from} \PYG{n+nn}{raster\PYGZus{}mask} \PYG{k+kn}{import} \PYG{n}{raster\PYGZus{}mask}


\PYG{k}{def} \PYG{n+nf}{read\PYGZus{}lai}\PYG{p}{(}\PYG{n}{filelist}\PYG{p}{,}\PYG{n}{datadir}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{country}\PYG{o}{=}\PYG{n+nb+bp}{None}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+sd}{    Read MODIS LAI data from a set of files}
\PYG{l+s+sd}{    in the list filelist. Data assumed to be in}
\PYG{l+s+sd}{    directory datadir.}

\PYG{l+s+sd}{    Parameters:}
\PYG{l+s+sd}{    filelist : list of LAI files}

\PYG{l+s+sd}{    Options:}
\PYG{l+s+sd}{    datadir  : data directory}
\PYG{l+s+sd}{    country  : country name (in files/data/world.shp)}

\PYG{l+s+sd}{    Returns:}
\PYG{l+s+sd}{    lai dictionary}
\PYG{l+s+sd}{    \PYGZsq{}\PYGZsq{}\PYGZsq{}}
    \PYG{k}{if} \PYG{n}{country}\PYG{p}{:}
        \PYG{c}{\PYGZsh{} make a raster mask}
        \PYG{c}{\PYGZsh{} from the layer UNITED KINGDOM in world.shp}
        \PYG{n}{file\PYGZus{}template} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{:MOD\PYGZus{}Grid\PYGZus{}MOD15A2:}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZsq{}}
        \PYG{n}{file\PYGZus{}spec} \PYG{o}{=} \PYG{n}{file\PYGZus{}template}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{n}{filelist}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

        \PYG{n}{mask} \PYG{o}{=} \PYG{n}{raster\PYGZus{}mask}\PYG{p}{(}\PYG{n}{file\PYGZus{}spec}\PYG{p}{,}\PYGZbs{}
                           \PYG{n}{target\PYGZus{}vector\PYGZus{}file} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{files/data/world.shp}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYGZbs{}
                           \PYG{n}{attribute\PYGZus{}filter} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{NAME = }\PYG{l+s}{\PYGZsq{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZpc{}}\PYG{n}{country}\PYG{p}{)}
        \PYG{c}{\PYGZsh{} extract just the area we want}
        \PYG{c}{\PYGZsh{} by getting the min/max rows/cols}
        \PYG{c}{\PYGZsh{} of the data mask}
        \PYG{c}{\PYGZsh{} The mask is False for the area we want}
        \PYG{n}{rowpix}\PYG{p}{,}\PYG{n}{colpix} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{where}\PYG{p}{(}\PYG{n}{mask} \PYG{o}{==} \PYG{n+nb+bp}{False}\PYG{p}{)}
        \PYG{n}{mincol}\PYG{p}{,}\PYG{n}{maxcol} \PYG{o}{=} \PYG{n+nb}{min}\PYG{p}{(}\PYG{n}{colpix}\PYG{p}{)}\PYG{p}{,}\PYG{n+nb}{max}\PYG{p}{(}\PYG{n}{colpix}\PYG{p}{)}
        \PYG{n}{minrow}\PYG{p}{,}\PYG{n}{maxrow} \PYG{o}{=} \PYG{n+nb}{min}\PYG{p}{(}\PYG{n}{rowpix}\PYG{p}{)}\PYG{p}{,}\PYG{n+nb}{max}\PYG{p}{(}\PYG{n}{rowpix}\PYG{p}{)}
        \PYG{n}{ncol} \PYG{o}{=} \PYG{n}{maxcol} \PYG{o}{\PYGZhy{}} \PYG{n}{mincol} \PYG{o}{+} \PYG{l+m+mi}{1}
        \PYG{n}{nrow} \PYG{o}{=} \PYG{n}{maxrow} \PYG{o}{\PYGZhy{}} \PYG{n}{minrow} \PYG{o}{+} \PYG{l+m+mi}{1}
        \PYG{c}{\PYGZsh{} and make a small mask}
        \PYG{n}{small\PYGZus{}mask} \PYG{o}{=} \PYG{n}{mask}\PYG{p}{[}\PYG{n}{minrow}\PYG{p}{:}\PYG{n}{minrow}\PYG{o}{+}\PYG{n}{nrow}\PYG{p}{,}\PYG{n}{mincol}\PYG{p}{:}\PYG{n}{mincol}\PYG{o}{+}\PYG{n}{ncol}\PYG{p}{]}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{c}{\PYGZsh{} no country}
        \PYG{n}{mincol} \PYG{o}{=} \PYG{l+m+mi}{0}
        \PYG{n}{maxcol} \PYG{o}{=} \PYG{l+m+mi}{0}
        \PYG{n}{ncol} \PYG{o}{=} \PYG{n+nb+bp}{None}
        \PYG{n}{nrow} \PYG{o}{=} \PYG{n+nb+bp}{None}

    \PYG{c}{\PYGZsh{} data\PYGZus{}fields with empty lists}
    \PYG{n}{data\PYGZus{}fields} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{LaiStdDev\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{p}{[}\PYG{p}{]}\PYG{p}{\PYGZcb{}}

    \PYG{c}{\PYGZsh{} make a dictionary and put the filenames in it}
    \PYG{c}{\PYGZsh{} along with the mask and min/max info}
    \PYG{n}{lai} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{filenames}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{n}{np}\PYG{o}{.}\PYG{n}{sort}\PYG{p}{(}\PYG{n}{filelist}\PYG{p}{)}\PYG{p}{,}\PYGZbs{}
           \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{minrow}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{n}{minrow}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{mincol}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{n}{mincol}\PYG{p}{,}\PYGZbs{}
           \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{mask}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{n}{small\PYGZus{}mask}\PYG{p}{\PYGZcb{}}

    \PYG{c}{\PYGZsh{} combine the dictionaries}
    \PYG{n}{lai}\PYG{o}{.}\PYG{n}{update}\PYG{p}{(}\PYG{n}{data\PYGZus{}fields}\PYG{p}{)}

    \PYG{c}{\PYGZsh{} loop over each filename}
    \PYG{k}{for} \PYG{n}{f} \PYG{o+ow}{in} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sort}\PYG{p}{(}\PYG{n}{lai}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{filenames}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{this\PYGZus{}lai} \PYG{o}{=} \PYG{n}{get\PYGZus{}lai}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{n}{f}\PYG{p}{,}\PYGZbs{}
                           \PYG{n}{mincol}\PYG{o}{=}\PYG{n}{mincol}\PYG{p}{,}\PYG{n}{ncol}\PYG{o}{=}\PYG{n}{ncol}\PYG{p}{,}\PYGZbs{}
                           \PYG{n}{minrow}\PYG{o}{=}\PYG{n}{minrow}\PYG{p}{,}\PYG{n}{nrow}\PYG{o}{=}\PYG{n}{nrow}\PYG{p}{)}
        \PYG{k}{for} \PYG{n}{layer} \PYG{o+ow}{in} \PYG{n}{data\PYGZus{}fields}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
            \PYG{c}{\PYGZsh{} apply the mask}
            \PYG{k}{if} \PYG{n}{country}\PYG{p}{:}
                \PYG{n}{new\PYGZus{}mask} \PYG{o}{=} \PYG{n}{this\PYGZus{}lai}\PYG{p}{[}\PYG{n}{layer}\PYG{p}{]}\PYG{o}{.}\PYG{n}{mask} \PYG{o}{\textbar{}} \PYG{n}{small\PYGZus{}mask}
                \PYG{n}{this\PYGZus{}lai}\PYG{p}{[}\PYG{n}{layer}\PYG{p}{]} \PYG{o}{=} \PYG{n}{ma}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{this\PYGZus{}lai}\PYG{p}{[}\PYG{n}{layer}\PYG{p}{]}\PYG{p}{,}\PYG{n}{mask}\PYG{o}{=}\PYG{n}{new\PYGZus{}mask}\PYG{p}{)}
            \PYG{n}{lai}\PYG{p}{[}\PYG{n}{layer}\PYG{p}{]}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{this\PYGZus{}lai}\PYG{p}{[}\PYG{n}{layer}\PYG{p}{]}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{layer} \PYG{o+ow}{in} \PYG{n}{data\PYGZus{}fields}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{lai}\PYG{p}{[}\PYG{n}{layer}\PYG{p}{]} \PYG{o}{=} \PYG{n}{ma}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{lai}\PYG{p}{[}\PYG{n}{layer}\PYG{p}{]}\PYG{p}{)}

    \PYG{k}{return} \PYG{n}{lai}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} test this ... the one in the file}
\PYG{c}{\PYGZsh{} does a cutout of the data area as well}
\PYG{c}{\PYGZsh{} which will keep the memory}
\PYG{c}{\PYGZsh{} requirements down}
\PYG{k+kn}{from} \PYG{n+nn}{get\PYGZus{}lai} \PYG{k+kn}{import} \PYG{n}{read\PYGZus{}lai}

\PYG{n}{lai} \PYG{o}{=} \PYG{n}{read\PYGZus{}lai}\PYG{p}{(}\PYG{n}{filelist}\PYG{p}{,}\PYG{n}{country}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{IRELAND}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{verbose}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}

\PYG{c}{\PYGZsh{} have a look at one of these}

\PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{20}

\PYG{c}{\PYGZsh{} just see what the shape is ...}
\PYG{k}{print} \PYG{n}{lai}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{.}\PYG{n}{shape}

\PYG{n}{root} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/images/lai\PYGZus{}eire}\PYG{l+s}{\PYGZsq{}}

\PYG{n}{cmap} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{cm}\PYG{o}{.}\PYG{n}{Greens}

\PYG{n}{f} \PYG{o}{=} \PYG{n}{lai}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{filenames}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
\PYG{n}{fig} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{)}\PYG{p}{)}
\PYG{c}{\PYGZsh{} get some info from filename}
\PYG{n}{file\PYGZus{}id} \PYG{o}{=} \PYG{n}{f}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{.}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{p}{]}
\PYG{k}{print} \PYG{n}{file\PYGZus{}id}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{lai}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,}\PYG{n}{cmap}\PYG{o}{=}\PYG{n}{cmap}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{vmax}\PYG{o}{=}\PYG{l+m+mf}{4.}\PYG{p}{,}\PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mf}{0.0}\PYG{p}{)}
\PYG{c}{\PYGZsh{} plot a jpg}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{n}{file\PYGZus{}id}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZus{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{.jpg}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{root}\PYG{p}{,}\PYG{n}{file\PYGZus{}id}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
creating mask of IRELAND
... MCD15A2.A2005001.h17v03.005.2007350235547.hdf
... MCD15A2.A2005009.h17v03.005.2007351235445.hdf
... MCD15A2.A2005017.h17v03.005.2007352033411.hdf
... MCD15A2.A2005025.h17v03.005.2007353055037.hdf
... MCD15A2.A2005033.h17v03.005.2007355050158.hdf
... MCD15A2.A2005041.h17v03.005.2007357014602.hdf
... MCD15A2.A2005049.h17v03.005.2007360165724.hdf
... MCD15A2.A2005057.h17v03.005.2007361230641.hdf
... MCD15A2.A2005065.h17v03.005.2007365024202.hdf
... MCD15A2.A2005073.h17v03.005.2008001043631.hdf
... MCD15A2.A2005081.h17v03.005.2008003173048.hdf
... MCD15A2.A2005089.h17v03.005.2008005154542.hdf
... MCD15A2.A2005097.h17v03.005.2008007175837.hdf
... MCD15A2.A2005105.h17v03.005.2008018085544.hdf
... MCD15A2.A2005113.h17v03.005.2008021020137.hdf
... MCD15A2.A2005121.h17v03.005.2008021193749.hdf
... MCD15A2.A2005129.h17v03.005.2008024061330.hdf
... MCD15A2.A2005137.h17v03.005.2008032075236.hdf
... MCD15A2.A2005145.h17v03.005.2008033192556.hdf
... MCD15A2.A2005153.h17v03.005.2008035054421.hdf
... MCD15A2.A2005161.h17v03.005.2008036173810.hdf
... MCD15A2.A2005169.h17v03.005.2008039132812.hdf
... MCD15A2.A2005177.h17v03.005.2008042090537.hdf
... MCD15A2.A2005185.h17v03.005.2008044115459.hdf
... MCD15A2.A2005193.h17v03.005.2008046140018.hdf
... MCD15A2.A2005201.h17v03.005.2008050015227.hdf
... MCD15A2.A2005209.h17v03.005.2008052203557.hdf
... MCD15A2.A2005217.h17v03.005.2008055145215.hdf
... MCD15A2.A2005225.h17v03.005.2008057010213.hdf
... MCD15A2.A2005233.h17v03.005.2008060214119.hdf
... MCD15A2.A2005241.h17v03.005.2008063115631.hdf
... MCD15A2.A2005249.h17v03.005.1998144165707.hdf
... MCD15A2.A2005257.h17v03.005.2008067051936.hdf
... MCD15A2.A2005265.h17v03.005.2008069073121.hdf
... MCD15A2.A2005273.h17v03.005.2008071050025.hdf
... MCD15A2.A2005281.h17v03.005.2008072202421.hdf
... MCD15A2.A2005289.h17v03.005.2008074194126.hdf
... MCD15A2.A2005297.h17v03.005.2008077061121.hdf
... MCD15A2.A2005305.h17v03.005.2008080055607.hdf
... MCD15A2.A2005313.h17v03.005.2008083165435.hdf
... MCD15A2.A2005321.h17v03.005.2008084043211.hdf
... MCD15A2.A2005329.h17v03.005.2008086063619.hdf
... MCD15A2.A2005337.h17v03.005.2008087175845.hdf
... MCD15A2.A2005345.h17v03.005.2008088144615.hdf
... MCD15A2.A2005353.h17v03.005.2008091004441.hdf
... MCD15A2.A2005361.h17v03.005.2008091025114.hdf
... done
(478, 348)
2005161
\end{Verbatim}

\includegraphics{Interpolation_34_1.png}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} make a movie}

\PYG{k+kn}{import} \PYG{n+nn}{pylab} \PYG{k+kn}{as} \PYG{n+nn}{plt}
\PYG{k+kn}{import} \PYG{n+nn}{os}

\PYG{c}{\PYGZsh{} just see what the shape is ...}
\PYG{k}{print} \PYG{n}{lai}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{shape}

\PYG{n}{root} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/images/lai\PYGZus{}country\PYGZus{}eire}\PYG{l+s}{\PYGZsq{}}

\PYG{n}{cmap} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{cm}\PYG{o}{.}\PYG{n}{Greens}

\PYG{k}{for} \PYG{n}{i}\PYG{p}{,}\PYG{n}{f} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{lai}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{filenames}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{fig} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{)}\PYG{p}{)}
    \PYG{c}{\PYGZsh{} get some info from filename}
    \PYG{n}{file\PYGZus{}id} \PYG{o}{=} \PYG{n}{f}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{.}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{p}{]}
    \PYG{k}{print} \PYG{n}{file\PYGZus{}id}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{lai}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,}\PYG{n}{cmap}\PYG{o}{=}\PYG{n}{cmap}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{vmax}\PYG{o}{=}\PYG{l+m+mf}{4.}\PYG{p}{,}\PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mf}{0.0}\PYG{p}{)}
    \PYG{c}{\PYGZsh{} plot a jpg}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{n}{file\PYGZus{}id}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZus{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{.jpg}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{root}\PYG{p}{,}\PYG{n}{file\PYGZus{}id}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{n}{fig}\PYG{p}{)}

\PYG{n}{cmd} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{convert \PYGZhy{}delay 100 \PYGZhy{}loop 0 \PYGZob{}0\PYGZcb{}\PYGZus{}*.jpg \PYGZob{}0\PYGZcb{}\PYGZus{}movie.gif}\PYG{l+s}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{root}\PYG{p}{)}
\PYG{n}{os}\PYG{o}{.}\PYG{n}{system}\PYG{p}{(}\PYG{n}{cmd}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{l+m+mi}{46}\PYG{p}{,} \PYG{l+m+mi}{478}\PYG{p}{,} \PYG{l+m+mi}{348}\PYG{p}{)}
\PYG{l+m+mi}{2005001}
\PYG{l+m+mi}{2005009}
\PYG{l+m+mi}{2005017}
\PYG{l+m+mi}{2005025}
\PYG{l+m+mi}{2005033}
\PYG{l+m+mi}{2005041}
\PYG{l+m+mi}{2005049}
\PYG{l+m+mi}{2005057}
\PYG{l+m+mi}{2005065}
\PYG{l+m+mi}{2005073}
\PYG{l+m+mi}{2005081}
\PYG{l+m+mi}{2005089}
\PYG{l+m+mi}{2005097}
\PYG{l+m+mi}{2005105}
\PYG{l+m+mi}{2005113}
\PYG{l+m+mi}{2005121}
\PYG{l+m+mi}{2005129}
\PYG{l+m+mi}{2005137}
\PYG{l+m+mi}{2005145}
\PYG{l+m+mi}{2005153}
\PYG{l+m+mi}{2005161}
\PYG{l+m+mi}{2005169}
\PYG{l+m+mi}{2005177}
\PYG{l+m+mi}{2005185}
\PYG{l+m+mi}{2005193}
\PYG{l+m+mi}{2005201}
\PYG{l+m+mi}{2005209}
\PYG{l+m+mi}{2005217}
\PYG{l+m+mi}{2005225}
\PYG{l+m+mi}{2005233}
\PYG{l+m+mi}{2005241}
\PYG{l+m+mi}{2005249}
\PYG{l+m+mi}{2005257}
\PYG{l+m+mi}{2005265}
\PYG{l+m+mi}{2005273}
\PYG{l+m+mi}{2005281}
\PYG{l+m+mi}{2005289}
\PYG{l+m+mi}{2005297}
\PYG{l+m+mi}{2005305}
\PYG{l+m+mi}{2005313}
\PYG{l+m+mi}{2005321}
\PYG{l+m+mi}{2005329}
\PYG{l+m+mi}{2005337}
\PYG{l+m+mi}{2005345}
\PYG{l+m+mi}{2005353}
\PYG{l+m+mi}{2005361}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{0}
\end{Verbatim}
\begin{figure}[htbp]
\centering

\includegraphics{Chapter5_Interpolation/files/images/lai_country_eire_movie.gif}
\end{figure}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} The movie making works, so pack that into a function}

\PYG{k+kn}{import} \PYG{n+nn}{pylab} \PYG{k+kn}{as} \PYG{n+nn}{plt}
\PYG{k+kn}{import} \PYG{n+nn}{os}

\PYG{n}{root} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/images/lai\PYGZus{}eire}\PYG{l+s}{\PYGZsq{}}

\PYG{k}{def} \PYG{n+nf}{make\PYGZus{}movie}\PYG{p}{(}\PYG{n}{lai}\PYG{p}{,}\PYG{n}{root}\PYG{p}{,}\PYG{n}{layer}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{vmax}\PYG{o}{=}\PYG{l+m+mf}{4.}\PYG{p}{,}\PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{n}{do\PYGZus{}plot}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+sd}{    Make an animated gif from MODIS LAI data in}
\PYG{l+s+sd}{    dictionary \PYGZsq{}lai\PYGZsq{}.}

\PYG{l+s+sd}{    Parameters:}
\PYG{l+s+sd}{    lai    : data dictionary}
\PYG{l+s+sd}{    root   : root file /directory name of frames and movie}

\PYG{l+s+sd}{    layer  : data layer to plot}
\PYG{l+s+sd}{    vmax   : max value for plotting}
\PYG{l+s+sd}{    vmin   : min value for plotting}
\PYG{l+s+sd}{    do\PYGZus{}plot: set True if you want the individual plots}
\PYG{l+s+sd}{             to display}

\PYG{l+s+sd}{    Returns:}
\PYG{l+s+sd}{    movie name}

\PYG{l+s+sd}{    \PYGZsq{}\PYGZsq{}\PYGZsq{}}
    \PYG{n}{cmap} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{cm}\PYG{o}{.}\PYG{n}{Greens}

    \PYG{k}{for} \PYG{n}{i}\PYG{p}{,}\PYG{n}{f} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{lai}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{filenames}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{fig} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{)}\PYG{p}{)}
        \PYG{c}{\PYGZsh{} get some info from filename}
        \PYG{n}{file\PYGZus{}id} \PYG{o}{=} \PYG{n}{f}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{.}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{p}{]}
        \PYG{k}{print} \PYG{n}{file\PYGZus{}id}
        \PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{lai}\PYG{p}{[}\PYG{n}{layer}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,}\PYG{n}{cmap}\PYG{o}{=}\PYG{n}{cmap}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYGZbs{}
                   \PYG{n}{vmax}\PYG{o}{=}\PYG{n}{vmax}\PYG{p}{,}\PYG{n}{vmin}\PYG{o}{=}\PYG{n}{vmin}\PYG{p}{)}
        \PYG{c}{\PYGZsh{} plot a jpg}
        \PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{n}{file\PYGZus{}id}\PYG{p}{)}
        \PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{plt}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZus{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{.jpg}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{root}\PYG{p}{,}\PYG{n}{file\PYGZus{}id}\PYG{p}{)}\PYG{p}{)}
        \PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{do\PYGZus{}plot}\PYG{p}{:}
            \PYG{n}{plt}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{n}{fig}\PYG{p}{)}

    \PYG{n}{cmd} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{convert \PYGZhy{}delay 100 \PYGZhy{}loop 0 \PYGZob{}0\PYGZcb{}\PYGZus{}*.jpg \PYGZob{}0\PYGZcb{}\PYGZus{}movie.gif}\PYG{l+s}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{root}\PYG{p}{)}
    \PYG{n}{os}\PYG{o}{.}\PYG{n}{system}\PYG{p}{(}\PYG{n}{cmd}\PYG{p}{)}
    \PYG{k}{return} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZob{}0\PYGZcb{}\PYGZus{}movie.gif}\PYG{l+s}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{root}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} test it}

\PYG{n}{lai\PYGZus{}uk} \PYG{o}{=} \PYG{n}{read\PYGZus{}lai}\PYG{p}{(}\PYG{n}{filelist}\PYG{p}{,}\PYG{n}{country}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{UNITED KINGDOM}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{root} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/images/lai\PYGZus{}UK}\PYG{l+s}{\PYGZsq{}}
\PYG{n}{movie} \PYG{o}{=} \PYG{n}{make\PYGZus{}movie}\PYG{p}{(}\PYG{n}{lai\PYGZus{}uk}\PYG{p}{,}\PYG{n}{root}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{movie}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{2005001}
\PYG{l+m+mi}{2005009}
\PYG{l+m+mi}{2005017}
\PYG{l+m+mi}{2005025}
\PYG{l+m+mi}{2005033}
\PYG{l+m+mi}{2005041}
\PYG{l+m+mi}{2005049}
\PYG{l+m+mi}{2005057}
\PYG{l+m+mi}{2005065}
\PYG{l+m+mi}{2005073}
\PYG{l+m+mi}{2005081}
\PYG{l+m+mi}{2005089}
\PYG{l+m+mi}{2005097}
\PYG{l+m+mi}{2005105}
\PYG{l+m+mi}{2005113}
\PYG{l+m+mi}{2005121}
\PYG{l+m+mi}{2005129}
\PYG{l+m+mi}{2005137}
\PYG{l+m+mi}{2005145}
\PYG{l+m+mi}{2005153}
\PYG{l+m+mi}{2005161}
\PYG{l+m+mi}{2005169}
\PYG{l+m+mi}{2005177}
\PYG{l+m+mi}{2005185}
\PYG{l+m+mi}{2005193}
\PYG{l+m+mi}{2005201}
\PYG{l+m+mi}{2005209}
\PYG{l+m+mi}{2005217}
\PYG{l+m+mi}{2005225}
\PYG{l+m+mi}{2005233}
\PYG{l+m+mi}{2005241}
\PYG{l+m+mi}{2005249}
\PYG{l+m+mi}{2005257}
\PYG{l+m+mi}{2005265}
\PYG{l+m+mi}{2005273}
\PYG{l+m+mi}{2005281}
\PYG{l+m+mi}{2005289}
\PYG{l+m+mi}{2005297}
\PYG{l+m+mi}{2005305}
\PYG{l+m+mi}{2005313}
\PYG{l+m+mi}{2005321}
\PYG{l+m+mi}{2005329}
\PYG{l+m+mi}{2005337}
\PYG{l+m+mi}{2005345}
\PYG{l+m+mi}{2005353}
\PYG{l+m+mi}{2005361}
\PYG{n}{files}\PYG{o}{/}\PYG{n}{images}\PYG{o}{/}\PYG{n}{lai\PYGZus{}UK\PYGZus{}movie}\PYG{o}{.}\PYG{n}{gif}
\end{Verbatim}
\begin{figure}[htbp]
\centering

\includegraphics{Chapter5_Interpolation/files/images/lai_UK_movie.gif}
\end{figure}


\section{5.2 Interpolation}
\label{Chapter5_Interpolation/Interpolation:interpolation}

\subsection{5.2.1 Univariate interpolation}
\label{Chapter5_Interpolation/Interpolation:univariate-interpolation}
So, we can load the data we want from multiple MODIS hdf files that we
have downloaded from the NASA server into a 3D masked numpy array, with
a country boundary mask (projected int the raster data coordinate
system) from a vector dataset.

Let's start to explore the data then.

You should have an array of LAI for Ireland:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{lai}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{numpy}\PYG{o}{.}\PYG{n}{ma}\PYG{o}{.}\PYG{n}{core}\PYG{o}{.}\PYG{n}{MaskedArray}
\end{Verbatim}

Let's plot the LAI for some given pixels.

First, we might like to identify which pixels actually have any data.

A convenient function for this would be \code{np.where} that returns the
indices of items that are \code{True}.

Since the data mask is \code{False} for good data, we take the complement
\code{\textasciitilde{}} so that good data are {}`True:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{data} \PYG{o}{=} \PYG{n}{lai}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{np}\PYG{o}{.}\PYG{n}{where}\PYG{p}{(}\PYG{o}{\PYGZti{}}\PYG{n}{data}\PYG{o}{.}\PYG{n}{mask}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[} \PYG{l+m+mi}{3}\PYG{p}{,}  \PYG{l+m+mi}{3}\PYG{p}{,}  \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,} \PYG{l+m+mi}{39}\PYG{p}{,} \PYG{l+m+mi}{39}\PYG{p}{,} \PYG{l+m+mi}{39}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}
 \PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{326}\PYG{p}{,} \PYG{l+m+mi}{328}\PYG{p}{,} \PYG{l+m+mi}{329}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,} \PYG{l+m+mi}{472}\PYG{p}{,} \PYG{l+m+mi}{472}\PYG{p}{,} \PYG{l+m+mi}{475}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}
 \PYG{n}{array}\PYG{p}{(}\PYG{p}{[} \PYG{l+m+mi}{82}\PYG{p}{,} \PYG{l+m+mi}{145}\PYG{p}{,}  \PYG{l+m+mi}{83}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,}  \PYG{l+m+mi}{86}\PYG{p}{,}  \PYG{l+m+mi}{87}\PYG{p}{,}  \PYG{l+m+mi}{51}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

An example good pixel this is (3,329,145). Let's look at this for all
time periods:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{data} \PYG{o}{=} \PYG{n}{lai}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}

\PYG{n}{r} \PYG{o}{=} \PYG{l+m+mi}{329}
\PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{83}

\PYG{n}{pixel} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{]}

\PYG{c}{\PYGZsh{} plot red stars at the data points}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{pixel}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{n}{pixel}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r*}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{c}{\PYGZsh{} plot a black (k) dashed line (\PYGZhy{}\PYGZhy{})}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{pixel}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{n}{pixel}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{k\PYGZhy{}\PYGZhy{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{doy}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{LAI}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{pixel }\PYG{l+s+si}{\PYGZpc{}03d}\PYG{l+s}{ }\PYG{l+s+si}{\PYGZpc{}03d}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.text.Text at 0x11e77950\PYGZgt{}
\end{Verbatim}

\includegraphics{Interpolation_47_1.png}

The data follow the trend of what we might expect for LAI development,
but they are clearly a little noisy.

We also have access to uncertainty information (standard deviation):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} copy the data in case we change it any}

\PYG{n}{data} \PYG{o}{=} \PYG{n}{lai}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{sd}   \PYG{o}{=} \PYG{n}{lai}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{LaiStdDev\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{r} \PYG{o}{=} \PYG{l+m+mi}{329}
\PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{83}

\PYG{n}{pixel}    \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{]}
\PYG{n}{pixel\PYGZus{}sd} \PYG{o}{=}   \PYG{n}{sd}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{]}

\PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{pixel}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{8}

\PYG{c}{\PYGZsh{} plot red stars at the data points}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{pixel}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r*}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{c}{\PYGZsh{} plot a black (k) dashed line (\PYGZhy{}\PYGZhy{})}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{pixel}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{k\PYGZhy{}\PYGZhy{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{c}{\PYGZsh{} plot error bars:}
\PYG{c}{\PYGZsh{} 1.96 because that is the 95\PYGZpc{} confidence interval}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{errorbar}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{pixel}\PYG{p}{,}\PYG{n}{yerr}\PYG{o}{=}\PYG{n}{pixel\PYGZus{}sd}\PYG{o}{*}\PYG{l+m+mf}{1.96}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{doy}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{LAI}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{pixel }\PYG{l+s+si}{\PYGZpc{}03d}\PYG{l+s}{ }\PYG{l+s+si}{\PYGZpc{}03d}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.text.Text at 0x2ae9e53409d0\PYGZgt{}
\end{Verbatim}

\includegraphics{Interpolation_49_1.png}

We would generally expect LAI to be quite smoothly varying over time.
Visualising the data with 95\% confidence intervals is quite useful as we
can now `imagine' some smooth line that would generally go within these
bounds.

Some of the uncertainty estimates are really rather small though, which
are probably not reliable.

Let's inflate them:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{data} \PYG{o}{=} \PYG{n}{lai}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{sd}   \PYG{o}{=} \PYG{n}{lai}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{LaiStdDev\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{r} \PYG{o}{=} \PYG{l+m+mi}{329}
\PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{83}

\PYG{n}{pixel}    \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{]}
\PYG{n}{pixel\PYGZus{}sd} \PYG{o}{=}   \PYG{n}{sd}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{]}
\PYG{c}{\PYGZsh{} threshold}
\PYG{n}{thresh} \PYG{o}{=} \PYG{l+m+mf}{0.25}
\PYG{n}{pixel\PYGZus{}sd}\PYG{p}{[}\PYG{n}{pixel\PYGZus{}sd}\PYG{o}{\PYGZlt{}}\PYG{n}{thresh}\PYG{p}{]} \PYG{o}{=} \PYG{n}{thresh}

\PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{pixel}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{8}

\PYG{c}{\PYGZsh{} plot red stars at the data points}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{pixel}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r*}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{c}{\PYGZsh{} plot a black (k) dashed line (\PYGZhy{}\PYGZhy{})}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{pixel}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{k\PYGZhy{}\PYGZhy{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{c}{\PYGZsh{} plot error bars:}
\PYG{c}{\PYGZsh{} 1.96 because that is the 95\PYGZpc{} confidence interval}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{errorbar}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{pixel}\PYG{p}{,}\PYG{n}{yerr}\PYG{o}{=}\PYG{n}{pixel\PYGZus{}sd}\PYG{o}{*}\PYG{l+m+mf}{1.96}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{doy}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{LAI}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{pixel }\PYG{l+s+si}{\PYGZpc{}03d}\PYG{l+s}{ }\PYG{l+s+si}{\PYGZpc{}03d}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.text.Text at 0x2ae9e5554910\PYGZgt{}
\end{Verbatim}

\includegraphics{Interpolation_51_1.png}

This is perhaps a bit more realistic ...

The data now have some missing values (data gaps) and, as we have noted,
are a little noisy.

A Python module we can use for many scientific functions is
\code{{}`scipy} \textless{}\href{http://docs.scipy.org/doc/scipy}{http://docs.scipy.org/doc/scipy}\textgreater{}{}`\_\_, in particular here, the
\code{{}`scipy} interpolation
functions \textless{}\href{http://docs.scipy.org/doc/scipy/reference/interpolate.html}{http://docs.scipy.org/doc/scipy/reference/interpolate.html}\textgreater{}{}`\_\_.

We need to make a careful choice of the interpolation functions.

We might, in many circumstances simply want something that interpolates
between data points, i.e. that goes through the data points that we
have.

Many interpolators will not provide extrapolation, so in the example
above we could not get an estimate of LAI prior to the first sample and
after the last.

The best way to deal with that would be to have multiple years of data.

Instead here, we will repeat the dataset three times to mimic this:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{scipy} \PYG{k+kn}{import} \PYG{n}{interpolate}

\PYG{n}{pixel} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{]}

\PYG{c}{\PYGZsh{} original x,y}
\PYG{n}{y\PYGZus{}} \PYG{o}{=} \PYG{n}{pixel}
\PYG{n}{x\PYGZus{}} \PYG{o}{=} \PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{y\PYGZus{}}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mf}{8.}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{[}\PYG{o}{\PYGZti{}}\PYG{n}{pixel}\PYG{o}{.}\PYG{n}{mask}\PYG{p}{]}
\PYG{n}{y\PYGZus{}} \PYG{o}{=} \PYG{n}{y\PYGZus{}}\PYG{p}{[}\PYG{o}{\PYGZti{}}\PYG{n}{pixel}\PYG{o}{.}\PYG{n}{mask}\PYG{p}{]}

\PYG{c}{\PYGZsh{} extend: using np.tile() to repeat data}
\PYG{n}{y\PYGZus{}extend} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{tile}\PYG{p}{(}\PYG{n}{y\PYGZus{}}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{c}{\PYGZsh{} extend: using vstack to stack 3 different arrays}
\PYG{n}{x\PYGZus{}extend} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{hstack}\PYG{p}{(}\PYG{p}{(}\PYG{n}{x\PYGZus{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{46}\PYG{o}{*}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{n}{x\PYGZus{}}\PYG{p}{,}\PYG{n}{x\PYGZus{}}\PYG{o}{+}\PYG{l+m+mi}{46}\PYG{o}{*}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} plot the extended dataset}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x\PYGZus{}extend}\PYG{p}{,}\PYG{n}{y\PYGZus{}extend}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{b}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x\PYGZus{}}\PYG{p}{,}\PYG{n}{y\PYGZus{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{k+}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{l+m+mf}{0.}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{l+m+mf}{2.5}\PYG{p}{]}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{365.}\PYG{p}{,}\PYG{l+m+mf}{365.}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{l+m+mf}{2.5}\PYG{p}{]}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlim}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{356}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{l+m+mi}{365}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{day of year}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{LAI}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.text.Text at 0x2ae9e6108550\PYGZgt{}
\end{Verbatim}

\includegraphics{Interpolation_54_1.png}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} define xnew at 1 day interval}
\PYG{n}{xnew} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{p}{,}\PYG{l+m+mf}{366.}\PYG{p}{)}

\PYG{c}{\PYGZsh{} linear interpolation}
\PYG{n}{f} \PYG{o}{=} \PYG{n}{interpolate}\PYG{o}{.}\PYG{n}{interp1d}\PYG{p}{(}\PYG{n}{x\PYGZus{}extend}\PYG{p}{,}\PYG{n}{y\PYGZus{}extend}\PYG{p}{,}\PYG{n}{kind}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{linear}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ynew} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{n}{xnew}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{xnew}\PYG{p}{,}\PYG{n}{ynew}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x\PYGZus{}}\PYG{p}{,}\PYG{n}{y\PYGZus{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r+}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlim}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{366}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{366}\PYG{p}{)}
\end{Verbatim}

\includegraphics{Interpolation_56_1.png}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} cubic interpolation}
\PYG{n}{f} \PYG{o}{=} \PYG{n}{interpolate}\PYG{o}{.}\PYG{n}{interp1d}\PYG{p}{(}\PYG{n}{x\PYGZus{}extend}\PYG{p}{,}\PYG{n}{y\PYGZus{}extend}\PYG{p}{,}\PYG{n}{kind}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{cubic}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ynew} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{n}{xnew}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{xnew}\PYG{p}{,}\PYG{n}{ynew}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x\PYGZus{}}\PYG{p}{,}\PYG{n}{y\PYGZus{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r+}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlim}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{366}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{366}\PYG{p}{)}
\end{Verbatim}

\includegraphics{Interpolation_57_1.png}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} nearest neighbour interpolation}
\PYG{n}{f} \PYG{o}{=} \PYG{n}{interpolate}\PYG{o}{.}\PYG{n}{interp1d}\PYG{p}{(}\PYG{n}{x\PYGZus{}extend}\PYG{p}{,}\PYG{n}{y\PYGZus{}extend}\PYG{p}{,}\PYG{n}{kind}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nearest}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ynew} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{n}{xnew}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{xnew}\PYG{p}{,}\PYG{n}{ynew}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x\PYGZus{}}\PYG{p}{,}\PYG{n}{y\PYGZus{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r+}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlim}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{366}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{366}\PYG{p}{)}
\end{Verbatim}

\includegraphics{Interpolation_58_1.png}

Depending on the problem you are trying to solve, different
interpolation schemes will be appropriate. For categorical data (e.g.
`snow', coded as 1 and `no snow' coded as 1), for instance, a nearest
neighbour interpolation might be a good idea.


\subsection{5.2.2 Smoothing}
\label{Chapter5_Interpolation/Interpolation:smoothing}
One issue with the schemes above is that they go exactly through the
data points, but a more realistic description of the data might be one
that incorporated the uncertainty information we have. Visually, this is
quite easy to imagine, but how can we implement such ideas?

One way of thinking about this is to think about other sources of
information that we might bring to bear on the problem. One such would
be that we expect the function to be `quite smooth'. This allows us to
consider applying smoothness as an additional constraint to the
solution.

Many such problems can be phrased as convolution operations.

Convolution is a form of digital filtering that combines two sequences
of numbers \(y\) and \(w\) to give a third, the result \(z\)
that is a filtered version of \(y\), where for each element
\(j\) of \(y\):
\begin{gather}
\begin{split}z_j = \sum_{i=-n}^{i=n}{w_i y_{j+i}}\end{split}\notag
\end{gather}
where \(n\) is the half width of the filter \(w\). For a
smoothing filter, the elements of this will sum to 1 (so that the
magnitude of \(y\) is not changed).

To illustrate this in Python:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} a simple box smoothing filter}
\PYG{c}{\PYGZsh{} filter width 11}
\PYG{n}{w} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}\PYG{l+m+mi}{11}\PYG{p}{)}
\PYG{c}{\PYGZsh{} normalise}
\PYG{n}{w} \PYG{o}{=} \PYG{n}{w}\PYG{o}{/}\PYG{n}{w}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{p}{)}
\PYG{c}{\PYGZsh{} half width}
\PYG{n}{n} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{2}

\PYG{c}{\PYGZsh{} Take the linear interpolation of the LAI above as the signal}
\PYG{c}{\PYGZsh{} linear interpolation}
\PYG{n}{x} \PYG{o}{=} \PYG{n}{xnew}
\PYG{n}{f} \PYG{o}{=} \PYG{n}{interpolate}\PYG{o}{.}\PYG{n}{interp1d}\PYG{p}{(}\PYG{n}{x\PYGZus{}extend}\PYG{p}{,}\PYG{n}{y\PYGZus{}extend}\PYG{p}{,}\PYG{n}{kind}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{linear}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{y} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}

\PYG{c}{\PYGZsh{} where we will put the result}
\PYG{n}{z} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros\PYGZus{}like}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}

\PYG{c}{\PYGZsh{} This is a straight implementation of the}
\PYG{c}{\PYGZsh{} equation above}
\PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{n}{n}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{n}\PYG{p}{,}\PYG{n}{n}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{z}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{w}\PYG{p}{[}\PYG{n}{n}\PYG{o}{+}\PYG{n}{i}\PYG{p}{]} \PYG{o}{*} \PYG{n}{y}\PYG{p}{[}\PYG{n}{j}\PYG{o}{+}\PYG{n}{i}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{k\PYGZhy{}\PYGZhy{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{label}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{y}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{z}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{label}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{z}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlim}\PYG{p}{(}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{x}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{n}{loc}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{best}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{smoothing with filter width }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.text.Text at 0x2ae9e579e3d0\PYGZgt{}
\end{Verbatim}

\includegraphics{Interpolation_63_1.png}

As we suggested, the result of convolving \(y\) with the filter
\(w\) (of width 31 here) is \(z\), a smoothed version of
\(y\).

You might notice that the filter is only applied once we are \code{n}
samples into the signal, so we get `edge effects'. There are various
ways of dealing with edge effects, such as repeating the signal (as we
did above, for much the same reason), reflecting the signal, or assuming
the signal to be some constant value (e.g. 0) outside of its defined
domain.

If we make the filter wider (width 31 now):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} a simple box smoothing filter}
\PYG{c}{\PYGZsh{} filter width 31}
\PYG{n}{w} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}\PYG{l+m+mi}{31}\PYG{p}{)}
\PYG{c}{\PYGZsh{} normalise}
\PYG{n}{w} \PYG{o}{=} \PYG{n}{w}\PYG{o}{/}\PYG{n}{w}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{p}{)}
\PYG{c}{\PYGZsh{} half width}
\PYG{n}{n} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{2}

\PYG{c}{\PYGZsh{} Take the linear interpolation of the LAI above as the signal}
\PYG{c}{\PYGZsh{} linear interpolation}
\PYG{n}{x} \PYG{o}{=} \PYG{n}{xnew}
\PYG{n}{f} \PYG{o}{=} \PYG{n}{interpolate}\PYG{o}{.}\PYG{n}{interp1d}\PYG{p}{(}\PYG{n}{x\PYGZus{}extend}\PYG{p}{,}\PYG{n}{y\PYGZus{}extend}\PYG{p}{,}\PYG{n}{kind}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{linear}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{y} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}

\PYG{c}{\PYGZsh{} where we will put the result}
\PYG{n}{z} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros\PYGZus{}like}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}

\PYG{c}{\PYGZsh{} This is a straight implementation of the}
\PYG{c}{\PYGZsh{} equation above}
\PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{n}{n}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{n}\PYG{p}{,}\PYG{n}{n}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{z}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{w}\PYG{p}{[}\PYG{n}{n}\PYG{o}{+}\PYG{n}{i}\PYG{p}{]} \PYG{o}{*} \PYG{n}{y}\PYG{p}{[}\PYG{n}{j}\PYG{o}{+}\PYG{n}{i}\PYG{p}{]}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{k\PYGZhy{}\PYGZhy{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{label}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{y}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{z}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{label}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{z}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlim}\PYG{p}{(}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{x}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{n}{loc}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{best}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{smoothing with filter width }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.text.Text at 0x2ae9e61f8cd0\PYGZgt{}
\end{Verbatim}

\includegraphics{Interpolation_65_1.png}

Then the signal is `more' smoothed.

There are \emph{many} filters implemented in
\code{{}`scipy.signal} \textless{}\href{http://docs.scipy.org/doc/scipy/reference/signal.html}{http://docs.scipy.org/doc/scipy/reference/signal.html}\textgreater{}{}`\_\_
that you should look over.

A very commonly used smoothing filter is the
\href{http://en.wikipedia.org/wiki/SavitzkyGolay\_filter\_for\_smoothing\_and\_differentiation}{Savitsky-Golay}
filter for which you define the window size and filter order.

As with most filters, the filter width controls the degree of smoothing
(see examples above). The filter order (related to polynomial order) in
essence controls the shape of the filter and defines the `peakiness' of
the response.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{n}{sys}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/python}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{c}{\PYGZsh{} see http://wiki.scipy.org/Cookbook/SavitzkyGolay}
\PYG{k+kn}{from} \PYG{n+nn}{savitzky\PYGZus{}golay} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{n}{window\PYGZus{}size} \PYG{o}{=} \PYG{l+m+mi}{31}
\PYG{n}{order} \PYG{o}{=} \PYG{l+m+mi}{1}

\PYG{c}{\PYGZsh{} Take the linear interpolation of the LAI above as the signal}
\PYG{c}{\PYGZsh{} linear interpolation}
\PYG{n}{x} \PYG{o}{=} \PYG{n}{xnew}
\PYG{n}{f} \PYG{o}{=} \PYG{n}{interpolate}\PYG{o}{.}\PYG{n}{interp1d}\PYG{p}{(}\PYG{n}{x\PYGZus{}extend}\PYG{p}{,}\PYG{n}{y\PYGZus{}extend}\PYG{p}{,}\PYG{n}{kind}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{linear}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{y} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}

\PYG{n}{z} \PYG{o}{=} \PYG{n}{savitzky\PYGZus{}golay}\PYG{p}{(}\PYG{n}{y}\PYG{p}{,}\PYG{n}{window\PYGZus{}size}\PYG{p}{,}\PYG{n}{order}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{k\PYGZhy{}\PYGZhy{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{label}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{y}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{z}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{label}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{z}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlim}\PYG{p}{(}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{x}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{n}{loc}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{best}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{smoothing with filter width }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{ order }\PYG{l+s+si}{\PYGZpc{}.2f}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{window\PYGZus{}size}\PYG{p}{,}\PYG{n}{order}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.text.Text at 0x2ae9e65e6890\PYGZgt{}
\end{Verbatim}

\includegraphics{Interpolation_68_1.png}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{n}{sys}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/python}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{c}{\PYGZsh{} see http://wiki.scipy.org/Cookbook/SavitzkyGolay}
\PYG{k+kn}{from} \PYG{n+nn}{savitzky\PYGZus{}golay} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{n}{window\PYGZus{}size} \PYG{o}{=} \PYG{l+m+mi}{61}
\PYG{n}{order} \PYG{o}{=} \PYG{l+m+mi}{2}

\PYG{c}{\PYGZsh{} Take the linear interpolation of the LAI above as the signal}
\PYG{c}{\PYGZsh{} linear interpolation}
\PYG{n}{x} \PYG{o}{=} \PYG{n}{xnew}
\PYG{n}{f} \PYG{o}{=} \PYG{n}{interpolate}\PYG{o}{.}\PYG{n}{interp1d}\PYG{p}{(}\PYG{n}{x\PYGZus{}extend}\PYG{p}{,}\PYG{n}{y\PYGZus{}extend}\PYG{p}{,}\PYG{n}{kind}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{linear}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{y} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}

\PYG{n}{z} \PYG{o}{=} \PYG{n}{savitzky\PYGZus{}golay}\PYG{p}{(}\PYG{n}{y}\PYG{p}{,}\PYG{n}{window\PYGZus{}size}\PYG{p}{,}\PYG{n}{order}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{k\PYGZhy{}\PYGZhy{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{label}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{y}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{z}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{label}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{z}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlim}\PYG{p}{(}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{x}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{n}{loc}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{best}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{smoothing with filter width }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{ order }\PYG{l+s+si}{\PYGZpc{}.2f}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{window\PYGZus{}size}\PYG{p}{,}\PYG{n}{order}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.text.Text at 0x2ae9e663bb50\PYGZgt{}
\end{Verbatim}

\includegraphics{Interpolation_69_1.png}

If the samples \(y\) have uncertainty (standard deviation
\(\sigma_j\) for sample \(j\)) associated with them, we can
incorporate this into smoothing, although many of the methods in
\code{scipy} and \code{numpy} do not directly allow for this.

Instead, we call an optimal interpolation scheme (a regulariser) here
that achieves this. This also has the advantage of giving an estimate of
uncertainty for the smoothed samples.

In this case, the parameters are: \code{order} (as above, but only integer
in this implementation) and \code{wsd} which is an estimate of the
variation (standard deviation) in the signal that control smoothness.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{tile} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{h17v03}\PYG{l+s}{\PYGZsq{}}
\PYG{n}{year} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{2005}\PYG{l+s}{\PYGZsq{}}

\PYG{c}{\PYGZsh{} specify the file with the urls in}
\PYG{n}{ifile}\PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/modis\PYGZus{}lai\PYGZus{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZus{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{.txt}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{tile}\PYG{p}{,}\PYG{n}{year}\PYG{p}{)}

\PYG{n}{fp} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{ifile}\PYG{p}{)}
\PYG{n}{filelist} \PYG{o}{=} \PYG{p}{[}\PYG{n}{url}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{strip}\PYG{p}{(}\PYG{p}{)} \PYG{k}{for} \PYG{n}{url} \PYG{o+ow}{in} \PYG{n}{fp}\PYG{o}{.}\PYG{n}{readlines}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}
\PYG{n}{fp}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{n}{sys}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/python}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{k+kn}{from} \PYG{n+nn}{get\PYGZus{}lai} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{k}{try}\PYG{p}{:}
    \PYG{n}{data} \PYG{o}{=} \PYG{n}{lai}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
    \PYG{n}{sd} \PYG{o}{=} \PYG{n}{lai}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{LaiStdDev\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\PYG{k}{except}\PYG{p}{:}
    \PYG{n}{lai} \PYG{o}{=} \PYG{n}{read\PYGZus{}lai}\PYG{p}{(}\PYG{n}{filelist}\PYG{p}{,}\PYG{n}{country}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{IRELAND}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{data} \PYG{o}{=} \PYG{n}{lai}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
    \PYG{n}{sd} \PYG{o}{=} \PYG{n}{lai}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{LaiStdDev\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}

\PYG{n}{thresh} \PYG{o}{=} \PYG{l+m+mf}{0.25}
\PYG{n}{sd}\PYG{p}{[}\PYG{n}{sd}\PYG{o}{\PYGZlt{}}\PYG{n}{thresh}\PYG{p}{]} \PYG{o}{=} \PYG{n}{thresh}

\PYG{n}{r} \PYG{o}{=} \PYG{l+m+mi}{472}
\PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{84}
\PYG{k+kn}{from} \PYG{n+nn}{smoothn} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{c}{\PYGZsh{} this is about the right amount of smoothing here}
\PYG{n}{gamma} \PYG{o}{=} \PYG{l+m+mf}{5.}

\PYG{n}{pixel} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{]}
\PYG{n}{pixel\PYGZus{}sd} \PYG{o}{=}   \PYG{n}{sd}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{]}

\PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{46}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{8}\PYG{o}{+}\PYG{l+m+mi}{1}

\PYG{n}{order} \PYG{o}{=} \PYG{l+m+mi}{2}
\PYG{n}{z} \PYG{o}{=} \PYG{n}{smoothn}\PYG{p}{(}\PYG{n}{pixel}\PYG{p}{,}\PYG{n}{s}\PYG{o}{=}\PYG{n}{gamma}\PYG{p}{,}\PYG{n}{sd}\PYG{o}{=}\PYG{n}{pixel\PYGZus{}sd}\PYG{p}{,}\PYG{n}{smoothOrder}\PYG{o}{=}\PYG{l+m+mf}{2.0}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}

\PYG{c}{\PYGZsh{} plot}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{pixel}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{k*}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{label}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{y}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{errorbar}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{pixel}\PYG{p}{,}\PYG{n}{pixel\PYGZus{}sd}\PYG{o}{*}\PYG{l+m+mf}{1.96}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{z}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{label}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{z}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{c}{\PYGZsh{} lower and upper bounds of 95\PYGZpc{} CI}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlim}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{366}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylim}\PYG{p}{(}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{l+m+mf}{2.5}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{n}{loc}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{best}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.legend.Legend at 0x2b75e4be2790\PYGZgt{}
\end{Verbatim}

\includegraphics{Interpolation_71_1.png}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} test it on a new pixel}

\PYG{n}{r} \PYG{o}{=} \PYG{l+m+mi}{472}
\PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{86}

\PYG{n}{gamma} \PYG{o}{=} \PYG{l+m+mi}{5}

\PYG{n}{pixel} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{]}
\PYG{n}{pixel\PYGZus{}sd} \PYG{o}{=}   \PYG{n}{sd}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{]}

\PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{46}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{8}\PYG{o}{+}\PYG{l+m+mi}{1}

\PYG{n}{order} \PYG{o}{=} \PYG{l+m+mi}{2}
\PYG{n}{z} \PYG{o}{=} \PYG{n}{smoothn}\PYG{p}{(}\PYG{n}{pixel}\PYG{p}{,}\PYG{n}{s}\PYG{o}{=}\PYG{n}{gamma}\PYG{p}{,}\PYG{n}{sd}\PYG{o}{=}\PYG{n}{pixel\PYGZus{}sd}\PYG{p}{,}\PYG{n}{smoothOrder}\PYG{o}{=}\PYG{l+m+mf}{2.0}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}

\PYG{c}{\PYGZsh{} plot}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{pixel}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{k*}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{label}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{y}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{errorbar}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{pixel}\PYG{p}{,}\PYG{n}{pixel\PYGZus{}sd}\PYG{o}{*}\PYG{l+m+mf}{1.96}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{z}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{label}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{z}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlim}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{366}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{n}{loc}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{best}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{z}\PYG{o}{.}\PYG{n}{ndim}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{1}
\end{Verbatim}

\includegraphics{Interpolation_72_1.png}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} and test it on a new pixel}

\PYG{n}{r} \PYG{o}{=} \PYG{l+m+mi}{472}
\PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{84}

\PYG{c}{\PYGZsh{}r = 9}
\PYG{c}{\PYGZsh{}c = 277}
\PYG{n}{gamma} \PYG{o}{=} \PYG{l+m+mf}{5.}

\PYG{n}{pixel} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{]}
\PYG{n}{pixel\PYGZus{}sd} \PYG{o}{=}   \PYG{n}{sd}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{]}

\PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{46}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{8}\PYG{o}{+}\PYG{l+m+mi}{1}

\PYG{n}{order} \PYG{o}{=} \PYG{l+m+mi}{2}
\PYG{c}{\PYGZsh{} solve for gamma \PYGZhy{} degree of smoothness}
\PYG{n}{zz} \PYG{o}{=} \PYG{n}{smoothn}\PYG{p}{(}\PYG{n}{pixel}\PYG{p}{,}\PYG{n}{sd}\PYG{o}{=}\PYG{n}{pixel\PYGZus{}sd}\PYG{p}{,}\PYG{n}{smoothOrder}\PYG{o}{=}\PYG{l+m+mf}{2.0}\PYG{p}{)}
\PYG{n}{z} \PYG{o}{=} \PYG{n}{zz}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{k}{print} \PYG{n}{zz}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{n}{zz}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}

\PYG{n}{gamma} \PYG{o}{=} \PYG{n}{zz}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}

\PYG{c}{\PYGZsh{} plot}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{pixel}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{k*}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{label}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{y}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{errorbar}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{pixel}\PYG{p}{,}\PYG{n}{pixel\PYGZus{}sd}\PYG{o}{*}\PYG{l+m+mf}{1.96}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{z}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{label}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{z}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlim}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{366}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{n}{loc}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{best}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
7.56265788653 True
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.legend.Legend at 0x2b75e6878890\PYGZgt{}
\end{Verbatim}

\includegraphics{Interpolation_73_2.png}

To apply this approach to our 3D dataset, we could simply loop over all
pixels.

Note that \emph{any} per-pixel processing will be slow ... but this is quite
a fast smoothing method, so is feasible here.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} we have put in an axis control to smoothn}
\PYG{c}{\PYGZsh{} here so it will only smooth over doy}
\PYG{c}{\PYGZsh{} This will take a few minutes to process}
\PYG{c}{\PYGZsh{} we switch on verbose mode to get some feedback}
\PYG{c}{\PYGZsh{} on progress}

\PYG{c}{\PYGZsh{} make a mask of pixels where there is at least 1 sample}
\PYG{c}{\PYGZsh{} over the time period}
\PYG{n}{mask} \PYG{o}{=} \PYG{p}{(}\PYG{n}{data}\PYG{o}{.}\PYG{n}{mask}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{mask} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{n}{mask}\PYG{p}{]}\PYG{o}{*}\PYG{n}{data}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{z} \PYG{o}{=} \PYG{n}{smoothn}\PYG{p}{(}\PYG{n}{data}\PYG{p}{,}\PYG{n}{s}\PYG{o}{=}\PYG{l+m+mf}{5.0}\PYG{p}{,}\PYG{n}{sd}\PYG{o}{=}\PYG{n}{sd}\PYG{p}{,}\PYG{n}{smoothOrder}\PYG{o}{=}\PYG{l+m+mf}{2.0}\PYG{p}{,}\PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{TolZ}\PYG{o}{=}\PYG{l+m+mf}{0.05}\PYG{p}{,}\PYG{n}{verbose}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{z} \PYG{o}{=} \PYG{n}{ma}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{z}\PYG{p}{,}\PYG{n}{mask}\PYG{o}{=}\PYG{n}{mask}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
tol 1.0 nit 0
tol 1.03767913976 nit 1
tol 0.695375818129 nit 2
tol 0.55340286659 nit 3
tol 0.379048609608 nit 4
tol 0.297133997656 nit 5
tol 0.211254020382 nit 6
tol 0.161703395437 nit 7
tol 0.118022633002 nit 8
tol 0.089141179031 nit 9
tol 0.0662378920796 nit 10
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{9}\PYG{p}{,}\PYG{l+m+mi}{9}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{z}\PYG{p}{[}\PYG{l+m+mi}{20}\PYG{p}{]}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{vmax}\PYG{o}{=}\PYG{l+m+mi}{6}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.colorbar.Colorbar instance at 0x2b75d2d9fd40\PYGZgt{}
\end{Verbatim}

\includegraphics{Interpolation_76_1.png}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} similarly, take frame 20}
\PYG{c}{\PYGZsh{} and smooth that}

\PYG{n}{ZZ} \PYG{o}{=} \PYG{n}{smoothn}\PYG{p}{(}\PYG{n}{z}\PYG{p}{[}\PYG{l+m+mi}{20}\PYG{p}{]}\PYG{p}{,}\PYG{n}{smoothOrder}\PYG{o}{=}\PYG{l+m+mf}{2.}\PYG{p}{)}
\PYG{c}{\PYGZsh{} self\PYGZhy{}calibrated smoothness term}
\PYG{n}{s} \PYG{o}{=} \PYG{n}{ZZ}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{s =}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{s}
\PYG{n}{Z} \PYG{o}{=} \PYG{n}{ZZ}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{9}\PYG{p}{,}\PYG{l+m+mi}{9}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{Z}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{vmax}\PYG{o}{=}\PYG{l+m+mi}{6}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{s} \PYG{o}{=} \PYG{l+m+mf}{0.731142059593}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.colorbar.Colorbar instance at 0x1857ee18\PYGZgt{}
\end{Verbatim}

\includegraphics{Interpolation_77_2.png}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} similarly, take frame 20}
\PYG{c}{\PYGZsh{} and smooth that}

\PYG{n}{ZZ} \PYG{o}{=} \PYG{n}{smoothn}\PYG{p}{(}\PYG{n}{z}\PYG{p}{,}\PYG{n}{s}\PYG{o}{=}\PYG{n}{s}\PYG{p}{,}\PYG{n}{smoothOrder}\PYG{o}{=}\PYG{l+m+mf}{2.}\PYG{p}{,}\PYG{n}{axis}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,}\PYG{n}{verbose}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}

\PYG{n}{Z} \PYG{o}{=} \PYG{n}{ZZ}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{9}\PYG{p}{,}\PYG{l+m+mi}{9}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{Z}\PYG{p}{[}\PYG{l+m+mi}{30}\PYG{p}{]}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{vmax}\PYG{o}{=}\PYG{l+m+mi}{6}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
tol 1.0 nit 0
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.colorbar.Colorbar instance at 0x23289dd0\PYGZgt{}
\end{Verbatim}

\includegraphics{Interpolation_78_2.png}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{46}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{8}\PYG{o}{+}\PYG{l+m+mf}{1.}
\PYG{k}{try}\PYG{p}{:}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{n}{Z}\PYG{p}{,}\PYG{n}{axis}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{min}\PYG{p}{(}\PYG{n}{Z}\PYG{p}{,}\PYG{n}{axis}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r\PYGZhy{}\PYGZhy{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{n}{Z}\PYG{p}{,}\PYG{n}{axis}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r\PYGZhy{}\PYGZhy{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{except}\PYG{p}{:}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{n}{Z}\PYG{p}{,}\PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{min}\PYG{p}{(}\PYG{n}{Z}\PYG{p}{,}\PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{.}\PYG{n}{min}\PYG{p}{(}\PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r\PYGZhy{}\PYGZhy{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{n}{Z}\PYG{p}{,}\PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r\PYGZhy{}\PYGZhy{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{LAI variation of Eire}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.text.Text at 0x232b2ed0\PYGZgt{}
\end{Verbatim}

\includegraphics{Interpolation_79_1.png}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} or doing this pixel by pixel ...}
\PYG{c}{\PYGZsh{} which is slower than using axis}

\PYG{n}{order} \PYG{o}{=} \PYG{l+m+mi}{2}

\PYG{c}{\PYGZsh{} pixels that have some data}
\PYG{n}{mask} \PYG{o}{=} \PYG{p}{(}\PYG{o}{\PYGZti{}}\PYG{n}{data}\PYG{o}{.}\PYG{n}{mask}\PYG{p}{)}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}

\PYG{n}{odata} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{46}\PYG{p}{,}\PYG{p}{)} \PYG{o}{+} \PYG{n}{mask}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{)}

\PYG{n}{rows}\PYG{p}{,}\PYG{n}{cols} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{where}\PYG{p}{(}\PYG{n}{mask}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{0}\PYG{p}{)}

\PYG{n}{len\PYGZus{}x} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{rows}\PYG{p}{)}
\PYG{n}{order} \PYG{o}{=} \PYG{l+m+mi}{2}
\PYG{n}{gamma} \PYG{o}{=} \PYG{l+m+mf}{5.}

\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{n}{len\PYGZus{}x}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{r}\PYG{p}{,}\PYG{n}{c} \PYG{o}{=} \PYG{n}{rows}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,}\PYG{n}{cols}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
    \PYG{c}{\PYGZsh{} progress bar}
    \PYG{k}{if} \PYG{n}{i}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{len\PYGZus{}x}\PYG{o}{/}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:}
        \PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{... }\PYG{l+s+si}{\PYGZpc{}4.2f}\PYG{l+s}{ percent}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{i}\PYG{o}{*}\PYG{l+m+mf}{100.}\PYG{o}{/}\PYG{n+nb}{float}\PYG{p}{(}\PYG{n}{len\PYGZus{}x}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{pixel}    \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{]}
    \PYG{n}{pixel\PYGZus{}sd} \PYG{o}{=} \PYG{n}{sd}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{]}

    \PYG{n}{zz} \PYG{o}{=} \PYG{n}{smoothn}\PYG{p}{(}\PYG{n}{pixel}\PYG{p}{,}\PYG{n}{s}\PYG{o}{=}\PYG{n}{gamma}\PYG{p}{,}\PYG{n}{sd}\PYG{o}{=}\PYG{n}{pixel\PYGZus{}sd}\PYG{p}{,}\PYG{n}{smoothOrder}\PYG{o}{=}\PYG{n}{order}\PYG{p}{,}\PYG{n}{TolZ}\PYG{o}{=}\PYG{l+m+mf}{0.05}\PYG{p}{)}
    \PYG{n}{odata}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{rows}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,}\PYG{n}{cols}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{]} \PYG{o}{=} \PYG{n}{zz}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{0.00} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{5.00} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{10.00} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{15.00} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{20.00} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{25.00} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{30.00} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{35.00} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{40.00} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{45.00} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{50.00} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{55.00} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{60.00} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{65.00} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{70.00} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{75.00} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{80.00} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{85.00} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{90.00} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{95.00} \PYG{n}{percent}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{pylab} \PYG{k+kn}{as} \PYG{n+nn}{plt}
\PYG{k+kn}{import} \PYG{n+nn}{os}

\PYG{n}{root} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/images/lai\PYGZus{}eire\PYGZus{}colourZ}\PYG{l+s}{\PYGZsq{}}

\PYG{k}{for} \PYG{n}{i}\PYG{p}{,}\PYG{n}{f} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{lai}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{filenames}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{fig} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{)}\PYG{p}{)}
    \PYG{c}{\PYGZsh{} get some info from filename}
    \PYG{n}{file\PYGZus{}id} \PYG{o}{=} \PYG{n}{f}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{.}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{p}{]}
    \PYG{k}{print} \PYG{n}{file\PYGZus{}id}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{Z}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{vmax}\PYG{o}{=}\PYG{l+m+mf}{6.}\PYG{p}{,}\PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mf}{0.0}\PYG{p}{)}
    \PYG{c}{\PYGZsh{} plot a jpg}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{n}{file\PYGZus{}id}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZus{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{.jpg}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{root}\PYG{p}{,}\PYG{n}{file\PYGZus{}id}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{n}{fig}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{2005001}
\PYG{l+m+mi}{2005009}
\PYG{l+m+mi}{2005017}
\PYG{l+m+mi}{2005025}
\PYG{l+m+mi}{2005033}
\PYG{l+m+mi}{2005041}
\PYG{l+m+mi}{2005049}
\PYG{l+m+mi}{2005057}
\PYG{l+m+mi}{2005065}
\PYG{l+m+mi}{2005073}
\PYG{l+m+mi}{2005081}
\PYG{l+m+mi}{2005089}
\PYG{l+m+mi}{2005097}
\PYG{l+m+mi}{2005105}
\PYG{l+m+mi}{2005113}
\PYG{l+m+mi}{2005121}
\PYG{l+m+mi}{2005129}
\PYG{l+m+mi}{2005137}
\PYG{l+m+mi}{2005145}
\PYG{l+m+mi}{2005153}
\PYG{l+m+mi}{2005161}
\PYG{l+m+mi}{2005169}
\PYG{l+m+mi}{2005177}
\PYG{l+m+mi}{2005185}
\PYG{l+m+mi}{2005193}
\PYG{l+m+mi}{2005201}
\PYG{l+m+mi}{2005209}
\PYG{l+m+mi}{2005217}
\PYG{l+m+mi}{2005225}
\PYG{l+m+mi}{2005233}
\PYG{l+m+mi}{2005241}
\PYG{l+m+mi}{2005249}
\PYG{l+m+mi}{2005257}
\PYG{l+m+mi}{2005265}
\PYG{l+m+mi}{2005273}
\PYG{l+m+mi}{2005281}
\PYG{l+m+mi}{2005289}
\PYG{l+m+mi}{2005297}
\PYG{l+m+mi}{2005305}
\PYG{l+m+mi}{2005313}
\PYG{l+m+mi}{2005321}
\PYG{l+m+mi}{2005329}
\PYG{l+m+mi}{2005337}
\PYG{l+m+mi}{2005345}
\PYG{l+m+mi}{2005353}
\PYG{l+m+mi}{2005361}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{cmd} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{convert \PYGZhy{}delay 100 \PYGZhy{}loop 0 \PYGZob{}0\PYGZcb{}\PYGZus{}*.jpg \PYGZob{}0\PYGZcb{}\PYGZus{}movie2.gif}\PYG{l+s}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{root}\PYG{p}{)}
\PYG{n}{os}\PYG{o}{.}\PYG{n}{system}\PYG{p}{(}\PYG{n}{cmd}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{0}
\end{Verbatim}
\begin{figure}[htbp]
\centering

\includegraphics{Chapter5_Interpolation/files/images/lai_eire_colourZ_movie2.gif}
\end{figure}


\subsection{5.3 Function fitting}
\label{Chapter5_Interpolation/Interpolation:function-fitting}
Sometimes, instead of applying some arbitrary smoothing function to
data, we want to extract particular infromation from the time series.

One way to approach this is to fit some function to the time series at
each location.

Let us suppose that we wish to characterise the phenology of vegetation
in Ireland.
\begin{figure}[htbp]
\centering
\end{figure}

One way we could do this would be to look in the lai data for the most
rapid changes.

Another would be to explicitly fit some mathematical function to the LAI
data that would would expect to descrive typical LAI trajectories.

One example of such a function is the double logistic. A logistic
function is:
\begin{gather}
\begin{split}\hat{y} = p_0 - p_1 \left( \frac{1}{1 + e^{p_2 (t - p_3)}} + \frac{1}{1 + e^{p_4 (t - p_5)}} -1\right)\end{split}\notag
\end{gather}
We can give a function for a double logistic:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{dbl\PYGZus{}logistic\PYGZus{}model} \PYG{p}{(} \PYG{n}{p}\PYG{p}{,} \PYG{n}{t} \PYG{p}{)}\PYG{p}{:}
        \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}A double logistic model, as in Sobrino and Juliean, or Zhang et al\PYGZdq{}\PYGZdq{}\PYGZdq{}}
        \PYG{k}{return} \PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{*} \PYG{p}{(} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{*}\PYG{p}{(}\PYG{n}{t}\PYG{o}{\PYGZhy{}}\PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYGZbs{}
                              \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{o}{*}\PYG{p}{(}\PYG{n}{t}\PYG{o}{\PYGZhy{}}\PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}  \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1} \PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{tile} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{h17v03}\PYG{l+s}{\PYGZsq{}}
\PYG{n}{year} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{2005}\PYG{l+s}{\PYGZsq{}}

\PYG{c}{\PYGZsh{} specify the file with the urls in}
\PYG{n}{ifile}\PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/modis\PYGZus{}lai\PYGZus{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZus{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{.txt}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{tile}\PYG{p}{,}\PYG{n}{year}\PYG{p}{)}

\PYG{n}{fp} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{ifile}\PYG{p}{)}
\PYG{n}{filelist} \PYG{o}{=} \PYG{p}{[}\PYG{n}{url}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{/}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{strip}\PYG{p}{(}\PYG{p}{)} \PYG{k}{for} \PYG{n}{url} \PYG{o+ow}{in} \PYG{n}{fp}\PYG{o}{.}\PYG{n}{readlines}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}
\PYG{n}{fp}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{n}{sys}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/python}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{k+kn}{from} \PYG{n+nn}{get\PYGZus{}lai} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{k}{try}\PYG{p}{:}
    \PYG{n}{data} \PYG{o}{=} \PYG{n}{lai}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
    \PYG{n}{sd} \PYG{o}{=} \PYG{n}{lai}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{LaiStdDev\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\PYG{k}{except}\PYG{p}{:}
    \PYG{n}{lai} \PYG{o}{=} \PYG{n}{read\PYGZus{}lai}\PYG{p}{(}\PYG{n}{filelist}\PYG{p}{,}\PYG{n}{country}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{IRELAND}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{data} \PYG{o}{=} \PYG{n}{lai}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
    \PYG{n}{sd} \PYG{o}{=} \PYG{n}{lai}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{LaiStdDev\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}

\PYG{n}{thresh} \PYG{o}{=} \PYG{l+m+mf}{0.25}
\PYG{n}{sd}\PYG{p}{[}\PYG{n}{sd}\PYG{o}{\PYGZlt{}}\PYG{n}{thresh}\PYG{p}{]} \PYG{o}{=} \PYG{n}{thresh}

\PYG{c}{\PYGZsh{} test pixel}
\PYG{n}{r} \PYG{o}{=} \PYG{l+m+mi}{472}
\PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{84}


\PYG{n}{y} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{]}
\PYG{n}{mask} \PYG{o}{=} \PYG{o}{\PYGZti{}}\PYG{n}{y}\PYG{o}{.}\PYG{n}{mask}
\PYG{n}{y} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{y}\PYG{p}{[}\PYG{n}{mask}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{x} \PYG{o}{=} \PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{46}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{8}\PYG{o}{+}\PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{[}\PYG{n}{mask}\PYG{p}{]}
\PYG{n}{unc} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{sd}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{]}\PYG{p}{[}\PYG{n}{mask}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

And see what this looks like:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} define x (time)}
\PYG{n}{x\PYGZus{}full} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{366}\PYG{p}{)}

\PYG{c}{\PYGZsh{} some default values for the parameters}
\PYG{n}{p} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)}

\PYG{c}{\PYGZsh{} some stats on y}
\PYG{n}{ysd} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{std}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}
\PYG{n}{ymean} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}

\PYG{c}{\PYGZsh{} some rough guesses at the parameters}

\PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n}{ymean} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{1.151}\PYG{o}{*}\PYG{n}{ysd}\PYG{p}{;}   \PYG{c}{\PYGZsh{} minimum  (1.151 is 75\PYGZpc{} CI)}
\PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{l+m+mf}{1.151}\PYG{o}{*}\PYG{n}{ysd}          \PYG{c}{\PYGZsh{} range}
\PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{0.19}                 \PYG{c}{\PYGZsh{} related to up slope}
\PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{120}                  \PYG{c}{\PYGZsh{} midpoint of up slope}
\PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{0.13}                 \PYG{c}{\PYGZsh{} related to down slope}
\PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{220}                  \PYG{c}{\PYGZsh{} midpoint of down slope}

\PYG{n}{y\PYGZus{}hat} \PYG{o}{=} \PYG{n}{dbl\PYGZus{}logistic\PYGZus{}model}\PYG{p}{(}\PYG{n}{p}\PYG{p}{,}\PYG{n}{x\PYGZus{}full}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{clf}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x\PYGZus{}full}\PYG{p}{,}\PYG{n}{y\PYGZus{}hat}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{*}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{errorbar}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{unc}\PYG{o}{*}\PYG{l+m+mf}{1.96}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}Container object of 3 artists\PYGZgt{}
\end{Verbatim}

\includegraphics{Interpolation_90_1.png}

We could manually `tweak' the parameters until we got a better `fit' to
the observations.

First though, let's define a measure of `fit':
\begin{gather}
\begin{split}Z_i = \frac{\hat{y}_i - y_i}{\sigma_i}\end{split}\notag
\end{gather}\begin{gather}
\begin{split}Z^2 = \sum_i{Z_i^2} =  \sum_i{\left( \frac{\hat{y}_i - y_i}{\sigma_i} \right)^2}\end{split}\notag
\end{gather}
and implement this as a mismatch function where we have data points:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{mismatch\PYGZus{}function}\PYG{p}{(}\PYG{n}{p}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{unc}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{y\PYGZus{}hat} \PYG{o}{=} \PYG{n}{dbl\PYGZus{}logistic\PYGZus{}model}\PYG{p}{(}\PYG{n}{p}\PYG{p}{,} \PYG{n}{x}\PYG{p}{)}
    \PYG{n}{diff} \PYG{o}{=} \PYG{p}{(}\PYG{n}{y\PYGZus{}hat} \PYG{o}{\PYGZhy{}} \PYG{n}{y}\PYG{p}{)}\PYG{o}{/}\PYG{n}{unc}
    \PYG{k}{return} \PYG{n}{diff}


\PYG{n}{Z} \PYG{o}{=} \PYG{n}{mismatch\PYGZus{}function}\PYG{p}{(}\PYG{n}{p}\PYG{p}{,}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{unc}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mf}{365.}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mf}{0.}\PYG{p}{]}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{k\PYGZhy{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlim}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{365}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{Z}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{*}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}


\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Z\PYGZca{}2 =}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{p}{(}\PYG{n}{Z}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Z}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{=} \PYG{l+m+mf}{113.325251358}
\end{Verbatim}

\includegraphics{Interpolation_92_1.png}

Now lets change p a bit:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n}{ymean} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{1.151}\PYG{o}{*}\PYG{n}{ysd}\PYG{p}{;}   \PYG{c}{\PYGZsh{} minimum  (1.151 is 75\PYGZpc{} CI)}
\PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{l+m+mf}{1.151}\PYG{o}{*}\PYG{n}{ysd}          \PYG{c}{\PYGZsh{} range}
\PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{0.19}                 \PYG{c}{\PYGZsh{} related to up slope}
\PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{140}                  \PYG{c}{\PYGZsh{} midpoint of up slope}
\PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{0.13}                 \PYG{c}{\PYGZsh{} related to down slope}
\PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{220}                  \PYG{c}{\PYGZsh{} midpoint of down slope}

\PYG{n}{Z} \PYG{o}{=} \PYG{n}{mismatch\PYGZus{}function}\PYG{p}{(}\PYG{n}{p}\PYG{p}{,}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{unc}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mf}{365.}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mf}{0.}\PYG{p}{]}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{k\PYGZhy{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlim}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{365}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{Z}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{*}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}


\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Z\PYGZca{}2 =}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{p}{(}\PYG{n}{Z}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Z}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{=} \PYG{l+m+mf}{105.478274642}
\end{Verbatim}

\includegraphics{Interpolation_94_1.png}

We have made the mismatch go down a little ...

Clearly it would be tedious (and impractical) to do a lot of such
tweaking, so we can use methods that seek the minimum of some function.

One such method is implemented in \code{scipy.optimize.leastsq}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{scipy} \PYG{k+kn}{import} \PYG{n}{optimize}

\PYG{c}{\PYGZsh{} initial estimate is in p}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{initial parameters:}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}\PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,}\PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{,}\PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}

\PYG{c}{\PYGZsh{} set some bounds for the parameters}
\PYG{n}{bound} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{(}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{l+m+mf}{10.}\PYG{p}{)}\PYG{p}{,}\PYG{p}{(}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{l+m+mf}{10.}\PYG{p}{)}\PYG{p}{,}\PYG{p}{(}\PYG{l+m+mf}{0.01}\PYG{p}{,}\PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{,}\PYG{p}{(}\PYG{l+m+mf}{50.}\PYG{p}{,}\PYG{l+m+mf}{300.}\PYG{p}{)}\PYG{p}{,}\PYG{p}{(}\PYG{l+m+mf}{0.01}\PYG{p}{,}\PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{,}\PYG{p}{(}\PYG{l+m+mf}{50.}\PYG{p}{,}\PYG{l+m+mf}{300.}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}


\PYG{c}{\PYGZsh{} test pixel}
\PYG{n}{r} \PYG{o}{=} \PYG{l+m+mi}{472}
\PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{84}


\PYG{n}{y} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{]}
\PYG{n}{mask} \PYG{o}{=} \PYG{o}{\PYGZti{}}\PYG{n}{y}\PYG{o}{.}\PYG{n}{mask}
\PYG{n}{y} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{y}\PYG{p}{[}\PYG{n}{mask}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{x} \PYG{o}{=} \PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{46}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{8}\PYG{o}{+}\PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{[}\PYG{n}{mask}\PYG{p}{]}
\PYG{n}{unc} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{sd}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{]}\PYG{p}{[}\PYG{n}{mask}\PYG{p}{]}\PYG{p}{)}

\PYG{c}{\PYGZsh{} define function to give Z\PYGZca{}2}

\PYG{k}{def} \PYG{n+nf}{sse}\PYG{p}{(}\PYG{n}{p}\PYG{p}{,}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{unc}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}Sum of squared error\PYGZsq{}\PYGZsq{}\PYGZsq{}}
    \PYG{c}{\PYGZsh{} penalise p[3] \PYGZgt{} p[5]}
    \PYG{n}{err} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{p}{(}\PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mf}{1e4}
    \PYG{k}{return} \PYG{p}{(}\PYG{n}{mismatch\PYGZus{}function}\PYG{p}{(}\PYG{n}{p}\PYG{p}{,}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{unc}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{p}{)}\PYG{o}{+}\PYG{n}{err}

\PYG{c}{\PYGZsh{} we pass the function:}
\PYG{c}{\PYGZsh{}}
\PYG{c}{\PYGZsh{} sse               : the name of the function we wrote to give}
\PYG{c}{\PYGZsh{}                     sum of squares of Z\PYGZus{}i}
\PYG{c}{\PYGZsh{} p                 : an initial estimate of the parameters}
\PYG{c}{\PYGZsh{} args=(x,y,unc)    : the other information (other than p) that}
\PYG{c}{\PYGZsh{}                     mismatch\PYGZus{}function needs}
\PYG{c}{\PYGZsh{} approx\PYGZus{}grad       : if we dont have a function for the gradien}
\PYG{c}{\PYGZsh{}                     we have to get the solver to approximate it}
\PYG{c}{\PYGZsh{}                     which takes time ... see if you can work out}
\PYG{c}{\PYGZsh{}                     d\PYGZus{}sse / dp and use that to speed this up!}

\PYG{n}{psolve} \PYG{o}{=} \PYG{n}{optimize}\PYG{o}{.}\PYG{n}{fmin\PYGZus{}l\PYGZus{}bfgs\PYGZus{}b}\PYG{p}{(}\PYG{n}{sse}\PYG{p}{,}\PYG{n}{p}\PYG{p}{,}\PYG{n}{approx\PYGZus{}grad}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{,}\PYG{n}{iprint}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYGZbs{}
                                \PYG{n}{args}\PYG{o}{=}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{unc}\PYG{p}{)}\PYG{p}{,}\PYG{n}{bounds}\PYG{o}{=}\PYG{n}{bound}\PYG{p}{)}

\PYG{k}{print} \PYG{n}{psolve}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{pp} \PYG{o}{=} \PYG{n}{psolve}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{*}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{errorbar}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{unc}\PYG{o}{*}\PYG{l+m+mf}{1.96}\PYG{p}{)}
\PYG{n}{y\PYGZus{}hat} \PYG{o}{=} \PYG{n}{dbl\PYGZus{}logistic\PYGZus{}model}\PYG{p}{(}\PYG{n}{pp}\PYG{p}{,}\PYG{n}{x\PYGZus{}full}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x\PYGZus{}full}\PYG{p}{,}\PYG{n}{y\PYGZus{}hat}\PYG{p}{)}

\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{solved parameters: }\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{pp}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{pp}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{n}{pp}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}\PYG{n}{pp}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,}\PYG{n}{pp}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{,}\PYG{n}{pp}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}

\PYG{c}{\PYGZsh{} if we define the phenology as the parameter p[3]}
\PYG{c}{\PYGZsh{} and the \PYGZsq{}length\PYGZsq{} of the growing season:}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{phenology}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{pp}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,}\PYG{n}{pp}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{n}{pp}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
initial parameters: 1.04703335612 1.62445180627 0.19 140.0 0.13 220.0
23.2882812239
solved parameters:  0.614031423522 2.92120123969 0.0357337165804 159.497584338 0.0381324783625 227.002721261
phenology 159.497584338 67.5051369225
\end{Verbatim}

\includegraphics{Interpolation_96_1.png}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} and run over each pixel ... this will take some time}

\PYG{c}{\PYGZsh{} pixels that have some data}
\PYG{n}{mask} \PYG{o}{=} \PYG{p}{(}\PYG{o}{\PYGZti{}}\PYG{n}{data}\PYG{o}{.}\PYG{n}{mask}\PYG{p}{)}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}

\PYG{n}{pdata} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{p}{)} \PYG{o}{+} \PYG{n}{mask}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{)}

\PYG{n}{rows}\PYG{p}{,}\PYG{n}{cols} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{where}\PYG{p}{(}\PYG{n}{mask}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{len\PYGZus{}x} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{rows}\PYG{p}{)}

\PYG{c}{\PYGZsh{} lets just do some random ones to start with}
\PYG{c}{\PYGZsh{}rows = rows[::10]}
\PYG{c}{\PYGZsh{}cols = cols[::10]}

\PYG{n}{len\PYGZus{}x} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{rows}\PYG{p}{)}


\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{n}{len\PYGZus{}x}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{r}\PYG{p}{,}\PYG{n}{c} \PYG{o}{=} \PYG{n}{rows}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,}\PYG{n}{cols}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
    \PYG{c}{\PYGZsh{} progress bar}
    \PYG{k}{if} \PYG{n}{i}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{len\PYGZus{}x}\PYG{o}{/}\PYG{l+m+mi}{40}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:}
        \PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{... }\PYG{l+s+si}{\PYGZpc{}4.2f}\PYG{l+s}{ percent}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{i}\PYG{o}{*}\PYG{l+m+mf}{100.}\PYG{o}{/}\PYG{n+nb}{float}\PYG{p}{(}\PYG{n}{len\PYGZus{}x}\PYG{p}{)}\PYG{p}{)}

    \PYG{n}{y} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{]}
    \PYG{n}{mask} \PYG{o}{=} \PYG{o}{\PYGZti{}}\PYG{n}{y}\PYG{o}{.}\PYG{n}{mask}
    \PYG{n}{y} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{y}\PYG{p}{[}\PYG{n}{mask}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{x} \PYG{o}{=} \PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{46}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{8}\PYG{o}{+}\PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{[}\PYG{n}{mask}\PYG{p}{]}
    \PYG{n}{unc} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{sd}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{]}\PYG{p}{[}\PYG{n}{mask}\PYG{p}{]}\PYG{p}{)}

    \PYG{c}{\PYGZsh{} need to get an initial estimate of the parameters}

    \PYG{c}{\PYGZsh{} some stats on y}
    \PYG{n}{ysd} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{std}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}
    \PYG{n}{ymean} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}

    \PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n}{ymean} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{1.151}\PYG{o}{*}\PYG{n}{ysd}\PYG{p}{;}   \PYG{c}{\PYGZsh{} minimum  (1.151 is 75\PYGZpc{} CI)}
    \PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{l+m+mf}{1.151}\PYG{o}{*}\PYG{n}{ysd}          \PYG{c}{\PYGZsh{} range}
    \PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{0.19}                 \PYG{c}{\PYGZsh{} related to up slope}
    \PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{140}                  \PYG{c}{\PYGZsh{} midpoint of up slope}
    \PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{0.13}                 \PYG{c}{\PYGZsh{} related to down slope}
    \PYG{n}{p}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{220}                  \PYG{c}{\PYGZsh{} midpoint of down slope}


    \PYG{c}{\PYGZsh{} set factr to quite large number (relative error in solution)}
    \PYG{c}{\PYGZsh{} as it\PYGZsq{}ll take too long otherwise}
    \PYG{n}{psolve} \PYG{o}{=} \PYG{n}{optimize}\PYG{o}{.}\PYG{n}{fmin\PYGZus{}l\PYGZus{}bfgs\PYGZus{}b}\PYG{p}{(}\PYG{n}{sse}\PYG{p}{,}\PYG{n}{p}\PYG{p}{,}\PYG{n}{approx\PYGZus{}grad}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{,}\PYG{n}{iprint}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYGZbs{}
                                \PYG{n}{args}\PYG{o}{=}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{unc}\PYG{p}{)}\PYG{p}{,}\PYG{n}{bounds}\PYG{o}{=}\PYG{n}{bound}\PYG{p}{,}\PYG{n}{factr}\PYG{o}{=}\PYG{l+m+mf}{1e12}\PYG{p}{)}

    \PYG{n}{pdata}\PYG{p}{[}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{rows}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,}\PYG{n}{cols}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{]} \PYG{o}{=} \PYG{n}{psolve}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
    \PYG{n}{pdata}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{rows}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,}\PYG{n}{cols}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{]} \PYG{o}{=} \PYG{n}{psolve}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{c}{\PYGZsh{} sse}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{0.00} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{2.50} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{5.00} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{7.50} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{10.00} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{12.50} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{15.00} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{17.50} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{19.99} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{22.49} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{24.99} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{27.49} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{29.99} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{32.49} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{34.99} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{37.49} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{39.99} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{42.49} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{44.99} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{47.49} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{49.99} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{52.49} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{54.99} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{57.49} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{59.98} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{62.48} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{64.98} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{67.48} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{69.98} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{72.48} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{74.98} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{77.48} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{79.98} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{82.48} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{84.98} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{87.48} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{89.98} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{92.48} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{94.98} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{97.47} \PYG{n}{percent}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{l+m+mf}{99.97} \PYG{n}{percent}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{pdata}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mi}{137}\PYG{p}{,}\PYG{n}{vmax}\PYG{o}{=}\PYG{l+m+mi}{141}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{green up doy}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{pdata}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{n}{pdata}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mi}{74}\PYG{p}{,}\PYG{n}{vmax}\PYG{o}{=}\PYG{l+m+mi}{84}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{season length}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{pdata}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{n}{vmax}\PYG{o}{=}\PYG{l+m+mf}{6.}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{min LAI}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{pdata}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{+}\PYG{n}{pdata}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{n}{vmax}\PYG{o}{=}\PYG{l+m+mf}{6.}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{max LAI}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{pdata}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{none}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{vmax}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{500}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{RSSE}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.colorbar.Colorbar instance at 0x2b75e5deefc8\PYGZgt{}
\end{Verbatim}

\includegraphics{Interpolation_98_1.png}

\includegraphics{Interpolation_98_2.png}

\includegraphics{Interpolation_98_3.png}

\includegraphics{Interpolation_98_4.png}

\includegraphics{Interpolation_98_5.png}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} check a few pixels}

\PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{200}

\PYG{k}{for} \PYG{n}{r} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{l+m+mi}{200}\PYG{p}{,}\PYG{l+m+mi}{400}\PYG{p}{,}\PYG{l+m+mi}{25}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{y} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{]}
    \PYG{n}{mask} \PYG{o}{=} \PYG{o}{\PYGZti{}}\PYG{n}{y}\PYG{o}{.}\PYG{n}{mask}
    \PYG{n}{y} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{y}\PYG{p}{[}\PYG{n}{mask}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{x} \PYG{o}{=} \PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{46}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{8}\PYG{o}{+}\PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{[}\PYG{n}{mask}\PYG{p}{]}
    \PYG{n}{unc} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{sd}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{]}\PYG{p}{[}\PYG{n}{mask}\PYG{p}{]}\PYG{p}{)}

    \PYG{n}{x\PYGZus{}full} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{366}\PYG{p}{)}

    \PYG{c}{\PYGZsh{} some default values for the parameters}
    \PYG{n}{pp} \PYG{o}{=} \PYG{n}{pdata}\PYG{p}{[}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{]}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{ c }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{*}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{errorbar}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{unc}\PYG{o}{*}\PYG{l+m+mf}{1.96}\PYG{p}{)}
    \PYG{n}{y\PYGZus{}hat} \PYG{o}{=} \PYG{n}{dbl\PYGZus{}logistic\PYGZus{}model}\PYG{p}{(}\PYG{n}{pp}\PYG{p}{,}\PYG{n}{x\PYGZus{}full}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x\PYGZus{}full}\PYG{p}{,}\PYG{n}{y\PYGZus{}hat}\PYG{p}{)}

    \PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{solved parameters: }\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{pp}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{pp}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{n}{pp}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}\PYG{n}{pp}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,}\PYG{n}{pp}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{,}\PYG{n}{pp}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}

    \PYG{c}{\PYGZsh{} if we define the phenology as the parameter p[3]}
    \PYG{c}{\PYGZsh{} and the \PYGZsq{}length\PYGZsq{} of the growing season:}
    \PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{phenology}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{pp}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,}\PYG{n}{pp}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{n}{pp}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
solved parameters:  0.837899998448 2.82427082241 0.0164922480786 139.933827392 0.015218312802 219.620042827
phenology 139.933827392 79.6862154345
solved parameters:  1.25111026954 2.3270241822 0.0190331997407 137.746147061 0.0650489530419 220.049105733
phenology 137.746147061 82.3029586718
solved parameters:  1.24735745202 2.64641924245 0.01 139.923207754 0.0103960017819 220.21982824
phenology 139.923207754 80.2966204854
solved parameters:  0.932759824658 2.57001493023 0.0499114191497 141.274250409 1.0 220.241108243
phenology 141.274250409 78.9668578339
solved parameters:  3.3118926764 10.0 0.0227526645775 141.59060759 0.0129963184052 218.391152509
phenology 141.59060759 76.8005449187
solved parameters:  1.00690819411 2.5680266473 0.0244446244614 139.049623755 0.0196297496409 220.194411837
phenology 139.049623755 81.1447880828
solved parameters:  1.41787972842 0.735065812424 0.183737093991 139.730989265 0.0642603310649 219.975475755
phenology 139.730989265 80.2444864894
solved parameters:  1.03836639365 1.58477670269 0.0296244335923 139.895942883 0.0436631925744 220.03650496
phenology 139.895942883 80.1405620773
\end{Verbatim}

\includegraphics{Interpolation_99_1.png}

\includegraphics{Interpolation_99_2.png}

\includegraphics{Interpolation_99_3.png}

\includegraphics{Interpolation_99_4.png}

\includegraphics{Interpolation_99_5.png}

\includegraphics{Interpolation_99_6.png}

\includegraphics{Interpolation_99_7.png}

\includegraphics{Interpolation_99_8.png}


\chapter{ENVI}
\label{Chapter6_ENVI/envi:envi}\label{Chapter6_ENVI/envi::doc}
The purpose of this week's practical (Reading Week) is for you to become
familiar with using the software package ENVI.

You should do one oby following the
\href{http://www2.geog.ucl.ac.uk/~plewis/geog2021/classificationPractical/}{Classification}
practical.

There is no direct supervision for this session.

You are expected to get on with this yourselves.


\chapter{6a. Assessed Practical}
\label{Chapter6a_Practical/Practical::doc}\label{Chapter6a_Practical/Practical:a-assessed-practical}

\section{6.1 Introduction}
\label{Chapter6a_Practical/Practical:introduction}

\subsection{6.1.1 Site, Data and Task overview}
\label{Chapter6a_Practical/Practical:site-data-and-task-overview}
These notes describe the practical you must submit for assessment in
this course.

The practical comes in two parts: (1) data preparation; (2) modelling.

It is important that you complete both parts of this exercise, as you
will need to make use of the code and results in the work you submit for
assessment for this course.
\begin{itemize}
\item {} 
\textbf{Data Preparation}

The first task you must complete is to produce a dataset of the
proportion of HUC catchment 13010001 (Rio Grande headwaters in
Colorado, USA) that is covered by snow for \textbf{two consecutive years},
along with associated datasets on temperature (in C) and river
discharge at the Del Norte monitoring station. You \textbf{may not} use
data from the year 2005, as this is given to you in the illustrations
above.

The dataset you produce must have a value for the mean snow cover,
temperature and discharge in the catchment for every day over each
year.

Your write up \textbf{must} include fully labelled graph(s) of snow cover,
temperature and discharge for the catchment for each year (with units
as appropriate), along with some summary statistics (e.g. mean or
median, minimum, maximum, and the timing of these).

You \textbf{must} provide evidence of how you got these data (i.e. the
code and commands you ran to produce the data).

\item {} 
\textbf{Modelling}

You will have prepared two years of data above. Use one of these
years to calibrate the (snowmelt) hydrological model (described
below) and one year to test it.

The model parameter estimate \emph{must} be objective (i.e. you can't just
arbitrarily choose a set) and ideally optimal, and you \emph{must} state
the equation of the cost function you will try to minimise and
explain the approach used.

You \textbf{must} state the values of the model parameters that you have
estimated and show evidence for how you went about calculating them.
Ideally, you should also state the uncertainty in these parameter
estimates (not critical to pass this section though).

You \textbf{must} quantify the goodness of fit between your measured flow
data and that produced by your model, booth for the calibration
exercise and the validation.

\end{itemize}

You \textbf{must} work individually on this task. If you do not, it will be
treated as plagiarism. By reading these instructions for this exercise,
we assume that you are aware of the UCL rules on plagiarism. You can
find more information on this matter in your student handbook. If in
doubt about what might constitute plagiarism, ask one of the course
convenors.

What you are going to do is to build, calibrate and test a (snowmelt)
hydrological model, driven by observations in the Rio Grande Headwaters
in Colorado, USA.

\textbf{You will need to process two years of data (N.B. *not* 2005 as that is
given in the illustrations).}

The purpose of the model is to describe the streamflow at the Del Norte
measurement station, just on the edge of the catchment.

The average climate for Del Norte is:
\begin{figure}[htbp]
\centering

\includegraphics{Chapter6a_Practical/files/images/usco0103climatedelnorte.png}
\end{figure}

Further general information is available from various
\href{http://www.usclimatedata.com/climate.php?location=USCO0103}{websites},
including
\href{http://www4.ncdc.noaa.gov/cgi-win/wwcgi.dll?wwDI~StnSrch~StnID~10100138}{NOAA}.

You can visualise the site
\href{http://mesonet.agron.iastate.edu/sites/site.php?station=CO2184\&network=COCLIMATE}{here}.

First then, we should look at the streamflow data. These data are in the
file delnorte.dat for the years 2000 to
2010 inclusive. You can get further data from \href{http://waterdata.usgs.gov}{http://waterdata.usgs.gov}
if you wish.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} load a pre\PYGZhy{}cooked version of the data for 2005 (NB \PYGZhy{}\PYGZhy{} Dont use this year!!!}
\PYG{c}{\PYGZsh{} except perhaps for testing)}

\PYG{c}{\PYGZsh{} load the data from a pickle file}
\PYG{k+kn}{import} \PYG{n+nn}{pickle}
\PYG{n}{pkl\PYGZus{}file} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/data.pkl}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{rb}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{data} \PYG{o}{=} \PYG{n}{pickle}\PYG{o}{.}\PYG{n}{load}\PYG{p}{(}\PYG{n}{pkl\PYGZus{}file}\PYG{p}{)}
\PYG{n}{pkl\PYGZus{}file}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}

\PYG{c}{\PYGZsh{} set up plot}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlim}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{doy}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{doy}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{day of year 2005}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{c}{\PYGZsh{} plot data}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{doy}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{temp}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{label}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{temperature / C}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{doy}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{snowprop}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{*}\PYG{l+m+mi}{100}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{b}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{label}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{snow cover }\PYG{l+s}{\PYGZpc{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{doy}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{l+m+mi}{100}\PYG{o}{\PYGZhy{}}\PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{snowprop}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{*}\PYG{l+m+mi}{100}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{c}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{label}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{snow free cover }\PYG{l+s}{\PYGZpc{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{doy}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{flow}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{/}\PYG{l+m+mf}{100.}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{g}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{label}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{river flow / 100}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}


\PYG{n}{plt}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{n}{loc}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{best}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.legend.Legend at 0x1a2cae10\PYGZgt{}
\end{Verbatim}

\includegraphics{Practical_5_1.png}

we have plotted the streamflow (scaled) in green, the snow cover in
blue, and the non snow cover in cyan and the temperature in red. It
should be apparent that thge hydrology is snow melt dominated, and to
describe this (i.e. to build the simplest possible model) we can
probably just apply some time lag function to the snow cover.


\subsection{6.1.2 The Model}
\label{Chapter6a_Practical/Practical:the-model}
We will build a mass balance model, in terms of `snow water equivalent':

The basis of a model is going to be something of the form:
\begin{gather}
\begin{split}SWE = k * snowProportion\end{split}\notag
\end{gather}
where \(SWE\) is the `snow water equivalent', the amount of snow in
the entire snow pack in the catchment. \(snowProportion\) here then,
is the proportion of snow cover in the catchment. We lump together
density and volume terms into the coefficient \(k\).

\(SWE\) then is the `mass' (of water) that is available for melting
on a particular day. We can obtain \(snowProportion\) from satellite
data, so we only need the area / density term \(k\), which we can
suppose to be constant over time.

The simplest model of snowmelt is one where we assume that a proportion
of this \(SWE\) is released (melted) as a function of temperature.
In its simplest form, this is simply a temperature threshold:

\code{meltDays = np.where(temperature \textgreater{} tempThresh){[}0{]}}

On these melt days then, we add \code{k * snowProportion} of water into the
system. For the present, we will ignore direct precipitation. So:

\code{for d in meltDays:     water = K * snowProportion{[}d{]}}

Now we have a mechanism to release snow melt into the catchment, but
there will always be some delay in the water reaching the monitoring
station from far away regions, compared to nearby areas. The function
that describes this delay can be called a network response function. It
is often modelled as a Laplace function (an exponential). The idea is
that if we have a `flash' input to the catchment, this \href{http://www.google.co.uk/search?q=network+response+function\&ie=utf-8\&oe=utf-8\&aq=t\&rls=org.mozilla:en-US:official\&client=firefox-a\#sclient=psy-ab\&hl=en\&client=firefox-a\&hs=qgI\&rls=org.mozilla:en-US\%3Aofficial\&source=hp\&q=network+response+function+hydrology\&pbx=1\&oq=network+response+function+hydrology\&aq=f\&aqi=\&aql=\&gs\_sm=e\&gs\_upl=2213l4483l0l4547l10l9l0l0l0l0l226l961l6.2.1l9l0\&bav=on.2,or.r\_gc.r\_pw.r\_cp.,cf.osb\&fp=d48ede2c1f2a6462\&biw=1098\&bih=673}{network response
function}
will give us what we would measure as a hydrograph at the monitoring
station (or elsewhere).

We can parameterise this with a decay factor, p, so that if the amount
of water on day d is 1, the amount on day d+1 is p, on d+2, p\textasciicircum{}2 etc:

\code{n = np.arange(len(snowProportion)) - d m = p ** n m{[}np.where(n\textless{}0){]}=0}

so here, \code{m} is the decay function:
\begin{figure}[htbp]
\centering

\includegraphics{Chapter6a_Practical/files/images/laplace.png}
\end{figure}

for day 150. This model will transfer a large amount of water of the
peak day, then less and less as time goes by. So, a simple model then is
of the form:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{model\PYGZus{}accum}\PYG{p}{(}\PYG{n}{data}\PYG{p}{,}\PYG{n}{tempThresh}\PYG{p}{,}\PYG{n}{k}\PYG{p}{,}\PYG{n}{p}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{meltDays} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{where}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{temp}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{\PYGZgt{}} \PYG{n}{tempThresh}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
    \PYG{n}{accum} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{snowprop}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{*}\PYG{l+m+mf}{0.}
    \PYG{k}{for} \PYG{n}{d} \PYG{o+ow}{in} \PYG{n}{meltDays}\PYG{p}{:}
        \PYG{n}{water} \PYG{o}{=} \PYG{n}{k} \PYG{o}{*} \PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{snowprop}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{n}{d}\PYG{p}{]}
        \PYG{n}{n} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{snowprop}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{d}
        \PYG{n}{m} \PYG{o}{=} \PYG{n}{p} \PYG{o}{*}\PYG{o}{*} \PYG{n}{n}
        \PYG{n}{m}\PYG{p}{[}\PYG{n}{np}\PYG{o}{.}\PYG{n}{where}\PYG{p}{(}\PYG{n}{n}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{]}\PYG{o}{=}\PYG{l+m+mi}{0}
        \PYG{n}{accum} \PYG{o}{+}\PYG{o}{=} \PYG{n}{m} \PYG{o}{*} \PYG{n}{water}
    \PYG{k}{return} \PYG{n}{accum}


\PYG{n}{tempThresh} \PYG{o}{=} \PYG{l+m+mf}{8.5}
\PYG{n}{k} \PYG{o}{=} \PYG{l+m+mf}{2000.0}
\PYG{n}{p} \PYG{o}{=} \PYG{l+m+mf}{0.95}

\PYG{c}{\PYGZsh{} test it}
\PYG{n}{accum} \PYG{o}{=} \PYG{n}{model\PYGZus{}accum}\PYG{p}{(}\PYG{n}{data}\PYG{p}{,}\PYG{n}{tempThresh}\PYG{p}{,}\PYG{n}{k}\PYG{p}{,}\PYG{n}{p}\PYG{p}{)}
\end{Verbatim}

This is a very simple model. It has three parameters (\code{tempThresh},
\code{k}, \code{p}) and is driven only by temperature and snow cover data. And
yet, we see that even with a rough guess at what the parameters ought to
be, we can get a reasonable match with the observed flow data:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{doy}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{flow}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{k}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{label}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{measured}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{doy}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{accum}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{k\PYGZhy{}\PYGZhy{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{label}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{modelled}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{river flow / units??}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{day of year 2005}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{n}{loc}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{best}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.legend.Legend at 0x1c0b4ed0\PYGZgt{}
\end{Verbatim}

\includegraphics{Practical_11_1.png}


\section{6.2 Data Preparation}
\label{Chapter6a_Practical/Practical:data-preparation}

\subsection{6.2.1 Statement of the task}
\label{Chapter6a_Practical/Practical:statement-of-the-task}
The first task you must complete is to produce a dataset of the
proportion of HUC catchment 13010001 (Rio Grande headwaters) that is
covered by snow for \textbf{two years}, along with associated datasets on
temperature and river discharge at the Del Norte monitoring station.

The dataset you produce must have a value for the mean snow cover,
temperature and discharge in the catchment for every day over each year.

Your write up \textbf{must} include a fully labelled graph of snow cover,
temperature and discharge for the catchment for each year, along with
some summary statistics (e.g. mean or median, minimum, maximum, and the
timing of these).
\begin{figure}[htbp]
\centering

\includegraphics{Chapter6a_Practical/files/images/snow.png}
\end{figure}

You should aim to complete this task soon after Reading Week.


\subsection{6.2.2 Some Advice}
\label{Chapter6a_Practical/Practical:some-advice}
You would probably want to use a \textbf{daily} snow product for this task,
such as that available from MODIS, so make sure you know what that is
and explore the characteristics of the dataset.

You will notice from the figure above (the figure should give you some
clue as to a suitable data product) that there will be areas of each
image for which you have no information (described in the dataset QC).
You will need to decide what to do about `missing data'. For instance,
you might consider interpolating over missing values.

The simplest thing might be to produce a mean snow cover over what
samples are available (ignoring the missing values). But whilst that may
be sufficient to pass this section, it is far from ideal.

Whilst you only need to produce an average daily value for the
catchment, a better approach would be to try to estimate snow cover for
each pixel in the catchment (e.g. so you could do spatially explicit
modelling with such data). I stress that this is not strictly necessary,
but would be an interesting thing to do if you feel able.

However you decide to process the data, you must give a rationale for
why you have taken the approach you have done.

You will notice that if you use MODIS data, you have access to both data
from Terra (MOD10A) and Aqua (MYD10A), which potentially gives you two
samples per day. Think about how to take that into account. Again, the
simplest thing to do might be to just use one of these. That is likely
to be sufficient, but it would be much better to include both datasets.

You should be able to hunt around to find the temperature and discharge
data you want, but we take you through finding them in the advice below.


\subsection{6.2.3 Data Advice}
\label{Chapter6a_Practical/Practical:data-advice}

\subsubsection{6.2.3.1 MODIS snow cover data}
\label{Chapter6a_Practical/Practical:modis-snow-cover-data}
For MODIS data, you will need to work out which data product you want
and how to download it. To help you with this, we have included urls of
the MODIS Terra snow data product \code{MOD10A1} and Aqua product
\code{MYD10A1} in the files \code{files/data/robot\_snow.????.txt}:

\begin{Verbatim}[commandchars=\\\{\}]
!ls \PYGZhy{}l files/data/robot\PYGZus{}snow.????.txt
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis  9034752 Nov  6 09:12 files/data/robot\PYGZus{}snow.2000.txt
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis 10820568 Nov  6 09:12 files/data/robot\PYGZus{}snow.2001.txt
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis 16321938 Nov  6 09:12 files/data/robot\PYGZus{}snow.2002.txt
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis 22423068 Nov  6 09:12 files/data/robot\PYGZus{}snow.2003.txt
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis  7633374 Nov  6 09:12 files/data/robot\PYGZus{}snow.2004.txt
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis 18872448 Nov  6 09:12 files/data/robot\PYGZus{}snow.2005.txt
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis 11433078 Nov  6 09:12 files/data/robot\PYGZus{}snow.2006.txt
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis 22663686 Nov  6 09:12 files/data/robot\PYGZus{}snow.2007.txt
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis 22668990 Nov  6 09:12 files/data/robot\PYGZus{}snow.2008.txt
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis 22705317 Nov  6 09:12 files/data/robot\PYGZus{}snow.2009.txt
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis 22712370 Nov  6 09:13 files/data/robot\PYGZus{}snow.2010.txt
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis 17129166 Nov  6 09:13 files/data/robot\PYGZus{}snow.2011.txt
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis 22756824 Nov  6 09:13 files/data/robot\PYGZus{}snow.2012.txt
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis 18104898 Nov  6 09:13 files/data/robot\PYGZus{}snow.2013.txt
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
!head \PYGZhy{}10 \PYGZlt{} files/data/robot\PYGZus{}snow.2007.txt
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
ftp://n4ftl01u.ecs.nasa.gov/MOSA/MYD10A1.005/2007.01.01/MYD10A1.A2007001.h00v08.005.2008309053908.hdf
ftp://n4ftl01u.ecs.nasa.gov/MOSA/MYD10A1.005/2007.01.01/MYD10A1.A2007001.h00v09.005.2008309053510.hdf
ftp://n4ftl01u.ecs.nasa.gov/MOSA/MYD10A1.005/2007.01.01/MYD10A1.A2007001.h00v10.005.2008309053824.hdf
ftp://n4ftl01u.ecs.nasa.gov/MOSA/MYD10A1.005/2007.01.01/MYD10A1.A2007001.h01v08.005.2008309053759.hdf
ftp://n4ftl01u.ecs.nasa.gov/MOSA/MYD10A1.005/2007.01.01/MYD10A1.A2007001.h01v09.005.2008309053913.hdf
ftp://n4ftl01u.ecs.nasa.gov/MOSA/MYD10A1.005/2007.01.01/MYD10A1.A2007001.h01v10.005.2008309053817.hdf
ftp://n4ftl01u.ecs.nasa.gov/MOSA/MYD10A1.005/2007.01.01/MYD10A1.A2007001.h01v11.005.2008309053918.hdf
ftp://n4ftl01u.ecs.nasa.gov/MOSA/MYD10A1.005/2007.01.01/MYD10A1.A2007001.h02v06.005.2008309053503.hdf
ftp://n4ftl01u.ecs.nasa.gov/MOSA/MYD10A1.005/2007.01.01/MYD10A1.A2007001.h02v08.005.2008309053822.hdf
ftp://n4ftl01u.ecs.nasa.gov/MOSA/MYD10A1.005/2007.01.01/MYD10A1.A2007001.h02v09.005.2008309054221.hdf
\end{Verbatim}

We can use the usual tools to explore the MODIS hdf files:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{gdal}
\PYG{n}{target\PYGZus{}vector\PYGZus{}file} \PYG{o}{=} \PYG{n+nb}{file}
\PYG{n}{modis\PYGZus{}file} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/MYD10A1.A2003026.h09v05.005.2008047035848.hdf}\PYG{l+s}{\PYGZsq{}}
\PYG{n}{g} \PYG{o}{=} \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{Open}\PYG{p}{(}\PYG{n}{modis\PYGZus{}file}\PYG{p}{)}
\PYG{n}{data\PYGZus{}layer} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MOD\PYGZus{}Grid\PYGZus{}Snow\PYGZus{}500m:Fractional\PYGZus{}Snow\PYGZus{}Cover}\PYG{l+s}{\PYGZsq{}}

\PYG{n}{subdatasets} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{GetSubDatasets}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{fname}\PYG{p}{,} \PYG{n}{name} \PYG{o+ow}{in} \PYG{n}{subdatasets}\PYG{p}{:}
    \PYG{k}{print} \PYG{n}{name}
    \PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{fname}

\PYG{n}{fname} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{:}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{modis\PYGZus{}file}\PYG{p}{,}\PYG{n}{data\PYGZus{}layer}\PYG{p}{)}
\PYG{n}{raster} \PYG{o}{=} \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{Open}\PYG{p}{(}\PYG{n}{fname}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
[2400x2400] Snow\PYGZus{}Cover\PYGZus{}Daily\PYGZus{}Tile MOD\PYGZus{}Grid\PYGZus{}Snow\PYGZus{}500m (8\PYGZhy{}bit unsigned integer)
    HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:\PYGZdq{}files/data/MYD10A1.A2003026.h09v05.005.2008047035848.hdf\PYGZdq{}:MOD\PYGZus{}Grid\PYGZus{}Snow\PYGZus{}500m:Snow\PYGZus{}Cover\PYGZus{}Daily\PYGZus{}Tile
[2400x2400] Snow\PYGZus{}Spatial\PYGZus{}QA MOD\PYGZus{}Grid\PYGZus{}Snow\PYGZus{}500m (8\PYGZhy{}bit unsigned integer)
    HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:\PYGZdq{}files/data/MYD10A1.A2003026.h09v05.005.2008047035848.hdf\PYGZdq{}:MOD\PYGZus{}Grid\PYGZus{}Snow\PYGZus{}500m:Snow\PYGZus{}Spatial\PYGZus{}QA
[2400x2400] Snow\PYGZus{}Albedo\PYGZus{}Daily\PYGZus{}Tile MOD\PYGZus{}Grid\PYGZus{}Snow\PYGZus{}500m (8\PYGZhy{}bit unsigned integer)
    HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:\PYGZdq{}files/data/MYD10A1.A2003026.h09v05.005.2008047035848.hdf\PYGZdq{}:MOD\PYGZus{}Grid\PYGZus{}Snow\PYGZus{}500m:Snow\PYGZus{}Albedo\PYGZus{}Daily\PYGZus{}Tile
[2400x2400] Fractional\PYGZus{}Snow\PYGZus{}Cover MOD\PYGZus{}Grid\PYGZus{}Snow\PYGZus{}500m (8\PYGZhy{}bit unsigned integer)
    HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:\PYGZdq{}files/data/MYD10A1.A2003026.h09v05.005.2008047035848.hdf\PYGZdq{}:MOD\PYGZus{}Grid\PYGZus{}Snow\PYGZus{}500m:Fractional\PYGZus{}Snow\PYGZus{}Cover
\end{Verbatim}


\subsubsection{6.2.3.2 Boundary Data}
\label{Chapter6a_Practical/Practical:boundary-data}
Boundary data, such as catchments, might typically come as \href{http://en.wikipedia.org/wiki/Shapefile}{ESRI
shapefiles} or may be in
other vector formats. There tends to be variable quality among different
databases, but a reliable source for catchment data the USA is the
\href{http://water.usgs.gov/GIS/huc.html}{USGS}. One set of catchments in
the tile we have is the Rio Grande headwaters, which we can
\href{http://water.usgs.gov/GIS/huc\_rdb.html}{see} has a HUC 8-digit code
of 13010001. The full dataset is easily found from the
\href{http://water.usgs.gov/GIS/dsdl/huc250k\_shp.zip}{USGS} or
locally. Literature and associated data
concerning this area can be found
\href{http://water.usgs.gov/lookup/getwatershed?13010001}{here}.
Associated \href{http://water.usgs.gov/lookup/getgislist?type=huc\&value=13010001}{GIS data are
here},
including the \href{http://water.usgs.gov/GIS/dsdl/ds573\_wbdhuc8.ZIP}{watershed boundary
data}.

Data more specific to our particular catchment of interest can be found
on the \href{http://txpub.usgs.gov/USACE/resources.aspx}{Rio Grande Data Project
pages}.

You should download the file
\href{http://txpub.usgs.gov/USACE/data/water\_resources/Hydrologic\_Units.zip}{Hydrologic\_Units.zip}
or get this locally. Obviously,
you will need to \code{unzip} this file to get at the shapefile
\code{{}`Hydrologic\_Units/HUC\_Polygons.shp} \textless{}files/data/Hydrologic\_Units/HUC\_Polygons.shp\textgreater{}{}`\_\_
within it.

You can explore the shape file with the following:

\begin{Verbatim}[commandchars=\\\{\}]
!ogrinfo files/data/Hydrologic\PYGZus{}Units/HUC\PYGZus{}Polygons.shp HUC\PYGZus{}Polygons \textbar{} head \PYGZhy{}89 \textbar{} tail \PYGZhy{}16
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
OGRFeature(HUC\PYGZus{}Polygons):2
  HUC (Integer) = 13010001
  REG\PYGZus{}NAME (String) = Rio Grande Region
  SUB\PYGZus{}NAME (String) = Rio Grande Headwaters
  ACC\PYGZus{}NAME (String) = Rio Grande Headwaters
  CAT\PYGZus{}NAME (String) = Rio Grande Headwaters. Colorado.
  HUC2 (Integer) = 13
  HUC4 (Integer) = 1301
  HUC6 (Integer) = 130100
  REG (Integer) = 13
  SUB (Integer) = 1301
  ACC (Integer) = 130100
  CAT (Integer) = 13010001
  CAT\PYGZus{}NUM (String) = 13010001
  Shape\PYGZus{}Leng (Real) = 313605.66409400001
  Shape\PYGZus{}Area (Real) = 3458016895.23000001907
\end{Verbatim}

This tells us that we want \textbf{HUC feature 2} (catchment 13010001).

We can produce a mask with \code{raster\_mask}, but in this case, we need to
use a function \code{raster\_mask2}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{n}{sys}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/python}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{k+kn}{from} \PYG{n+nn}{raster\PYGZus{}mask} \PYG{k+kn}{import} \PYG{o}{*}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{m} \PYG{o}{=} \PYG{n}{raster\PYGZus{}mask2}\PYG{p}{(}\PYG{n}{fname}\PYG{p}{,}\PYGZbs{}
                \PYG{n}{target\PYGZus{}vector\PYGZus{}file}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{files/data/Hydrologic\PYGZus{}Units/HUC\PYGZus{}Polygons.shp}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYGZbs{}
                \PYG{n}{attribute\PYGZus{}filter}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{m}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.colorbar.Colorbar instance at 0x2b6b7fcd6cb0\PYGZgt{}
\end{Verbatim}

\includegraphics{Practical_32_1.png}

The catchment is only a very small portion of the dataset, so you should
make sure that you perform masking when you read the dataset in and only
extract the area of data that you want.


\subsubsection{6.2.3.3 Discharge Data}
\label{Chapter6a_Practical/Practical:discharge-data}
The river discharge data are in the file
\code{{}`files/data/delnorte.dat} \textless{}files/data/delnorte.dat\textgreater{}{}`\_\_.

If you examine the file:

\begin{Verbatim}[commandchars=\\\{\}]
!head \PYGZhy{}35 \PYGZlt{} files/data/delnorte.dat
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} WARNING \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
\PYGZsh{} The data you have obtained from this automated U.S. Geological Survey database
\PYGZsh{} have not received Director\PYGZsq{}s approval and as such are provisional and subject to
\PYGZsh{} revision.  The data are released on the condition that neither the USGS nor the
\PYGZsh{} United States Government may be held liable for any damages resulting from its use.
\PYGZsh{} Additional info: http://waterdata.usgs.gov/nwis/help/?provisional
\PYGZsh{}
\PYGZsh{} File\PYGZhy{}format description:  http://waterdata.usgs.gov/nwis/?tab\PYGZus{}delimited\PYGZus{}format\PYGZus{}info
\PYGZsh{} Automated\PYGZhy{}retrieval info: http://waterdata.usgs.gov/nwis/?automated\PYGZus{}retrieval\PYGZus{}info
\PYGZsh{}
\PYGZsh{} Contact:   gs\PYGZhy{}w\PYGZus{}support\PYGZus{}nwisweb@usgs.gov
\PYGZsh{} retrieved: 2011\PYGZhy{}09\PYGZhy{}30 09:35:31 EDT       (caww02)
\PYGZsh{}
\PYGZsh{} Data for the following 1 site(s) are contained in this file
\PYGZsh{}    USGS 08220000 RIO GRANDE NEAR DEL NORTE, CO
\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
\PYGZsh{}
\PYGZsh{} Data provided for site 08220000
\PYGZsh{}    DD parameter statistic   Description
\PYGZsh{}    01   00060     00003     Discharge, cubic feet per second (Mean)
\PYGZsh{}
\PYGZsh{} Data\PYGZhy{}value qualification codes included in this output:
\PYGZsh{}     A  Approved for publication \PYGZhy{}\PYGZhy{} Processing and review completed.
\PYGZsh{}     e  Value has been estimated.
\PYGZsh{} agency\PYGZus{}cd site\PYGZus{}no datetime        01\PYGZus{}00060\PYGZus{}00003  01\PYGZus{}00060\PYGZus{}00003\PYGZus{}cd
\PYGZsh{} 5s        15s     20d     14n     10s
USGS        08220000        2000\PYGZhy{}01\PYGZhy{}01      190     A:e
USGS        08220000        2000\PYGZhy{}01\PYGZhy{}02      170     A:e
USGS        08220000        2000\PYGZhy{}01\PYGZhy{}03      160     A:e
USGS        08220000        2000\PYGZhy{}01\PYGZhy{}04      160     A:e
USGS        08220000        2000\PYGZhy{}01\PYGZhy{}05      170     A:e
USGS        08220000        2000\PYGZhy{}01\PYGZhy{}06      180     A:e
USGS        08220000        2000\PYGZhy{}01\PYGZhy{}07      170     A:e
USGS        08220000        2000\PYGZhy{}01\PYGZhy{}08      190     A:e
USGS        08220000        2000\PYGZhy{}01\PYGZhy{}09      190     A:e
\end{Verbatim}

you will see comment lines that start with \code{\#}, followed by data
lines.

The easiest way to read these data would be to use:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nb}{file} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/delnorte.dat}\PYG{l+s}{\PYGZsq{}}
\PYG{n}{data} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{loadtxt}\PYG{p}{(}\PYG{n+nb}{file}\PYG{p}{,}\PYG{n}{usecols}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,}\PYG{n}{unpack}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{,}\PYG{n}{dtype}\PYG{o}{=}\PYG{n+nb}{str}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} so you have the dates in}
\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{2000\PYGZhy{}01\PYGZhy{}01}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{2000\PYGZhy{}01\PYGZhy{}02}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{2000\PYGZhy{}01\PYGZhy{}03}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{2010\PYGZhy{}12\PYGZhy{}29}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}
       \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{2010\PYGZhy{}12\PYGZhy{}30}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{2010\PYGZhy{}12\PYGZhy{}31}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}
      \PYG{n}{dtype}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\textbar{}S10}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} and the stream flow in data[1]}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{astype}\PYG{p}{(}\PYG{n+nb}{float}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
[\PYGZlt{}matplotlib.lines.Line2D at 0x2b6b7c573950\PYGZgt{}]
\end{Verbatim}

\includegraphics{Practical_40_1.png}

You will need to convert the date field (i.e. the data in \code{data{[}0{]}})
into the day of year.

This is readily accomplished using \code{datetime}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{datetime}
\PYG{c}{\PYGZsh{} transform the first one}
\PYG{n}{ds} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZhy{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}\PYG{o}{.}\PYG{n}{astype}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{ds}
\PYG{n}{year}\PYG{p}{,}\PYG{n}{doy} \PYG{o}{=} \PYG{n}{datetime}\PYG{o}{.}\PYG{n}{datetime}\PYG{p}{(}\PYG{n}{ds}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{ds}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{n}{ds}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{strftime}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZpc{}}\PYG{l+s}{Y }\PYG{l+s}{\PYGZpc{}}\PYG{l+s}{j}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{year}\PYG{p}{,}\PYG{n}{doy}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
[2000    1    1]
2000 001
\end{Verbatim}


\subsubsection{6.2.3.4 Temperature data}
\label{Chapter6a_Practical/Practical:temperature-data}
We can directly access temperature data from
\href{http://ccc.atmos.colostate.edu/cgi-bin/dlydb.pl?yrbeg=2000\&yrend=2020\&station=52184+DEL+NORTE\&proc=2+-+List+Format+\%28see+docs\%29}{here}.

The format of \code{{}`delNorteT.dat} \textless{}files/data/delNorteT.dat\textgreater{}{}`\_\_ is given
here.

The first three fields are date fields (\code{YEAR}, \code{MONTH} and
\code{DAY}), followed by \code{TMAX}, \code{TMIN}, \code{PRCP}, \code{SNOW}, \code{SNDP}.

You should read in the temperature data for the days and years that you
want.

For temperature, you might take a \textbf{mean of TMAX and TMIN}.

\textbf{Note that these are in Fahrenheit. You should convert them to
Celcius.}

Note also that there are missing data (values \code{9998} and \code{9999}).
You will need to filter these and interpolate the data in some way. A
median might be a good approach, but any interpolation will suffice.

With that processing then, you should have a dataset, Temperature that
will look something like (in cyan, for the year 2005):
\begin{figure}[htbp]
\centering

\includegraphics{Chapter6a_Practical/files/images/temperature.png}
\end{figure}


\section{6.3 Coursework}
\label{Chapter6a_Practical/Practical:coursework}
You need to submit you coursework in the usual manner by the usual
submission date.

You \textbf{must} work individually on this task. If you do not, it will be
treated as plagiarism. By reading these instructions for this exercise,
we assume that you are aware of the UCL rules on plagiarism. You can
find more information on this matter in your student handbook. If in
doubt about what might constitute plagiarism, ask one of the course
convenors.


\subsection{6.3.1 Summary of coursework requirements}
\label{Chapter6a_Practical/Practical:summary-of-coursework-requirements}\begin{itemize}
\item {} 
\textbf{Data Preparation}

The first task you must complete is to produce a dataset of the
proportion of HUC catchment 13010001 (Rio Grande headwaters in
Colorado, USA) that is covered by snow for \textbf{two consecutive years},
along with associated datasets on temperature (in C) and river
discharge at the Del Norte monitoring station.

You \textbf{may not} use data from the year 2005, as this is given to you
in the illustrations above.

The dataset you produce must have a value for the mean snow cover,
temperature and discharge in the catchment for every day over each
year.

Your write up \textbf{must} include fully labelled graph(s) of snow cover,
temperature and discharge for the catchment for each year (with units
as appropriate), along with some summary statistics (e.g. mean or
median, minimum, maximum, and the timing of these).

You \textbf{must} provide evidence of how you got these data (i.e. the
code and commands you ran to produce the data).

\item {} 
\textbf{Modelling}

You will have prepared two years of data above. Use one of these
years to calibrate the (snowmelt) hydrological model (described
below) and one year to test it.

The model parameter estimate \emph{must} be objective (i.e. you can't just
arbitrarily choose a set) and ideally optimal, and you \emph{must} state
the equation of the cost function you will try to minimise and
explain the approach used.

You \textbf{must} state the values of the model parameters that you have
estimated and show evidence for how you went about calculating them.
Ideally, you should also state the uncertainty in these parameter
estimates (not critical to pass this section though).

You \textbf{must} quantify the goodness of fit between your measured flow
data and that produced by your model, booth for the calibration
exercise and the validation.

\end{itemize}


\subsection{6.3.2 Summary of Advice}
\label{Chapter6a_Practical/Practical:summary-of-advice}
The first task involves pulling datasets from different sources. No
individual part of that should be too difficult, but you must put this
together from the material we have done so far. It is more a question of
organisation then.

Perhaps think first about where you want to end up with on this (the
`output'). This might for example be a dictionary with keys \code{temp},
\code{doy}, \code{snow} and \code{flow}, where each of these would be an array
with 365 values (or 366 in a leap year).

Then consider the datasets you have: these are: (i) a stack of MODIS
data with daily observations; (ii) temperature data in a file; (iii)
flow data in a file.

It might be a little fiddly getting the data you want from the flow and
temperature data files, but its not very complicated. You will need to
consider flagging invalid observations and perhaps interpolating between
these.

Processing the MODIS data might take a little more thought, but it is
much the same process. Again, we read the datasets in, trying to make
this efficient on data size by only using the area of the vector data
mask as in a previous exercise. The data reading will be very similar to
reading the MODIS LAI product, but you need to work out and implement
what changes are necessary. As advised abovem you should use the
\code{raster\_mask2()} function for creating the spatial data masks. Again,
you will need to interpolate or perhaps smooth between observations, and
then process the snow cover proportions to get an average over the
catchment.

The second task revolves around using the model that we have developed
above in the function \code{model\_accum()}. You have been through previous
examples in Python where you attempt to estimate some model parameters
given an initial estimate of the parameters and some cost function to be
minimised. Solving the model calibration part of problem should follow
those same lines then. Testing (validation) should be easy enough. Don't
forget to include the estimated parameters (and other relevant
information, e.g. your initial estimate, uncertainties if available) in
your write up.

There is quite a lot of data presentation here, and you need to provide
\emph{evidence} that you have done the task. Make sure you use images (e.g.
of snow cover varying), graphs (e.g. modelled and predicted flow, etc.),
and tables (e.g. model parameter estimates) throughout, as appropriate.

If, for some reason, you are unable to complete the first part of the
practical, you should submit what you can for that first part, and
continue with calibrating the model using the 2005 dataset that we used
above. This would be far from ideal as you would not have completed the
required elements for either part in that case, but it would generall be
better than not submitting anything.


\subsection{6.3.3 Further advice}
\label{Chapter6a_Practical/Practical:further-advice}
There is plenty of scope here for going beyond the basic requirements,
if you get time and are interested (and/or want a higher mark!).

You will be given credit for all additional work included in the write
up, \textbf{once you have achieved the basic requirements}. So, there is no
point (i.e. you will not get credit for) going off on all sorts of
interesting lines of exploration here \emph{unless} you have first completed
the core task.


\subsection{6.3.4 Structure of the Report}
\label{Chapter6a_Practical/Practical:structure-of-the-report}
The required elements of the report are:

\begin{Verbatim}[commandchars=\\\{\}]
Introduction (5\PYGZpc{})
Data Preparation (45\PYGZpc{})
Modelling (45\PYGZpc{})
Discussion/Conclusions (5\PYGZpc{})
\end{Verbatim}

The figures in brackets indicate the percentage of marks that we will
award for each section of the report.


\subsubsection{Introduction (5\%)}
\label{Chapter6a_Practical/Practical:introduction-5}
This should be of around 2-3 pages.

It should introduce the purpose of the study, being at a base level, to
build and calibrate a snow/hydrological model in Python.

It should provide some background to building models of this sort (their
purpose/role) and include some review of the types of models that might
be built, with reference to the literature (journals).

A pass mark for this section will describe and explain the purpose of
the study and examine some of the context to such modelling, with
appropriate literature being cited. Higher or lower marks will depend on
the depth that this goes into and the clarity of expression.


\subsubsection{Data Preparation (45\%)}
\label{Chapter6a_Practical/Practical:data-preparation-45}
This should contain around 3-4 pages of text, other than codes, figures
and tables.

For a pass mark in this section, you must :
\begin{itemize}
\item {} 
introduce the study site, giving general site characteristics, with
appropriate figures.

\item {} 
provide an overview of the data used in the study (snow cover,
temperature, flow data) and produce visualisations of the data you
are using (images, graphs, tables as appropriate) alongside
appropriate summary statistics.

\item {} 
fully demonstrate how you got these data to this point of processing
-- i.e. submit appropriate Python codes and/or unix commands that
when run in the sequence you describe would produce the data you have
described.

\end{itemize}

The weighting here on the study site description is 5\% and on the rest,
40\%.

You can obtain higher marks here by going beyond the basics in your
approaches to the data or modelling. You still need to demonstrate that
you have done the core `pass' material.


\subsubsection{Modelling}
\label{Chapter6a_Practical/Practical:modelling}
This should contain around 3-4 pages of text, other than codes, figures
and tables.

For a pass mark in this section, you must :
\begin{itemize}
\item {} 
provide an overview of the model that is constructed here, explaining
the role of each parameter.

\item {} 
explain the way in which model calibration and validation is to be
undertaken.

\item {} 
provide an overview of results of the calibration and validation
along with relevant visualisations (images, graphs, tables as
appropriate).

\item {} 
fully demonstrate how you got these results -- i.e. submit
appropriate Python codes and/or unix commands that when run in the
sequence you describe would produce the results you have described.

\end{itemize}

The weighting here is 5\% for the model description and on the rest, 40\%.

For a mildly improved mark, you should examine and discuss the model
assumptions in the context of any modelling literature you looked at in
the Introduction. For a significantly improved mark, you could try
improving the model.


\subsubsection{Discussion and Conclusions}
\label{Chapter6a_Practical/Practical:discussion-and-conclusions}
This section should be around 2 pages. It should provide a discussion
and analysis of your results and you should draw appropriate conclusions
from these.

You can also use this section to critique the model/data/methods, and
suggest ways that you would improve things. If you do this, you must
give some indication of how that would be achieved. You will get no
credit for simply saying next time I would make the code more
efficient, for example.

Very good/excellent marks would normally require you to cite appropriate
literature.

A sufficient effort for a pass would make a reasonable effort at
discussing these results in the context of some literature and draw a
few (non trivial) conclusions from the study.


\subsection{6.3.5 Computer Code}
\label{Chapter6a_Practical/Practical:computer-code}

\subsubsection{General requirements}
\label{Chapter6a_Practical/Practical:general-requirements}
You will obviously need to submit computer codes as part of this
assessment. Some flexibility in the style of these codes is to be
expected. For example, some might write a class that encompasses the
functionality for all tasks. Some poeple might have multiple versions of
codes with different functionality. All of these, and other reasonable
variations are allowed.

All codes needed to demonstrate that you have performed the core tasks
are required to be included in the submission. You should include all
codes that you make use of in the main body of the text in the main
body. Any other codes that you want to refer to (e.g. something you
tried out as an enhancement and didnt quite get there) you can include
in appendices.

All codes should be well-commented. Part of the marks you get for code
will depend on the adequacy of the commenting.


\subsubsection{Degree of original work required and plagiarism}
\label{Chapter6a_Practical/Practical:degree-of-original-work-required-and-plagiarism}
If you use a piece of code verbatim that you have taken from the course
pages or any other source, \textbf{you must acknowledge this} in comments in
your text. \textbf{Not to do so is plagiarism}. Where you have taken some
part (e.g. a few lines) of someone elses code, \textbf{you should also
indicate this}. If some of your code is heavily based on code from
elsewhere, \textbf{you must also indicate that}.

Some examples. You may recognise this snippet of code from above.

The first example is guilty of strong plagiarism, it does not seek to
acknowledge the source of this code, even though it is just a direct
copy, pasted into a method called \code{model()}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{model}\PYG{p}{(}\PYG{n}{tempThresh}\PYG{o}{=}\PYG{l+m+mf}{9.0}\PYG{p}{,}\PYG{n}{K}\PYG{o}{=}\PYG{l+m+mf}{2000.0}\PYG{p}{,}\PYG{n}{p}\PYG{o}{=}\PYG{l+m+mf}{0.96}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}need to comment this further ...}

\PYG{l+s+sd}{    \PYGZsq{}\PYGZsq{}\PYGZsq{}}
    \PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}
    \PYG{n}{meltDays} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{where}\PYG{p}{(}\PYG{n}{temperature} \PYG{o}{\PYGZgt{}} \PYG{n}{tempThresh}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
    \PYG{n}{accum} \PYG{o}{=} \PYG{n}{snowProportion}\PYG{o}{*}\PYG{l+m+mf}{0.}
    \PYG{k}{for} \PYG{n}{d} \PYG{o+ow}{in} \PYG{n}{meltDays}\PYG{p}{:}
        \PYG{n}{water} \PYG{o}{=} \PYG{n}{K} \PYG{o}{*} \PYG{n}{snowProportion}\PYG{p}{[}\PYG{n}{d}\PYG{p}{]}
        \PYG{n}{n} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{snowProportion}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{d}
        \PYG{n}{m} \PYG{o}{=} \PYG{n}{p} \PYG{o}{*}\PYG{o}{*} \PYG{n}{n}
        \PYG{n}{m}\PYG{p}{[}\PYG{n}{np}\PYG{o}{.}\PYG{n}{where}\PYG{p}{(}\PYG{n}{n}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{]}\PYG{o}{=}\PYG{l+m+mi}{0}
        \PYG{n}{accum} \PYG{o}{+}\PYG{o}{=} \PYG{n}{m} \PYG{o}{*} \PYG{n}{water}
    \PYG{k}{return} \PYG{n}{accum}
\end{Verbatim}

This is \textbf{not} acceptable.

This should probably be something along the lines of:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{model}\PYG{p}{(}\PYG{n}{tempThresh}\PYG{o}{=}\PYG{l+m+mf}{9.0}\PYG{p}{,}\PYG{n}{K}\PYG{o}{=}\PYG{l+m+mf}{2000.0}\PYG{p}{,}\PYG{n}{p}\PYG{o}{=}\PYG{l+m+mf}{0.96}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}need to comment this further ...}

\PYG{l+s+sd}{    This code is taken directly from}
\PYG{l+s+sd}{    \PYGZdq{}Modelling delay in a hydrological network\PYGZdq{}}
\PYG{l+s+sd}{    by P. Lewis http://www2.geog.ucl.ac.uk/\PYGZti{}plewis/geogg122/DelNorte.html}
\PYG{l+s+sd}{    and wrapped into a method.}
\PYG{l+s+sd}{    \PYGZsq{}\PYGZsq{}\PYGZsq{}}
    \PYG{c}{\PYGZsh{} my code: make sure numpy is imported}
    \PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}

    \PYG{c}{\PYGZsh{} code below verbatim from Lewis}
    \PYG{n}{meltDays} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{where}\PYG{p}{(}\PYG{n}{temperature} \PYG{o}{\PYGZgt{}} \PYG{n}{tempThresh}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
    \PYG{n}{accum} \PYG{o}{=} \PYG{n}{snowProportion}\PYG{o}{*}\PYG{l+m+mf}{0.}
    \PYG{k}{for} \PYG{n}{d} \PYG{o+ow}{in} \PYG{n}{meltDays}\PYG{p}{:}
        \PYG{n}{water} \PYG{o}{=} \PYG{n}{K} \PYG{o}{*} \PYG{n}{snowProportion}\PYG{p}{[}\PYG{n}{d}\PYG{p}{]}
        \PYG{n}{n} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{snowProportion}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{d}
        \PYG{n}{m} \PYG{o}{=} \PYG{n}{p} \PYG{o}{*}\PYG{o}{*} \PYG{n}{n}
        \PYG{n}{m}\PYG{p}{[}\PYG{n}{np}\PYG{o}{.}\PYG{n}{where}\PYG{p}{(}\PYG{n}{n}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{]}\PYG{o}{=}\PYG{l+m+mi}{0}
        \PYG{n}{accum} \PYG{o}{+}\PYG{o}{=} \PYG{n}{m} \PYG{o}{*} \PYG{n}{water}
    \PYG{c}{\PYGZsh{} my code: return accumulator}
    \PYG{k}{return} \PYG{n}{accum}
\end{Verbatim}

Now, we acknowledge that this is in essence a direct copy of someone
elses code, and clearly state this. We do also show that we have added
some new lines to the code, and that we have wrapped this into a method.

In the next example, we have seen that the way m is generated is in fact
rather inefficient, and have re-structured the code. It is partially
developed from the original code, and acknowledges this:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{model}\PYG{p}{(}\PYG{n}{tempThresh}\PYG{o}{=}\PYG{l+m+mf}{9.0}\PYG{p}{,}\PYG{n}{K}\PYG{o}{=}\PYG{l+m+mf}{2000.0}\PYG{p}{,}\PYG{n}{p}\PYG{o}{=}\PYG{l+m+mf}{0.96}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}need to comment this further ...}

\PYG{l+s+sd}{    This code after the model developed in}
\PYG{l+s+sd}{    \PYGZdq{}Modelling delay in a hydrological network\PYGZdq{}}
\PYG{l+s+sd}{    by P. Lewis}
\PYG{l+s+sd}{    http://www2.geog.ucl.ac.uk/\PYGZti{}plewis/geogg122/DelNorte.html}

\PYG{l+s+sd}{    My modifications have been to make the filtering more efficient.}
\PYG{l+s+sd}{    \PYGZsq{}\PYGZsq{}\PYGZsq{}}
    \PYG{c}{\PYGZsh{} my code: make sure numpy is imported}
    \PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}

    \PYG{c}{\PYGZsh{} code below verbatim from Lewis unless otherwise indicated}
    \PYG{n}{meltDays} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{where}\PYG{p}{(}\PYG{n}{temperature} \PYG{o}{\PYGZgt{}} \PYG{n}{tempThresh}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
    \PYG{n}{accum} \PYG{o}{=} \PYG{n}{snowProportion}\PYG{o}{*}\PYG{l+m+mf}{0.}

    \PYG{c}{\PYGZsh{} my code: pull the filter block out of the loop}
    \PYG{n}{n} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{snowProportion}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{m} \PYG{o}{=} \PYG{n}{p} \PYG{o}{*}\PYG{o}{*} \PYG{n}{n}

    \PYG{k}{for} \PYG{n}{d} \PYG{o+ow}{in} \PYG{n}{meltDays}\PYG{p}{:}
        \PYG{n}{water} \PYG{o}{=} \PYG{n}{K} \PYG{o}{*} \PYG{n}{snowProportion}\PYG{p}{[}\PYG{n}{d}\PYG{p}{]}

        \PYG{c}{\PYGZsh{} my code: shift the filter on by one day}
        \PYG{c}{\PYGZsh{} ...do something clever to shift it on by one day}

        \PYG{n}{accum} \PYG{o}{+}\PYG{o}{=} \PYG{n}{m} \PYG{o}{*} \PYG{n}{water}
    \PYG{c}{\PYGZsh{} my code: return accumulator}
    \PYG{k}{return} \PYG{n}{accum}
\end{Verbatim}

This example makes it clear that significant modifications have been
made to the code structure (and probably to its efficiency) although the
basic model and looping comes from an existing piece of code. It clearly
highlights what the actual modifications have been. Note that this is
not a working example!!

Although you are supposed to do this piece of work on your own, there
might be some circumstances under which someone has significantly helped
you to develop the code (e.g. written the main part of it for you \&
youve just copied that with some minor modifications). You \textbf{must}
acknowledge in your code comments if this has happened. On the whole
though, this should not occur, as you \textbf{must} complete this work on
your own.

If you take a piece of code from somewhere else and all you do is change
the variable names and/or other cosmetic changes, you \textbf{must}
acknowledge the source of the original code (with a URL if available).

Plagiarism in coding is a tricky issue. One reason for that is that
often the best way to learn something like this is to find an example
that someone else has written and adapt that to your purposes. Equally,
if someone has written some tool/library to do what you want to do, it
would generally not be worthwhile for you to write your own but to
concentrate on using that to achieve something new. Even in general code
writing (i.e. when not submitting it as part of your assessment) you and
anyone else who ever has to read your code would find it of value to
make reference to where you found the material to base what you did on.
The key issue to bear in mind in this work, as it is submitted as your
own work is that, to avoid being accused of plagiarism and to allow a
fair assessment of what you have done, you must clearly acknowledge
which parts of it are your own, and the degree to which you could claim
them to be your own.

For example, based on ... is absolutely fine, and you would certainly be
given credit for what you have done. In many circumstances taken
verbatim from ... would also be fine (provided it is acknowledged) but
then you would be given credit for what you had done with the code that
you had taken from elsewhere (e.g. you find some elegant way of doing
the graphs that someone has written and you make use of it for
presenting your results).

The difference between what you submit here and the code you might write
if this were not a piece submitted for assessment is that you the vast
majority of the credit you will gain for the code will be based on the
degree to which you demonstrate that you can write code to achieve the
required tasks. There would obviously be some credit for taking codes
from the coursenotes and bolting them together into something that
achieves the overall aim: provided that worked, and you had commented it
adequately and acknowledge what the extent of your efforts had been, you
should be able to achieve a pass in that component of the work. If there
was no original input other than vbolting pieces of existing code
together though, you be unlikely to achieve more than a pass. If you get
less than a pass in another component of the coursework, that then puts
you in danger of an overall fail.

Provided you achieve the core tasks, the more original work that you
do/show (that is of good quality), the higher the mark you will get.
Once you have achieved the core tasks, even if you try something and
dont quite achieve it, is is probably worth including, as you may get
marks for what you have done (or that fact that it was a good or
interesting thing to try to do).


\subsubsection{Documentation}
\label{Chapter6a_Practical/Practical:documentation}
Note: All methods/functions and classes must be documented for the code
to be adequate. Generally, this will contain:
\begin{itemize}
\item {} 
some text on the purpose of the method (/function/class)

\item {} 
some text describing the inputs and outputs, including reference to
any relevant details such as datatype, shape etc where such things
are of relevance to understanding the code.

\item {} 
some text on keywords, e.g.:

\end{itemize}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{complex}\PYG{p}{(}\PYG{n}{real}\PYG{o}{=}\PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{n}{imag}\PYG{o}{=}\PYG{l+m+mf}{0.0}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Form a complex number.}

\PYG{l+s+sd}{    Keyword arguments:}
\PYG{l+s+sd}{    real \PYGZhy{}\PYGZhy{} the real part (default 0.0)}
\PYG{l+s+sd}{    imag \PYGZhy{}\PYGZhy{} the imaginary part (default 0.0)}

\PYG{l+s+sd}{    Example taken verbatim from:}
\PYG{l+s+sd}{    http://www.python.org/dev/peps/pep\PYGZhy{}0257/}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{k}{if} \PYG{n}{imag} \PYG{o}{==} \PYG{l+m+mf}{0.0} \PYG{o+ow}{and} \PYG{n}{real} \PYG{o}{==} \PYG{l+m+mf}{0.0}\PYG{p}{:} \PYG{k}{return} \PYG{n}{complex\PYGZus{}zero}
\end{Verbatim}

You should look at the \href{http://www.python.org/dev/peps/pep-0257/}{document on good docstring
conventions} when
considering how to document methods, classes etc.

To demonstrate your documentation, you \textbf{must} include the help text
generated by your code after you include the code. e.g.:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{print\PYGZus{}something}\PYG{p}{(}\PYG{n}{this}\PYG{p}{,}\PYG{n}{stderr}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}This does something.}

\PYG{l+s+sd}{    Keyword arguments:}
\PYG{l+s+sd}{    stderr \PYGZhy{}\PYGZhy{} set to True to print to stderr (default False)}
\PYG{l+s+sd}{    \PYGZsq{}\PYGZsq{}\PYGZsq{}}

    \PYG{k}{if} \PYG{n}{stderr}\PYG{p}{:}
        \PYG{c}{\PYGZsh{} import sys.stderr}
        \PYG{k+kn}{from} \PYG{n+nn}{sys} \PYG{k+kn}{import} \PYG{n}{stderr}

        \PYG{c}{\PYGZsh{} print to stderr channel, converting this to str}
        \PYG{k}{print} \PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{n}{stderr}\PYG{p}{,}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{this}\PYG{p}{)}

        \PYG{c}{\PYGZsh{} job done, return}
        \PYG{k}{return}

    \PYG{c}{\PYGZsh{} print to stdout, converting this to str}
    \PYG{k}{print} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{this}\PYG{p}{)}

    \PYG{k}{return}
\end{Verbatim}

Then the help text would be:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{help}\PYG{p}{(}\PYG{n}{print\PYGZus{}something}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
Help on function print\PYGZus{}something in module \PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}:

print\PYGZus{}something(this, stderr=False)
    This does something.

    Keyword arguments:
    stderr \PYGZhy{}\PYGZhy{} set to True to print to stderr (default False)
\end{Verbatim}

The above example represents a good level of commenting as the code
broadly adheres to the style suggestions and most of the major features
are covered. It is not quite very good/excellent as the description of
the purpose of the method (rather important) is trivial and it fails to
describe the input this in any way. An excellent piece would do all of
these things, and might well tell us about any dependencies (e.g.
requires sys if stderr set to True).

An inadequate example would be:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{print\PYGZus{}something}\PYG{p}{(}\PYG{n}{this}\PYG{p}{,}\PYG{n}{stderr}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}This prints something\PYGZsq{}\PYGZsq{}\PYGZsq{}}
    \PYG{k}{if} \PYG{n}{stderr}\PYG{p}{:}
        \PYG{k+kn}{from} \PYG{n+nn}{sys} \PYG{k+kn}{import} \PYG{n}{stderr}
        \PYG{k}{print} \PYG{o}{\PYGZgt{}\PYGZgt{}} \PYG{n}{stderr}\PYG{p}{,}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{this}\PYG{p}{)}
        \PYG{k}{return}
    \PYG{k}{print} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{this}\PYG{p}{)}
\end{Verbatim}

It is inadequate because it still only has a trivial description of the
purpose of the method, it tells us nothing about inputs/outputs and
there is no commenting inside the method.


\subsubsection{Word limit}
\label{Chapter6a_Practical/Practical:word-limit}
There is no word limit per se on the computer codes, though as with all
writing, you should try to be succint rather than overly verbose.


\subsubsection{Code style}
\label{Chapter6a_Practical/Practical:code-style}
A good to excellent piece of code would take into account issues raised
in the \href{http://www.python.org/dev/peps/pep-0008/}{style guide}. The
degree of excellence would depend on how well you take those points on
board.


\chapter{7.0 Fire/ENSO teleconnections}
\label{Chapter7_ENSO/ENSO::doc}\label{Chapter7_ENSO/ENSO:fire-enso-teleconnections}

\section{7.1 Introduction}
\label{Chapter7_ENSO/ENSO:introduction}
There is much public and scientific interest in monitoring and
predicting the activity of wildfires and such topics are \href{http://www.bbc.co.uk/news/science-environment-15691060}{often in the
media}.

Part of this interest stems from the role fire plays in issues such as
\href{http://www.eufirelab.org/toolbox2/library/upload/2086.pdf}{land cover change, deforestation and forest
degradation}
and \href{http://www.google.com/url?sa=t\&rct=j\&q=fire\%20carbon\%20emissions\&source=web\&cd=6\&ved=0CFEQFjAF\&url=http\%3A\%2F\%2Fwww.kcl.ac.uk\%2Fsspp\%2Fdepartments\%2Fgeography\%2Fpeople\%2Facademic\%2Fwooster\%2F30yongwoosteretal.pdf\&ei=4FPCTuvZE9Gg8gPZybyxBA\&usg=AFQjCNG81fTRoCcK1nhKnk3u0b8az24bGQ\&sig2=EjJYm2S-\_2gHu2vgt4ByvA\&cad=rja}{Carbon
emissions}
from the land surface to the atmosphere, but also of concern are human
health impacts. The impacts of fire should not however be considered as
wholy negative, as it plays a \href{http://www.fl-dof.com/publications/fires\_natural\_role.html\#firerole}{significant role in natural ecosystem
processes}.

For many regions of the Earth, there are large inter-annual variations
in the timing, frequency and severity of wildfires. Whilst anthropogenic
activity accounts for a \href{http://www.google.com/url?sa=t\&rct=j\&q=fire\%20frequency\%20july\%204th\&source=web\&cd=7\&ved=0CFIQFjAG\&url=http\%3A\%2F\%2Farctic.synergiesprairies.ca\%2Farctic\%2Findex.php\%2Farctic\%2Farticle\%2Fdownload\%2F2806\%2F2783\&ei=K1bCTqv1MYS28QOR9ekG\&usg=AFQjCNFKillAOZMXrT5xpFhckMKvqW50Vg\&sig2=r3J6454VcvI1xpC3Sf3RKw\&cad=rja}{large and probably increasing
proportion}
of fires started, this is not in itself \href{http://www.google.com/url?sa=t\&rct=j\&q=anthropogenic\%20fire\&source=web\&cd=2\&ved=0CCcQFjAB\&url=http\%3A\%2F\%2Fwww.as.ua.edu\%2Fant\%2Fbindon\%2Fant475\%2FPapers\%2FHamm.pdf\&ei=rFXCTu-PHsay8QPdy-2MBA\&usg=AFQjCNGUMrfnDTwRDBxFB-wioZokBt8EtA\&sig2=Zt1nfHoKktbka-pEZs6NGw\&cad=rja}{a new
phenomenon}.

Fires spread where: (i) there is an ignition source (lightning or man,
mostly); (ii) sufficient combustible fuel to maintain the fire. The
latter is strongly dependent on fuel loads and mositure content, as well
as meteorological conditions. Generally then, when conditions are drier
(and there is sufficient fuel and appropriate weather conditions), we
would expect fire spread to increase. If the number of ignitions
remained approximately constant, this would mean more fires. \href{http://www.nasa.gov/images/content/492949main\_Figure-2-Wildfires.jpg}{Many
models of fire
activity}
predict increases in fire frequency in the coming decades, although
there may well be \href{http://news.sciencemag.org/sciencenow/2009/04/10-02.html}{different behaviours in differet parts of the
world}.

\href{http://www.nasa.gov/images/content/492949main\_Figure-2-Wildfires.jpg}{\includegraphics{Chapter7_ENSO/files/images/492949main_Figure-2-Wildfires_s3.jpg}}

Satellite data has been able to provide us with increasingly useful
tools for monitoring wildfire activity, particularly since 2000 with the
MODIS instruments on the NASA Terra and Aqua (2002) satellites. A suite
of \href{http://modis-fire.umd.edu/index.html}{fire products} have been
generated from these data that have been used in a large number of
\href{http://modis-fire.umd.edu/Publications.html}{publications} and
\href{http://maps.geog.umd.edu/firms/\#}{practical/management projects}.

There is growing evidence of teleconnection links between fire
occurence and large scale climate patterns, such as
\href{http://www.esrl.noaa.gov/psd/enso/}{ENSO}.

\href{http://www.esrl.noaa.gov/psd/enso/mei/}{}

The proposed mechanisms are essentially that such climatic patterns are
linked to local water status and temperature and thus affect the ability
of fires to spread. For some regions of the Earth, empirical models
built from such considerations have quite reasonable predictive skill,
meaning that fire season severity might be predicted \href{http://www.sciencemag.org/content/334/6057/787.full}{some months ahead
of time}.


\section{7.2 A Practical Exercise}
\label{Chapter7_ENSO/ENSO:a-practical-exercise}

\subsection{7.2.1 In This Session}
\label{Chapter7_ENSO/ENSO:in-this-session}
In this session, you will be working in groups (of 3 or 4) to build a
computer code in python to explore links between fire activity and Sea
Surface Temperature anomalies.

This is a team exercise, but does not form part of your formal
assessment for this course. You should be able to complete the exercise
in the 3 hour session, if you work effectively as a team. Staff will be
on hand to provide pointers.

You should be able to complete the exercise using coding skills and
python modules that you have previously experience of, though we will
also provide some pointers to get you started.


\subsection{7.2.2 Statement of the problem}
\label{Chapter7_ENSO/ENSO:statement-of-the-problem}
Using monthly fire count data from MODIS Terra, develop and test a
predictive model for the number of fires per unit area per year driven
by Sea Surface Temperature anomaly data.


\subsection{7.2.3 Datasets}
\label{Chapter7_ENSO/ENSO:datasets}
We suggest that the datasets you use of this analysis, following Chen at
al. (2011), are:
\begin{itemize}
\item {} 
MODIS Terra fire counts (2001-2011) (MOD14CMH). The particular
dataset you will want from the file is SUBDATASET\_2 {[}360x720{]}
CloudCorrFirePix (16-bit integer).

\item {} 
Climate index data from NOAA

\end{itemize}

If you ever wish to take this study further, you can find various other
useful datasets such as these.


\subsubsection{Fire Data}
\label{Chapter7_ENSO/ENSO:fire-data}
The MOD14CMH \href{http://maps.geog.umd.edu/firms/CMG.htm}{CMG data} are
available from the \href{ftp://fire:burnt@fuoco.geog.umd.edu/modis/C5/cmg/monthly/hdf}{UMD ftp
server}
but the data you will need are also directly available from
/data/geospatial\_10/ucfajlg/MOD14CMH/. Note that, if you are on the UCL
system, you do not need to copy the data, just use them from where they
are.

If for any reason, you \emph{did} want to copy or update them, use the
following unix command:

\code{wget 'ftp://fire:burnt@fuoco.geog.umd.edu/modis/C5/cmg/monthly/hdf/*'}

The data are in files/data and are in HDF format, so
you should know how to read them into a numpy array in python.

\begin{Verbatim}[commandchars=\\\{\}]
!ls \PYGZhy{}l files/data/*hdf \textbar{} head \PYGZhy{}10
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis  961993 Nov  1  2007 files/data/MOD14CMH.200011.005.01.hdf
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis  923238 Nov  1  2007 files/data/MOD14CMH.200012.005.01.hdf
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis  953227 Mar 22  2008 files/data/MOD14CMH.200101.005.01.hdf
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis  951917 Apr 23  2008 files/data/MOD14CMH.200102.005.01.hdf
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis  959282 Apr 23  2008 files/data/MOD14CMH.200103.005.01.hdf
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis  943794 Apr 23  2008 files/data/MOD14CMH.200104.005.01.hdf
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis  988588 Apr 23  2008 files/data/MOD14CMH.200105.005.01.hdf
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis  898137 Mar 22  2008 files/data/MOD14CMH.200106.005.01.hdf
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis  962767 Mar 22  2008 files/data/MOD14CMH.200107.005.01.hdf
\PYGZhy{}rw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} 1 plewis plewis  982616 Nov  5  2007 files/data/MOD14CMH.200108.005.01.hdf
ls: write error: Broken pipe
\end{Verbatim}

If you are \textbf{really} stuck on reading the data, or just want to move on
to the next parts, you can use
\code{{}`files/python/reader.py} \textless{}files/python/reader.py\textgreater{}{}`\_\_ which will
create a masked array in \code{data}, and an array of years (\code{year}) and
months (\code{month}):

\begin{Verbatim}[commandchars=\\\{\}]
run files/python/reader
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{x} \PYG{o}{=} \PYG{n}{year} \PYG{o}{+} \PYG{n}{month}\PYG{o}{/}\PYG{l+m+mf}{12.}
\PYG{n}{y} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{data}\PYG{p}{,}\PYG{n}{axis}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{global fire count}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{time}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.text.Text at 0x2b4488089490\PYGZgt{}
\end{Verbatim}

\includegraphics{ENSO_13_1.png}

This dataset is at 0.5 degree resolution and we want to perform tha
analysis as 5 degrees.

We need to shrink the dataset by a factor of 10 then.

There are different ways to achive this, but one way would be to
reoganise the data:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{rdata} \PYG{o}{=} \PYG{p}{[}\PYG{n}{data}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{i}\PYG{p}{:}\PYG{p}{:}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{n}{j}\PYG{p}{:}\PYG{p}{:}\PYG{l+m+mi}{10}\PYG{p}{]} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{]}
\PYG{n}{rdata} \PYG{o}{=} \PYG{n}{ma}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{rdata}\PYG{p}{)}

\PYG{k}{print} \PYG{n}{rdata}\PYG{o}{.}\PYG{n}{shape}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{l+m+mi}{154}\PYG{p}{,} \PYG{l+m+mi}{36}\PYG{p}{,} \PYG{l+m+mi}{72}\PYG{p}{)}
\end{Verbatim}

So, we have made the dataset which as \code{(154, 360, 720)} into a shape
\code{(100, 154, 36, 72)}.

We can now get the total fire counts easily at 5 degrees by summing over
those 100 cells (axis=0):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{fdata} \PYG{o}{=} \PYG{n}{rdata}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{fdata}\PYG{o}{.}\PYG{n}{shape}

\PYG{n}{lf} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{log}\PYG{p}{(}\PYG{n}{fdata}\PYG{p}{)}
\PYG{n}{vmax} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{n}{lf}\PYG{p}{[}\PYG{n}{lf}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{lf}\PYG{p}{[}\PYG{l+m+mi}{8}\PYG{p}{]}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nearest}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{vmax}\PYG{o}{=}\PYG{n}{vmax}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{log fire count for }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{ month }\PYG{l+s+si}{\PYGZpc{}02d}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{year}\PYG{p}{[}\PYG{l+m+mi}{8}\PYG{p}{]}\PYG{p}{,}\PYG{n}{month}\PYG{p}{[}\PYG{l+m+mi}{8}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{l+m+mi}{154}\PYG{p}{,} \PYG{l+m+mi}{36}\PYG{p}{,} \PYG{l+m+mi}{72}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.text.Text at 0x1e19add0\PYGZgt{}
\end{Verbatim}

\includegraphics{ENSO_17_2.png}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} or even make a movie}
\PYG{n}{lf} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{log}\PYG{p}{(}\PYG{n}{fdata}\PYG{p}{)}
\PYG{n}{vmax} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{n}{lf}\PYG{p}{[}\PYG{n}{lf}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{root} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/images/}\PYG{l+s}{\PYGZsq{}}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{n}{lf}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{fig} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{log}\PYG{p}{(}\PYG{n}{fdata}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nearest}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{vmax}\PYG{o}{=}\PYG{n}{vmax}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{file\PYGZus{}id} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{ month }\PYG{l+s+si}{\PYGZpc{}02d}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{year}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,}\PYG{n}{month}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{log fire count for }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{n}{file\PYGZus{}id}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZus{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{.jpg}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{root}\PYG{p}{,}\PYG{n}{file\PYGZus{}id}\PYG{o}{.}\PYG{n}{replace}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZus{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{n}{fig}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZhy{}c:2: RuntimeWarning: divide by zero encountered in log
\PYGZhy{}c:2: RuntimeWarning: invalid value encountered in log
\PYGZhy{}c:8: RuntimeWarning: divide by zero encountered in log
\PYGZhy{}c:8: RuntimeWarning: invalid value encountered in log
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{cmd} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{convert \PYGZhy{}delay 100 \PYGZhy{}loop 0 \PYGZob{}0\PYGZcb{}\PYGZus{}*month*.jpg \PYGZob{}0\PYGZcb{}fire\PYGZus{}movie3.gif}\PYG{l+s}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{root}\PYG{p}{)}
\PYG{n}{os}\PYG{o}{.}\PYG{n}{system}\PYG{p}{(}\PYG{n}{cmd}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{0}
\end{Verbatim}
\begin{figure}[htbp]
\centering

\includegraphics{Chapter7_ENSO/files/images/fire_movie3.gif}
\end{figure}

The information we want is the peak fire count and to know which month
this occurred in.

To do this, we might reoder the data first:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{nlatlon} \PYG{o}{=} \PYG{n}{fdata}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{p}{]}
\PYG{n}{min\PYGZus{}year} \PYG{o}{=} \PYG{n}{year}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{max\PYGZus{}year} \PYG{o}{=} \PYG{n}{year}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{c}{\PYGZsh{} number of years}
\PYG{n}{nyears} \PYG{o}{=} \PYG{n}{max\PYGZus{}year} \PYG{o}{\PYGZhy{}} \PYG{n}{min\PYGZus{}year} \PYG{o}{+} \PYG{l+m+mi}{1}

\PYG{c}{\PYGZsh{} set up a big array}
\PYG{n}{f2data}  \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{,}\PYG{n}{nyears}\PYG{p}{)}\PYG{o}{+}\PYG{n}{nlatlon}\PYG{p}{)}
\PYG{n}{f2datam} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{,}\PYG{n}{nyears}\PYG{p}{)}\PYG{o}{+}\PYG{n}{nlatlon}\PYG{p}{)}\PYG{o}{.}\PYG{n}{astype}\PYG{p}{(}\PYG{n+nb}{bool}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{i}\PYG{p}{,}\PYG{p}{(}\PYG{n}{y}\PYG{p}{,}\PYG{n}{m}\PYG{p}{)} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n+nb}{zip}\PYG{p}{(}\PYG{n}{year}\PYG{o}{\PYGZhy{}}\PYG{n}{year}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{month}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{f2data}\PYG{p}{[}\PYG{n}{m}\PYG{p}{,}\PYG{n}{y}\PYG{p}{]} \PYG{o}{=} \PYG{n}{fdata}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
    \PYG{n}{f2datam}\PYG{p}{[}\PYG{n}{m}\PYG{p}{,}\PYG{n}{y}\PYG{p}{]} \PYG{o}{=} \PYG{p}{(}\PYG{n}{fdata}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{c}{\PYGZsh{} mask it}
\PYG{n}{f2data} \PYG{o}{=} \PYG{n}{ma}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{f2data}\PYG{p}{,}\PYG{n}{mask}\PYG{o}{=}\PYG{n}{f2datam}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{f2data}\PYG{o}{.}\PYG{n}{shape}

\PYG{c}{\PYGZsh{} test it}
\PYG{n}{m} \PYG{o}{=} \PYG{l+m+mi}{8}
\PYG{n}{y} \PYG{o}{=} \PYG{l+m+mi}{2005}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{log}\PYG{p}{(}\PYG{n}{f2data}\PYG{p}{[}\PYG{n}{m}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{y}\PYG{o}{\PYGZhy{}}\PYG{n}{year}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nearest}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{log fire count for }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{ month }\PYG{l+s+si}{\PYGZpc{}02d}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{y}\PYG{p}{,}\PYG{n}{m}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{14}\PYG{p}{,} \PYG{l+m+mi}{36}\PYG{p}{,} \PYG{l+m+mi}{72}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZhy{}c:22: RuntimeWarning: divide by zero encountered in log
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.text.Text at 0x2b4489c91ad0\PYGZgt{}
\end{Verbatim}

\includegraphics{ENSO_22_3.png}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} which month has the highest fire count}
\PYG{c}{\PYGZsh{} NB 0\PYGZhy{}based here but we use a masked array}

\PYG{c}{\PYGZsh{} total fire count summed over month (axis 0)}
\PYG{n}{fmask} \PYG{o}{=} \PYG{n}{f2data}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{0}

\PYG{c}{\PYGZsh{} which month (axis 0) has the max value?}
\PYG{n}{fire\PYGZus{}month} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{argmax}\PYG{p}{(}\PYG{n}{f2data}\PYG{p}{,}\PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}

\PYG{c}{\PYGZsh{} masked array of this}
\PYG{n}{fire\PYGZus{}month} \PYG{o}{=} \PYG{n}{ma}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{fire\PYGZus{}month}\PYG{p}{,}\PYG{n}{mask}\PYG{o}{=}\PYG{n}{fmask}\PYG{p}{)}

\PYG{n}{y} \PYG{o}{=} \PYG{l+m+mi}{2005}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{fire\PYGZus{}month}\PYG{p}{[}\PYG{n}{y}\PYG{o}{\PYGZhy{}}\PYG{n}{year}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nearest}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Peak fire month for }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}\PYG{p}{)}

\PYG{c}{\PYGZsh{} suppose this is the same for all years:}
\PYG{n}{av\PYGZus{}fire\PYGZus{}month} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{median}\PYG{p}{(}\PYG{n}{fire\PYGZus{}month}\PYG{p}{,}\PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{o}{.}\PYG{n}{astype}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{av\PYGZus{}fire\PYGZus{}month}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nearest}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Average peak fire month}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.text.Text at 0x134d27d0\PYGZgt{}
\end{Verbatim}

\includegraphics{ENSO_23_1.png}

\includegraphics{ENSO_23_2.png}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} and now get the fire count for that month}
\PYG{c}{\PYGZsh{} lets try this by hand first}

\PYG{n}{peak\PYGZus{}count} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros\PYGZus{}like}\PYG{p}{(}\PYG{n}{f2data}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{y} \PYG{o}{=} \PYG{l+m+mi}{2001}
\PYG{n}{m} \PYG{o}{=} \PYG{l+m+mi}{0}

\PYG{n}{fmask} \PYG{o}{=} \PYG{p}{(}\PYG{n}{av\PYGZus{}fire\PYGZus{}month} \PYG{o}{==} \PYG{n}{m}\PYG{p}{)}
\PYG{n}{peak\PYGZus{}count}\PYG{p}{[}\PYG{n}{y}\PYG{o}{\PYGZhy{}}\PYG{n}{year}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{[}\PYG{n}{fmask}\PYG{p}{]} \PYG{o}{=} \PYG{n}{f2data}\PYG{p}{[}\PYG{n}{m}\PYG{p}{,}\PYG{n}{y}\PYG{o}{\PYGZhy{}}\PYG{n}{year}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{[}\PYG{n}{fmask}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} and now extend it}
\PYG{n}{peak\PYGZus{}count} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros\PYGZus{}like}\PYG{p}{(}\PYG{n}{f2data}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{m} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{n}{f2data}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{fmask} \PYG{o}{=} \PYG{p}{(}\PYG{n}{av\PYGZus{}fire\PYGZus{}month} \PYG{o}{==} \PYG{n}{m}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{y} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{n}{f2data}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{peak\PYGZus{}count}\PYG{p}{[}\PYG{n}{y}\PYG{p}{]}\PYG{p}{[}\PYG{n}{fmask}\PYG{p}{]} \PYG{o}{=} \PYG{n}{f2data}\PYG{p}{[}\PYG{n}{m}\PYG{p}{,}\PYG{n}{y}\PYG{p}{]}\PYG{p}{[}\PYG{n}{fmask}\PYG{p}{]}


\PYG{c}{\PYGZsh{} test it}
\PYG{n}{y} \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{log}\PYG{p}{(}\PYG{n}{peak\PYGZus{}count}\PYG{p}{[}\PYG{n}{y}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nearest}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Log Peak count for year }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{min\PYGZus{}year}\PYG{o}{+}\PYG{n}{y}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.text.Text at 0x2b44901b2090\PYGZgt{}
\end{Verbatim}

\includegraphics{ENSO_25_1.png}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} In summary, we have developed the following datasets:}

\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{peak\PYGZus{}count}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{peak\PYGZus{}count}\PYG{o}{.}\PYG{n}{shape}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{av\PYGZus{}fire\PYGZus{}month}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{av\PYGZus{}fire\PYGZus{}month}\PYG{o}{.}\PYG{n}{shape}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{min\PYGZus{}year}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{min\PYGZus{}year}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
peak\PYGZus{}count (14, 36, 72)
av\PYGZus{}fire\PYGZus{}month (36, 72)
min\PYGZus{}year 2000
\end{Verbatim}


\subsubsection{Climate Data}
\label{Chapter7_ENSO/ENSO:climate-data}
The climate data you will want will be some form of Sea Surface
Temperature (SST) anomaly measure. There is a long list of such measures
on
\href{http://www.esrl.noaa.gov/psd/data/climateindices/list/}{http://www.esrl.noaa.gov/psd/data/climateindices/list}.

Examples would be
\href{http://www.esrl.noaa.gov/psd/data/correlation/amon.us.data}{AMO} or
\href{http://www.esrl.noaa.gov/psd/data/correlation/oni.data}{ONI}. Note
that some of these measures are smoothed and others not.

Suppose we had selected AMO and we want to read directly from the url:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{urllib2}

\PYG{n}{url} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{http://www.esrl.noaa.gov/psd/data/correlation/amon.us.data}\PYG{l+s}{\PYGZsq{}}

\PYG{n}{req} \PYG{o}{=} \PYG{n}{urllib2}\PYG{o}{.}\PYG{n}{Request} \PYG{p}{(} \PYG{n}{url} \PYG{p}{)}
\PYG{n}{raw\PYGZus{}data} \PYG{o}{=} \PYG{n}{urllib2}\PYG{o}{.}\PYG{n}{urlopen}\PYG{p}{(}\PYG{n}{req}\PYG{p}{)}\PYG{o}{.}\PYG{n}{readlines}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} we notice from inspection that}
\PYG{c}{\PYGZsh{} we want data from rows 1 to \PYGZhy{}4}
\PYG{n}{raw\PYGZus{}data}\PYG{p}{[}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{]}
\end{Verbatim}
\begin{alltt}
{[}'  1948         2013n',
 ` 1948   -0.006   -0.018    0.037   -0.061    0.005    0.064   -0.030   -0.013   -0.043    0.017    0.144    0.072n'{]}
\end{alltt}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{raw\PYGZus{}data}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{]}
\end{Verbatim}
\begin{alltt}
{[}' 2008    0.051    0.150    0.185    0.071    0.193    0.287    0.237    0.201    0.228    0.129    0.031    0.049n',
 ` 2009   -0.032   -0.137   -0.139   -0.103   -0.039    0.152    0.259    0.182    0.086    0.198    0.098    0.112n',
 ` 2010    0.068    0.201    0.313    0.457    0.486    0.476    0.482    0.559    0.481    0.357    0.269    0.240n',
 ` 2011    0.173    0.134    0.082    0.119    0.172    0.206    0.126    0.180    0.183    0.094   -0.045   -0.020n',
 ` 2012   -0.041    0.028    0.048    0.109    0.191    0.332    0.412    0.468    0.482    0.372    0.206    0.173n',
 ` 2013    0.155    0.144    0.186    0.168    0.132    0.078    0.218    0.226    0.290  -99.990  -99.990  -99.990n'{]}
\end{alltt}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{cdata} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{n}{r}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)} \PYG{k}{for} \PYG{n}{r} \PYG{o+ow}{in} \PYG{n}{raw\PYGZus{}data}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{astype}\PYG{p}{(}\PYG{n+nb}{float}\PYG{p}{)}

\PYG{n}{cmask} \PYG{o}{=} \PYG{p}{(}\PYG{n}{cdata} \PYG{o}{\PYGZlt{}} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{50} \PYG{p}{)}
\PYG{n}{cdata} \PYG{o}{=} \PYG{n}{ma}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{cdata}\PYG{p}{,}\PYG{n}{mask}\PYG{o}{=}\PYG{n}{cmask}\PYG{p}{)}\PYG{o}{.}\PYG{n}{T}
\PYG{n}{cyears} \PYG{o}{=} \PYG{n}{cdata}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{cdata} \PYG{o}{=} \PYG{n}{cdata}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{p}{]}

\PYG{c}{\PYGZsh{} now we have the climate data as a masked array}
\PYG{c}{\PYGZsh{} column 0 is years, column 1 is Jan etc.}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{cyears}\PYG{p}{,}\PYG{n}{cdata}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{year}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{January AMO}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{cdata}\PYG{o}{.}\PYG{n}{shape}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{66}\PYG{p}{)}
\end{Verbatim}

\includegraphics{ENSO_32_1.png}


\subsection{7.2.4 Code to perform correlation analysis}
\label{Chapter7_ENSO/ENSO:code-to-perform-correlation-analysis}
The idea here is, for a particular (or set of) SST anomaly measures,
work out which lag month gives the highest correlation coefficient
with fire count.

By lag month, we mean that e.g. if the peak fire month for a
particular pixel was September, which month prior to that has a set of
SST anomalies over the sample years that is most strongly correlated
with fire count.

So, if we were using a single SST anomaly measure (e.g. AMO or ONI) and
sample years 2001 to 2009 to build our model, then we would do a linear
regression of fire count for a particular pixel over these years against
e.g. AMO data for September (lag 0) then August (lag 1) then July (lag
2) etc. and see which produced the highest \(R^2\).

Before we get into that, let's look again at the data structure we have:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} climate data}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{cdata}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{cdata}\PYG{o}{.}\PYG{n}{shape}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{cyears}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{cyears}\PYG{o}{.}\PYG{n}{shape}

\PYG{c}{\PYGZsh{} From the fire data}

\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{peak\PYGZus{}count}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{peak\PYGZus{}count}\PYG{o}{.}\PYG{n}{shape}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{av\PYGZus{}fire\PYGZus{}month}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{av\PYGZus{}fire\PYGZus{}month}\PYG{o}{.}\PYG{n}{shape}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{min\PYGZus{}year}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{min\PYGZus{}year}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
cdata (12, 66)
cyears (66,)
peak\PYGZus{}count (14, 36, 72)
av\PYGZus{}fire\PYGZus{}month (36, 72)
min\PYGZus{}year 2000
\end{Verbatim}

So, if we want to select data for particular years:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} which years (inclusive)}
\PYG{n}{years} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{2001}\PYG{p}{,}\PYG{l+m+mi}{2010}\PYG{p}{]}

\PYG{n}{ypeak\PYGZus{}count} \PYG{o}{=} \PYG{n}{peak\PYGZus{}count}\PYG{p}{[}\PYG{n}{years}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{n}{min\PYGZus{}year}\PYG{p}{:}\PYG{n}{years}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{min\PYGZus{}year} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{ycdata}  \PYG{o}{=}  \PYG{n}{cdata}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n}{years}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{cyears}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{:}\PYG{n}{years}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{cyears}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{]}

\PYG{c}{\PYGZsh{} check the shape}
\PYG{k}{print} \PYG{n}{ycdata}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{,}\PYG{n}{ypeak\PYGZus{}count}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{,}\PYG{n}{av\PYGZus{}fire\PYGZus{}month}\PYG{o}{.}\PYG{n}{shape}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{36}\PYG{p}{,} \PYG{l+m+mi}{72}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mi}{36}\PYG{p}{,} \PYG{l+m+mi}{72}\PYG{p}{)}
\end{Verbatim}

We need to consider a little carefully the implementation of lag ...

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} we will need to access ycdata[month \PYGZhy{} n][year]}
\PYG{c}{\PYGZsh{} which is a bit fiddly as e.g. \PYGZhy{}3 will be interpreted as}
\PYG{c}{\PYGZsh{} October for that same year, rather than the previous year}
\PYG{n}{y} \PYG{o}{=} \PYG{l+m+mi}{2001} \PYG{o}{\PYGZhy{}} \PYG{n}{min\PYGZus{}year}
\PYG{n}{m} \PYG{o}{=} \PYG{l+m+mi}{2}
\PYG{n}{lag} \PYG{o}{=} \PYG{l+m+mi}{5}
\PYG{k}{print} \PYG{n}{m} \PYG{o}{\PYGZhy{}} \PYG{n}{lag}\PYG{p}{,}\PYG{n}{y}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZhy{}3 1
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} so one way to fix this is to decrease y by one}
\PYG{c}{\PYGZsh{} if m \PYGZhy{} lag is \PYGZhy{}ve}
\PYG{n}{Y} \PYG{o}{=} \PYG{n}{y} \PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{n}{m} \PYG{o}{\PYGZhy{}} \PYG{n}{lag} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{m}\PYG{o}{\PYGZhy{}}\PYG{n}{lag}\PYG{p}{,}\PYG{n}{Y}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZhy{}3 0
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{scipy.stats} \PYG{k+kn}{import} \PYG{n}{linregress}

\PYG{c}{\PYGZsh{} examine an example row col}
\PYG{c}{\PYGZsh{} for a given month over all years}

\PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{24}
\PYG{n}{r} \PYG{o}{=} \PYG{l+m+mi}{19}
\PYG{n}{m} \PYG{o}{=} \PYG{n}{av\PYGZus{}fire\PYGZus{}month}\PYG{p}{[}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{]}
\PYG{c}{\PYGZsh{} pull the data}
\PYG{n}{yyears} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{n}{years}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{n}{years}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}

\PYG{n}{R2} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{n}{linregress}\PYG{p}{(}\PYGZbs{}
            \PYG{n}{ycdata}\PYG{p}{[}\PYG{n}{m}\PYG{o}{\PYGZhy{}}\PYG{n}{n}\PYG{p}{,}\PYG{n}{yyears} \PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{n}{m} \PYG{o}{\PYGZhy{}} \PYG{n}{n} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,}\PYGZbs{}
            \PYG{n}{ypeak\PYGZus{}count}\PYG{p}{[}\PYG{n}{yyears} \PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{n}{m} \PYG{o}{\PYGZhy{}} \PYG{n}{n} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{]}\PYGZbs{}
        \PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{k}{for} \PYG{n}{n} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{n} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{argmax}\PYG{p}{(}\PYG{n}{R2}\PYG{p}{)}

\PYG{n}{x}  \PYG{o}{=} \PYG{n}{ycdata}\PYG{p}{[}\PYG{n}{m}\PYG{o}{\PYGZhy{}}\PYG{n}{n}\PYG{p}{,}\PYG{n}{yyears} \PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{n}{m} \PYG{o}{\PYGZhy{}} \PYG{n}{n} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{]}
\PYG{n}{y} \PYG{o}{=} \PYG{n}{ypeak\PYGZus{}count}\PYG{p}{[}\PYG{n}{yyears} \PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{n}{m} \PYG{o}{\PYGZhy{}} \PYG{n}{n} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{]}
\PYG{n}{slope}\PYG{p}{,}\PYG{n}{intercept}\PYG{p}{,}\PYG{n}{R}\PYG{p}{,}\PYG{n}{p}\PYG{p}{,}\PYG{n}{err} \PYG{o}{=} \PYG{n}{linregress}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{)}

\PYG{k}{print} \PYG{n}{slope}\PYG{p}{,}\PYG{n}{intercept}\PYG{p}{,}\PYG{n}{p}\PYG{p}{,}\PYG{n}{err}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{ycdata}\PYG{p}{[}\PYG{n}{m}\PYG{o}{\PYGZhy{}}\PYG{n}{n}\PYG{p}{]}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r+}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Climate Index}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Fire count}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{x}\PYG{o}{.}\PYG{n}{min}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{x}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,}\PYGZbs{}
         \PYG{p}{[}\PYG{n}{intercept}\PYG{o}{+}\PYG{n}{slope}\PYG{o}{*}\PYG{n}{x}\PYG{o}{.}\PYG{n}{min}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{intercept}\PYG{o}{+}\PYG{n}{slope}\PYG{o}{*}\PYG{n}{x}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{k\PYGZhy{}\PYGZhy{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Fire count at r }\PYG{l+s+si}{\PYGZpc{}03d}\PYG{l+s}{ c }\PYG{l+s+si}{\PYGZpc{}03d}\PYG{l+s}{: R\PYGZca{}2 = }\PYG{l+s+si}{\PYGZpc{}.3f}\PYG{l+s}{: lag }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{,}\PYG{n}{R2}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{p}{,}\PYG{n}{n}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
11175.1548059 2691.89246835 0.0207363379213 3889.85050593
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.text.Text at 0x166679d0\PYGZgt{}
\end{Verbatim}

\includegraphics{ENSO_41_2.png}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} looper}

\PYG{n}{data\PYGZus{}mask} \PYG{o}{=} \PYG{n}{ypeak\PYGZus{}count}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{100}

\PYG{n}{rs}\PYG{p}{,}\PYG{n}{cs} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{where}\PYG{p}{(}\PYG{n}{data\PYGZus{}mask}\PYG{p}{)}

\PYG{n}{results} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{intercept}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{slope}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{p}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{R}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{stderr}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{lag}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{0}\PYG{p}{\PYGZcb{}}
\PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n}{results}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{results}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros\PYGZus{}like}\PYG{p}{(}\PYG{n}{av\PYGZus{}fire\PYGZus{}month}\PYG{p}{)}\PYG{o}{.}\PYG{n}{astype}\PYG{p}{(}\PYG{n+nb}{float}\PYG{p}{)}
    \PYG{n}{results}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]} \PYG{o}{=} \PYG{n}{ma}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{results}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{,}\PYG{n}{mask}\PYG{o}{=}\PYG{o}{\PYGZti{}}\PYG{n}{data\PYGZus{}mask}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{r}\PYG{p}{,}\PYG{n}{c} \PYG{o+ow}{in} \PYG{n+nb}{zip}\PYG{p}{(}\PYG{n}{rs}\PYG{p}{,}\PYG{n}{cs}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{m} \PYG{o}{=} \PYG{n}{av\PYGZus{}fire\PYGZus{}month}\PYG{p}{[}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{]}
    \PYG{c}{\PYGZsh{} pull the data}
    \PYG{n}{yyears} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{n}{years}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{n}{years}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{n}{R2} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYGZbs{}
            \PYG{n}{linregress}\PYG{p}{(}\PYGZbs{}
                \PYG{n}{ycdata}\PYG{p}{[}\PYG{n}{m}\PYG{o}{\PYGZhy{}}\PYG{n}{n}\PYG{p}{,}\PYG{n}{yyears} \PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{n}{m} \PYG{o}{\PYGZhy{}} \PYG{n}{n} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,}\PYGZbs{}
                \PYG{n}{ypeak\PYGZus{}count}\PYG{p}{[}\PYG{n}{yyears} \PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{n}{m} \PYG{o}{\PYGZhy{}} \PYG{n}{n} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{]}\PYGZbs{}
            \PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{k}{for} \PYG{n}{n} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}

    \PYG{n}{n} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{argmax}\PYG{p}{(}\PYG{n}{R2}\PYG{p}{)}
    \PYG{n}{results}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{lag}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{]} \PYG{o}{=} \PYG{n}{n}
    \PYG{n}{x}  \PYG{o}{=} \PYG{n}{ycdata}\PYG{p}{[}\PYG{n}{m}\PYG{o}{\PYGZhy{}}\PYG{n}{n}\PYG{p}{,}\PYG{n}{yyears} \PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{n}{m} \PYG{o}{\PYGZhy{}} \PYG{n}{n} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{]}
    \PYG{n}{y} \PYG{o}{=} \PYG{n}{ypeak\PYGZus{}count}\PYG{p}{[}\PYG{n}{yyears} \PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{n}{m} \PYG{o}{\PYGZhy{}} \PYG{n}{n} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{]}
    \PYG{n}{results}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{slope}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{]}\PYG{p}{,}\PYG{n}{results}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{intercept}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{]}\PYG{p}{,}\PYGZbs{}
    \PYG{n}{results}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{R}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{]}\PYG{p}{,}\PYG{n}{results}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{p}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{]}\PYG{p}{,}\PYGZbs{}
    \PYG{n}{results}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{stderr}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{]} \PYG{o}{=} \PYG{n}{linregress}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{results}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{R}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nearest}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{R}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{results}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{p}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nearest}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{p}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}


\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{results}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{slope}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nearest}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{slope}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}


\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{results}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{lag}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nearest}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{lag}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.text.Text at 0x6d69890\PYGZgt{}
\end{Verbatim}

\includegraphics{ENSO_43_1.png}

\includegraphics{ENSO_43_2.png}

\includegraphics{ENSO_43_3.png}

\includegraphics{ENSO_43_4.png}

which we can now predict:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} prediction year}
\PYG{n}{pyear} \PYG{o}{=} \PYG{l+m+mi}{2012}

\PYG{c}{\PYGZsh{} which month?}
\PYG{n}{M} \PYG{o}{=} \PYG{n}{av\PYGZus{}fire\PYGZus{}month} \PYG{o}{\PYGZhy{}} \PYG{n}{results}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{lag}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{Y} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros\PYGZus{}like}\PYG{p}{(}\PYG{n}{M}\PYG{p}{)} \PYG{o}{+} \PYG{n}{pyear}
\PYG{n}{Y}\PYG{p}{[}\PYG{n}{M}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{l+m+mi}{1}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} lets look at that ...}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{Y}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nearest}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.image.AxesImage at 0x7d6ab90\PYGZgt{}
\end{Verbatim}

\includegraphics{ENSO_46_1.png}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} climate data}
\PYG{n}{scdata} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros\PYGZus{}like}\PYG{p}{(}\PYG{n}{Y}\PYG{p}{)}\PYG{o}{.}\PYG{n}{astype}\PYG{p}{(}\PYG{n+nb}{float}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{y} \PYG{o+ow}{in} \PYG{p}{[}\PYG{n}{pyear}\PYG{p}{,}\PYG{n}{pyear}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{:}
    \PYG{k}{for} \PYG{n}{m} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{scdata}\PYG{p}{[}\PYG{p}{(}\PYG{n}{Y} \PYG{o}{==} \PYG{n}{y}\PYG{p}{)} \PYG{o}{\PYGZam{}} \PYG{p}{(}\PYG{n}{M} \PYG{o}{==} \PYG{n}{m}\PYG{p}{)}\PYG{p}{]} \PYG{o}{=} \PYG{n}{cdata}\PYG{p}{[}\PYG{n}{m}\PYG{p}{,}\PYG{n}{y}\PYG{o}{\PYGZhy{}}\PYG{n}{cyears}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{scdata}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nearest}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.image.AxesImage at 0x7d5a590\PYGZgt{}
\end{Verbatim}

\includegraphics{ENSO_47_1.png}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} now predict}

\PYG{n}{fc\PYGZus{}predict} \PYG{o}{=} \PYG{n}{results}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{intercept}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{+} \PYG{n}{results}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{slope}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{*} \PYG{n}{scdata}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{fc\PYGZus{}predict}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nearest}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{vmax}\PYG{o}{=}\PYG{l+m+mi}{10000}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{predicted peak fire count for }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{n}{pyear}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{peak\PYGZus{}count}\PYG{p}{[}\PYG{n}{pyear}\PYG{o}{\PYGZhy{}}\PYG{n}{min\PYGZus{}year}\PYG{p}{]}\PYG{p}{,}\PYGZbs{}
           \PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nearest}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{vmax}\PYG{o}{=}\PYG{l+m+mi}{10000}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{actual peak fire count for }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{n}{pyear}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.text.Text at 0x83ec750\PYGZgt{}
\end{Verbatim}

\includegraphics{ENSO_48_1.png}

\includegraphics{ENSO_48_2.png}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{=} \PYG{n}{peak\PYGZus{}count}\PYG{p}{[}\PYG{n}{pyear}\PYG{o}{\PYGZhy{}}\PYG{n}{min\PYGZus{}year}\PYG{p}{]}\PYG{o}{.}\PYG{n}{flatten}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{y} \PYG{o}{=} \PYG{n}{fc\PYGZus{}predict}\PYG{o}{.}\PYG{n}{flatten}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{slope}\PYG{p}{,}\PYG{n}{intercept}\PYG{p}{,}\PYG{n}{R}\PYG{p}{,}\PYG{n}{p}\PYG{p}{,}\PYG{n}{err} \PYG{o}{=} \PYG{n}{linregress}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{+}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{measured fire count}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{predicted fire count}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{cc} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{n}{x}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{cc}\PYG{p}{,}\PYG{n}{cc}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{k\PYGZhy{}\PYGZhy{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{cc}\PYG{p}{,}\PYG{n}{slope}\PYG{o}{*}\PYG{n}{cc}\PYG{o}{+}\PYG{n}{intercept}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{k\PYGZhy{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{fire count predictions}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{slope}\PYG{p}{,}\PYG{n}{intercept}\PYG{p}{,}\PYG{n}{R}\PYG{p}{,}\PYG{n}{p}\PYG{p}{,}\PYG{n}{err}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}class \PYGZsq{}numpy.ma.core.MaskedArray\PYGZsq{}\PYGZgt{}
0.802827703736 \PYGZhy{}6.97449131978 0.880785138861 0.0 0.00848080897451
\end{Verbatim}

\includegraphics{ENSO_49_1.png}


\chapter{Recollision Probability Theory}
\label{Chapter8_ptheory/Ptheory::doc}\label{Chapter8_ptheory/Ptheory:recollision-probability-theory}
A useful source of information quantifying vegetation amount is the Leaf
Area Index (LAI). To interpret LAI from satellite data, we build models
of radiative transfer.

One of the simplest such models that we can use at optical wavelengths
uses what is known as `p theory' or `recollision probability theory'
(Lewis and Disney, 2007; Huang et al., 2007).

\textbf{The task today is to use p-theory to estimate LAI over some
agricultural fields.}

References
\begin{itemize}
\item {} 
P. Lewis and M. Disney (2007) Spectral invariants and scattering
across multiple scales from within-leaf to canopy, \href{http://www2.geog.ucl.ac.uk/~mdisney/papers/lewis\_disney\_prospect.pdf}{Remote Sensing of
Environment 109,
196-206.}

\item {} 
D. Huang, Y. Knyazikhin, R.E. Dickinson, M. Rautiainen, P. Stenberg,
M. Disney, P. Lewis, A. Cescatti, Y. Tian, W. Verhoef, and R.B.
Myneni (2007), Canopy spectral invariants for remote sensing and
model applications, \href{http://www2.geog.ucl.ac.uk/~plewis/Huang\_Spectral\_Revised.pdf}{Remote Sensing of Environment, 106,
106-122}

\item {} 
Knyazikhin Y, Schull MA, Stenberg P, Mottus M, Rautiainen M, Yang Y,
Marshak A, Latorre Carmona P, Kaufmann RK, Lewis P, Disney MI,
Vanderbilt V, Davis AB, Baret F, Jacquemoud S, Lyapustin A, Myneni
RB. (2013) Hyperspectral remote sensing of foliar nitrogen content.
Proc Natl Acad Sci USA,
\href{http://cybele.bu.edu/download/manuscripts/knyazikhin-pnas-hypspec.pdf}{10.1073/pnas.1210196109}.

\end{itemize}


\chapter{Data}
\label{Chapter8_ptheory/Ptheory:data}
The dataset you have available is an airborne hyperspectral image
(HYMAP) dataset for which you have a 512x512 pixel subscene taken in 125
wavebands with a spatial resolution of 4m. The data were obtained on 17
June 2000 over Barton Bendish Farms, Norfolk during the BNSC/NERC SHAC
campaign.

The data are available as a compressed \emph{flat binary} file in the
directory \code{{}`files/data} \textless{}files/data\textgreater{}{}`\_\_.

First, uncompress the dataset:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{} or try zcat if gzcat isnt there
!gzcat files/data/bbHYMAP.dat.gz \PYGZgt{} files/data/bbHYMAP.dat
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
!ls \PYGZhy{}l files/data/bbHYMAP.dat
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{}r\PYGZhy{}\PYGZhy{}  1 plewis  staff  131072000 26 Nov 17:31 files/data/bbHYMAP.dat
\end{Verbatim}

The file is 131072000 bytes in 32 bit floating point format:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nbands =}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{131072000}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mi}{512}\PYG{o}{*}\PYG{l+m+mi}{512}\PYG{o}{*}\PYG{l+m+mi}{4}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{nbands} \PYG{o}{=} \PYG{l+m+mi}{125}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} we wuill use memmap to read the data in}
\PYG{k+kn}{from} \PYG{n+nn}{numpy} \PYG{k+kn}{import} \PYG{n}{memmap}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{hymap} \PYG{o}{=} \PYG{n}{memmap}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/bbHYMAP.dat}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{dtype}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{float32}\PYG{p}{,}\PYG{n}{mode}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{shape}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{125}\PYG{p}{,}\PYG{l+m+mi}{512}\PYG{p}{,}\PYG{l+m+mi}{512}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{hymap}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{,}\PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nearest}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.image.AxesImage at 0x10598edd0\PYGZgt{}
\end{Verbatim}

\includegraphics{Ptheory_10_1.png}

The wavelengths associated with each band are stored in
\code{{}`files/data/wavebands.dat} \textless{}files/data/wavebands.dat\textgreater{}{}`\_\_.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{mean} \PYG{o}{=} \PYG{n}{hymap}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{n}{axis}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{wavelength} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{loadtxt}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/wavebands.dat}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{wavelength}\PYG{p}{,}\PYG{n}{mean}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
[\PYGZlt{}matplotlib.lines.Line2D at 0x10f089790\PYGZgt{}]
\end{Verbatim}

\includegraphics{Ptheory_12_1.png}


\chapter{Theory}
\label{Chapter8_ptheory/Ptheory:theory}
The simplest form of model in p-theory assumes that the photon
recollision probability is constant with wavelength and scattering
order. Under this assumption, the total scattering from the canopy,
\(W\) is:
\begin{gather}
\begin{split}W = i_0 \frac{(1 - p) \omega}{1 - p \omega}\end{split}\notag
\end{gather}
where \(i_0\) is the canopy interception probability, \(\omega\)
is the leaf-level scattering (the leaf single scattering albedo) and
\(p\) is the recollision probability: the probability that a photon,
having intercepted a canopy element, will recollide with another element
rather than escape the canopy.

We can develop from this a model of the canopy \emph{reflectance}
\(\rho\) (i.e. that portion scattered upwards, perhaps in a
particular direction):
\begin{gather}
\begin{split}\rho = \frac{a \omega}{1 - p \omega}\end{split}\notag
\end{gather}
For a closed canopy, or one with only little soil influence, this will
describe the spectral reflectance for some given leaf single scattering
albedo spectrum and given \(p\).

If we know \(\omega\) then, and have a measurement of \(\rho\),
we can estimate \(p\). From \(p\), we can estimate LAI according
to Lewis and Disney (2007) by:
\begin{gather}
\begin{split}p = 0.88 \left( 1 - exp(- 0.7 LAI^{0.75}) \right)\end{split}\notag
\end{gather}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{LAI} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{12}\PYG{p}{,}\PYG{l+m+mf}{0.01}\PYG{p}{)}
\PYG{n}{p} \PYG{o}{=} \PYG{l+m+mf}{0.88}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.7} \PYG{o}{*} \PYG{n}{LAI}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mf}{0.75}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{LAI}\PYG{p}{,}\PYG{n}{p}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{LAI}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{p}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.text.Text at 0x10f12f0d0\PYGZgt{}
\end{Verbatim}

\includegraphics{Ptheory_15_1.png}

There are several ways we could estimate \(p\). An interesting
feature exploited by Knyazikhin et al. (2013) follows from:
\begin{gather}
\begin{split}\frac{\rho}{\omega} = \frac{a}{1 - p \omega}\end{split}\notag
\end{gather}
so
\begin{gather}
\begin{split}\frac{\rho}{\omega}  = a + p \rho\end{split}\notag
\end{gather}
So that if we plot \(\frac{\rho}{\omega}\) as a function of
\(\rho\), this theory predicts we should see a straight line.

An example leaf single scattering albedo is given in
\code{{}`files/data/ssalbedo.dat} \textless{}files/data/ssalbedo.dat\textgreater{}{}`\_\_:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{ssalbedo} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{loadtxt}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{files/data/ssalbedo.dat}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{T}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{ssalbedo}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{ssalbedo}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{wavelength / nm}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{single scattering albedo}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlim}\PYG{p}{(}\PYG{n}{ssalbedo}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{ssalbedo}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{l+m+mf}{400.0}\PYG{p}{,} \PYG{l+m+mf}{2400.0}\PYG{p}{)}
\end{Verbatim}

\includegraphics{Ptheory_17_1.png}

which is sampled every 1 nm from 400 to 2400 nm.

We will clearly need to resample this to the same wavebands as the
hyperspectral data:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{scipy.interpolate} \PYG{k+kn}{import} \PYG{n}{interp1d}
\PYG{k+kn}{from} \PYG{n+nn}{scipy.stats} \PYG{k+kn}{import} \PYG{n}{linregress}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{f} \PYG{o}{=} \PYG{n}{interp1d}\PYG{p}{(}\PYG{n}{ssalbedo}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{ssalbedo}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{omega} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{n}{wavelength}\PYG{p}{[}\PYG{n}{wavelength}\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{l+m+mi}{2400}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

The theory becomes more complicated when multiple absorbing constituents
are involved, so we select here only wavelengths between 710 and 790 nm
(on the `red edge'), where the main absorbing constituent is
chlorophyll.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} wavelength}
\PYG{n}{W} \PYG{o}{=} \PYG{p}{(}\PYG{n}{wavelength} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{710}\PYG{p}{)} \PYG{o}{\PYGZam{}} \PYG{p}{(}\PYG{n}{wavelength} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{790}\PYG{p}{)}

\PYG{n}{wave} \PYG{o}{=} \PYG{n}{wavelength}\PYG{p}{[}\PYG{n}{W}\PYG{p}{]}
\PYG{c}{\PYGZsh{} single scattering albedo}
\PYG{n}{omega} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{n}{wavelength}\PYG{p}{[}\PYG{n}{W}\PYG{p}{]}\PYG{p}{)}
\PYG{c}{\PYGZsh{} reflectance}
\PYG{n}{rho} \PYG{o}{=} \PYG{n}{hymap}\PYG{p}{[}\PYG{n}{W}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} lets see if its a straight line!}
\PYG{n}{mean} \PYG{o}{=} \PYG{n}{rho}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{n}{axis}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{mean}\PYG{p}{,}\PYG{n}{mean}\PYG{o}{/}\PYG{n}{omega}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{+}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{c}{\PYGZsh{} linear fit}
\PYG{n}{slope}\PYG{p}{,} \PYG{n}{intercept}\PYG{p}{,} \PYG{n}{r\PYGZus{}value}\PYG{p}{,} \PYG{n}{p\PYGZus{}value}\PYG{p}{,} \PYG{n}{std\PYGZus{}err} \PYG{o}{=} \PYG{n}{linregress}\PYG{p}{(}\PYG{n}{mean}\PYG{p}{,}\PYG{n}{mean}\PYG{o}{/}\PYG{n}{omega}\PYG{p}{)}
\PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{n}{mean}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{mean}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{x}\PYG{o}{*}\PYG{n}{slope}\PYG{o}{+}\PYG{n}{intercept}\PYG{p}{)}
\PYG{k}{print} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{slope}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{slope}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{intercept}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{intercept}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
slope 0.710882123721 intercept 0.125383329915
\end{Verbatim}

\includegraphics{Ptheory_23_1.png}

So, here, \(p\) is 0.71088

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{}p = 0.88*(1 \PYGZhy{} np.exp(\PYGZhy{}0.7 * LAI**0.75))}
\PYG{n}{LAI} \PYG{o}{=} \PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{log}\PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}} \PYG{n}{slope}\PYG{o}{/}\PYG{l+m+mf}{0.88}\PYG{p}{)}\PYG{o}{/}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.7}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mf}{4.}\PYG{o}{/}\PYG{l+m+mf}{3.}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{LAI}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{3.13529156174}
\end{Verbatim}

Following Knyazikhin et al. (2013) we can calculate the \code{DASF}
(Directional Area Scattering Function) from:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{DASF} \PYG{o}{=} \PYG{n}{intercept}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}} \PYG{n}{slope}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{DASF}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{0.43367546666}
\end{Verbatim}

and from that, \(W\):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{W} \PYG{o}{=} \PYG{n}{mean}\PYG{o}{/}\PYG{n}{DASF}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{wave}\PYG{p}{,}\PYG{n}{W}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{wave}\PYG{p}{,}\PYG{n}{omega}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
[\PYGZlt{}matplotlib.lines.Line2D at 0x11b5d1410\PYGZgt{}]
\end{Verbatim}

\includegraphics{Ptheory_29_1.png}

which in turn can give access to leaf biochemistry.


\chapter{The Task}
\label{Chapter8_ptheory/Ptheory:the-task}
The output of this exercise should be a spatial dataset of LAI.

The processing for this task is quite straightforward, and you \emph{should}
be able to develop a neat algorithm given the information above.

You should work in teams for this exercise as in previous weeks, and
assign tasks for people to complete after you have discussed an overall
algorithm and defined any interfaces you will need.

If you finish the task quickly, you could explore the impact of the the
leaf single scattering albedo assumed, and/or examine the impact of
widening the wavelength range used here.


\chapter{Read and use some different file formats}
\label{ChapterX_GDAL/GDAL_HDF::doc}\label{ChapterX_GDAL/GDAL_HDF:read-and-use-some-different-file-formats}
In this session, we will learn to use some geospatial tools using GDAL
in Python. A good set of working notes on how to use GDAL has been
developed that you will find useful for background reading.

\href{http://www.hdfgroup.org/HDF-FAQ.html}{HDF}(Hierarchical Data
Format) and \href{http://hdfeos.org/}{HDF-EOS} are common formats for EO
data so you need to have some idea how to use and manipulate them.

A hierarchical data format is essentially a format that packs together
various aspects of a dataset (metadata, raster data etc.) into a binary
file. There are many tools for manipulating and reading HDF in python,
but we will use one of the more generic tools,
\href{http://gdal.org}{gdal} here.

When using HDF files, we need to have some idea of the stucture of the
contents, although you can clearly explore that yourself in an
interactive session. MODIS products have extensive information available
to help you interpret the datasets, for example the MODIS LAI/fAPAR
product
\href{https://lpdaac.usgs.gov/products/modis\_products\_table/leaf\_area\_index\_fraction\_of\_photosynthetically\_active\_radiation/8\_day\_l4\_global\_1km/mod15a2}{MOD15A2}.
We will use this as an example to explore a dataset.

You will need access to the file
\code{{}`MCD15A2.A2011185.h09v05.005.2011213154534.hdf} \textless{}\href{http://www2.geog.ucl.ac.uk/~plewis/geogg122/\_images/MCD15A2.A2011185.h09v05.005.2011213154534.hdf}{http://www2.geog.ucl.ac.uk/\textasciitilde{}plewis/geogg122/\_images/MCD15A2.A2011185.h09v05.005.2011213154534.hdf}\textgreater{}{}`\_\_,
which you might access from the \href{https://lpdaac.usgs.gov/}{MODIS Land Products
site}

Before going into the Python coding for GDAL, it is worthwhile looking
over some of the tools that are provided with GDAL and that can be run
from the shell. In particular, we can use the \code{gdalinfo} program, that
takes a filename and will output a copious description of the data,
including metadata, but also geogrpahic projection, size, number of
bands, etc.

\begin{Verbatim}[commandchars=\\\{\}]
!gdalinfo MCD15A2.A2011185.h09v05.005.2011213154534.hdf
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
Driver: HDF4/Hierarchical Data Format Release 4
Files: MCD15A2.A2011185.h09v05.005.2011213154534.hdf
Size is 512, 512
Coordinate System is {}`\PYGZsq{}
Metadata:
  HDFEOSVersion=HDFEOS\PYGZus{}V2.9
  LOCALGRANULEID=MCD15A2.A2011185.h09v05.005.2011213154534.hdf
  PRODUCTIONDATETIME=2011\PYGZhy{}08\PYGZhy{}01T15:45:34.000Z
  DAYNIGHTFLAG=Day
  REPROCESSINGACTUAL=reprocessed
  LOCALVERSIONID=5.0.4
  REPROCESSINGPLANNED=further update is anticipated
  SCIENCEQUALITYFLAG=Not Investigated
  AUTOMATICQUALITYFLAGEXPLANATION=No automatic quality assessment is performed in the PGE
  AUTOMATICQUALITYFLAG=Passed
  SCIENCEQUALITYFLAGEXPLANATION=See http://landweb.nascom/nasa.gov/cgi\PYGZhy{}bin/QA\PYGZus{}WWW/qaFlagPage.cgi?sat=aqua the product Science Quality status.
  QAPERCENTMISSINGDATA=3
  QAPERCENTOUTOFBOUNDSDATA=3
  QAPERCENTCLOUDCOVER=23
  QAPERCENTINTERPOLATEDDATA=0
  PARAMETERNAME=MCD15A2
  VERSIONID=5
  SHORTNAME=MCD15A2
  INPUTPOINTER=MYD15A1.A2011192.h09v05.005.2011194222549.hdf, MYD15A1.A2011191.h09v05.005.2011194224921.hdf, MYD15A1.A2011190.h09v05.005.2011192044353.hdf, MYD15A1.A2011189.h09v05.005.2011191043320.hdf, MYD15A1.A2011188.h09v05.005.2011190043751.hdf, MYD15A1.A2011187.h09v05.005.2011189125127.hdf, MYD15A1.A2011186.h09v05.005.2011188044024.hdf, MYD15A1.A2011185.h09v05.005.2011187152544.hdf, MOD15A1.A2011192.h09v05.005.2011194044548.hdf, MOD15A1.A2011191.h09v05.005.2011193042953.hdf, MOD15A1.A2011190.h09v05.005.2011192045720.hdf, MOD15A1.A2011189.h09v05.005.2011191045425.hdf, MOD15A1.A2011188.h09v05.005.2011190045726.hdf, MOD15A1.A2011187.h09v05.005.2011189045204.hdf, MOD15A1.A2011186.h09v05.005.2011188195439.hdf, MOD15A1.A2011185.h09v05.005.2011210211523.hdf, MCD15A2\PYGZus{}ANC\PYGZus{}RI4.hdf
  GRINGPOINTLONGITUDE=\PYGZhy{}103.835851753394, \PYGZhy{}117.486656023174, \PYGZhy{}104.256722414513, \PYGZhy{}92.131858571552
  GRINGPOINTLATITUDE=29.8360532722546, 39.9999999964079, 40.0742066197196, 29.9009502428382
  GRINGPOINTSEQUENCENO=1, 2, 3, 4
  EXCLUSIONGRINGFLAG=N
  RANGEENDINGDATE=2011\PYGZhy{}07\PYGZhy{}11
  RANGEENDINGTIME=23:59:59
  RANGEBEGINNINGDATE=2011\PYGZhy{}07\PYGZhy{}04
  RANGEBEGINNINGTIME=00:00:00
  PGEVERSION=5.0.9
  ASSOCIATEDSENSORSHORTNAME=MODIS
  ASSOCIATEDPLATFORMSHORTNAME=Terra
  ASSOCIATEDINSTRUMENTSHORTNAME=MODIS
  ASSOCIATEDSENSORSHORTNAME=MODIS
  ASSOCIATEDPLATFORMSHORTNAME=Aqua
  ASSOCIATEDINSTRUMENTSHORTNAME=MODIS
  QAPERCENTGOODQUALITY=100
  QAPERCENTOTHERQUALITY=100
  HORIZONTALTILENUMBER=09
  VERTICALTILENUMBER=05
  TileID=51009005
  NDAYS\PYGZus{}COMPOSITED=16
  QAPERCENTGOODFPAR=100
  QAPERCENTGOODLAI=100
  QAPERCENTMAINMETHOD=100
  QAPERCENTEMPIRICALMODEL=0
  NORTHBOUNDINGCOORDINATE=39.9999999964079
  SOUTHBOUNDINGCOORDINATE=29.9999999973059
  EASTBOUNDINGCOORDINATE=\PYGZhy{}92.3664205550513
  WESTBOUNDINGCOORDINATE=\PYGZhy{}117.486656023174
  ALGORITHMPACKAGEACCEPTANCEDATE=10\PYGZhy{}01\PYGZhy{}2004
  ALGORITHMPACKAGEMATURITYCODE=Normal
  ALGORITHMPACKAGENAME=MCDPR\PYGZus{}15A2
  ALGORITHMPACKAGEVERSION=5
  GEOANYABNORMAL=False
  GEOESTMAXRMSERROR=50.0
  LONGNAME=MODIS/Terra+Aqua Leaf Area Index/FPAR 8\PYGZhy{}Day L4 Global 1km SIN Grid
  PROCESSINGCENTER=MODAPS
  SYSTEMFILENAME=MYD15A1.A2011192.h09v05.005.2011194222549.hdf, MYD15A1.A2011191.h09v05.005.2011194224921.hdf, MYD15A1.A2011190.h09v05.005.2011192044353.hdf, MYD15A1.A2011189.h09v05.005.2011191043320.hdf, MYD15A1.A2011188.h09v05.005.2011190043751.hdf, MYD15A1.A2011187.h09v05.005.2011189125127.hdf, MYD15A1.A2011186.h09v05.005.2011188044024.hdf, MYD15A1.A2011185.h09v05.005.2011187152544.hdf, MOD15A1.A2011192.h09v05.005.2011194044548.hdf, MOD15A1.A2011191.h09v05.005.2011193042953.hdf, MOD15A1.A2011190.h09v05.005.2011192045720.hdf, MOD15A1.A2011189.h09v05.005.2011191045425.hdf, MOD15A1.A2011188.h09v05.005.2011190045726.hdf, MOD15A1.A2011187.h09v05.005.2011189045204.hdf, MOD15A1.A2011186.h09v05.005.2011188195439.hdf, MOD15A1.A2011185.h09v05.005.2011210211523.hdf
  NUMBEROFGRANULES=1
  GRANULEDAYNIGHTFLAG=Day
  GRANULEBEGINNINGDATETIME=2011\PYGZhy{}07\PYGZhy{}29T21:15:23.000Z
  GRANULEENDINGDATETIME=2011\PYGZhy{}07\PYGZhy{}29T21:15:23.000Z
  CHARACTERISTICBINANGULARSIZE=30.0
  CHARACTERISTICBINSIZE=926.625433055556
  DATACOLUMNS=1200
  DATAROWS=1200
  GLOBALGRIDCOLUMNS=43200
  GLOBALGRIDROWS=21600
  NADIRDATARESOLUTION=1km
  MAXIMUMOBSERVATIONS=1
  SPSOPARAMETERS=5367, 2680
  PROCESSINGENVIRONMENT=Linux minion5559 2.6.18\PYGZhy{}238.12.1.el5PAE \PYGZsh{}1 SMP Tue May 31 14:02:45 EDT 2011 i686 i686 i386 GNU/Linux
  DESCRREVISION=5.0
  ENGINEERING\PYGZus{}DATA=
\PYGZsh{} MOD\PYGZus{}PR15A2 (Vers 5.0.4 Rele 10.18.2006 23:59)
\PYGZsh{} MUM API Vers 2.5.8 Rev 104 Rel. 11.15.2000 10:49 (pgs)
\PYGZsh{} (c) 2000 J.M. Glassy, NTSG,LLSD
\PYGZsh{} portions of MUM API by Petr Votava,NTSG Lab,U.Montana
\PYGZsh{} HOST ECS\PYGZus{}PGS\PYGZus{}VirtualHost PROCESS 19540618
\PYGZsh{} PLATFORM Sys genericunix Vers unknown Release unknown Node (no nodename available)
\PYGZsh{} INIT\PYGZhy{}TIME Mon Aug  1 11:45:14 2011

YEARDAY 185 COMPOSITE\PYGZus{}PERIOD  24 FIRSTDAY\PYGZus{}IN\PYGZus{}PERIOD 185
SDS[PGE34\PYGZus{}ISG\PYGZus{}MBRLUT] \PYGZpc{}ID 268697600 Rank   2 (664 120)
SDS[PGE34\PYGZus{}OUTFIELD\PYGZus{}PROP] \PYGZpc{}ID 268697601 Rank   2 (78 179)
SDS[PGE34\PYGZus{}BROWSEFIELD\PYGZus{}PROP] \PYGZpc{}ID 268697602 Rank   2 (77 164)
READANC SDS[PGE34\PYGZus{}ISG\PYGZus{}MBRLUT] RANK 2 (664 120)
READANC SDS[PGE34\PYGZus{}OUTFIELD\PYGZus{}PROP] RANK 2 (78 179)
READANC SDS[PGE34\PYGZus{}BROWSEFIELD\PYGZus{}PROP] RANK 2 (77 164)
READANC SDS[PGE34\PYGZus{}ECSMETA\PYGZus{}DICT] RANK 2 (73 110)
READANC SDS[PGE34\PYGZus{}RELEASE\PYGZus{}NOTES] RANK 2 (84 98)
FLDPROP SDSnam(PGE34\PYGZus{}OUTFIELD\PYGZus{}PROP)MoleName(PGE34\PYGZus{}OUTFIELD\PYGZus{}PROP)Status 3 Nelem 13962
BROWSE cvlBrwMol 0 Nelem 57600 Type 21 Status 3
BROWSE cvlBrwMol 1 Nelem 57600 Type 21 Status 3
BROWSE cvlBrwMol 2 Nelem 57600 Type 21 Status 3
BROWSE cvlBrwMol 3 Nelem 57600 Type 21 Status 3
BROWSE: NEW GRID ID 4194320
BROWSEFIELD  0 Sum 1725178 Average 29.951
BROWSEFIELD  1 Sum 581056 Average 10.0878
BROWSEFIELD  2 Sum 358279 Average 6.22012
BROWSEFIELD  3 Sum 8016362 Average 139.173
BROWSE\PYGZhy{}DONE: N\PYGZhy{}Pixels 57600 Invalid offsets: 0 OutOfRange 0

COMPOSITING FPAR FREQUENCIES
FPAR   0       34
FPAR   1       71
FPAR   2       21
FPAR   3       50
FPAR   4      221
FPAR   5      592
FPAR   6     4712
FPAR   7     1445
FPAR   8      522
FPAR   9     1210
FPAR  10    12969
FPAR  11    17195
FPAR  12    83945
FPAR  13   197436
FPAR  14    79525
FPAR  15    55842
FPAR  16    68815
FPAR  17    40112
FPAR  18    62851
FPAR  19    42180
FPAR  20    43324
FPAR  21    34354
FPAR  22    20947
FPAR  23    29184
FPAR  24    35510
FPAR  25    32078
FPAR  26    34318
FPAR  27    24998
FPAR  28    28379
FPAR  29    18195
FPAR  30    17813
FPAR  31    15146
FPAR  32    10109
FPAR  33    14734
FPAR  34    17210
FPAR  35    23089
FPAR  36    14491
FPAR  37    15924
FPAR  38    15249
FPAR  39    15657
FPAR  40     9683
FPAR  41     9847
FPAR  42     7833
FPAR  43    11433
FPAR  44    12093
FPAR  45    10148
FPAR  46     9235
FPAR  47    11742
FPAR  48    10464
FPAR  49     8277
FPAR  50     5914
FPAR  51     8763
FPAR  52     6712
FPAR  53     6807
FPAR  54     9616
FPAR  55     7249
FPAR  56     5771
FPAR  57     6052
FPAR  58     5514
FPAR  59     6665
FPAR  60     5731
FPAR  61     5195
FPAR  62     5484
FPAR  63     4754
FPAR  64     4820
FPAR  65     4963
FPAR  66     3775
FPAR  67     4243
FPAR  68     4047
FPAR  69     3461
FPAR  70     2613
FPAR  71     3143
FPAR  72     2812
FPAR  73     2463
FPAR  74     1918
FPAR  75     1894
FPAR  76     1938
FPAR  77     1574
FPAR  78     1329
FPAR  79     1287
FPAR  80     1165
FPAR  81     1210
FPAR  82     1268
FPAR  83     1501
FPAR  84     1562
FPAR  85     1466
FPAR  86     1875
FPAR  87     1865
FPAR  88     2695
FPAR  89     8083
FPAR  90     4573
FPAR  91      800
FPAR  92      830
FPAR  93      723
FPAR  94      446
FPAR  95      146
FPAR  96       59
FPAR  97       52
FPAR  98       26
FPAR  99        6
FPAR 100        1

COMPOSITING LAI FREQUENCIES
LAI    0      135
LAI    1     7017
LAI    2   333047
LAI    3   320752
LAI    4   116468
LAI    5   116636
LAI    6    95497
LAI    7    74899
LAI    8    46317
LAI    9    30182
LAI   10    38262
LAI   11    28509
LAI   12    20955
LAI   13    16270
LAI   14    18420
LAI   15    13305
LAI   16    13099
LAI   17    10446
LAI   18     6287
LAI   19     8236
LAI   20     6428
LAI   21     5986
LAI   22     5851
LAI   23     4651
LAI   24     3958
LAI   25     4149
LAI   26     3228
LAI   27     2795
LAI   28     2712
LAI   29     2032
LAI   30     1961
LAI   31     1927
LAI   32     1557
LAI   33     1448
LAI   34     1445
LAI   35     1123
LAI   36     1135
LAI   37      991
LAI   38      849
LAI   39      748
LAI   40      771
LAI   41      712
LAI   42      641
LAI   43      655
LAI   44      816
LAI   45      947
LAI   46      965
LAI   47      947
LAI   48      934
LAI   49      948
LAI   50      758
LAI   51      677
LAI   52      662
LAI   53      727
LAI   54      651
LAI   55      643
LAI   56      789
LAI   57      790
LAI   58      613
LAI   59      868
LAI   60      676
LAI   61      776
LAI   62     3217
LAI   63      796
LAI   64      608
LAI   65     2298
LAI   66     4179
LAI   67      166
LAI   68      123
LAI   69        5

COMPOSITING DAY INDEX FREQUENCIES
TILE\PYGZhy{}INDEX    0 Selection Frequency:   177256
TILE\PYGZhy{}INDEX    1 Selection Frequency:   143267
TILE\PYGZhy{}INDEX    2 Selection Frequency:   164215
TILE\PYGZhy{}INDEX    3 Selection Frequency:   128123
TILE\PYGZhy{}INDEX    4 Selection Frequency:   168637
TILE\PYGZhy{}INDEX    5 Selection Frequency:    99292
TILE\PYGZhy{}INDEX    6 Selection Frequency:   110562
TILE\PYGZhy{}INDEX    7 Selection Frequency:    61898
TILE\PYGZhy{}INDEX    8 Selection Frequency:    27366
TILE\PYGZhy{}INDEX    9 Selection Frequency:    89455
TILE\PYGZhy{}INDEX   10 Selection Frequency:    32747
TILE\PYGZhy{}INDEX   11 Selection Frequency:    73910
TILE\PYGZhy{}INDEX   12 Selection Frequency:    43557
TILE\PYGZhy{}INDEX   13 Selection Frequency:    26380
TILE\PYGZhy{}INDEX   14 Selection Frequency:    36942
TILE\PYGZhy{}INDEX   15 Selection Frequency:    14464

LOCALGRANULEID [MCD15A2.A2011185.h09v05.005.2011213154534.hdf]
ECS QC PERCENT N valid (demominator) : 1398071.000000
ECS Total Pixels       (denominator) : 1440000

QAPERCENTxx PSA BEFORE CALC
QAPERCENTINTERPOLATEDDATA: 0
QAPERCENTMISSINGDATA     : 41929
QAPERCENTOUTOFBOUNDSDATA : 41929
QAPERCENTCLOUDCOVER      : 334183
QAPERCENTNOTPRODUCEDCLOUD: 0
QAPERCENTNOTPRODUCEDOTHER: 0
QAPERCENTGOODQUALITY     : 1391137
QAPERCENTOTHERQUALITY    : 48863
QAPERCENTGOODFPAR        : 1391137
QAPERCENTGOODLAI         : 1391137
QAPERCENTMAINMETHOD      : 1391137
QAPERCENTEMPIRICALMODEL  : 6934
QAPERCENTNDAYSCOMPOSITED : 16
QAPERCENTTERRA           : 1052272


QAPERCENTxx PSA AFTER CALC
QAPERCENTINTERPOLATEDDATA: 0
QAPERCENTMISSINGDATA     : 3
QAPERCENTOUTOFBOUNDSDATA : 3
QAPERCENTCLOUDCOVER      : 23
QAPERCENTNOTPRODUCEDCLOUD: 0
QAPERCENTNOTPRODUCEDOTHER: 0
QAPERCENTGOODQUALITY     : 100
QAPERCENTOTHERQUALITY    : 100
QAPERCENTGOODFPAR        : 100
QAPERCENTGOODLAI         : 100
QAPERCENTMAINMETHOD      : 100
QAPERCENTEMPIRICALMODEL  : 0
QAPERCENTNDAYSCOMPOSITED : 16


SESSION ENGINEERING SUMMARY FOR PGE34 8\PYGZhy{}day FPAR,LAI
UM\PYGZus{}VERSION U.MONTANA MODIS PGE34 Vers 5.0.4 Rev 4 Release 10.18.2006 23:59
Candidate Days: 16

N. invalid loads      : 0
Pixels failing best day : 41929
Pixels set to fill      : 0
Pixels skipped (disqual): 1118070
Unclassified Pixels     : 41929
MOD15A1 DAILY Input: /MODAPSops8/archive/f5559/running/AMPM\PYGZus{}L10m/6913096/MOD15A1.A2011185.h09v05.005.2011210211523.hdf
MOD15A1 DAILY Input: /MODAPSops8/archive/f5559/running/AMPM\PYGZus{}L10m/6913096/MOD15A1.A2011186.h09v05.005.2011188195439.hdf
MOD15A1 DAILY Input: /MODAPSops8/archive/f5559/running/AMPM\PYGZus{}L10m/6913096/MOD15A1.A2011187.h09v05.005.2011189045204.hdf
MOD15A1 DAILY Input: /MODAPSops8/archive/f5559/running/AMPM\PYGZus{}L10m/6913096/MOD15A1.A2011188.h09v05.005.2011190045726.hdf
MOD15A1 DAILY Input: /MODAPSops8/archive/f5559/running/AMPM\PYGZus{}L10m/6913096/MOD15A1.A2011189.h09v05.005.2011191045425.hdf
MOD15A1 DAILY Input: /MODAPSops8/archive/f5559/running/AMPM\PYGZus{}L10m/6913096/MOD15A1.A2011190.h09v05.005.2011192045720.hdf
MOD15A1 DAILY Input: /MODAPSops8/archive/f5559/running/AMPM\PYGZus{}L10m/6913096/MOD15A1.A2011191.h09v05.005.2011193042953.hdf
MOD15A1 DAILY Input: /MODAPSops8/archive/f5559/running/AMPM\PYGZus{}L10m/6913096/MOD15A1.A2011192.h09v05.005.2011194044548.hdf
MOD15A1 DAILY Input: /MODAPSops8/archive/f5559/running/AMPM\PYGZus{}L10m/6913096/MYD15A1.A2011185.h09v05.005.2011187152544.hdf
MOD15A1 DAILY Input: /MODAPSops8/archive/f5559/running/AMPM\PYGZus{}L10m/6913096/MYD15A1.A2011186.h09v05.005.2011188044024.hdf
MOD15A1 DAILY Input: /MODAPSops8/archive/f5559/running/AMPM\PYGZus{}L10m/6913096/MYD15A1.A2011187.h09v05.005.2011189125127.hdf
MOD15A1 DAILY Input: /MODAPSops8/archive/f5559/running/AMPM\PYGZus{}L10m/6913096/MYD15A1.A2011188.h09v05.005.2011190043751.hdf
MOD15A1 DAILY Input: /MODAPSops8/archive/f5559/running/AMPM\PYGZus{}L10m/6913096/MYD15A1.A2011189.h09v05.005.2011191043320.hdf
MOD15A1 DAILY Input: /MODAPSops8/archive/f5559/running/AMPM\PYGZus{}L10m/6913096/MYD15A1.A2011190.h09v05.005.2011192044353.hdf
MOD15A1 DAILY Input: /MODAPSops8/archive/f5559/running/AMPM\PYGZus{}L10m/6913096/MYD15A1.A2011191.h09v05.005.2011194224921.hdf
MOD15A1 DAILY Input: /MODAPSops8/archive/f5559/running/AMPM\PYGZus{}L10m/6913096/MYD15A1.A2011192.h09v05.005.2011194222549.hdf

PGE34 Output       : /MODAPSx/archive/f5559/ops8/running/AMPM\PYGZus{}L10m/6913096/MCD15A2.1.2011\PYGZhy{}185T00:00:00.000000Z.51009005.8618434.215230\PYGZus{}1.hdf
MOD15A2 ANCILLARY    : /MODAPSops8/PGE/AMPM/coeff/PGE34/MCD15A2\PYGZus{}ANC\PYGZus{}RI4.hdf

QAPERCENTxx PSA AFTER CALC
QAPERCENTINTERPOLATEDDATA: 0
QAPERCENTMISSINGDATA     : 3
QAPERCENTOUTOFBOUNDSDATA : 3
QAPERCENTCLOUDCOVER      : 23
QAPERCENTTERRA          : 75
QAPERCENTGOODQUALITY     : 100
QAPERCENTOTHERQUALITY    : 100
QAPERCENTGOODFPAR        : 100
QAPERCENTGOODLAI         : 100
QAPERCENTMAINMETHOD      : 100
QAPERCENTEMPIRICALMODEL  : 0
QAPERCENTNDAYSCOMPOSITED : 16


Started Mon Aug  1 11:45:14 2011  Ended Mon Aug  1 11:45:34 2011
Elapsed Time          20 Sec (       0.33 Min)
  MOD15A2\PYGZus{}FILLVALUE\PYGZus{}DOC=MOD15A2 FILL VALUE LEGEND
255 = \PYGZus{}Fillvalue, assigned when:
    * the MODAGAGG suf. reflectance for channel VIS, NIR was assigned its \PYGZus{}Fillvalue, or
    * land cover pixel itself was assigned \PYGZus{}Fillvalus 255 or 254.
254 = land cover assigned as perennial salt or inland fresh water.
253 = land cover assigned as barren, sparse vegetation (rock, tundra, desert.)
252 = land cover assigned as perennial snow, ice.
251 = land cover assigned as \PYGZdq{}permanent\PYGZdq{} wetlands/inundated marshlands.
250 = land cover assigned as urban/built\PYGZhy{}up.
249 = land cover assigned as \PYGZdq{}unclassified\PYGZdq{} or not able to determine.

  MOD15A2\PYGZus{}FparLai\PYGZus{}QC\PYGZus{}DOC=
FparLai\PYGZus{}QC 5 BITFIELDS IN 8 BITWORD
MODLAND\PYGZus{}QC START 0 END 0 VALIDS 2
MODLAND\PYGZus{}QC   0 = Good Quality (main algorithm with or without saturation)
MODLAND\PYGZus{}QC   1 = Other Quality (back\PYGZhy{}up algorithm or fill value)
SENSOR START 1 END 1 VALIDS 2
SENSOR       0  = Terra
SENSOR       1  = Aqua
DEADDETECTOR START 2 END 2 VALIDS 2
DEADDETECTOR 0 = Detectors apparently fine for up to 50\PYGZpc{} of channels 1,2
DEADDETECTOR 1 = Dead detectors caused \PYGZgt{}50\PYGZpc{} adjacent detector retrieval
CLOUDSTATE START 3 END 4 VALIDS 4 (this inherited from Aggregate\PYGZus{}QC bits \PYGZob{}0,1\PYGZcb{} cloud state)
CLOUDSTATE   00 = 0 Significant clouds NOT present (clear)
CLOUDSTATE   01 = 1 Significant clouds WERE present
CLOUDSTATE   10 = 2 Mixed cloud present on pixel
CLOUDSTATE   11 = 3 Cloud state not defined,assumed clear
SCF\PYGZus{}QC START 5 END 7 VALIDS 5
SCF\PYGZus{}QC       000=0 Main (RT) algorithm used, best result possible (no saturation)
SCF\PYGZus{}QC       001=1 Main (RT) algorithm used, saturation occured. Good, very usable.
SCF\PYGZus{}QC       010=2 Main algorithm failed due to bad geometry, empirical algorithm used
SCF\PYGZus{}QC       011=3 Main algorithm faild due to problems other than geometry, empirical algorithm used
SCF\PYGZus{}QC       100=4 Pixel not produced at all, value coudn\PYGZsq{}t be retrieved (possible reasons: bad L1B data, unusable MODAGAGG data)

  MOD15A2\PYGZus{}FparExtra\PYGZus{}QC\PYGZus{}DOC=
FparExtra\PYGZus{}QC 6 BITFIELDS IN 8 BITWORD
LANDSEA PASS\PYGZhy{}THROUGH START 0 END 1 VALIDS 4
LANDSEA   00 = 0 LAND       AggrQC(3,5)values\PYGZob{}001\PYGZcb{}
LANDSEA   01 = 1 SHORE      AggrQC(3,5)values\PYGZob{}000,010,100\PYGZcb{}
LANDSEA   10 = 2 FRESHWATER AggrQC(3,5)values\PYGZob{}011,101\PYGZcb{}
LANDSEA   11 = 3 OCEAN      AggrQC(3,5)values\PYGZob{}110,111\PYGZcb{}
SNOW\PYGZus{}ICE (from Aggregate\PYGZus{}QC bits) START 2 END 2 VALIDS 2
SNOW\PYGZus{}ICE  0 = No snow/ice detected
SNOW\PYGZus{}ICE  1 = Snow/ice were detected
AEROSOL START 3 END 3 VALIDS 2
AEROSOL   0 = No or low atmospheric aerosol levels detected
AEROSOL   1 = Average or high aerosol levels detected
CIRRUS (from Aggregate\PYGZus{}QC bits \PYGZob{}8,9\PYGZcb{} ) START 4 END 4 VALIDS 2
CIRRUS    0 = No cirrus detected
CIRRUS    1 = Cirrus was detected
INTERNAL\PYGZus{}CLOUD\PYGZus{}MASK START 5 END 5 VALIDS 2
INTERNAL\PYGZus{}CLOUD\PYGZus{}MASK 0 = No clouds
INTERNAL\PYGZus{}CLOUD\PYGZus{}MASK 1 = Clouds were detected
CLOUD\PYGZus{}SHADOW START 6 END 6 VALIDS 2
CLOUD\PYGZus{}SHADOW        0 = No cloud shadow detected
CLOUD\PYGZus{}SHADOW        1 = Cloud shadow detected
SCF\PYGZus{}BIOME\PYGZus{}MASK START 7 END 7 VALIDS 2
SCF\PYGZus{}BIOME\PYGZus{}MASK  0 = Biome outside interval \PYGZlt{}1,4\PYGZgt{}
SCF\PYGZus{}BIOME\PYGZus{}MASK  1 = Biome in interval \PYGZlt{}1,4\PYGZgt{}

  MOD15A2\PYGZus{}StdDev\PYGZus{}QC\PYGZus{}DOC=MOD15A2 STANDARD DEVIATION FILL VALUE LEGEND
255 = \PYGZus{}Fillvalue, assigned when:
    * the MODAGAGG suf. reflectance for channel VIS, NIR was assigned its \PYGZus{}Fillvalue, or
    * land cover pixel itself was assigned \PYGZus{}Fillvalus 255 or 254.
254 = land cover assigned as perennial salt or inland fresh water.
253 = land cover assigned as barren, sparse vegetation (rock, tundra, desert.)
252 = land cover assigned as perennial snow, ice.
251 = land cover assigned as \PYGZdq{}permanent\PYGZdq{} wetlands/inundated marshlands.
250 = land cover assigned as urban/built\PYGZhy{}up.
249 = land cover assigned as \PYGZdq{}unclassified\PYGZdq{} or not able to determine.
248 = no standard deviation available, pixel produced using backup method.

  MOD15A1\PYGZus{}ANC\PYGZus{}BUILD\PYGZus{}CERT=mtAncUtil v. 1.8 Rel. 09.11.2000 17:36 API v. 2.5.6 release 09.14.2000 16:33 Rev.Index 102 (J.Glassy)

  UM\PYGZus{}VERSION=U.MONTANA MODIS PGE34 Vers 5.0.4 Rev 4 Release 10.18.2006 23:59
Subdatasets:
  SUBDATASET\PYGZus{}1\PYGZus{}NAME=HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:\PYGZdq{}MCD15A2.A2011185.h09v05.005.2011213154534.hdf\PYGZdq{}:MOD\PYGZus{}Grid\PYGZus{}MOD15A2:Fpar\PYGZus{}1km
  SUBDATASET\PYGZus{}1\PYGZus{}DESC=[1200x1200] Fpar\PYGZus{}1km MOD\PYGZus{}Grid\PYGZus{}MOD15A2 (8\PYGZhy{}bit unsigned integer)
  SUBDATASET\PYGZus{}2\PYGZus{}NAME=HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:\PYGZdq{}MCD15A2.A2011185.h09v05.005.2011213154534.hdf\PYGZdq{}:MOD\PYGZus{}Grid\PYGZus{}MOD15A2:Lai\PYGZus{}1km
  SUBDATASET\PYGZus{}2\PYGZus{}DESC=[1200x1200] Lai\PYGZus{}1km MOD\PYGZus{}Grid\PYGZus{}MOD15A2 (8\PYGZhy{}bit unsigned integer)
  SUBDATASET\PYGZus{}3\PYGZus{}NAME=HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:\PYGZdq{}MCD15A2.A2011185.h09v05.005.2011213154534.hdf\PYGZdq{}:MOD\PYGZus{}Grid\PYGZus{}MOD15A2:FparLai\PYGZus{}QC
  SUBDATASET\PYGZus{}3\PYGZus{}DESC=[1200x1200] FparLai\PYGZus{}QC MOD\PYGZus{}Grid\PYGZus{}MOD15A2 (8\PYGZhy{}bit unsigned integer)
  SUBDATASET\PYGZus{}4\PYGZus{}NAME=HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:\PYGZdq{}MCD15A2.A2011185.h09v05.005.2011213154534.hdf\PYGZdq{}:MOD\PYGZus{}Grid\PYGZus{}MOD15A2:FparExtra\PYGZus{}QC
  SUBDATASET\PYGZus{}4\PYGZus{}DESC=[1200x1200] FparExtra\PYGZus{}QC MOD\PYGZus{}Grid\PYGZus{}MOD15A2 (8\PYGZhy{}bit unsigned integer)
  SUBDATASET\PYGZus{}5\PYGZus{}NAME=HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:\PYGZdq{}MCD15A2.A2011185.h09v05.005.2011213154534.hdf\PYGZdq{}:MOD\PYGZus{}Grid\PYGZus{}MOD15A2:FparStdDev\PYGZus{}1km
  SUBDATASET\PYGZus{}5\PYGZus{}DESC=[1200x1200] FparStdDev\PYGZus{}1km MOD\PYGZus{}Grid\PYGZus{}MOD15A2 (8\PYGZhy{}bit unsigned integer)
  SUBDATASET\PYGZus{}6\PYGZus{}NAME=HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:\PYGZdq{}MCD15A2.A2011185.h09v05.005.2011213154534.hdf\PYGZdq{}:MOD\PYGZus{}Grid\PYGZus{}MOD15A2:LaiStdDev\PYGZus{}1km
  SUBDATASET\PYGZus{}6\PYGZus{}DESC=[1200x1200] LaiStdDev\PYGZus{}1km MOD\PYGZus{}Grid\PYGZus{}MOD15A2 (8\PYGZhy{}bit unsigned integer)
Corner Coordinates:
Upper Left  (    0.0,    0.0)
Lower Left  (    0.0,  512.0)
Upper Right (  512.0,    0.0)
Lower Right (  512.0,  512.0)
Center      (  256.0,  256.0)
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{} Filter lines that do not have BOUNDINGCOORDINATE in them
!gdalinfo MCD15A2.A2011185.h09v05.005.2011213154534.hdf \textbar{} grep BOUNDINGCOORDINATE
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{NORTHBOUNDINGCOORDINATE}\PYG{o}{=}\PYG{l+m+mf}{39.9999999964079}
\PYG{n}{SOUTHBOUNDINGCOORDINATE}\PYG{o}{=}\PYG{l+m+mf}{29.9999999973059}
\PYG{n}{EASTBOUNDINGCOORDINATE}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{92.3664205550513}
\PYG{n}{WESTBOUNDINGCOORDINATE}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{117.486656023174}
\end{Verbatim}

We can check this against e.g. the \href{http://remotesensing.unh.edu/modis/modis.shtml}{UNH MODIS tile
calculator}, just to
confirm that we have interpreted the coordinates correctly.

We can apply other shell GDAL tools, e.g. to perform a reprojection from
the native \href{http://modis-land.gsfc.nasa.gov/MODLAND\_grid.html}{MODIS
sinusoidal}
projection, to the \href{http://spatialreference.org/ref/sr-org/7271/}{Contiguous United States NAD27 Albers Equal
Area}:

\begin{Verbatim}[commandchars=\\\{\}]
!gdalwarp \PYGZhy{}of GTiff \PYGZbs{}
    \PYGZhy{}t\PYGZus{}srs \PYGZsq{}+proj=aea +lat\PYGZus{}1=29.5 +lat\PYGZus{}2=45.5 +lat\PYGZus{}0=23 +lon\PYGZus{}0=\PYGZhy{}96 +x\PYGZus{}0=0 +y\PYGZus{}0=0 +ellps=clrk66 +units=m +no\PYGZus{}defs\PYGZsq{}  \PYGZbs{}
    \PYGZhy{}tr 1000 1000 \PYGZbs{}
    \PYGZsq{}HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:MCD15A2.A2011185.h09v05.005.2011213154534.hdf:MOD\PYGZus{}Grid\PYGZus{}MOD15A2:Lai\PYGZus{}1km\PYGZsq{} output\PYGZus{}file.tif
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
Creating output file that is 2152P x 1323L.
Processing input file HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:MCD15A2.A2011185.h09v05.005.2011213154534.hdf:MOD\PYGZus{}Grid\PYGZus{}MOD15A2:Lai\PYGZus{}1km.
Using internal nodata values (eg. 255) for image HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:MCD15A2.A2011185.h09v05.005.2011213154534.hdf:MOD\PYGZus{}Grid\PYGZus{}MOD15A2:Lai\PYGZus{}1km.
0...10...20...30...40...50...60...70...80...90...100 \PYGZhy{} done.
\end{Verbatim}

where \code{MCD15A2.A2011185.h09v05.005.2011213154534.hdf} is the name of
the input HDF file, \code{MOD\_Grid\_MOD15A2:Lai\_1km} is the data product we
want, and the rather menacing string
\code{+proj=aea +lat\_1=29.5 +lat\_2=45.5 +lat\_0=23 +lon\_0=-96 +x\_0=0 +y\_0=0 +ellps=clrk66 +units=m +no\_defs}
specifies the projection in Proj4 format. You can typically find the
projection you want on
\href{http://spatialreference.org}{spatialreference.org}, and just copy
and paste the contents of \href{http://spatialreference.org/ref/sr-org/7271/proj4/}{Proj4
definition}
(remember to surround it by quotes). The option \code{-tr xres yres}
specifies the desired resolution of the output dataset (1000 by 1000 m
in the case above). \code{-of GTiff} specifies the GeoTiff format to be
used as as output.

Having some idea what information is in the hdf file then, we can
proceed to read the data in inside Python using the GDAL library:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{gdal} \PYG{c}{\PYGZsh{} Import GDAL library bindings}

\PYG{c}{\PYGZsh{} The file that we shall be using}
\PYG{c}{\PYGZsh{} Needs to be on current directory}
\PYG{n}{filename} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MCD15A2.A2011185.h09v05.005.2011213154534.hdf}\PYG{l+s}{\PYGZsq{}}

\PYG{n}{g} \PYG{o}{=} \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{Open}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{)}
\PYG{c}{\PYGZsh{} g should now be a GDAL dataset, but if the file isn\PYGZsq{}t found}
\PYG{c}{\PYGZsh{} g will be none. Let\PYGZsq{}s test this:}
\PYG{k}{if} \PYG{n}{g} \PYG{o+ow}{is} \PYG{n+nb+bp}{None}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Problem opening file }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{!}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n}{filename}
\PYG{k}{else}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{File }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{ opened fine}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n}{filename}


\PYG{n}{subdatasets} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{GetSubDatasets}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{fname}\PYG{p}{,} \PYG{n}{name} \PYG{o+ow}{in} \PYG{n}{subdatasets}\PYG{p}{:}
    \PYG{k}{print} \PYG{n}{name}
    \PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{fname}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
File MCD15A2.A2011185.h09v05.005.2011213154534.hdf opened fine
[1200x1200] Fpar\PYGZus{}1km MOD\PYGZus{}Grid\PYGZus{}MOD15A2 (8\PYGZhy{}bit unsigned integer)
    HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:\PYGZdq{}MCD15A2.A2011185.h09v05.005.2011213154534.hdf\PYGZdq{}:MOD\PYGZus{}Grid\PYGZus{}MOD15A2:Fpar\PYGZus{}1km
[1200x1200] Lai\PYGZus{}1km MOD\PYGZus{}Grid\PYGZus{}MOD15A2 (8\PYGZhy{}bit unsigned integer)
    HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:\PYGZdq{}MCD15A2.A2011185.h09v05.005.2011213154534.hdf\PYGZdq{}:MOD\PYGZus{}Grid\PYGZus{}MOD15A2:Lai\PYGZus{}1km
[1200x1200] FparLai\PYGZus{}QC MOD\PYGZus{}Grid\PYGZus{}MOD15A2 (8\PYGZhy{}bit unsigned integer)
    HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:\PYGZdq{}MCD15A2.A2011185.h09v05.005.2011213154534.hdf\PYGZdq{}:MOD\PYGZus{}Grid\PYGZus{}MOD15A2:FparLai\PYGZus{}QC
[1200x1200] FparExtra\PYGZus{}QC MOD\PYGZus{}Grid\PYGZus{}MOD15A2 (8\PYGZhy{}bit unsigned integer)
    HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:\PYGZdq{}MCD15A2.A2011185.h09v05.005.2011213154534.hdf\PYGZdq{}:MOD\PYGZus{}Grid\PYGZus{}MOD15A2:FparExtra\PYGZus{}QC
[1200x1200] FparStdDev\PYGZus{}1km MOD\PYGZus{}Grid\PYGZus{}MOD15A2 (8\PYGZhy{}bit unsigned integer)
    HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:\PYGZdq{}MCD15A2.A2011185.h09v05.005.2011213154534.hdf\PYGZdq{}:MOD\PYGZus{}Grid\PYGZus{}MOD15A2:FparStdDev\PYGZus{}1km
[1200x1200] LaiStdDev\PYGZus{}1km MOD\PYGZus{}Grid\PYGZus{}MOD15A2 (8\PYGZhy{}bit unsigned integer)
    HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:\PYGZdq{}MCD15A2.A2011185.h09v05.005.2011213154534.hdf\PYGZdq{}:MOD\PYGZus{}Grid\PYGZus{}MOD15A2:LaiStdDev\PYGZus{}1km
\end{Verbatim}

In the previous code snippet we have done a number of different things:
\begin{enumerate}
\item {} 
Import the GDAL library

\item {} 
Open a file with GDAL, storing a handler to the file in \code{g}

\item {} 
Test that \code{g} is not \code{None} (as this indicates failure opening
the file. Try changing \code{filename} above to something else)

\item {} 
We then use the \code{GetSubDatasets()} method to read out information
on the different subdatasets available from this file (compare to the
output of \code{gdalinfo} on the shelf earlier)

\item {} 
Loop over the retrieved subdatasets to print the name (human-readable
information) and the GDAL filename. This last item is the filename
that you need to use to tell GDAL to open a particular data layer of
the 6 layers present in this example

\end{enumerate}

Let's say that we want to access the LAI information. By contrasting the
output of the above code (or \code{gdalinfo}) to the contents of the
\href{https://lpdaac.usgs.gov/products/modis\_products\_table/leaf\_area\_index\_fraction\_of\_photosynthetically\_active\_radiation/8\_day\_l4\_global\_1km/mod15a2}{LAI/fAPAR product information
page},
we find out that we want the layers for \code{Lai\_1km}, \code{FparLai\_Qc},
\code{FparExtra\_QC} and \code{LaiStdDev\_1km}.

To read these individual datasets, we need to open each of them
individually using GDAL, and the GDAL filenames used above:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} Let\PYGZsq{}s create a list with the selected layer names}
\PYG{n}{selected\PYGZus{}layers} \PYG{o}{=} \PYG{p}{[}  \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{FparLai\PYGZus{}QC}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{FparExtra\PYGZus{}QC}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}  \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{LaiStdDev\PYGZus{}1km}\PYG{l+s}{\PYGZdq{}} \PYG{p}{]}
\PYG{c}{\PYGZsh{} We will store the data in a dictionary}
\PYG{c}{\PYGZsh{} Initialise an empty dictionary}
\PYG{n}{data} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{c}{\PYGZsh{} for convenience, we will use string substitution to create a}
\PYG{c}{\PYGZsh{} template for GDAL filenames, which we\PYGZsq{}ll substitute on the fly:}
\PYG{n}{file\PYGZus{}template} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{:MOD\PYGZus{}Grid\PYGZus{}MOD15A2:}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZsq{}}
\PYG{k}{for} \PYG{n}{i}\PYG{p}{,} \PYG{n}{layer} \PYG{o+ow}{in} \PYG{n+nb}{enumerate} \PYG{p}{(} \PYG{n}{selected\PYGZus{}layers} \PYG{p}{)}\PYG{p}{:}
    \PYG{n}{this\PYGZus{}file} \PYG{o}{=} \PYG{n}{file\PYGZus{}template} \PYG{o}{\PYGZpc{}} \PYG{p}{(} \PYG{n}{filename}\PYG{p}{,} \PYG{n}{layer} \PYG{p}{)}
    \PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Opening Layer }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{: }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{this\PYGZus{}file} \PYG{p}{)}
    \PYG{n}{g} \PYG{o}{=} \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{Open} \PYG{p}{(} \PYG{n}{this\PYGZus{}file} \PYG{p}{)}

    \PYG{k}{if} \PYG{n}{g} \PYG{o+ow}{is} \PYG{n+nb+bp}{None}\PYG{p}{:}
        \PYG{k}{raise} \PYG{n+ne}{IOError}
    \PYG{n}{data}\PYG{p}{[}\PYG{n}{layer}\PYG{p}{]} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{ReadAsArray}\PYG{p}{(}\PYG{p}{)}
    \PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZgt{}\PYGZgt{}\PYGZgt{} Read }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{!}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n}{layer}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
Opening Layer 1: HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:\PYGZdq{}MCD15A2.A2011185.h09v05.005.2011213154534.hdf\PYGZdq{}:MOD\PYGZus{}Grid\PYGZus{}MOD15A2:Lai\PYGZus{}1km
    \PYGZgt{}\PYGZgt{}\PYGZgt{} Read Lai\PYGZus{}1km!
Opening Layer 2: HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:\PYGZdq{}MCD15A2.A2011185.h09v05.005.2011213154534.hdf\PYGZdq{}:MOD\PYGZus{}Grid\PYGZus{}MOD15A2:FparLai\PYGZus{}QC
    \PYGZgt{}\PYGZgt{}\PYGZgt{} Read FparLai\PYGZus{}QC!
Opening Layer 3: HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:\PYGZdq{}MCD15A2.A2011185.h09v05.005.2011213154534.hdf\PYGZdq{}:MOD\PYGZus{}Grid\PYGZus{}MOD15A2:FparExtra\PYGZus{}QC
    \PYGZgt{}\PYGZgt{}\PYGZgt{} Read FparExtra\PYGZus{}QC!
Opening Layer 4: HDF4\PYGZus{}EOS:EOS\PYGZus{}GRID:\PYGZdq{}MCD15A2.A2011185.h09v05.005.2011213154534.hdf\PYGZdq{}:MOD\PYGZus{}Grid\PYGZus{}MOD15A2:LaiStdDev\PYGZus{}1km
    \PYGZgt{}\PYGZgt{}\PYGZgt{} Read LaiStdDev\PYGZus{}1km!
\end{Verbatim}

In the previous code, we have seen a way of neatly creating the
filenames required by GDAL to access the independent datasets: a
template string that gets substituted with the \code{filename} and the
\code{layer} name. Note that the presence of double quotes in the template
requires us to use single quotes around it. The data is now stored in a
dictionary, and can be accessed as e.g. \code{data{[}'Lai\_1km'{]}}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{n}{read\PYGZus{}data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
[[ 3  3  2 ...,  6  8 21]
 [ 4  3  6 ...,  8 18 14]
 [ 3 12 11 ..., 12  8  8]
 ...,
 [ 2  3  2 ..., 18 11 17]
 [ 2  3  3 ..., 16 19 15]
 [ 3  2  2 ..., 15 16 15]]
\end{Verbatim}

Now we have to translate the LAI values into meaningful quantities.
According to the
\href{https://lpdaac.usgs.gov/products/modis\_products\_table/leaf\_area\_index\_fraction\_of\_photosynthetically\_active\_radiation/8\_day\_l4\_global\_1km/mod15a2}{LAI}
webpage, there is a scale factor of 0.1 involved for LAI and SD LAI:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{lai} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Lai\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{*} \PYG{l+m+mf}{0.1}
\PYG{n}{lai\PYGZus{}sd} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{LaiStdDev\PYGZus{}1km}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{*} \PYG{l+m+mf}{0.1}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{LAI}\PYG{l+s}{\PYGZdq{}}
\PYG{k}{print} \PYG{n}{lai}
\PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{SD}\PYG{l+s}{\PYGZdq{}}
\PYG{k}{print} \PYG{n}{lai\PYGZus{}sd}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
LAI
[[ 0.3  0.3  0.2 ...,  0.6  0.8  2.1]
 [ 0.4  0.3  0.6 ...,  0.8  1.8  1.4]
 [ 0.3  1.2  1.1 ...,  1.2  0.8  0.8]
 ...,
 [ 0.2  0.3  0.2 ...,  1.8  1.1  1.7]
 [ 0.2  0.3  0.3 ...,  1.6  1.9  1.5]
 [ 0.3  0.2  0.2 ...,  1.5  1.6  1.5]]
SD
[[ 0.2  0.2  0.1 ...,  0.2  0.1  0.3]
 [ 0.2  0.2  0.2 ...,  0.2  0.3  0.2]
 [ 0.   0.1  0.2 ...,  0.1  0.2  0.2]
 ...,
 [ 0.1  0.1  0.1 ...,  0.3  0.   0.1]
 [ 0.1  0.1  0.1 ...,  0.2  0.2  0.1]
 [ 0.1  0.1  0.1 ...,  0.1  0.2  0.1]]
\end{Verbatim}

Some SD values are clearly given as 0.0, which is unlikely to be true.
We should then examine the QC (Quality Control) information. The codes
for this are also given on the LAI product page. They are described as
bit combinations:

Bit No.

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}th\PYGZgt{}Parameter Name\PYGZlt{}/th\PYGZgt{}\PYGZlt{}th\PYGZgt{} Bit Combination\PYGZlt{}/th\PYGZgt{}\PYGZlt{}th\PYGZgt{}Explanation\PYGZlt{}/th\PYGZgt{}
\end{Verbatim}

0

MODLAND\_QC bits

0

Good quality (main algorithm with or without saturation)

1

Other Quality (back-up algorithm or fill values)

1

Sensor

\begin{Verbatim}[commandchars=\\\{\}]
0\PYGZlt{}/td\PYGZgt{}\PYGZlt{}td\PYGZgt{}  TERRA\PYGZlt{}/td\PYGZgt{}
\end{Verbatim}

1

AQUA

2

DeadDetector

0

Detectors apparently fine for up to 50\% of channels 1 2

1

Dead detectors caused \textgreater{}50\% adjacent detector retrieval

3-4

CloudState

00

Significant clouds NOT present (clear)

01

Significant clouds WERE present

10

Mixed clouds present on pixel

11

Cloud state not defined assumed clear

5-7

CF\_QC

000

\begin{Verbatim}[commandchars=\\\{\}]
Main (RT) method used   best result possible (no saturation)     \PYGZlt{}/td\PYGZgt{}
\end{Verbatim}

001

Main (RT) method used with saturation. Good very usable

010

Main (RT) method failed due to bad geometry empirical algorithm used

011

Main (RT) method failed due to problems other than geometry empirical
algorithm used

100

Pixel not produced at all value coudnt be retrieved (possible reasons:
bad L1B data unusable MODAGAGG data)

In using this information, it is up to the use which data he/she wants
to pass through for any further processing. There are clearly
trade-offs: if you look for only the highest quality data, then the
number of samples is likely to be lower than if you were more tolerant.
But if you are too tolerant, you will get spurious results. You may find
useful information on how to convert from actual QA flags to diagnostics
in \href{http://gis.cri.fmach.it/modis-ndvi-evi/}{this page} (they focus
on NDVI/EVI, but the theory is the same).

But let's just say that we want to use only the highest quality data.
From the table above, these data are given by the \code{CF\_QC} flag being
set to \code{000} or \code{001}, or in other words \code{00000000} and
\code{00000001}, or 0 and 1 in decimal:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{pylab} \PYG{k+kn}{as} \PYG{n+nn}{plt}

\PYG{n}{qc} \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{FparLai\PYGZus{}QC}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]} \PYG{c}{\PYGZsh{} Get the QC data}
\PYG{c}{\PYGZsh{} Create a mask like the LAI product}
\PYG{n}{mask} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros\PYGZus{}like}\PYG{p}{(}\PYG{n}{lai}\PYG{p}{)}\PYG{o}{.}\PYG{n}{astype}\PYG{p}{(}\PYG{n+nb}{bool}\PYG{p}{)}
\PYG{c}{\PYGZsh{} Fill the mask where the conditions are met}
\PYG{n}{mask} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{where} \PYG{p}{(} \PYG{n}{qc} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n+nb+bp}{True}\PYG{p}{,} \PYG{n+nb+bp}{False} \PYG{p}{)}
\PYG{n}{mask} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{where} \PYG{p}{(} \PYG{n}{qc} \PYG{o}{==} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n+nb+bp}{True}\PYG{p}{,} \PYG{n}{mask} \PYG{p}{)}

\PYG{c}{\PYGZsh{} Select a black/white colormap}
\PYG{n}{cmap} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{cm}\PYG{o}{.}\PYG{n}{gray}
\PYG{c}{\PYGZsh{} plot the data}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{mask}\PYG{p}{,} \PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nearest}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{n}{cmap}\PYG{p}{)}
\PYG{c}{\PYGZsh{} add a colorbar}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{n}{ticks}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.colorbar.Colorbar instance at 0xbb01b00\PYGZgt{}
\end{Verbatim}

\includegraphics{GDAL_HDF_19_1.png}

To plot LAI only for the valid pixels (\code{mask == True}). We can used
masked arrays for this. Masked arrays are like normal arrays, but they
have an associated mask, which in this case is \code{mask} define above. We
shall also choose another colormap (there are \href{http://wiki.scipy.org/Cookbook/Matplotlib/Show\_colormaps}{lots to choose
from}), and
set values outside the 0.1 and 4 to be shown as black pixels.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{cmap} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{cm}\PYG{o}{.}\PYG{n}{Greens}
\PYG{n}{cmap}\PYG{o}{.}\PYG{n}{set\PYGZus{}bad} \PYG{p}{(} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{k}\PYG{l+s}{\PYGZsq{}} \PYG{p}{)}
\PYG{n}{laim} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ma}\PYG{o}{.}\PYG{n}{array} \PYG{p}{(} \PYG{n}{lai}\PYG{p}{,} \PYG{n}{mask}\PYG{o}{=}\PYG{n}{mask} \PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow} \PYG{p}{(} \PYG{n}{laim}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{n}{cmap}\PYG{p}{,} \PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nearest}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{n}{vmax}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.colorbar.Colorbar instance at 0xd429e18\PYGZgt{}
\end{Verbatim}

\includegraphics{GDAL_HDF_21_1.png}

Similarly, we can do a similar thing for Standard Deviation

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{cmap} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{cm}\PYG{o}{.}\PYG{n}{spectral}
\PYG{n}{cmap}\PYG{o}{.}\PYG{n}{set\PYGZus{}bad} \PYG{p}{(} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{k}\PYG{l+s}{\PYGZsq{}} \PYG{p}{)}
\PYG{n}{stdm} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ma}\PYG{o}{.}\PYG{n}{array} \PYG{p}{(} \PYG{n}{lai\PYGZus{}sd}\PYG{p}{,} \PYG{n}{mask}\PYG{o}{=}\PYG{n}{mask} \PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow} \PYG{p}{(} \PYG{n}{stdm}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{n}{cmap}\PYG{p}{,} \PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nearest}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mf}{0.001}\PYG{p}{,} \PYG{n}{vmax}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.colorbar.Colorbar instance at 0x2b8ee20374d0\PYGZgt{}
\end{Verbatim}

\includegraphics{GDAL_HDF_23_1.png}


\section{Exercise 1}
\label{ChapterX_GDAL/GDAL_HDF:exercise-1}
For the moment, we will suppose this data masking to be sufficient.
However, closer inspection of the \href{https://lpdaac.usgs.gov/products/modis\_products\_table/leaf\_area\_index\_fraction\_of\_photosynthetically\_active\_radiation/8\_day\_l4\_global\_1km/mod15a2}{product
data}
page would show us that the data can take on various Fill Values which
any data user should check for.

Modify the code we have developed above to also check that the data are
not unwanted fill values and use this to modify the data mask.

\emph{Hint} Note that these fill values are applied to Lai\_1km, not the QC
information, so you have to check values in that dataset and modify the
mask accordingly.


\section{Exercise 2}
\label{ChapterX_GDAL/GDAL_HDF:exercise-2}
We also have access to \code{FparExtra\_QC}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{qc1}  \PYG{o}{=} \PYG{n}{data}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{FparExtra\PYGZus{}QC}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\end{Verbatim}

The data values in FparExtra\_QC are:

Bit No.

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}th\PYGZgt{}Parameter Name\PYGZlt{}/th\PYGZgt{}\PYGZlt{}th\PYGZgt{} Bit Combination\PYGZlt{}/th\PYGZgt{}\PYGZlt{}th\PYGZgt{}Explanation\PYGZlt{}/th\PYGZgt{}
\end{Verbatim}

0-1

LandSea

00

Land

01

Shore

10

Freshwater

11

Ocean

2

Snow/Ice

0

No snow/ice detected

1

Snow/ice detected

3

Aerosol

0

No or low atmospheric aerosol levels detected

1

Average or high atmospheric aerosol levels detected

4

Cirrus

\begin{Verbatim}[commandchars=\\\{\}]
0\PYGZlt{}/td\PYGZgt{}\PYGZlt{}td\PYGZgt{}No cirrus detected\PYGZlt{}/td\PYGZgt{}
\end{Verbatim}

1

Cirrus detected

5

Cloud

0

No cloud detected

1

Cloud detected

6

Cloud shadow

0

No cloud shadow detected

1

Cloud shadowdetected

7

Biome\_mask

\begin{Verbatim}[commandchars=\\\{\}]
0\PYGZlt{}/td\PYGZgt{}\PYGZlt{}td\PYGZgt{}Biome outside interval 1\PYGZhy{}4\PYGZlt{}/td\PYGZgt{}
\end{Verbatim}

1

Biome in interval 1-4

Use this QC dataset to make sure that \textbf{only} Land pixels are passed in
the mask, and apply other data quality measures as appropriate.

\emph{Hint} this is much the same as the exercise above, but looking at a
different QC dataset. The key to doing this is to identify the bit codes
for combinations that you want to set or unset.

You can find an example of how to do this \textbf{here}{[}\textbf{DEADLINK}{]}.
This filtering shouldnt make much difference in this case, as the tile
is mostly land pixels. However, consider tile h17v03 (part of the UK)
for the month of June (e.g.
\code{MCD15A2.A2011185.h17v03.005.2011213154608.hdf})

\textbf{TODO} as NASA website is down!!!!!
\begin{figure}[htbp]
\centering
\capstart
\caption{UK LAI map}\end{figure}

\begin{Verbatim}[commandchars=\\\{\}]
!pwd
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
shell\PYGZhy{}init: error retrieving current directory: getcwd: cannot access parent directories: No such file or directory
pwd: error retrieving current directory: getcwd: cannot access parent directories: No such file or directory
pwd: error retrieving current directory: getcwd: cannot access parent directories: No such file or directory
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{css\PYGZus{}styling}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{k+kn}{from} \PYG{n+nn}{IPython.display} \PYG{k+kn}{import} \PYG{n}{display}\PYG{p}{,} \PYG{n}{HTML}
    \PYG{n}{styles} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{https://github.com/CamDavidsonPilon/Probabilistic\PYGZhy{}Programming\PYGZhy{}and\PYGZhy{}Bayesian\PYGZhy{}Methods\PYGZhy{}for\PYGZhy{}Hackers/raw/master/styles/custom.css}\PYG{l+s}{\PYGZdq{}}
    \PYG{k}{return} \PYG{n}{HTML}\PYG{p}{(}\PYG{n}{styles}\PYG{p}{)}
\PYG{n}{css\PYGZus{}styling}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
import json
import matplotlib
fp = open(\PYGZdq{}../bmh\PYGZus{}matplotlibrc.json\PYGZdq{}, \PYGZsq{}r\PYGZsq{} )
s = json.load ( fp )
fp.close()
matplotlib.rcParams.update(s)
\PYGZpc{}pylab inline
\PYGZpc{}config InlineBackend.figure\PYGZus{}format = \PYGZsq{}svg\PYGZsq{}
figsize( 7,7 )
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
Populating the interactive namespace from numpy and matplotlib
\end{Verbatim}


\chapter{GDAL and OGR libraries}
\label{ChapterX_GDAL/GDAL_Python_bindings::doc}\label{ChapterX_GDAL/GDAL_Python_bindings:gdal-and-ogr-libraries}
In the previous session, we used the GDAL library to open HDF files.
GDAL is not limited to a single file format, but can actually cope with
many different raster file formats semalessly. For \emph{vector} data (i.e.,
data that is stored by features, each being made up of fields containing
different types of information, one of them being a \emph{geometry}, such as
polygon, line or point), GDAL has a sister library called OGR. The
usefulness of these two libraries is that they allow the user to deal
with many of the different file formats in a consistent way.

It is important to note that both GDAL and OGR come with a suite of
command line tools that let you do many complex tasks on the command
line directly. A listing of the GDAL command line tools is available
\href{http://www.gdal.org/gdal\_utilities.html}{here}, but bear in mind
that many blogs etc. carry out examples of using GDAL tools in practice.
For OGR, most of the library can be accessed using
\href{http://www.gdal.org/ogr2ogr.html}{ogr2ogr}, but as usual, you might
find more useful information on
\href{http://www.bostongis.com/PrinterFriendly.aspx?content\_name=ogr\_cheatsheet}{blogs}
etc.


\section{GDAL data type}
\label{ChapterX_GDAL/GDAL_Python_bindings:gdal-data-type}
GDAL provides a very handy way of dealing with raster data in many
different formats, not only by making access to the data easy, but also
abstracting the nuances and complications of different file formats. In
GDAL, a raster file is made up of the actual raster data (i.e., the
values of each pixel of LAI that we saw before), and of some \emph{metadata}.
Metadata is data that describes something, and in this case it could be
the projection, the location of corners and pixel spacing, etc.


\subsection{The GeoTransform}
\label{ChapterX_GDAL/GDAL_Python_bindings:the-geotransform}
GDAL stores information about the location of each pixel using the
GeoTransform. The GeoTransform contains the coordinates (in some
projection) of the upper left (UL) corner of the image (taken to be the
\textbf{borders of the pixel} in the UL corner, not the center), the pixel
spacing and an additional rotation. By knowing these figures, we can
calculate the location of each pixel in the image easily. Let's see how
this works with an easy example. We have prepared a GeoTIFF file
(GeoTIFF is the more ubiquitous file format for EO data) of the MODIS
landcover product for the UK. The data has been extracted from the
HDF-EOS files that are similar to the LAI product that we have seen
before, and converted. The file is
\code{{}`lc\_h17v03.tif} \textless{}\href{https://raw.github.com/jgomezdans/geogg122/master/ChapterX\_GDAL/lc\_h17v03.tif}{https://raw.github.com/jgomezdans/geogg122/master/ChapterX\_GDAL/lc\_h17v03.tif}\textgreater{}{}`\_\_.
We will open the file in Python, and have a look at finding a particular
location.

Assume we are interested in locating \href{http://toolserver.org/~rhaworth/os/coor\_g.php?pagename=Kinder\_Scout\&params=SK086875\_region\%3AGB\_scale\%3A25000}{Kinder
Scout},
a moorland in the Peak District National Park. Its coordinates are
1.871417W, 53.384726N. In the MODIS integerised sinusoidal projection,
the coordinates are (-124114.3, 5936117.4) (you can use the \href{http://landweb.nascom.nasa.gov/cgi-bin/developer/tilemap.cgi}{MODLAND
tile calculator
website}
to do this calculation yourself).

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{gdal} \PYG{c}{\PYGZsh{} Import GDAL library}
\PYG{n}{g} \PYG{o}{=} \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{Open} \PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{lc\PYGZus{}h17v03.tif}\PYG{l+s}{\PYGZdq{}} \PYG{p}{)} \PYG{c}{\PYGZsh{} Open the file}
\PYG{k}{if} \PYG{n}{g} \PYG{o+ow}{is} \PYG{n+nb+bp}{None}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Could not open the file!}\PYG{l+s}{\PYGZdq{}}
\PYG{n}{geo\PYGZus{}transform} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{GetGeoTransform} \PYG{p}{(}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{geo\PYGZus{}transform}
\PYG{k}{print} \PYG{n}{g}\PYG{o}{.}\PYG{n}{RasterXSize}\PYG{p}{,} \PYG{n}{g}\PYG{o}{.}\PYG{n}{RasterYSize}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
(\PYGZhy{}1111950.519667, 463.3127165279167, 0.0, 6671703.118, 0.0, \PYGZhy{}463.3127165279165)
2400 2400
\end{Verbatim}

In the previous code, we open the file (we just use the filename), and
then query the object for its GeoTransform, which we then print out. The
6-element tuple comprises
\begin{enumerate}
\item {} 
The Upper Left \emph{easting} coordinate (i.e., \emph{horizontal})

\item {} 
The E-W pixel spacing

\item {} 
The rotation (0 degrees if image is ``North Up'')

\item {} 
The Upper left \emph{northing} coordinate (i.e., \emph{vertical})

\item {} 
The rotation (0 degrees)

\item {} 
The N-S pixel spacing, negative as we will be counting from the UL
corner

\end{enumerate}

We have also seen that the dataset is of size 2400x2400, using
\code{RasterXSize} and \code{RasterYSize}. The goal is to find the pixel
number \((i,j), \;\;0\le i,j < 2400\) that corresponds to Kinder
Scout. To do this, we use the following calculations:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{pixel\PYGZus{}x} \PYG{o}{=} \PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{124114.3} \PYG{o}{\PYGZhy{}} \PYG{n}{geo\PYGZus{}transform}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{o}{/}\PYG{n}{geo\PYGZus{}transform}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYGZbs{}
        \PYG{c}{\PYGZsh{} The difference in distance between the UL corner (geot[0] \PYGZbs{}}
        \PYG{c}{\PYGZsh{}and point of interest. Scaled by geot[1] to get pixel number}

\PYG{n}{pixel\PYGZus{}y} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mf}{5936117.4} \PYG{o}{\PYGZhy{}} \PYG{n}{geo\PYGZus{}transform}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}\PYG{o}{/}\PYG{p}{(}\PYG{n}{geo\PYGZus{}transform}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{)} \PYG{c}{\PYGZsh{} Like for pixel\PYGZus{}x, \PYGZbs{}}
        \PYG{c}{\PYGZsh{}but in vertical direction. Note the different elements of geot \PYGZbs{}}
        \PYG{c}{\PYGZsh{}being used}

\PYG{k}{print} \PYG{n}{pixel\PYGZus{}x}\PYG{p}{,} \PYG{n}{pixel\PYGZus{}y}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
2132.11549009 1587.66572071
\end{Verbatim}

So the pixel number is a floating point number, which we might need to
round off as an integer. Let's plot the entire raster map (with minimum
value 0 to ignore the ocean) using
\code{{}`plt.imshow} \textless{}\href{http://matplotlib.org/api/pyplot\_api.html\#matplotlib.pyplot.imshow}{http://matplotlib.org/api/pyplot\_api.html\#matplotlib.pyplot.imshow}\textgreater{}{}`\_\_
and plot the location of Kinder Scout using
\code{{}`plt.plot} \textless{}\href{http://matplotlib.org/api/pyplot\_api.html\#matplotlib.pyplot.plt}{http://matplotlib.org/api/pyplot\_api.html\#matplotlib.pyplot.plt}\textgreater{}{}`\_\_.
We will also use
\code{{}`plt.annotate} \textless{}\href{http://matplotlib.org/api/pyplot\_api.html\#matplotlib.pyplot.annotate}{http://matplotlib.org/api/pyplot\_api.html\#matplotlib.pyplot.annotate}\textgreater{}{}`\_\_
to add a label with an arrow:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{lc} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{ReadAsArray}\PYG{p}{(}\PYG{p}{)} \PYG{c}{\PYGZsh{} Read raster data}
\PYG{c}{\PYGZsh{} Now plot the raster data using gist\PYGZus{}earth palette}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow} \PYG{p}{(} \PYG{n}{lc}\PYG{p}{,} \PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nearest}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{n}{plt}\PYG{o}{.}\PYG{n}{cm}\PYG{o}{.}\PYG{n}{gist\PYGZus{}earth} \PYG{p}{)}
\PYG{c}{\PYGZsh{} Plot location of our area of interest as a red dot (\PYGZsq{}ro\PYGZsq{})}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot} \PYG{p}{(} \PYG{n}{pixel\PYGZus{}x}\PYG{p}{,} \PYG{n}{pixel\PYGZus{}y}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{ro}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{c}{\PYGZsh{} Annotate}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{annotate}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Kinder Scout}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{xy}\PYG{o}{=}\PYG{p}{(}\PYG{n}{pixel\PYGZus{}x}\PYG{p}{,} \PYG{n}{pixel\PYGZus{}y}\PYG{p}{)}\PYG{p}{,}  \PYGZbs{}
        \PYG{n}{xycoords}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{data}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{xytext}\PYG{o}{=}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{150}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{60}\PYG{p}{)}\PYG{p}{,} \PYGZbs{}
        \PYG{n}{textcoords}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{offset points}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}  \PYG{n}{size}\PYG{o}{=}\PYG{l+m+mi}{12}\PYG{p}{,} \PYGZbs{}
        \PYG{n}{bbox}\PYG{o}{=}\PYG{n+nb}{dict}\PYG{p}{(}\PYG{n}{boxstyle}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{round4,pad=.5}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{fc}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0.8}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,} \PYGZbs{}
        \PYG{n}{arrowprops}\PYG{o}{=}\PYG{n+nb}{dict}\PYG{p}{(}\PYG{n}{arrowstyle}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}\PYGZgt{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYGZbs{}
        \PYG{n}{connectionstyle}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{angle,angleA=0,angleB=\PYGZhy{}90,rad=10}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYGZbs{}
        \PYG{n}{color}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{w}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,} \PYG{p}{)}
\PYG{c}{\PYGZsh{} Remove vertical and horizontal ticks}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xticks}\PYG{p}{(}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{yticks}\PYG{p}{(}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
([], \PYGZlt{}a list of 0 Text yticklabel objects\PYGZgt{})
\end{Verbatim}

\includegraphics{GDAL_Python_bindings_12_1.svg}


\subsubsection{Try it out in some other places!}
\label{ChapterX_GDAL/GDAL_Python_bindings:try-it-out-in-some-other-places}
Find the longitude and latitude of some places of interest in the
British isles (West of Greenwich!) and using the MODLAND MODIS tile
calculator and the geotransform, repeat the above experiment. Note that
the \href{http://landweb.nascom.nasa.gov/cgi-bin/developer/tilemap.cgi}{MODIS
calculator}
calculates both the projected coordinates in the MODIS sinusoidal
projection, as well as the pixel number, so it is a helpful way to check
whether you got the right result.

Park name

Longitude {[}deg{]}

Latitude {[}deg{]}

Dartmoor national park

-3.904

50.58

New forest national park

-1.595

50.86

Exmoor national park

-3.651

51.14

Pembrokeshire coast national park

-4.694

51.64

Brecon beacons national park

-3.432

\begin{Verbatim}[commandchars=\\\{\}]
51.88\PYGZlt{}/td\PYGZgt{}
\end{Verbatim}

Pembrokeshire coast national park

-4.79

51.99

Norfolk and suffolk broads

1.569

52.62

Snowdonia national park

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZhy{}3.898  \PYGZlt{}/td\PYGZgt{}\PYGZlt{}td\PYGZgt{}52.9\PYGZlt{}/td\PYGZgt{}
\end{Verbatim}

Peak district national park

-1.802

53.3

Yorkshire dales national park

-2.157

54.23

North yorkshire moors national park

-0.8855

54.37

Lake district national park

-3.084

54.47

Galloway forest park

-4.171

54.87

Northumberland national park

-2.228

55.28

Loch lomond and the trossachs national park

-4.593

56.24

Tay forest park

-4.025

\begin{Verbatim}[commandchars=\\\{\}]
56.59\PYGZlt{}/td\PYGZgt{}
\end{Verbatim}

Cairngorms national park

-3.545

57.08


\section{The projection}
\label{ChapterX_GDAL/GDAL_Python_bindings:the-projection}
Projections in GDAL objects are stored can be accessed by querying the
dataset using the \code{GetProjection()} method. If we do that on the
currently opened dataset (stored in variable \code{g}), we get:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{n}{g}\PYG{o}{.}\PYG{n}{GetProjection}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{PROJCS}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{unnamed}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{GEOGCS}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Unknown datum based upon the custom spheroid}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{DATUM}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Not\PYGZus{}specified\PYGZus{}based\PYGZus{}on\PYGZus{}custom\PYGZus{}spheroid}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{SPHEROID}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Custom spheroid}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+m+mf}{6371007.181}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,}\PYG{n}{PRIMEM}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Greenwich}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{UNIT}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{degree}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+m+mf}{0.0174532925199433}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,}\PYG{n}{PROJECTION}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Sinusoidal}\PYG{l+s}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{PARAMETER}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{longitude\PYGZus{}of\PYGZus{}center}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{PARAMETER}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{false\PYGZus{}easting}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{PARAMETER}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{false\PYGZus{}northing}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{UNIT}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{metre}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{AUTHORITY}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{EPSG}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{9001}\PYG{l+s}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{]}\PYG{p}{]}
\end{Verbatim}

The above is the description of the projection (in this case, MODIS
sinusoidal) in \code{WKT} (well-known text) format. There are a number of
different ways of specifying projections, the most important being
\begin{itemize}
\item {} 
WKT

\item {} 
Proj4

\item {} 
EPSG codes

\end{itemize}

The site \href{http://spatialreference.org}{spatialreference.org} allows
you to search a large collection of projections, and get the
representation that you want to use.


\section{Saving files}
\label{ChapterX_GDAL/GDAL_Python_bindings:saving-files}
So far, we have read data from files, but lets see how we can save
raster data \textbf{to} a new file. We will use the previous landcover map as
an example. We will write a method to save the data in a format provided
by the user. The procedure is fairly straightforward: we get a handler
to a driver (e.g. a GeoTIFF or Erdas Imagine format), we create the
output file (giving a filename, number of rows, columns, bands, the data
type), and then add the relevant metadata (projection, geotransform,
...). We then select a band from the output and copy the array that we
want to write to that band.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{g} \PYG{o}{=} \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{Open} \PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{lc\PYGZus{}h17v03.tif}\PYG{l+s}{\PYGZdq{}} \PYG{p}{)} \PYG{c}{\PYGZsh{} Open original file}
\PYG{c}{\PYGZsh{} Get the x, y and number of bands from the original file}
\PYG{n}{x\PYGZus{}size}\PYG{p}{,} \PYG{n}{y\PYGZus{}size}\PYG{p}{,} \PYG{n}{n\PYGZus{}bands} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{RasterXSize}\PYG{p}{,} \PYG{n}{g}\PYG{o}{.}\PYG{n}{RasterYSize}\PYG{p}{,} \PYG{n}{g}\PYG{o}{.}\PYG{n}{RasterCount}
\PYG{n}{data} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{ReadAsArray} \PYG{p}{(}\PYG{p}{)}
\PYG{n}{driver} \PYG{o}{=} \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{GetDriverByName} \PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{HFA}\PYG{l+s}{\PYGZdq{}} \PYG{p}{)} \PYG{c}{\PYGZsh{} Get a handler to a driver}
                                        \PYG{c}{\PYGZsh{} Maybe try \PYGZdq{}GeoTIFF\PYGZdq{} here}
\PYG{c}{\PYGZsh{} Next line creates the output dataset with}
\PYG{c}{\PYGZsh{} 1. The filename (\PYGZdq{}test\PYGZus{}lc\PYGZus{}h17v03.img\PYGZdq{})}
\PYG{c}{\PYGZsh{} 2. The raster size (x\PYGZus{}size, y\PYGZus{}size)}
\PYG{c}{\PYGZsh{} 3. The number of bands}
\PYG{c}{\PYGZsh{} 4.The data type (in this case, Byte.}
\PYG{c}{\PYGZsh{}     Other typical values might be gdal.GDT\PYGZus{}Int16}
\PYG{c}{\PYGZsh{}     or gdal.GDT\PYGZus{}Float32)}

\PYG{n}{dataset\PYGZus{}out} \PYG{o}{=} \PYG{n}{driver}\PYG{o}{.}\PYG{n}{Create} \PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{test\PYGZus{}lc\PYGZus{}h17v03.img}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{x\PYGZus{}size}\PYG{p}{,} \PYG{n}{y\PYGZus{}size}\PYG{p}{,} \PYG{n}{n\PYGZus{}bands}\PYG{p}{,} \PYGZbs{}
                             \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{GDT\PYGZus{}Byte} \PYG{p}{)}
\PYG{c}{\PYGZsh{} Set the output geotransform by reading the input one}
\PYG{n}{dataset\PYGZus{}out}\PYG{o}{.}\PYG{n}{SetGeoTransform} \PYG{p}{(} \PYG{n}{g}\PYG{o}{.}\PYG{n}{GetGeoTransform}\PYG{p}{(}\PYG{p}{)} \PYG{p}{)}
\PYG{c}{\PYGZsh{} Set the output projection by reading the input one}
\PYG{n}{dataset\PYGZus{}out}\PYG{o}{.}\PYG{n}{SetProjection} \PYG{p}{(} \PYG{n}{g}\PYG{o}{.}\PYG{n}{GetProjectionRef}\PYG{p}{(}\PYG{p}{)} \PYG{p}{)}
\PYG{c}{\PYGZsh{} Now, get band \PYGZsh{} 1, and write our data array.}
\PYG{c}{\PYGZsh{} Note that the data array needs to have the same type}
\PYG{c}{\PYGZsh{} as the one specified for dataset\PYGZus{}out}
\PYG{n}{dataset\PYGZus{}out}\PYG{o}{.}\PYG{n}{GetRasterBand} \PYG{p}{(} \PYG{l+m+mi}{1} \PYG{p}{)}\PYG{o}{.}\PYG{n}{WriteArray} \PYG{p}{(} \PYG{n}{data} \PYG{p}{)}
\PYG{c}{\PYGZsh{} This bit forces GDAL to close the file and write to it}
\PYG{n}{dataset\PYGZus{}out} \PYG{o}{=} \PYG{n+nb+bp}{None}
\end{Verbatim}

The output file should hopefully exist in this directory. Let's use
\code{{}`gdalinfo} \textless{}\href{http://www.gdal.org/gdalinfo.html}{http://www.gdal.org/gdalinfo.html}\textgreater{}{}`\_\_ to find out about
it

\begin{Verbatim}[commandchars=\\\{\}]
!gdalinfo test\PYGZus{}lc\PYGZus{}h17v03.img
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
Driver: HFA/Erdas Imagine Images (.img)
Files: test\PYGZus{}lc\PYGZus{}h17v03.img
Size is 2400, 2400
Coordinate System is:
PROJCS[\PYGZdq{}Sinusoidal\PYGZdq{},
    GEOGCS[\PYGZdq{}GCS\PYGZus{}Unknown datum based upon the custom spheroid\PYGZdq{},
        DATUM[\PYGZdq{}Not\PYGZus{}specified\PYGZus{}based\PYGZus{}on\PYGZus{}custom\PYGZus{}spheroid\PYGZdq{},
            SPHEROID[\PYGZdq{}Custom\PYGZus{}spheroid\PYGZdq{},6371007.181,0]],
        PRIMEM[\PYGZdq{}Greenwich\PYGZdq{},0],
        UNIT[\PYGZdq{}Degree\PYGZdq{},0.017453292519943295]],
    PROJECTION[\PYGZdq{}Sinusoidal\PYGZdq{}],
    PARAMETER[\PYGZdq{}longitude\PYGZus{}of\PYGZus{}center\PYGZdq{},0],
    PARAMETER[\PYGZdq{}false\PYGZus{}easting\PYGZdq{},0],
    PARAMETER[\PYGZdq{}false\PYGZus{}northing\PYGZdq{},0],
    UNIT[\PYGZdq{}Meter\PYGZdq{},1]]
Origin = (\PYGZhy{}1111950.519667000044137,6671703.117999999783933)
Pixel Size = (463.312716527916677,\PYGZhy{}463.312716527916507)
Corner Coordinates:
Upper Left  (\PYGZhy{}1111950.520, 6671703.118) ( 20d 0\PYGZsq{} 0.00\PYGZdq{}W, 60d 0\PYGZsq{} 0.00\PYGZdq{}N)
Lower Left  (\PYGZhy{}1111950.520, 5559752.598) ( 15d33\PYGZsq{}26.06\PYGZdq{}W, 50d 0\PYGZsq{} 0.00\PYGZdq{}N)
Upper Right (       0.000, 6671703.118) (  0d 0\PYGZsq{} 0.01\PYGZdq{}E, 60d 0\PYGZsq{} 0.00\PYGZdq{}N)
Lower Right (       0.000, 5559752.598) (  0d 0\PYGZsq{} 0.01\PYGZdq{}E, 50d 0\PYGZsq{} 0.00\PYGZdq{}N)
Center      ( \PYGZhy{}555975.260, 6115727.858) (  8d43\PYGZsq{} 2.04\PYGZdq{}W, 55d 0\PYGZsq{} 0.00\PYGZdq{}N)
Band 1 Block=64x64 Type=Byte, ColorInterp=Undefined
  Description = Layer\PYGZus{}1
  Metadata:
    LAYER\PYGZus{}TYPE=athematic
\end{Verbatim}

So the previous code works. Since this is something we typically do
(read some data from one or more files, manipulate it and save the
result in output files), it makes a lot of sense to try to put this code
in a method that is more or less generic, that we can test and then
re-use. Here's a first attempt at it:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{save\PYGZus{}raster} \PYG{p}{(} \PYG{n}{output\PYGZus{}name}\PYG{p}{,} \PYG{n}{raster\PYGZus{}data}\PYG{p}{,} \PYG{n}{dataset}\PYG{p}{,} \PYG{n}{driver}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{GTiff}\PYG{l+s}{\PYGZdq{}} \PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    A function to save a 1\PYGZhy{}band raster using GDAL to the file indicated}
\PYG{l+s+sd}{    by {}`{}`output\PYGZus{}name{}`{}`. It requires a GDAL\PYGZhy{}accesible dataset to collect}
\PYG{l+s+sd}{    the projection and geotransform.}

\PYG{l+s+sd}{    Parameters}
\PYG{l+s+sd}{    \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{l+s+sd}{    output\PYGZus{}name: str}
\PYG{l+s+sd}{        The output filename, with full path and extension if required}
\PYG{l+s+sd}{    raster\PYGZus{}data: array}
\PYG{l+s+sd}{        The array that we want to save}
\PYG{l+s+sd}{    dataset: str}
\PYG{l+s+sd}{        Filename of a GDAL\PYGZhy{}friendly dataset that we want to use to}
\PYG{l+s+sd}{        read geotransform \PYGZam{} projection information}
\PYG{l+s+sd}{    driver: str}
\PYG{l+s+sd}{        A GDAL driver string, like GTiff or HFA.}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}

    \PYG{c}{\PYGZsh{} Open the reference dataset}
    \PYG{n}{g} \PYG{o}{=} \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{Open} \PYG{p}{(} \PYG{n}{dataset} \PYG{p}{)}
    \PYG{c}{\PYGZsh{} Get the Geotransform vector}
    \PYG{n}{geo\PYGZus{}transform} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{GetGeoTransform} \PYG{p}{(}\PYG{p}{)}
    \PYG{n}{x\PYGZus{}size} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{RasterXSize} \PYG{c}{\PYGZsh{} Raster xsize}
    \PYG{n}{y\PYGZus{}size} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{RasterYSize} \PYG{c}{\PYGZsh{} Raster ysize}
    \PYG{n}{srs} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{GetProjectionRef} \PYG{p}{(}\PYG{p}{)} \PYG{c}{\PYGZsh{} Projection}
    \PYG{c}{\PYGZsh{} Need a driver object. By default, we use GeoTIFF}
    \PYG{n}{driver} \PYG{o}{=} \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{GetDriverByName} \PYG{p}{(} \PYG{n}{driver} \PYG{p}{)}
    \PYG{n}{dataset\PYGZus{}out} \PYG{o}{=} \PYG{n}{driver}\PYG{o}{.}\PYG{n}{Create} \PYG{p}{(} \PYG{n}{output\PYGZus{}name}\PYG{p}{,} \PYG{n}{x\PYGZus{}size}\PYG{p}{,} \PYG{n}{y\PYGZus{}size}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYGZbs{}
            \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{GDT\PYGZus{}Float32} \PYG{p}{)}
    \PYG{n}{dataset\PYGZus{}out}\PYG{o}{.}\PYG{n}{SetGeoTransform} \PYG{p}{(} \PYG{n}{geo\PYGZus{}transform} \PYG{p}{)}
    \PYG{n}{dataset\PYGZus{}out}\PYG{o}{.}\PYG{n}{SetProjection} \PYG{p}{(} \PYG{n}{srs} \PYG{p}{)}
    \PYG{n}{dataset\PYGZus{}out}\PYG{o}{.}\PYG{n}{GetRasterBand} \PYG{p}{(} \PYG{l+m+mi}{1} \PYG{p}{)}\PYG{o}{.}\PYG{n}{WriteArray} \PYG{p}{(} \PYGZbs{}
            \PYG{n}{raster\PYGZus{}data}\PYG{o}{.}\PYG{n}{astype}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{float32}\PYG{p}{)} \PYG{p}{)}
    \PYG{n}{dataset\PYGZus{}out} \PYG{o}{=} \PYG{n+nb+bp}{None}
\end{Verbatim}

Now try modifying that method so that you can
\begin{enumerate}
\item {} 
Select the output data type diffrent to Float32

\item {} 
Provide a given projection and geotransform (e.g. if you don't have a
GDAL filename)

\end{enumerate}


\section{Reprojecting things}
\label{ChapterX_GDAL/GDAL_Python_bindings:reprojecting-things}
Previously, we have used the \href{http://landweb.nascom.nasa.gov/cgi-bin/developer/tilemap.cgi}{MODLAND grid
converter}
site to go from latitude/longitude pairs to MODIS projection. However,
in practice, we might want to use a range of different projections, and
convert many points at the same time, so how do we go about that?

In GDAL/OGR, most projection-related tools are in the \code{osr} package,
which needs to be imported like e.g. \code{gdal} itself. The main tools are
the \code{osr.SpatialReference} object, which defines a projection object
(with no projection to start with), and the
\code{osr.CoordinateTransformation} object.

Once you instantiate \code{osr.SpatialReference}, it holds no projection
information. You need to use methods to set it up, using EPSG codes,
Proj4 strings, or whatever. These methods typically start by
\code{ImportFrom} (e.g. \code{ImportFromEPSG}, \code{ImportFromProj4}, ...).

The \code{CoordinateTransformation} requires a source and destination
spatial references that have been configured. Once this is done, it
expose the method \code{TransformPoint} to convert coordinates from the
source to the destination projection.

Let's see how this works by converting some latitude/longitude pairs to
the Ordnance Survey's \href{http://en.wikipedia.org/wiki/Ordnance\_Survey\_National\_Grid}{National
Grid}
projection. The projection is also available in
\href{http://spatialreference.org/ref/epsg/27700/}{spatialreference.org},
where we can gleam its EPSG code (27700). The EPSG code for longitude
latitude is \href{http://spatialreference.org/ref/epsg/4326/}{4326}. Let's
see this in practice:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{osgeo} \PYG{k+kn}{import} \PYG{n}{osr}

\PYG{c}{\PYGZsh{} Define the source projection, WGS84 lat/lon.}
\PYG{n}{wgs84} \PYG{o}{=} \PYG{n}{osr}\PYG{o}{.}\PYG{n}{SpatialReference}\PYG{p}{(} \PYG{p}{)} \PYG{c}{\PYGZsh{} Define a SpatialReference object}
\PYG{n}{wgs84}\PYG{o}{.}\PYG{n}{ImportFromEPSG}\PYG{p}{(} \PYG{l+m+mi}{4326} \PYG{p}{)} \PYG{c}{\PYGZsh{} And set it to WGS84 using the EPSG code}

\PYG{c}{\PYGZsh{} Now for the target projection, Ordnance Survey\PYGZsq{}s British National Grid}
\PYG{n}{osng} \PYG{o}{=} \PYG{n}{osr}\PYG{o}{.}\PYG{n}{SpatialReference}\PYG{p}{(}\PYG{p}{)} \PYG{c}{\PYGZsh{} define the SpatialReference object}
\PYG{c}{\PYGZsh{} In this case, we get the projection from a Proj4 string}
\PYG{n}{osng}\PYG{o}{.}\PYG{n}{ImportFromEPSG}\PYG{p}{(} \PYG{l+m+mi}{27700}\PYG{p}{)}
\PYG{c}{\PYGZsh{} or, if using the proj4 representation}
\PYG{n}{osng}\PYG{o}{.}\PYG{n}{ImportFromProj4} \PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{+proj=tmerc +lat\PYGZus{}0=49 +lon\PYGZus{}0=\PYGZhy{}2 }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYGZbs{}
                      \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{+k=0.9996012717 +x\PYGZus{}0=400000 +y\PYGZus{}0=\PYGZhy{}100000 }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYGZbs{}
                      \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{+ellps=airy +datum=OSGB36 +units=m +no\PYGZus{}defs}\PYG{l+s}{\PYGZdq{}} \PYG{p}{)}


\PYG{c}{\PYGZsh{} Now, we define a coordinate transformtion object, *from* wgs84 *to* OSNG}
\PYG{n}{tx} \PYG{o}{=} \PYG{n}{osr}\PYG{o}{.}\PYG{n}{CoordinateTransformation}\PYG{p}{(} \PYG{n}{wgs84}\PYG{p}{,} \PYG{n}{osng}\PYG{p}{)}
\PYG{c}{\PYGZsh{} We loop over the lines of park\PYGZus{}data,}
\PYG{c}{\PYGZsh{}         using the split method to split by newline characters}
\PYG{n}{park\PYGZus{}name}\PYG{p}{,} \PYG{n}{lon}\PYG{p}{,} \PYG{n}{lat} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Snowdonia national park}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{3.898}\PYG{p}{,}    \PYG{l+m+mf}{52.9}

\PYG{c}{\PYGZsh{} Actually do the transformation using the TransformPoint method}
\PYG{n}{osng\PYGZus{}x}\PYG{p}{,} \PYG{n}{osng\PYGZus{}y}\PYG{p}{,} \PYG{n}{osng\PYGZus{}z} \PYG{o}{=} \PYG{n}{tx}\PYG{o}{.}\PYG{n}{TransformPoint} \PYG{p}{(} \PYG{n}{lon}\PYG{p}{,} \PYG{n}{lat} \PYG{p}{)}
\PYG{c}{\PYGZsh{} Print out}
\PYG{k}{print} \PYG{n}{park\PYGZus{}name}\PYG{p}{,} \PYG{n}{lon}\PYG{p}{,} \PYG{n}{lat}\PYG{p}{,} \PYG{n}{osng\PYGZus{}x}\PYG{p}{,} \PYG{n}{osng\PYGZus{}y}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
Snowdonia national park \PYGZhy{}3.898 52.9 272430.180112 335304.936823
\end{Verbatim}

You can test the result is reasonable by feeding the data for \code{osng\_x}
and \code{osng\_y} in the OS own \href{http://www.ordnancesurvey.co.uk/gps/transformation}{coordinate conversion
website} and
making sure that the calculated longitude latitude pair is the same as
the one you started with.


\section{Reprojecting whole rasters}
\label{ChapterX_GDAL/GDAL_Python_bindings:reprojecting-whole-rasters}

\subsection{Using command line tools}
\label{ChapterX_GDAL/GDAL_Python_bindings:using-command-line-tools}
The easiest way to reproject a raster file is to use GDAL's
\code{{}`gdalwarp} \textless{}\href{http://www.gdal.org/gdalwarp.html}{http://www.gdal.org/gdalwarp.html}\textgreater{}{}`\_\_ tool. As an
example, let's say we want to reproject the landcover file from earlier
on into latitude/longitude (WGS84):

\begin{Verbatim}[commandchars=\\\{\}]
!gdalwarp \PYGZhy{}of GTiff \PYGZhy{}t\PYGZus{}srs \PYGZdq{}EPSG:4326\PYGZdq{} \PYGZhy{}ts 2400 2400 test\PYGZus{}lc\PYGZus{}h17v03.img  lc\PYGZus{}h17v03\PYGZus{}wgs84.tif
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
Output dataset lc\PYGZus{}h17v03\PYGZus{}wgs84.tif exists,
but some commandline options were provided indicating a new dataset
should be created.  Please delete existing dataset and run again.
\end{Verbatim}

We see here that the command takes a number of arguments:
\begin{enumerate}
\item {} 
\code{-of GTiff} is the outut format (in this case GeoTIFF)

\item {} 
\code{-t\_srs "EPSG:4326"} is the \textbf{to} projection (the \textbf{from}
projection is already specified in the source dataset), in this case,
lat/long WGS84, known by its \href{http://spatialreference.org/ref/epsg/4326/}{EPSG
code}

\item {} 
\code{-ts 2400 2400} instructs \code{gdalwarp} to use an output of size
\code{2400*2400}.

\item {} 
\code{test\_lc\_h17v03.img} is the \textbf{input dataset}

\item {} 
\code{lc\_h17v03\_wgs84.tif} is the \textbf{output dataset}

\end{enumerate}

Note that \code{gdalwarp} will reproject the data, and decide on the pixel
size based on some considerations. This can result in the size of the
raster changing. If you wanted to still keep the same raster size, we
use the \code{-ts 2400 2400} option, or select an appropriate pixel size
using \code{-tr xres yres} (note it has to be in the target projection, so
degrees in this case). We can use \code{gdalinfo} to see what we've done.

\begin{Verbatim}[commandchars=\\\{\}]
!gdalinfo test\PYGZus{}lc\PYGZus{}h17v03.img
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
Driver: HFA/Erdas Imagine Images (.img)
Files: test\PYGZus{}lc\PYGZus{}h17v03.img
Size is 2400, 2400
Coordinate System is:
PROJCS[\PYGZdq{}Sinusoidal\PYGZdq{},
    GEOGCS[\PYGZdq{}GCS\PYGZus{}Unknown datum based upon the custom spheroid\PYGZdq{},
        DATUM[\PYGZdq{}Not\PYGZus{}specified\PYGZus{}based\PYGZus{}on\PYGZus{}custom\PYGZus{}spheroid\PYGZdq{},
            SPHEROID[\PYGZdq{}Custom\PYGZus{}spheroid\PYGZdq{},6371007.181,0]],
        PRIMEM[\PYGZdq{}Greenwich\PYGZdq{},0],
        UNIT[\PYGZdq{}Degree\PYGZdq{},0.017453292519943295]],
    PROJECTION[\PYGZdq{}Sinusoidal\PYGZdq{}],
    PARAMETER[\PYGZdq{}longitude\PYGZus{}of\PYGZus{}center\PYGZdq{},0],
    PARAMETER[\PYGZdq{}false\PYGZus{}easting\PYGZdq{},0],
    PARAMETER[\PYGZdq{}false\PYGZus{}northing\PYGZdq{},0],
    UNIT[\PYGZdq{}Meter\PYGZdq{},1]]
Origin = (\PYGZhy{}1111950.519667000044137,6671703.117999999783933)
Pixel Size = (463.312716527916677,\PYGZhy{}463.312716527916507)
Corner Coordinates:
Upper Left  (\PYGZhy{}1111950.520, 6671703.118) ( 20d 0\PYGZsq{} 0.00\PYGZdq{}W, 60d 0\PYGZsq{} 0.00\PYGZdq{}N)
Lower Left  (\PYGZhy{}1111950.520, 5559752.598) ( 15d33\PYGZsq{}26.06\PYGZdq{}W, 50d 0\PYGZsq{} 0.00\PYGZdq{}N)
Upper Right (       0.000, 6671703.118) (  0d 0\PYGZsq{} 0.01\PYGZdq{}E, 60d 0\PYGZsq{} 0.00\PYGZdq{}N)
Lower Right (       0.000, 5559752.598) (  0d 0\PYGZsq{} 0.01\PYGZdq{}E, 50d 0\PYGZsq{} 0.00\PYGZdq{}N)
Center      ( \PYGZhy{}555975.260, 6115727.858) (  8d43\PYGZsq{} 2.04\PYGZdq{}W, 55d 0\PYGZsq{} 0.00\PYGZdq{}N)
Band 1 Block=64x64 Type=Byte, ColorInterp=Undefined
  Description = Layer\PYGZus{}1
  Metadata:
    LAYER\PYGZus{}TYPE=athematic
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
!gdalinfo lc\PYGZus{}h17v03\PYGZus{}wgs84.tif
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
Driver: GTiff/GeoTIFF
Files: lc\PYGZus{}h17v03\PYGZus{}wgs84.tif
Size is 2400, 2400
Coordinate System is:
GEOGCS[\PYGZdq{}WGS 84\PYGZdq{},
    DATUM[\PYGZdq{}WGS\PYGZus{}1984\PYGZdq{},
        SPHEROID[\PYGZdq{}WGS 84\PYGZdq{},6378137,298.257223563,
            AUTHORITY[\PYGZdq{}EPSG\PYGZdq{},\PYGZdq{}7030\PYGZdq{}]],
        AUTHORITY[\PYGZdq{}EPSG\PYGZdq{},\PYGZdq{}6326\PYGZdq{}]],
    PRIMEM[\PYGZdq{}Greenwich\PYGZdq{},0],
    UNIT[\PYGZdq{}degree\PYGZdq{},0.0174532925199433],
    AUTHORITY[\PYGZdq{}EPSG\PYGZdq{},\PYGZdq{}4326\PYGZdq{}]]
Origin = (\PYGZhy{}19.999999994952233,59.999999994611805)
Pixel Size = (0.008333919248404,\PYGZhy{}0.004166959624202)
Metadata:
  AREA\PYGZus{}OR\PYGZus{}POINT=Area
Image Structure Metadata:
  INTERLEAVE=BAND
Corner Coordinates:
Upper Left  ( \PYGZhy{}20.0000000,  60.0000000) ( 20d 0\PYGZsq{} 0.00\PYGZdq{}W, 60d 0\PYGZsq{} 0.00\PYGZdq{}N)
Lower Left  ( \PYGZhy{}20.0000000,  49.9992969) ( 20d 0\PYGZsq{} 0.00\PYGZdq{}W, 49d59\PYGZsq{}57.47\PYGZdq{}N)
Upper Right (   0.0014062,  60.0000000) (  0d 0\PYGZsq{} 5.06\PYGZdq{}E, 60d 0\PYGZsq{} 0.00\PYGZdq{}N)
Lower Right (   0.0014062,  49.9992969) (  0d 0\PYGZsq{} 5.06\PYGZdq{}E, 49d59\PYGZsq{}57.47\PYGZdq{}N)
Center      (  \PYGZhy{}9.9992969,  54.9996484) (  9d59\PYGZsq{}57.47\PYGZdq{}W, 54d59\PYGZsq{}58.73\PYGZdq{}N)
Band 1 Block=2400x3 Type=Byte, ColorInterp=Gray
  Description = Layer\PYGZus{}1
  Metadata:
    LAYER\PYGZus{}TYPE=athematic
\end{Verbatim}

Let's see how different these two datasets are:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{g} \PYG{o}{=} \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{Open} \PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{lc\PYGZus{}h17v03\PYGZus{}wgs84.tif}\PYG{l+s}{\PYGZdq{}} \PYG{p}{)}
\PYG{n}{wgs84} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{ReadAsArray}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{g} \PYG{o}{=} \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{Open}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{test\PYGZus{}lc\PYGZus{}h17v03.img}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{modis} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{ReadAsArray}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplot} \PYG{p}{(} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1} \PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow} \PYG{p}{(} \PYG{n}{modis}\PYG{p}{,} \PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nearest}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{n}{plt}\PYG{o}{.}\PYG{n}{cm}\PYG{o}{.}\PYG{n}{gist\PYGZus{}earth} \PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplot} \PYG{p}{(} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2} \PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow} \PYG{p}{(} \PYG{n}{wgs84}\PYG{p}{,} \PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nearest}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{n}{plt}\PYG{o}{.}\PYG{n}{cm}\PYG{o}{.}\PYG{n}{gist\PYGZus{}earth} \PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.image.AxesImage at 0xe566950\PYGZgt{}
\end{Verbatim}

\includegraphics{GDAL_Python_bindings_41_1.svg}


\subsection{Reprojecting using the Python bindings}
\label{ChapterX_GDAL/GDAL_Python_bindings:reprojecting-using-the-python-bindings}
The previous section demonstrated how you can reproject raster files
using command line tools. Sometimes, you might want to do this from
inside a Python script. Ideally, you would have a python method that
would perform the projection for you. GDAL allows this by defining
in-memory raster files. These are normal GDAL datasets, but that dont
exist on the filesystem, only in the computers memory. They are a
convenient scratchpad for quick intermediate calculations. GDAL also
makes available a function, gdal.ReprojectImage that exposes most of the
abilities of gdalwarp. We shall combine these two tricks to carry out
the reprojection. As an example, we shall look at the case where the
landcover data for the British Isles mentioned in the previous section
needs to be reprojected to the Ordnance Survey National Grid, an
appropriate projection for the UK.

The main complication comes from the need of gdal.ReprojectImage to
operate on GDAL datasets. In the previous section, we saved the data to
a GeoTIFF file, so this gives us a starting dataset. We still need to
create the output dataset. This means that we need to define the
geotransform and size of the output dataset before the projection is
made. This entails gathering information on the extent of the original
dataset, projecting it to the destination projection, and calculating
the number of pixels and geotransform parameters from there. This is a
(heavily commented) function that performs just that task:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{reproject\PYGZus{}dataset} \PYG{p}{(} \PYG{n}{dataset}\PYG{p}{,} \PYGZbs{}
            \PYG{n}{pixel\PYGZus{}spacing}\PYG{o}{=}\PYG{l+m+mf}{463.}\PYG{p}{,} \PYG{n}{epsg\PYGZus{}from}\PYG{o}{=}\PYG{l+m+mi}{4326}\PYG{p}{,} \PYG{n}{epsg\PYGZus{}to}\PYG{o}{=}\PYG{l+m+mi}{27700} \PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    A sample function to reproject and resample a GDAL dataset from within}
\PYG{l+s+sd}{    Python. The idea here is to reproject from one system to another, as well}
\PYG{l+s+sd}{    as to change the pixel size. The procedure is slightly long\PYGZhy{}winded, but}
\PYG{l+s+sd}{    goes like this:}

\PYG{l+s+sd}{    1. Set up the two Spatial Reference systems.}
\PYG{l+s+sd}{    2. Open the original dataset, and get the geotransform}
\PYG{l+s+sd}{    3. Calculate bounds of new geotransform by projecting the UL corners}
\PYG{l+s+sd}{    4. Calculate the number of pixels with the new projection \PYGZam{} spacing}
\PYG{l+s+sd}{    5. Create an in\PYGZhy{}memory raster dataset}
\PYG{l+s+sd}{    6. Perform the projection}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{c}{\PYGZsh{} Define the UK OSNG, see \PYGZlt{}http://spatialreference.org/ref/epsg/27700/\PYGZgt{}}
    \PYG{n}{osng} \PYG{o}{=} \PYG{n}{osr}\PYG{o}{.}\PYG{n}{SpatialReference} \PYG{p}{(}\PYG{p}{)}
    \PYG{n}{osng}\PYG{o}{.}\PYG{n}{ImportFromEPSG} \PYG{p}{(} \PYG{n}{epsg\PYGZus{}to} \PYG{p}{)}
    \PYG{n}{wgs84} \PYG{o}{=} \PYG{n}{osr}\PYG{o}{.}\PYG{n}{SpatialReference} \PYG{p}{(}\PYG{p}{)}
    \PYG{n}{wgs84}\PYG{o}{.}\PYG{n}{ImportFromEPSG} \PYG{p}{(} \PYG{n}{epsg\PYGZus{}from} \PYG{p}{)}
    \PYG{n}{tx} \PYG{o}{=} \PYG{n}{osr}\PYG{o}{.}\PYG{n}{CoordinateTransformation} \PYG{p}{(} \PYG{n}{wgs84}\PYG{p}{,} \PYG{n}{osng} \PYG{p}{)}
    \PYG{c}{\PYGZsh{} Up to here, all  the projection have been defined, as well as a}
    \PYG{c}{\PYGZsh{} transformation from the from to the  to :)}
    \PYG{c}{\PYGZsh{} We now open the dataset}
    \PYG{n}{g} \PYG{o}{=} \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{Open} \PYG{p}{(} \PYG{n}{dataset} \PYG{p}{)}

    \PYG{c}{\PYGZsh{} Get the Geotransform vector}
    \PYG{n}{geo\PYGZus{}t} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{GetGeoTransform} \PYG{p}{(}\PYG{p}{)}
    \PYG{n}{x\PYGZus{}size} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{RasterXSize} \PYG{c}{\PYGZsh{} Raster xsize}
    \PYG{n}{y\PYGZus{}size} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{RasterYSize} \PYG{c}{\PYGZsh{} Raster ysize}

    \PYG{c}{\PYGZsh{} Work out the boundaries of the new dataset in the target projection}
    \PYG{p}{(}\PYG{n}{ulx}\PYG{p}{,} \PYG{n}{uly}\PYG{p}{,} \PYG{n}{ulz} \PYG{p}{)} \PYG{o}{=} \PYG{n}{tx}\PYG{o}{.}\PYG{n}{TransformPoint}\PYG{p}{(} \PYG{n}{geo\PYGZus{}t}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{geo\PYGZus{}t}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}
    \PYG{p}{(}\PYG{n}{lrx}\PYG{p}{,} \PYG{n}{lry}\PYG{p}{,} \PYG{n}{lrz} \PYG{p}{)} \PYG{o}{=} \PYG{n}{tx}\PYG{o}{.}\PYG{n}{TransformPoint}\PYG{p}{(} \PYG{n}{geo\PYGZus{}t}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{+} \PYG{n}{geo\PYGZus{}t}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{*}\PYG{n}{x\PYGZus{}size}\PYG{p}{,} \PYGZbs{}
                                          \PYG{n}{geo\PYGZus{}t}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]} \PYG{o}{+} \PYG{n}{geo\PYGZus{}t}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{o}{*}\PYG{n}{y\PYGZus{}size} \PYG{p}{)}
    \PYG{k}{print} \PYG{n}{ulx}\PYG{p}{,} \PYG{n}{uly}\PYG{p}{,} \PYG{n}{ulz}
    \PYG{k}{print} \PYG{n}{lrx}\PYG{p}{,} \PYG{n}{lry}\PYG{p}{,} \PYG{n}{lrz}
    \PYG{c}{\PYGZsh{} See how using 27700 and WGS84 introduces a z\PYGZhy{}value!}
    \PYG{c}{\PYGZsh{} Now, we create an in\PYGZhy{}memory raster}
    \PYG{n}{mem\PYGZus{}drv} \PYG{o}{=} \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{GetDriverByName}\PYG{p}{(} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MEM}\PYG{l+s}{\PYGZsq{}} \PYG{p}{)}
    \PYG{c}{\PYGZsh{} The size of the raster is given the new projection and pixel spacing}
    \PYG{c}{\PYGZsh{} Using the values we calculated above. Also, setting it to store one band}
    \PYG{c}{\PYGZsh{} and to use Float32 data type.}
    \PYG{n}{dest} \PYG{o}{=} \PYG{n}{mem\PYGZus{}drv}\PYG{o}{.}\PYG{n}{Create}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{int}\PYG{p}{(}\PYG{p}{(}\PYG{n}{lrx} \PYG{o}{\PYGZhy{}} \PYG{n}{ulx}\PYG{p}{)}\PYG{o}{/}\PYG{n}{pixel\PYGZus{}spacing}\PYG{p}{)}\PYG{p}{,} \PYGZbs{}
            \PYG{n+nb}{int}\PYG{p}{(}\PYG{p}{(}\PYG{n}{uly} \PYG{o}{\PYGZhy{}} \PYG{n}{lry}\PYG{p}{)}\PYG{o}{/}\PYG{n}{pixel\PYGZus{}spacing}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{GDT\PYGZus{}Float32}\PYG{p}{)}
    \PYG{c}{\PYGZsh{} Calculate the new geotransform}
    \PYG{n}{new\PYGZus{}geo} \PYG{o}{=} \PYG{p}{(} \PYG{n}{ulx}\PYG{p}{,} \PYG{n}{pixel\PYGZus{}spacing}\PYG{p}{,} \PYG{n}{geo\PYGZus{}t}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYGZbs{}
                \PYG{n}{uly}\PYG{p}{,} \PYG{n}{geo\PYGZus{}t}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{pixel\PYGZus{}spacing} \PYG{p}{)}
    \PYG{c}{\PYGZsh{} Set the geotransform}
    \PYG{n}{dest}\PYG{o}{.}\PYG{n}{SetGeoTransform}\PYG{p}{(} \PYG{n}{new\PYGZus{}geo} \PYG{p}{)}
    \PYG{n}{dest}\PYG{o}{.}\PYG{n}{SetProjection} \PYG{p}{(} \PYG{n}{osng}\PYG{o}{.}\PYG{n}{ExportToWkt}\PYG{p}{(}\PYG{p}{)} \PYG{p}{)}
    \PYG{c}{\PYGZsh{} Perform the projection/resampling}
    \PYG{n}{res} \PYG{o}{=} \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{ReprojectImage}\PYG{p}{(} \PYG{n}{g}\PYG{p}{,} \PYG{n}{dest}\PYG{p}{,} \PYGZbs{}
                \PYG{n}{wgs84}\PYG{o}{.}\PYG{n}{ExportToWkt}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{osng}\PYG{o}{.}\PYG{n}{ExportToWkt}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYGZbs{}
                \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{GRA\PYGZus{}Bilinear} \PYG{p}{)}
    \PYG{k}{return} \PYG{n}{dest}
\end{Verbatim}

The function returns a GDAL in-memory file object, where you can
\code{ReadAsArray} etc. As it stands, \code{reproject\_dataset} does not write
to disk. However, we can save the in-memory raster to any format
supported by GDAL very conveniently by making a copy of the dataset.
This takes a few lines of code:


\chapter{We need a LATLONG dataset!!! show gdalwarp usage for this}
\label{ChapterX_GDAL/GDAL_Python_bindings:we-need-a-latlong-dataset-show-gdalwarp-usage-for-this}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} Do in memory reprojection}
\PYG{n}{reprojected\PYGZus{}dataset} \PYG{o}{=} \PYG{n}{reproject\PYGZus{}dataset} \PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{lc\PYGZus{}h17v03\PYGZus{}wgs84.tif}\PYG{l+s}{\PYGZdq{}} \PYG{p}{)}
\PYG{c}{\PYGZsh{} Output driver, as before}
\PYG{n}{driver} \PYG{o}{=} \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{GetDriverByName} \PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{GTiff}\PYG{l+s}{\PYGZdq{}} \PYG{p}{)}
\PYG{c}{\PYGZsh{} Create a copy of the in memory dataset {}`reprojected\PYGZus{}dataset{}`, and save it}
\PYG{n}{dst\PYGZus{}ds} \PYG{o}{=} \PYG{n}{driver}\PYG{o}{.}\PYG{n}{CreateCopy}\PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{test\PYGZus{}lc\PYGZus{}h17v03\PYGZus{}OSNG.tif}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{reprojected\PYGZus{}dataset}\PYG{p}{,} \PYG{l+m+mi}{0} \PYG{p}{)}
\PYG{n}{dst\PYGZus{}ds} \PYG{o}{=} \PYG{n+nb+bp}{None} \PYG{c}{\PYGZsh{} Flush the dataset to disk}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZhy{}595472.202548 1261034.77555 \PYGZhy{}55.2326775854
543532.18509 12933.1712342 \PYGZhy{}43.993001678
\end{Verbatim}

Let's see how the different projections look like by plotting them side
by side

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplot} \PYG{p}{(} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{1} \PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MODIS sinusoidal}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow} \PYG{p}{(} \PYG{n}{modis}\PYG{p}{,} \PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nearest}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{n}{plt}\PYG{o}{.}\PYG{n}{cm}\PYG{o}{.}\PYG{n}{gist\PYGZus{}earth} \PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplot} \PYG{p}{(} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{2} \PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow} \PYG{p}{(} \PYG{n}{wgs84}\PYG{p}{,} \PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nearest}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{n}{plt}\PYG{o}{.}\PYG{n}{cm}\PYG{o}{.}\PYG{n}{gist\PYGZus{}earth} \PYG{p}{)}
\PYG{n}{g} \PYG{o}{=} \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{Open}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{test\PYGZus{}lc\PYGZus{}h17v03\PYGZus{}OSNG.tif}\PYG{l+s}{\PYGZdq{}} \PYG{p}{)}
\PYG{n}{osng} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{ReadAsArray}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{WGS84, Lat/Long}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplot} \PYG{p}{(} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{3} \PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow} \PYG{p}{(} \PYG{n}{osng}\PYG{p}{,} \PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nearest}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{n}{plt}\PYG{o}{.}\PYG{n}{cm}\PYG{o}{.}\PYG{n}{gist\PYGZus{}earth} \PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{OSNG}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.text.Text at 0x2b9eac0b4ed0\PYGZgt{}
\end{Verbatim}

\includegraphics{GDAL_Python_bindings_49_1.svg}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{css\PYGZus{}styling}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{k+kn}{from} \PYG{n+nn}{IPython.display} \PYG{k+kn}{import} \PYG{n}{display}\PYG{p}{,} \PYG{n}{HTML}
    \PYG{n}{styles} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{https://github.com/CamDavidsonPilon/Probabilistic\PYGZhy{}Programming\PYGZhy{}and\PYGZhy{}Bayesian\PYGZhy{}Methods\PYGZhy{}for\PYGZhy{}Hackers/raw/master/styles/custom.css}\PYG{l+s}{\PYGZdq{}}
    \PYG{c}{\PYGZsh{}return HTML(styles)}
\PYG{n}{css\PYGZus{}styling}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}


\chapter{Working with vector data: OGR}
\label{ChapterX_GDAL/OGR_Python:working-with-vector-data-ogr}\label{ChapterX_GDAL/OGR_Python::doc}
\begin{Verbatim}[commandchars=\\\{\}]
import json
import matplotlib
import os
import ogr
import osr
import gdal

fp = open(\PYGZdq{}../bmh\PYGZus{}matplotlibrc.json\PYGZdq{}, \PYGZsq{}r\PYGZsq{} )
s = json.load ( fp )
fp.close()
matplotlib.rcParams.update(s)
\PYGZpc{}pylab inline
\PYGZpc{}config InlineBackend.figure\PYGZus{}format = \PYGZsq{}svg\PYGZsq{}
figsize( 7,7 )
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
Populating the interactive namespace from numpy and matplotlib
\end{Verbatim}


\section{Vector data}
\label{ChapterX_GDAL/OGR_Python:vector-data}
Sometimes, geospatial data is acquired and recorded for particular
geometric objects such as polygons or lines. An example is a road
layout, where each road is represented as a geometric object (a line,
with points given in a geographical projection), with a number of added
\emph{features} associated with it, such as the road name, whether it is a
toll road, or whether it is dual-carriageway, etc. This data is quite
different to a raster, where the entire scene is tessellated into
pixels, and each pixel holds a value (or an array of value in the case
of multiband rasterfiles).

If you are familiar with databases, vector files are effectively a
database, where one of the fields is a geometry object (a line in our
previous road example, or a polygon if you consider a cadastral system).
We can thus select different records by writing queries on the features.
Some of these queries might be spatial (e.g. check whether a point is
inside a particular country polygon).

The most common format for vector data is the \textbf{ESRI Shapfile}, which
is a multifile format (i.e., several files are needed in order to access
the data). We'll start by getting hold of a shapefile that contains the
countries of the world as polygons, together with information on country
name, capital name, population, etc. The file is available
\href{http://aprsworld.net/gisdata/world/world.zip}{here}.
\begin{figure}[htbp]
\centering
\capstart
\caption{World}\end{figure}

We will download the file with \code{wget} (or \code{curl} if you want to),
and uncompress it using \code{unzip} in the shell:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZsh{} Downloads the data using wget
!wget http://aprsworld.net/gisdata/world/world.zip
\PYGZsh{} or if you want to use curl...
\PYGZsh{}! curl http://aprsworld.net/gisdata/world/world.zip \PYGZhy{}o world.zip
!unzip \PYGZhy{}o \PYGZhy{}x world.zip
\end{Verbatim}

We need to import \code{ogr}, and then open the file. As with GDAL, we get
a handler to the file, (\code{g} in this case). OGR files can have
different layers, although Shapefiles only have one. We need to select
the layer using \code{GetLayer(0)} (selecting the first layer).

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{osgeo} \PYG{k+kn}{import} \PYG{n}{ogr}

\PYG{n}{g} \PYG{o}{=} \PYG{n}{ogr}\PYG{o}{.}\PYG{n}{Open}\PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{world.shp}\PYG{l+s}{\PYGZdq{}} \PYG{p}{)}
\PYG{n}{layer} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{GetLayer}\PYG{p}{(} \PYG{l+m+mi}{0} \PYG{p}{)}
\end{Verbatim}

In order to see a field (the field \code{NAME}) we can loop over the
features in the layer, and use the \code{GetField('NAME')} method. We'll
only do ten features here:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{n\PYGZus{}feat} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{k}{for} \PYG{n}{feat} \PYG{o+ow}{in} \PYG{n}{layer}\PYG{p}{:}

    \PYG{k}{print} \PYG{n}{feat}\PYG{o}{.}\PYG{n}{GetField}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{NAME}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

    \PYG{n}{n\PYGZus{}feat} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
    \PYG{k}{if} \PYG{n}{n\PYGZus{}feat} \PYG{o}{==} \PYG{l+m+mi}{10}\PYG{p}{:}
        \PYG{k}{break}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
NameError                                 Traceback (most recent call last)

\PYGZlt{}ipython\PYGZhy{}input\PYGZhy{}2\PYGZhy{}f4731880d34d\PYGZgt{} in \PYGZlt{}module\PYGZgt{}()
      1
      2 n\PYGZus{}feat = 0
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} 3 for feat in layer:
      4
      5     print feat.GetField(\PYGZsq{}NAME\PYGZsq{})


NameError: name \PYGZsq{}layer\PYGZsq{} is not defined
\end{Verbatim}

If you wanted to see the different layers, we could do this using:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{layerDefinition} \PYG{o}{=} \PYG{n}{layer}\PYG{o}{.}\PYG{n}{GetLayerDefn}\PYG{p}{(}\PYG{p}{)}


\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{layerDefinition}\PYG{o}{.}\PYG{n}{GetFieldCount}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Field }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{: }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{p}{(} \PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{layerDefinition}\PYG{o}{.}\PYG{n}{GetFieldDefn}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{o}{.}\PYG{n}{GetName}\PYG{p}{(}\PYG{p}{)} \PYG{p}{)}
\end{Verbatim}

Each feature, in addition to the fields shown agove, will have a
\code{Geometry} field. We get a handle to this using the
\code{GetGeometryRef()} method. Geometries have many methods, such as
\code{ExportToKML()} to export to KML (Google Maps/Earth format):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{the\PYGZus{}geometry} \PYG{o}{=} \PYG{n}{feat}\PYG{o}{.}\PYG{n}{GetGeometryRef}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{the\PYGZus{}geometry}\PYG{o}{.}\PYG{n}{ExportToKML}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

Many of the methods that don't start with \code{\_\_} are interesting. Let's
see what these are. typically, the interesting methods start with an
upper case letter, so we'll only show those:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{m} \PYG{o+ow}{in} \PYG{n+nb}{dir} \PYG{p}{(} \PYG{n}{the\PYGZus{}geometry} \PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{m}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{isupper}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{print} \PYG{n}{m}
\end{Verbatim}

You'll notice that many of these mechanisms e.g. \code{Overlaps} or
\code{Touches} are effectively geoprocessing operations (they operate on
geometries and return \code{True} if one geometry overlaps or touches,
respectively, the other). Other operations, such as \code{Buffer} return a
buffered version of the same geometry. This allows you to actually do
fairly complicated geoprocessing operations with OGR. However, if you
want to do geoprocessing in earnest, you should really be using
\href{http://toblerity.org/shapely/manual.html}{Shapely}.

A particularly useful webpage for this section is \href{http://pcjericks.github.io/py-gdalogr-cookbook/}{available in the OGR
cookbook}. Have a
look through that if you want more in depth information.


\section{Selecting attributes and/or data extents}
\label{ChapterX_GDAL/OGR_Python:selecting-attributes-and-or-data-extents}
OGR provides an easy way to select attributes on a given layer. This is
done using a SQL-like syntax (you can read more on \href{http://www.gdal.org/ogr/ogr\_sql.html}{OGR's SQL subset
here}. The main point is that
the \emph{attribute filter} is applied to a complete layer. For example,
let's say that we want to select only countries with a population (field
APPROX) larger than 90 000 000 inhabitants:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{g} \PYG{o}{=} \PYG{n}{ogr}\PYG{o}{.}\PYG{n}{Open} \PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{world.shp}\PYG{l+s}{\PYGZdq{}} \PYG{p}{)}
\PYG{n}{lyr} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{GetLayer}\PYG{p}{(} \PYG{l+m+mi}{0} \PYG{p}{)}
\PYG{n}{lyr}\PYG{o}{.}\PYG{n}{SetAttributeFilter} \PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{APPROX \PYGZgt{} 90000000}\PYG{l+s}{\PYGZdq{}} \PYG{p}{)}
\PYG{k}{for} \PYG{n}{feat} \PYG{o+ow}{in} \PYG{n}{lyr}\PYG{p}{:}
    \PYG{k}{print} \PYG{n}{feat}\PYG{o}{.}\PYG{n}{GetFieldAsString} \PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{NAME}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ has }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{ inhabitants}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYGZbs{}
        \PYG{n}{feat}\PYG{o}{.}\PYG{n}{GetFieldAsInteger}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{APPROX}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
PAKISTAN has 123490000 inhabitants
JAPAN has 124710000 inhabitants
RUSSIAN FEDERATION has 150500000 inhabitants
INDIA has 873850000 inhabitants
BANGLADESH has 120850000 inhabitants
BRAZIL has 159630000 inhabitants
NIGERIA has 91700000 inhabitants
CHINA has 1179030000 inhabitants
INDONESIA has 186180000 inhabitants
JOHNSTON ATOLL has 256420000 inhabitants
KINGMAN REEF \PYGZhy{} PALMYRA ATOLL has 256420000 inhabitants
UNITED STATES has 256420000 inhabitants
\end{Verbatim}

So we get a list of popoulous countries (note that Johnston Atoll and
Palmyra are part of the US, and report the sample popuation as the US!)

An additional way to filter the data is by geographical extent. Let's
say we wanted a list of all the countries in (broadly speaking) Europe,
\emph{i.e.} a geographical extent in longitude from 14W to 37E, and in
latitude from 72N to 38N. We can use \code{SetSpatialFilterRect} to do
this:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{g} \PYG{o}{=} \PYG{n}{ogr}\PYG{o}{.}\PYG{n}{Open} \PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{world.shp}\PYG{l+s}{\PYGZdq{}} \PYG{p}{)}
\PYG{n}{lyr} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{GetLayer}\PYG{p}{(} \PYG{l+m+mi}{0} \PYG{p}{)}
\PYG{n}{lyr}\PYG{o}{.}\PYG{n}{SetSpatialFilterRect} \PYG{p}{(} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{14}\PYG{p}{,} \PYG{l+m+mi}{37}\PYG{p}{,} \PYG{l+m+mi}{38}\PYG{p}{,} \PYG{l+m+mi}{72}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{feat} \PYG{o+ow}{in} \PYG{n}{lyr}\PYG{p}{:}
    \PYG{k}{print} \PYG{n}{feat}\PYG{o}{.}\PYG{n}{GetFieldAsString} \PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{NAME}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{feat}\PYG{o}{.}\PYG{n}{GetFieldAsString} \PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{CAPITAL}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
ALGERIA \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} ALGIERS
BELGIUM \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} BRUSSELS
LUXEMBOURG \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} LUXEMBOURG
SAN MARINO \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} SAN MARINO
AUSTRIA \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} VIENNA
CZECH REPUBLIC \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} PRAGUE
SLOVENIA \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} LJUBLJANA
HUNGARY \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} BUDAPEST
SLOVAKIA \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} BRATISLAVA
YUGOSLAVIA \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} BELGRADE [BEOGRADE]
BOSNIA AND HERZEGOVINA \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} SARAJEVO
ALBANIA \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} TIRANE
MACEDONIA, THE FORMER YUGOSLAV REPUBLIC \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} SKOPJE
LITHUANIA \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} VILNIUS
LATVIA \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} RIGA
BULGARIA \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} SOFIA
BELARUS \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} MINSK
MOLDOVA, REPUBLIC OF \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} KISHINEV
IRELAND \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} DUBLIN
ICELAND \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} REYKJAVIK
SPAIN \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} MADRID
SWEDEN \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} STOCKHOLM
FINLAND \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} HELSINKI
TURKEY \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} ANKARA
RUSSIAN FEDERATION \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} MOSCOW
GREECE \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} ATHENS
PORTUGAL \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} LISBON
POLAND \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} WARSAW
NORWAY \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} OSLO
GERMANY \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} BERLIN
ESTONIA \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} TALLINN
TUNISIA \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} TUNIS
CROATIA \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} ZAGREB
ROMANIA \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} BUCURESTI
UKRAINE \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} KIEV
NETHERLANDS \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} AMSTERDAM
JERSEY \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} SAINT HELIER
GUERNSEY \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} SAINT PETER PORT
FAROE ISLANDS \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} TORSHAVN
DENMARK \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} COPENHAGEN
MONACO \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} MONACO
ANDORRA \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} ANDORRA LA VELLA
LIECHTENSTEIN \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} VADUZ
SWITZERLAND \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} BERN
ISLE OF MAN \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} DOUGLAS
UNITED KINGDOM \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} LONDON
FRANCE \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} PARIS
VATICAN CITY (HOLY SEE) \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} VATICAN CITY
ITALY \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} ROME
\end{Verbatim}


\section{Saving a vector file}
\label{ChapterX_GDAL/OGR_Python:saving-a-vector-file}
Saving a vector file using OGR requires a number of steps:
\begin{enumerate}
\item {} 
Definition of the format

\item {} 
Definition of the layer projection and geometry type (e.g. lines,
polygons...)

\item {} 
Definition of the data type of the different fields

\item {} 
Creation of a feature, population of the different fields, and
setting a geometry

\item {} 
Addition of the feature to the layer

\item {} 
Destruction of the feature

\end{enumerate}

This appears quite involved, but let's see how this works. Note that
when you generate a new vector file, OGR will fail if the file already
exists. You might want to use \code{os.remove()} to get rid of the file if
it exists.

Let's see how this is done with an example which is a snippet that
creates a GeoJSON file with the location of the different national
parks. GeoJSON is a nice geographic format, and \href{https://github.com/blog/1528-there-s-a-map-for-that}{github allows you to
display it easily as a
map}.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} National park information, separated by TABs}

\PYG{n}{parks} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}\PYG{l+s}{Dartmoor national park}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZhy{}3.904}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{50.58}
\PYG{l+s}{New forest national park}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZhy{}1.595}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{50.86}
\PYG{l+s}{Exmoor national park}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZhy{}3.651}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{51.14}
\PYG{l+s}{Pembrokeshire coast national park}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZhy{}4.694}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{51.64}
\PYG{l+s}{Brecon beacons national park}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZhy{}3.432}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{51.88}
\PYG{l+s}{Pembrokeshire coast national park}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZhy{}4.79}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{51.99}
\PYG{l+s}{Norfolk and suffolk broads}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{1.569}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{52.62}
\PYG{l+s}{Snowdonia national park}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZhy{}3.898}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{52.9}
\PYG{l+s}{Peak district national park}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZhy{}1.802}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{53.3}
\PYG{l+s}{Yorkshire dales national park}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZhy{}2.157}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{54.23}
\PYG{l+s}{North yorkshire moors national park}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZhy{}0.8855}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{54.37}
\PYG{l+s}{Lake district national park}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZhy{}3.084}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{54.47}
\PYG{l+s}{Galloway forest park}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZhy{}4.171}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{54.87}
\PYG{l+s}{Northumberland national park}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZhy{}2.228}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{55.28}
\PYG{l+s}{Loch lomond and the trossachs national park}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZhy{}4.593}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{56.24}
\PYG{l+s}{Tay forest park}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZhy{}4.025}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{56.59}
\PYG{l+s}{Cairngorms national park}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZhy{}3.545}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{57.08}\PYG{l+s}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}

\PYG{c}{\PYGZsh{} See if the file exists from a previous run of this snippet}
\PYG{k}{if} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{exists} \PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{parks.json}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{:}
    \PYG{c}{\PYGZsh{} It does exist, so remove it}
    \PYG{n}{os}\PYG{o}{.}\PYG{n}{remove} \PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{parks.json}\PYG{l+s}{\PYGZdq{}} \PYG{p}{)}

\PYG{c}{\PYGZsh{} We need the output projection to bet set to Lat/Long}
\PYG{n}{latlong} \PYG{o}{=} \PYG{n}{osr}\PYG{o}{.}\PYG{n}{SpatialReference}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{latlong}\PYG{o}{.}\PYG{n}{ImportFromEPSG}\PYG{p}{(} \PYG{l+m+mi}{4326} \PYG{p}{)}

\PYG{c}{\PYGZsh{} Invoke the GeoJSON driver}
\PYG{n}{drv} \PYG{o}{=} \PYG{n}{ogr}\PYG{o}{.}\PYG{n}{GetDriverByName}\PYG{p}{(} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{GeoJSON}\PYG{l+s}{\PYGZsq{}} \PYG{p}{)}
\PYG{c}{\PYGZsh{} This is the output filename}
\PYG{n}{dst\PYGZus{}ds} \PYG{o}{=} \PYG{n}{drv}\PYG{o}{.}\PYG{n}{CreateDataSource}\PYG{p}{(} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{parks.json}\PYG{l+s}{\PYGZsq{}} \PYG{p}{)}
\PYG{c}{\PYGZsh{} This is a single layer dataset. The layer needs to be of points}
\PYG{c}{\PYGZsh{} and needs to have the WGS84 projection, which we defined above}
\PYG{n}{dst\PYGZus{}layer} \PYG{o}{=} \PYG{n}{dst\PYGZus{}ds}\PYG{o}{.}\PYG{n}{CreateLayer}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{srs} \PYG{o}{=}\PYG{n}{latlong} \PYG{p}{,} \PYGZbs{}
                               \PYG{n}{geom\PYGZus{}type}\PYG{o}{=}\PYG{n}{ogr}\PYG{o}{.}\PYG{n}{wkbPoint} \PYG{p}{)}

\PYG{c}{\PYGZsh{} We just need a field with the Park\PYGZsq{}s name, and its type is a String}
\PYG{n}{field\PYGZus{}defn}\PYG{o}{=}\PYG{n}{ogr}\PYG{o}{.}\PYG{n}{FieldDefn}\PYG{p}{(} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{name}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{ogr}\PYG{o}{.}\PYG{n}{OFTString} \PYG{p}{)}
\PYG{n}{dst\PYGZus{}layer}\PYG{o}{.}\PYG{n}{CreateField}\PYG{p}{(} \PYG{n}{field\PYGZus{}defn} \PYG{p}{)}


\PYG{c}{\PYGZsh{} Algorithm is as follows:}
\PYG{c}{\PYGZsh{} 1. Loop over lines}
\PYG{c}{\PYGZsh{} 2. Split line into park name, longitude, latitude}
\PYG{c}{\PYGZsh{} 3. Create WKT of the point}
\PYG{c}{\PYGZsh{} 4. Set the attribute name to name of park}
\PYG{c}{\PYGZsh{} 5. Clean up}

\PYG{k}{for} \PYG{n}{park\PYGZus{}id}\PYG{p}{,} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(} \PYG{n}{parks}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}} \PYG{p}{)} \PYG{p}{)}\PYG{p}{:}
    \PYG{c}{\PYGZsh{} Get the relevant information}
    \PYG{n}{park\PYGZus{}name}\PYG{p}{,} \PYG{n}{lon}\PYG{p}{,} \PYG{n}{lat} \PYG{o}{=} \PYG{n}{line}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
    \PYG{c}{\PYGZsh{} Create a geogrpahical representation of the current park}
    \PYG{n}{wkt} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{POINT ( }\PYG{l+s+si}{\PYGZpc{}f}\PYG{l+s}{ }\PYG{l+s+si}{\PYGZpc{}f}\PYG{l+s}{ )}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{p}{(} \PYG{n+nb}{float}\PYG{p}{(}\PYG{n}{lon}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{float}\PYG{p}{(}\PYG{n}{lat}\PYG{p}{)} \PYG{p}{)}
    \PYG{c}{\PYGZsh{} Create a feature, using the attributes/fields that are}
    \PYG{c}{\PYGZsh{} required for this layer}
    \PYG{n}{feat} \PYG{o}{=} \PYG{n}{ogr}\PYG{o}{.}\PYG{n}{Feature}\PYG{p}{(}\PYG{n}{feature\PYGZus{}def}\PYG{o}{=}\PYG{n}{dst\PYGZus{}layer}\PYG{o}{.}\PYG{n}{GetLayerDefn}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{c}{\PYGZsh{} Feed the WKT into a geometry}
    \PYG{n}{p} \PYG{o}{=} \PYG{n}{ogr}\PYG{o}{.}\PYG{n}{CreateGeometryFromWkt}\PYG{p}{(} \PYG{n}{wkt} \PYG{p}{)}
    \PYG{c}{\PYGZsh{} Feed the geometry into a WKT}
    \PYG{n}{feat}\PYG{o}{.}\PYG{n}{SetGeometryDirectly}\PYG{p}{(} \PYG{n}{p} \PYG{p}{)}
    \PYG{c}{\PYGZsh{} Set the name field to its value}
    \PYG{n}{feat}\PYG{o}{.}\PYG{n}{SetField} \PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{name}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{park\PYGZus{}name} \PYG{p}{)}
    \PYG{c}{\PYGZsh{} Attach the feature to the layer}
    \PYG{n}{dst\PYGZus{}layer}\PYG{o}{.}\PYG{n}{CreateFeature}\PYG{p}{(} \PYG{n}{feat} \PYG{p}{)}
    \PYG{c}{\PYGZsh{} Clean up}
    \PYG{n}{feat}\PYG{o}{.}\PYG{n}{Destroy}\PYG{p}{(}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Close file}
\PYG{n}{dst\PYGZus{}ds} \PYG{o}{=} \PYG{n+nb+bp}{None}
\end{Verbatim}

You can see the result of this on
\href{https://gist.github.com/jgomezdans/6811102}{github}.

Additionally, note that if we had defined a coordinate transformation as
in the raster session, we could apply this transformation to an OGR
geometry entity (in the snippet above, \code{p} would be such), and it
would be reprojected.

\textbf{Exercise} Modify the above snippet to output a GeoJSON file for the
Peak District National Park, whose UTM30N (\href{http://spatialreference.org/ref/epsg/32630/}{EPSG code:
32630}) co-ordinates are
\(577659, 5911841\).


\section{Rasterising}
\label{ChapterX_GDAL/OGR_Python:rasterising}
A very frequent problem one finds is how to mask out an area in a raster
file that is defined as polygon in a shapefile. For example, if you have
a raster of the worlds population density, and you want to extract all
the pixels that belong to one particular country, how do you go about
that? One way around this is to \emph{rasterise} the polygon(s), which
translates into ``burning'' pixels that fall within the polygon with a
number, resulting in a mask.

The way to do this is to use GDAL's \code{RasterizeLayer} method. The
method takes a handle to a GDAL dataset (one that you create yourself,
with the right projection and geotransform, as you've seen above), and a
OGR layer. The syntax for \code{RasterizeLayer} is

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{err} \PYG{o}{=} \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{RasterizeLayer} \PYG{p}{(} \PYG{n}{raster\PYGZus{}ds}\PYG{p}{,} \PYG{p}{[}\PYG{n}{raster\PYGZus{}band\PYGZus{}no}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ogr\PYGZus{}layer}\PYG{p}{,} \PYG{n}{burn\PYGZus{}values}\PYG{o}{=}\PYG{p}{[}\PYG{n}{burn\PYGZus{}val}\PYG{p}{]} \PYG{p}{)}
\end{Verbatim}

where \code{raster\_ds} is the GDAL raster datasource (note that it needs to
be georreferenced, \emph{i.e.} it requires projection and geotransform),
\code{raster\_band\_no} is the band of the GDAL dataset where we want to burn
pixels, \code{ogr\_layer} is the vector layer object, and \code{burn\_val} is
the value that we want to burn.

Let's use \code{gdal.RasterizeLayer} in conjunction with all that we have
covered above. Say we want to create a mask that only selects the UK or
Ireland in \code{world.shp}, and we want to apply this mask to the MODIS
landcover product that we used in the GDAL session (h17v03 tile ), file
\code{lc\_h17v03.tif}. We find that in this case, \code{world.shp} is in
longitude latitude, and the MODIS data is in the MODIS projection, so we
will reproject the vector data to match the MODIS data (so the latter is
not interpolated and artifacts introduced). To make this efficient and
avoid saving to disk, we shall use \emph{in-memory vector and rasters}, and
we will output a numpy array as our mask. Note then the steps:
\begin{enumerate}
\item {} 
Crate the projection conversion object (as for GDAL before)

\item {} 
Create an in memory \textbf{raster} dataset to store the mask, using
\code{lc\_h17v03.tif} as a reference for geotransforms, array size and
projection.

\item {} 
Create an in memory \textbf{vector} dataset to hold the features that will
be reprojected

\item {} 
Open \code{world.shp} and apply an \code{AttributeFilter} to select a
country

\item {} 
Select a geometry from \code{world.shp}, project it and store it in the
destination in memory vector layer

\item {} 
Once this is done, use \code{gdal.RasterizeLayer} with both in-memory
raster and vector datasets

\item {} 
Read the in memory raster into an array

\end{enumerate}

This is a particularly good exercise that will stress all that we have
learned so far.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{reference\PYGZus{}filename} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{lc\PYGZus{}h17v03.tif}\PYG{l+s}{\PYGZdq{}}
\PYG{n}{target\PYGZus{}vector\PYGZus{}file} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{world.shp}\PYG{l+s}{\PYGZdq{}}
\PYG{n}{attribute\PYGZus{}filter} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{NAME = }\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{IRELAND}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZdq{}}
\PYG{n}{burn\PYGZus{}value} \PYG{o}{=} \PYG{l+m+mi}{1}

\PYG{c}{\PYGZsh{} First, open the file that we\PYGZsq{}ll be taking as a reference}
\PYG{c}{\PYGZsh{} We will need to gleam the size in pixels, as well as projection}
\PYG{c}{\PYGZsh{} and geotransform.}

\PYG{n}{g} \PYG{o}{=} \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{Open}\PYG{p}{(} \PYG{n}{reference\PYGZus{}filename} \PYG{p}{)}

\PYG{c}{\PYGZsh{} We now create an in\PYGZhy{}memory raster, with the appropriate dimensions}
\PYG{n}{drv} \PYG{o}{=} \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{GetDriverByName}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{MEM}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{target\PYGZus{}ds} \PYG{o}{=} \PYG{n}{drv}\PYG{o}{.}\PYG{n}{Create}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{g}\PYG{o}{.}\PYG{n}{RasterXSize}\PYG{p}{,} \PYG{n}{g}\PYG{o}{.}\PYG{n}{RasterXSize}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,}  \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{GDT\PYGZus{}Byte}\PYG{p}{)}
\PYG{n}{target\PYGZus{}ds}\PYG{o}{.}\PYG{n}{SetGeoTransform}\PYG{p}{(} \PYG{n}{g}\PYG{o}{.}\PYG{n}{GetGeoTransform}\PYG{p}{(}\PYG{p}{)} \PYG{p}{)}

\PYG{c}{\PYGZsh{} We set up a transform object as we saw in the previous notebook.}
\PYG{c}{\PYGZsh{} This goes from WGS84 to the projection in the reference datasets}

\PYG{n}{wgs84} \PYG{o}{=} \PYG{n}{osr}\PYG{o}{.}\PYG{n}{SpatialReference}\PYG{p}{(} \PYG{p}{)} \PYG{c}{\PYGZsh{} Define a SpatialReference object}
\PYG{n}{wgs84}\PYG{o}{.}\PYG{n}{ImportFromEPSG}\PYG{p}{(} \PYG{l+m+mi}{4326} \PYG{p}{)} \PYG{c}{\PYGZsh{} And set it to WGS84 using the EPSG code}

\PYG{c}{\PYGZsh{} Now for the target projection, Ordnance Survey\PYGZsq{}s British National Grid}
\PYG{n}{to\PYGZus{}proj} \PYG{o}{=} \PYG{n}{osr}\PYG{o}{.}\PYG{n}{SpatialReference}\PYG{p}{(}\PYG{p}{)} \PYG{c}{\PYGZsh{} define the SpatialReference object}
\PYG{c}{\PYGZsh{} In this case, we get the projection from a Proj4 string}

\PYG{c}{\PYGZsh{} or, if using the proj4 representation}
\PYG{n}{to\PYGZus{}proj}\PYG{o}{.}\PYG{n}{ImportFromWkt}\PYG{p}{(} \PYG{n}{g}\PYG{o}{.}\PYG{n}{GetProjectionRef}\PYG{p}{(}\PYG{p}{)} \PYG{p}{)}
\PYG{n}{target\PYGZus{}ds}\PYG{o}{.}\PYG{n}{SetProjection} \PYG{p}{(} \PYG{n}{to\PYGZus{}proj}\PYG{o}{.}\PYG{n}{ExportToWkt}\PYG{p}{(}\PYG{p}{)} \PYG{p}{)}
\PYG{c}{\PYGZsh{} Now, we define a coordinate transformtion object, *from* wgs84 *to* OSNG}
\PYG{n}{tx} \PYG{o}{=} \PYG{n}{osr}\PYG{o}{.}\PYG{n}{CoordinateTransformation}\PYG{p}{(} \PYG{n}{wgs84}\PYG{p}{,} \PYG{n}{to\PYGZus{}proj} \PYG{p}{)}

\PYG{c}{\PYGZsh{} We define an output in\PYGZhy{}memory OGR dataset}
\PYG{c}{\PYGZsh{} You could also do select a driver for an eg \PYGZdq{}ESRI Shapefile\PYGZdq{} here}
\PYG{c}{\PYGZsh{} and give it a sexier name than out!}

\PYG{n}{drv} \PYG{o}{=} \PYG{n}{ogr}\PYG{o}{.}\PYG{n}{GetDriverByName}\PYG{p}{(} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Memory}\PYG{l+s}{\PYGZsq{}} \PYG{p}{)}
\PYG{n}{dst\PYGZus{}ds} \PYG{o}{=} \PYG{n}{drv}\PYG{o}{.}\PYG{n}{CreateDataSource}\PYG{p}{(} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{out}\PYG{l+s}{\PYGZsq{}} \PYG{p}{)}
\PYG{c}{\PYGZsh{} This is a single layer dataset. The layer needs to be of polygons}
\PYG{c}{\PYGZsh{} and needs to have the target files\PYGZsq{} projection}
\PYG{n}{dst\PYGZus{}layer} \PYG{o}{=} \PYG{n}{dst\PYGZus{}ds}\PYG{o}{.}\PYG{n}{CreateLayer}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{srs} \PYG{o}{=} \PYG{n}{to\PYGZus{}proj}\PYG{p}{,} \PYG{n}{geom\PYGZus{}type}\PYG{o}{=}\PYG{n}{ogr}\PYG{o}{.}\PYG{n}{wkbPolygon} \PYG{p}{)}

\PYG{c}{\PYGZsh{} Open the original shapefile, get the first layer, and filter by attribute}
\PYG{n}{vector\PYGZus{}ds} \PYG{o}{=} \PYG{n}{ogr}\PYG{o}{.}\PYG{n}{Open}\PYG{p}{(} \PYG{n}{target\PYGZus{}vector\PYGZus{}file} \PYG{p}{)}
\PYG{n}{lyr} \PYG{o}{=} \PYG{n}{vector\PYGZus{}ds}\PYG{o}{.}\PYG{n}{GetLayer} \PYG{p}{(} \PYG{l+m+mi}{0} \PYG{p}{)}
\PYG{n}{lyr}\PYG{o}{.}\PYG{n}{SetAttributeFilter}\PYG{p}{(} \PYG{n}{attribute\PYGZus{}filter} \PYG{p}{)}


\PYG{c}{\PYGZsh{} Get a field definition from the original vector file.}
\PYG{c}{\PYGZsh{} We don\PYGZsq{}t need much more detail here}
\PYG{n}{feature} \PYG{o}{=} \PYG{n}{lyr}\PYG{o}{.}\PYG{n}{GetFeature}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{field} \PYG{o}{=} \PYG{n}{feature}\PYG{o}{.}\PYG{n}{GetFieldDefnRef}\PYG{p}{(} \PYG{l+m+mi}{0} \PYG{p}{)}
\PYG{c}{\PYGZsh{} Apply the field definition from the original to the output}
\PYG{n}{dst\PYGZus{}layer}\PYG{o}{.}\PYG{n}{CreateField}\PYG{p}{(} \PYG{n}{field} \PYG{p}{)}
\PYG{n}{feature\PYGZus{}defn} \PYG{o}{=} \PYG{n}{dst\PYGZus{}layer}\PYG{o}{.}\PYG{n}{GetLayerDefn}\PYG{p}{(}\PYG{p}{)}
\PYG{c}{\PYGZsh{} Reset the original layer so we can read all features}
\PYG{n}{lyr}\PYG{o}{.}\PYG{n}{ResetReading}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{feat} \PYG{o+ow}{in} \PYG{n}{lyr}\PYG{p}{:}
    \PYG{c}{\PYGZsh{} For each feature, get the geometry}
    \PYG{n}{geom} \PYG{o}{=} \PYG{n}{feat}\PYG{o}{.}\PYG{n}{GetGeometryRef}\PYG{p}{(}\PYG{p}{)}
    \PYG{c}{\PYGZsh{} transform it to the reference projection}
    \PYG{n}{geom}\PYG{o}{.}\PYG{n}{Transform} \PYG{p}{(} \PYG{n}{tx} \PYG{p}{)}
    \PYG{c}{\PYGZsh{} Create an output feature}
    \PYG{n}{out\PYGZus{}geom} \PYG{o}{=} \PYG{n}{ogr}\PYG{o}{.}\PYG{n}{Feature} \PYG{p}{(} \PYG{n}{feature\PYGZus{}defn} \PYG{p}{)}
    \PYG{c}{\PYGZsh{} Set the geometry to be the reprojected/transformed geometry}
    \PYG{n}{out\PYGZus{}geom}\PYG{o}{.}\PYG{n}{SetGeometry} \PYG{p}{(} \PYG{n}{geom} \PYG{p}{)}
    \PYG{c}{\PYGZsh{} Add the feature with its geometry to the output yaer}
    \PYG{n}{dst\PYGZus{}layer}\PYG{o}{.}\PYG{n}{CreateFeature}\PYG{p}{(}\PYG{n}{out\PYGZus{}geom} \PYG{p}{)}
    \PYG{c}{\PYGZsh{} Clear things up}
    \PYG{n}{out\PYGZus{}geom}\PYG{o}{.}\PYG{n}{Destroy}
    \PYG{n}{geom}\PYG{o}{.}\PYG{n}{Destroy}
\PYG{c}{\PYGZsh{} Done adding geometries}
\PYG{c}{\PYGZsh{} Reset the output layer to the 0th geometry}
\PYG{n}{dst\PYGZus{}layer}\PYG{o}{.}\PYG{n}{ResetReading}\PYG{p}{(}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Now, we rastertize the output vector in\PYGZhy{}memory file}
\PYG{c}{\PYGZsh{} into the in\PYGZhy{}memory output raster file}

\PYG{n}{err} \PYG{o}{=} \PYG{n}{gdal}\PYG{o}{.}\PYG{n}{RasterizeLayer}\PYG{p}{(}\PYG{n}{target\PYGZus{}ds}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{dst\PYGZus{}layer}\PYG{p}{,}
            \PYG{n}{burn\PYGZus{}values}\PYG{o}{=}\PYG{p}{[}\PYG{n}{burn\PYGZus{}value}\PYG{p}{]}\PYG{p}{)}
\PYG{k}{if} \PYG{n}{err} \PYG{o}{!=} \PYG{l+m+mi}{0}\PYG{p}{:}
    \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{error:}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{err}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Read the data from the raster, this is your mask}
\PYG{n}{data} \PYG{o}{=} \PYG{n}{target\PYGZus{}ds}\PYG{o}{.}\PYG{n}{ReadAsArray}\PYG{p}{(}\PYG{p}{)}



\PYG{c}{\PYGZsh{} Plotting to see whether this makes sense.}

\PYG{n}{ndata} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{ReadAsArray}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow} \PYG{p}{(} \PYG{n}{ndata}\PYG{p}{,} \PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nearest}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{n}{plt}\PYG{o}{.}\PYG{n}{cm}\PYG{o}{.}\PYG{n}{gray}\PYG{p}{,} \PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{vmax}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{alpha}\PYG{o}{=}\PYG{l+m+mf}{0.3} \PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{hold} \PYG{p}{(} \PYG{n+nb+bp}{True} \PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow} \PYG{p}{(} \PYG{n}{data}\PYG{p}{,} \PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nearest}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{n}{plt}\PYG{o}{.}\PYG{n}{cm}\PYG{o}{.}\PYG{n}{gray}\PYG{p}{,} \PYG{n}{alpha}\PYG{o}{=}\PYG{l+m+mf}{0.7} \PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{grid} \PYG{p}{(} \PYG{n+nb+bp}{False} \PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\includegraphics{OGR_Python_31_0.svg}


\section{Using matplotlib to plot geometries}
\label{ChapterX_GDAL/OGR_Python:using-matplotlib-to-plot-geometries}
Using matplotlib to plot geometries from OGR can be quite tedious.
Here's an example of plotting a map of Angola from the \code{world.shp}. In
the same vein of recommending Shapely and Fiona above for serious
geoprocessing of vector data, you are encouraged to use
\href{https://bitbucket.org/sgillies/descartes/}{descartes} for plotting
vector data!

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib.path} \PYG{k+kn}{as} \PYG{n+nn}{mpath}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib.patches} \PYG{k+kn}{as} \PYG{n+nn}{mpatches}


\PYG{c}{\PYGZsh{} Extract first layer of features from shapefile using OGR}
\PYG{n}{ds} \PYG{o}{=} \PYG{n}{ogr}\PYG{o}{.}\PYG{n}{Open}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{world.shp}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{lyr} \PYG{o}{=} \PYG{n}{ds}\PYG{o}{.}\PYG{n}{GetLayer}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}


\PYG{c}{\PYGZsh{} Prepare figure}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ioff}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplot}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{gca}\PYG{p}{(}\PYG{p}{)}


\PYG{n}{paths} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{lyr}\PYG{o}{.}\PYG{n}{ResetReading}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{lyr}\PYG{o}{.}\PYG{n}{SetAttributeFilter} \PYG{p}{(} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ NAME = }\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{ANGOLA}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlim}\PYG{p}{(}\PYG{l+m+mi}{11}\PYG{p}{,} \PYG{l+m+mf}{24.5} \PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylim}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{c}{\PYGZsh{} Read all features in layer and store as paths}

\PYG{k}{for} \PYG{n}{feat} \PYG{o+ow}{in} \PYG{n}{lyr}\PYG{p}{:}

    \PYG{k}{for} \PYG{n}{geom} \PYG{o+ow}{in} \PYG{n}{feat}\PYG{o}{.}\PYG{n}{GetGeometryRef}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{envelope} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(} \PYG{n}{geom}\PYG{o}{.}\PYG{n}{GetEnvelope}\PYG{p}{(}\PYG{p}{)} \PYG{p}{)}
        \PYG{c}{\PYGZsh{} check if geom is polygon}
        \PYG{k}{if} \PYG{n}{geom}\PYG{o}{.}\PYG{n}{GetGeometryType}\PYG{p}{(}\PYG{p}{)} \PYG{o}{==} \PYG{n}{ogr}\PYG{o}{.}\PYG{n}{wkbPolygon}\PYG{p}{:}
            \PYG{n}{codes} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
            \PYG{n}{all\PYGZus{}x} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
            \PYG{n}{all\PYGZus{}y} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
            \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{geom}\PYG{o}{.}\PYG{n}{GetGeometryCount}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                \PYG{c}{\PYGZsh{} Read ring geometry and create path}
                \PYG{n}{r} \PYG{o}{=} \PYG{n}{geom}\PYG{o}{.}\PYG{n}{GetGeometryRef}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}
                \PYG{n}{x} \PYG{o}{=} \PYG{p}{[}\PYG{n}{r}\PYG{o}{.}\PYG{n}{GetX}\PYG{p}{(}\PYG{n}{j}\PYG{p}{)} \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{r}\PYG{o}{.}\PYG{n}{GetPointCount}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{]}
                \PYG{n}{y} \PYG{o}{=} \PYG{p}{[}\PYG{n}{r}\PYG{o}{.}\PYG{n}{GetY}\PYG{p}{(}\PYG{n}{j}\PYG{p}{)} \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{r}\PYG{o}{.}\PYG{n}{GetPointCount}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{]}
                \PYG{c}{\PYGZsh{} skip boundary between individual rings}
                \PYG{n}{codes} \PYG{o}{+}\PYG{o}{=} \PYG{p}{[}\PYG{n}{mpath}\PYG{o}{.}\PYG{n}{Path}\PYG{o}{.}\PYG{n}{MOVETO}\PYG{p}{]} \PYG{o}{+} \PYGZbs{}
                             \PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{p}{[}\PYG{n}{mpath}\PYG{o}{.}\PYG{n}{Path}\PYG{o}{.}\PYG{n}{LINETO}\PYG{p}{]}
                \PYG{n}{all\PYGZus{}x} \PYG{o}{+}\PYG{o}{=} \PYG{n}{x}
                \PYG{n}{all\PYGZus{}y} \PYG{o}{+}\PYG{o}{=} \PYG{n}{y}
            \PYG{n}{path} \PYG{o}{=} \PYG{n}{mpath}\PYG{o}{.}\PYG{n}{Path}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{column\PYGZus{}stack}\PYG{p}{(}\PYG{p}{(}\PYG{n}{all\PYGZus{}x}\PYG{p}{,}\PYG{n}{all\PYGZus{}y}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{n}{codes}\PYG{p}{)}
            \PYG{n}{paths}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{path}\PYG{p}{)}
    \PYG{c}{\PYGZsh{} Add paths as patches to axes}
    \PYG{k}{for} \PYG{n}{path} \PYG{o+ow}{in} \PYG{n}{paths}\PYG{p}{:}
        \PYG{n}{patch} \PYG{o}{=} \PYG{n}{mpatches}\PYG{o}{.}\PYG{n}{PathPatch}\PYG{p}{(}\PYG{n}{path}\PYG{p}{,} \PYGZbs{}
                \PYG{n}{facecolor}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{0.8}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{edgecolor}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{black}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{ax}\PYG{o}{.}\PYG{n}{add\PYGZus{}patch}\PYG{p}{(}\PYG{n}{patch}\PYG{p}{)}



\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}aspect}\PYG{p}{(}\PYG{l+m+mf}{1.0}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\includegraphics{OGR_Python_34_0.svg}


\chapter{Indices and tables}
\label{index:indices-and-tables}\begin{itemize}
\item {} 
\emph{genindex}

\item {} 
\emph{modindex}

\item {} 
\emph{search}

\end{itemize}



\renewcommand{\indexname}{Index}
\printindex
\end{document}
